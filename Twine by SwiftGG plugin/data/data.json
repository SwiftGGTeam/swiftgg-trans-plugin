{
  "sample-apps/aboutme": {
    "About Me": {
      "zh": "å…³äºæˆ‘",
      "tips": ""
    },
    "Display data from a central source in multiple views.": {
      "zh": "åœ¨å¤šä¸ªè§†å›¾ä¸­æ˜¾ç¤ºæ¥è‡ªä¸€ä¸ªä¸­å¿ƒæºçš„æ•°æ®ã€‚",
      "tips": ""
    },
    "Welcome to the About Me app. In this walkthrough, youâ€™ll learn the basics of using SwiftUI to display information across multiple tab views.": {
      "zh": "æ¬¢è¿ä½¿ç”¨ About Me åº”ç”¨ç¨‹åºã€‚åœ¨è¿™ä¸ªæ¼”ç¤ºä¸­ï¼Œä½ å°†å­¦ä¹ ä½¿ç”¨ SwiftUI åœ¨å¤šä¸ªæ ‡ç­¾è§†å›¾ä¸­æ˜¾ç¤ºä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Run the preview and tap to select the Home, Story, Favorites, and Fun Facts tabs at the bottom of the screen.": {
      "zh": "è¿è¡Œé¢„è§ˆå¹¶é€‰æ‹©å±å¹•åº•éƒ¨çš„ Home, Story, Favorites, å’Œ Fun Facts æ ‡ç­¾æ ã€‚",
      "tips": ""
    },
    "You can change all of the data, or content, in the app to be about any topic of your choice. While you walk through this sample, try swapping out the information and edit colors and modifiers to suit your style.": {
      "zh": "ä½ å¯ä»¥æŒ‰ç…§ä½ çš„åå¥½æ›´æ”¹åº”ç”¨ç¨‹åºä¸­çš„æ‰€æœ‰æ•°æ®æˆ–è€…å†…å®¹ã€‚åœ¨æ¼”ç¤ºä¸­ï¼Œä½ å¯ä»¥ä¿®æ”¹ä¿¡æ¯å’Œé¢œè‰²ä»¥åŠä¿®é¥°ç¬¦æ¥å®šåˆ¶ä½ çš„é£æ ¼ã€‚",
      "tips": ""
    },
    "Tabbed Interface": {
      "zh": "æ ‡ç­¾è§†å›¾",
      "tips": ""
    },
    "Explore how to set up a tabbed interface.": {
      "zh": "æ¢ç´¢å¦‚ä½•è®¾ç½®æ ‡ç­¾è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "This is the ContentView view. Itâ€™s the first view that youâ€™ll see when you launch your app.": {
      "zh": "è¿™æ˜¯ä¸€ä¸ª ContentView è§†å›¾ã€‚å®ƒæ˜¯åº”ç”¨ç¨‹åºçš„ç¬¬ä¸€ä¸ªè§†å›¾ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "You create the user interface, or UI, for your app inside the body. The entire contents of your app are in the code below.": {
      "zh": "ä½ å¯ä»¥åœ¨ body ä¸­åˆ›å»ºåº”ç”¨ç¨‹åºçš„ç”¨æˆ·ç•Œé¢ã€‚ä½ çš„åº”ç”¨ç¨‹åºçš„æ‰€æœ‰å†…å®¹éƒ½åœ¨ body ä¸­ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "TabView is how you create a user interface with tabs. Inside the tab view, you list each of the tab items that you want.": {
      "zh": "TabView æ˜¯ä½ åˆ›å»ºçš„å¸¦æœ‰æ ‡ç­¾çš„å±•ç¤ºç”¨æˆ·ç•Œé¢çš„è§†å›¾ã€‚åœ¨ tab è§†å›¾ä¸­ï¼Œä½ åˆ—å‡ºäº†éœ€è¦å±•ç¤ºçš„æ ‡ç­¾é¡¹ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "To make a tab, create an instance of the view you want to display when someone taps a tab. The first tab view in the list is HomeView, so itâ€™s the first tab you see when the app launches.": {
      "zh": "è¦åˆ›å»ºä¸€ä¸ªæ ‡ç­¾ï¼Œé¦–å…ˆåˆ›å»ºä¸€ä¸ªä½ æƒ³è¦æ˜¾ç¤ºçš„è§†å›¾ã€‚åœ¨åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªæ ‡ç­¾è§†å›¾æ˜¯ HomeViewï¼Œå› æ­¤å®ƒæ˜¯åº”ç”¨ç¨‹åºå¯åŠ¨æ—¶æ˜¾ç¤ºçš„æ ‡ç­¾è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "Try commenting out a tab, using two slashes // at the beginning of each of the highlighted lines of code to see what happens to your UI.": {
      "zh": "å°è¯•æ³¨é‡Šæ‰ä¸€ä¸ªæ ‡ç­¾ï¼Œä½¿ç”¨ä¸¤ä¸ªæ–œæ  // æ”¾åœ¨é«˜äº®çš„ä»£ç è¡Œçš„å¼€å¤´æ¥çœ‹çœ‹ä½ çš„ UI ä¼šå‘ç”Ÿä»€ä¹ˆå˜åŒ–ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "Under the view, add the .tabItem modifier, and pass in a Label as the tab display. Without a tabItem, the tab for this view appears empty.": {
      "zh": "åœ¨è§†å›¾ä¸­æ·»åŠ  .tabItem ä¿®é¥°ç¬¦ï¼Œå¹¶ä¼ é€’ä¸€ä¸ª Label ä½œä¸ºæ ‡ç­¾æ˜¾ç¤ºã€‚å¦‚æœæ²¡æœ‰ .tabItem ä¿®é¥°ç¬¦ï¼Œåˆ™æ­¤è§†å›¾çš„æ ‡ç­¾æ˜¾ç¤ºä¸ºç©ºã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ä¸ƒæ­¥",
      "tips": ""
    },
    "The tabItem modifier only accepts Label, Text, and Image views. Including any other type of view, such as Button, results in an empty tab item.": {
      "zh": "tabItem ä¿®é¥°ç¬¦åªæ¥å— Labelã€Text å’Œ Image è§†å›¾ã€‚ä»»ä½•å…¶ä»–ç±»å‹çš„è§†å›¾ï¼Œä¾‹å¦‚ Button éƒ½å°†å¯¼è‡´ç©ºçš„æ ‡ç­¾å†…å®¹ã€‚",
      "tips": ""
    },
    "Your Data": {
      "zh": "ä½ çš„æ•°æ®",
      "tips": ""
    },
    "Modify your app data.": {
      "zh": "ä¿®æ”¹ä½ çš„åº”ç”¨æ•°æ®ã€‚",
      "tips": ""
    },
    "This file is where your app stores all of its data (information). In SwiftUI, itâ€™s best to keep the data separate from the visual components of your app. While learning SwiftUI, youâ€™ll frequently see the concept of having a â€œsource of truthâ€ for your data, which means that you only define a value in one place. You will practice this in a few steps when you begin to change the data.": {
      "zh": "è¿™ä¸ªæ–‡ä»¶æ˜¯å­˜å‚¨ä½ çš„åº”ç”¨æ•°æ®çš„åœ°æ–¹ã€‚åœ¨ SwiftUI ä¸­ï¼Œæœ€å¥½å°†æ•°æ®å’Œåº”ç”¨çš„å¯è§†åŒ–ç»„ä»¶åˆ†å¼€ã€‚åœ¨å­¦ä¹  SwiftUI æ—¶ï¼Œä½ ä¼šç»å¸¸çœ‹åˆ°å°†æ•°æ®æœ‰ä¸€ä¸ª â€œçœŸå®æ¥æºâ€ çš„æ¦‚å¿µï¼Œè¿™æ„å‘³ç€ä½ åªåœ¨ä¸€ä¸ªåœ°æ–¹å®šä¹‰ä¸€ä¸ªå€¼ï¼Œä½ å°†åœ¨ä¸‹é¢çš„æ­¥éª¤ä¸­åˆ†å‡ æ­¥ç»ƒä¹ ä¿®æ”¹æ•°æ®ã€‚",
      "tips": ""
    },
    "This structure provides the blueprint for your data. It contains properties that define the name and type of data that the app stores. For instance, your app stores a story property as a String and a colors property as an array of Color values.": {
      "zh": "è¿™ä¸ªç»“æ„ä½“è¡¨ç¤ºä½ éœ€è¦çš„æ•°æ®ç»“æ„ã€‚å®ƒåŒ…å«å®šä¹‰åº”ç”¨å­˜å‚¨çš„æ•°æ®å’Œç±»å‹ã€‚ä¾‹å¦‚ï¼Œä½ çš„åº”ç”¨å­˜å‚¨ä¸€ä¸ª String ç±»å‹çš„ Story å±æ€§å’Œå†…éƒ¨ä¸º Color ç±»å‹çš„åä¸º colors çš„æ•°ç»„ã€‚",
      "tips": ""
    },
    "This value, information, uses the Info structure to store all of the data used in your app. You can refer to this global variable by its name from any file of the project.": {
      "zh": "information ä½¿ç”¨ Info ç»“æ„ä½“æ¥å­˜å‚¨æ‰€æœ‰ç”¨äºåº”ç”¨çš„æ•°æ®ã€‚ä½ å¯ä»¥åœ¨é¡¹ç›®çš„ä»»ä½•æ–‡ä»¶ä¸­å¼•ç”¨è¿™ä¸ªå…¨å±€å˜é‡ã€‚",
      "tips": ""
    },
    "To personalize this project, change the string inside the quotes to your name.": {
      "zh": "è¦ä¸ªæ€§åŒ–è¿™ä¸ªé¡¹ç›®ï¼Œä¿®æ”¹åœ¨å¼•å·å†…çš„å­—ç¬¦ä¸²ä¸ºä½ æƒ³è¦çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "The value for your name is only created this one time, making it the source of truth. Whenever you want to use your name in a component or view, you refer to this value by its name: information.name.": {
      "zh": "ä½ å®šä¹‰çš„åç§°ä»…åœ¨è¿™é‡Œåˆ›å»ºä¸€æ¬¡ï¼Œå› æ­¤å®ƒæ˜¯ä½ æ•°æ®æºã€‚å½“ä½ æƒ³åœ¨ç»„ä»¶æˆ–è§†å›¾ä¸­ä½¿ç”¨ä½ çš„åç§°æ—¶ï¼Œä½ å¯ä»¥å¼•ç”¨å®ƒçš„åç§°ï¼š information.nameã€‚",
      "tips": ""
    },
    "Before moving on, try changing the image. The string â€œPlaceholderâ€ refers to the name of an image in your appâ€™s assets. To add a new image, open the sidebar and tap the Add New Item button in the toolbar. Choose Photo, and select an image from your Photos library. Then give your image a descriptive name.": {
      "zh": "åœ¨ç»§ç»­ä¹‹å‰ï¼Œå°è¯•æ›´æ”¹å›¾ç‰‡ã€‚å­—ç¬¦ä¸² â€œPlaceholderâ€ ä»£è¡¨åº”ç”¨ç¨‹åºçš„èµ„äº§ä¸­çš„åå­—ã€‚è¦æ·»åŠ ä¸€ä¸ªæ–°çš„å›¾ç‰‡ï¼Œæ‰“å¼€å·¥å…·æ å¹¶ç‚¹å‡» Add New Item æŒ‰é’®ã€‚é€‰æ‹© Photo å¹¶é€‰æ‹©ä½ çš„å›¾ç‰‡åº“ä¸­çš„å›¾ç‰‡ã€‚ç„¶åä¸ºä½ çš„å›¾ç‰‡æ·»åŠ ä¸€ä¸ªæè¿°æ€§çš„åç§°ã€‚",
      "tips": ""
    },
    "To use your new image, change â€œPlaceholderâ€ to the name of the new image you just added. Tap the the Home tab in the Preview to see your changes.": {
      "zh": "è¦ä½¿ç”¨ä½ çš„æ–°å›¾ç‰‡ï¼Œæ›´æ”¹ â€œPlaceholderâ€ ä¸ºä½ æ·»åŠ çš„æ–°å›¾ç‰‡çš„åç§°ã€‚ç‚¹å‡» Preview ä¸­çš„ Home æŒ‰é’®æ¥æŸ¥çœ‹ä½ çš„ä¿®æ”¹ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "ç¬¬å…«æ­¥",
      "tips": ""
    },
    "Swift Playgrounds adds your photo to the Assets section of the sidebar and highlights the name for you to edit. After youâ€™ve named the image asset, change the string for this property to match its new name.": {
      "zh": "Swift Playgrounds å°†ä½ çš„å›¾ç‰‡æ·»åŠ åˆ° Assets åˆ—è¡¨ä¸­å¹¶é«˜äº®äº†ä½ è¦ä¿®æ”¹çš„åç§°ã€‚å‘½åä½ çš„å›¾ç‰‡èµ„äº§åï¼Œæ›´æ”¹è¿™ä¸ªå±æ€§çš„å­—ç¬¦ä¸²ä»¥åŒ¹é…ä½ çš„æ–°åç§°ã€‚",
      "tips": ""
    },
    "Home Tab": {
      "zh": "Home æ ‡ç­¾é¡µ",
      "tips": ""
    },
    "Explore some basic SwiftUI code.": {
      "zh": "æ¢ç´¢ä¸€äº›åŸºæœ¬çš„ SwiftUI ä»£ç ã€‚",
      "tips": ""
    },
    "The HomeView is the first tab of your app, so itâ€™s the first thing youâ€™ll see when the app launches. Youâ€™ve seen this in action already, when you first opened the project.": {
      "zh": "HomeView æ˜¯åº”ç”¨ç¨‹åºçš„ç¬¬ä¸€ä¸ªæ ‡ç­¾ï¼Œå› æ­¤å®ƒæ˜¯åº”ç”¨ç¨‹åºå¯åŠ¨æ—¶æ˜¾ç¤ºçš„æ ‡ç­¾ã€‚å½“ä½ ç¬¬ä¸€æ¬¡æ‰“å¼€é¡¹ç›®æ—¶ï¼Œä½ å·²ç»çœ‹åˆ°äº†è¿™ä¸€ç‚¹ã€‚",
      "tips": ""
    },
    "A VStack organizes its contents vertically from top to bottom on the screen.": {
      "zh": "VStack åœ¨å±å¹•ä¸Šä»ä¸Šåˆ°ä¸‹æ’åˆ—å†…å®¹ã€‚",
      "tips": ""
    },
    "A Text view displays the string inside the quotation marks.": {
      "zh": "æ–‡æœ¬è§†å›¾å°†ä¼šæ˜¾ç¤ºå¼•å·å†…çš„å­—ç¬¦ä¸²ã€‚",
      "tips": ""
    },
    "Try changing the string before moving on. Do you see your new text in the preview?": {
      "zh": "åœ¨ç»§ç»­ä¹‹å‰å°è¯•æ›´æ”¹å­—ç¬¦ä¸²ã€‚åœ¨é¢„è§ˆä¸­ä½ çœ‹åˆ°äº†ä½ è®¾ç½®çš„æ–°æ–‡æœ¬äº†å—ï¼Ÿ",
      "tips": ""
    },
    "You can use modifiers to change how the app displays the text. Here are two good ones to know: You can use .font to specify different styles of text, and .fontWeight to change the weight of the font.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ä¿®é¥°ç¬¦æ¥æ”¹å˜åº”ç”¨æ˜¾ç¤ºçš„æ–‡æœ¬ã€‚ä¸‹é¢æ˜¯ä¸¤ä¸ªå€¼å¾—äº†è§£çš„æ–¹æ³•: å¯ä»¥ä½¿ç”¨ .font æ¥æŒ‡å®šä¸åŒçš„æ ·å¼çš„æ–‡æœ¬ï¼Œä»¥åŠ .fontWeight æ¥æ”¹å˜æ–‡æœ¬çš„ç²—ç»†ã€‚",
      "tips": ""
    },
    "Try changing .largeTitle and .bold to different values to see how they affect the view. To do this, delete the existing value â€” including the period (.) â€” then type a period and wait to see the options suggested in the autocompletion menu.": {
      "zh": "å°è¯•æ›´æ”¹ .largeTitle å’Œ .bold æ¥ä¸åŒå€¼æ¥çœ‹å¦‚ä½•å½±å“è§†å›¾ã€‚è¦åšæ­¤äº‹ï¼Œéœ€è¦åˆ é™¤ç°æœ‰å€¼ â€” åŒ…æ‹¬ç‚¹(.) â€” ç„¶åè¾“å…¥ç‚¹(.)ï¼Œçœ‹çœ‹è‡ªåŠ¨è¡¥å…¨èœå•ä¸­å»ºè®®çš„é€‰é¡¹ã€‚",
      "tips": ""
    },
    "The .padding modifier adds extra space between a view and the other views around it.": {
      "zh": ".padding ä¿®é¥°ç¬¦ä¸ºè§†å›¾ä¸å‘¨å›´çš„è§†å›¾æ·»åŠ é¢å¤–çš„ç©ºé—´ã€‚",
      "tips": ""
    },
    "Here, youâ€™re using the default SwiftUI padding. You can also specify a custom value, which you can spot below.": {
      "zh": "åœ¨è¿™é‡Œï¼Œä½ ä½¿ç”¨çš„æ˜¯é»˜è®¤ SwiftUI é—´è·ã€‚ä½ ä¹Ÿå¯ä»¥æŒ‡å®šä¸€ä¸ªè‡ªå®šä¹‰å€¼ï¼Œä½ å¯ä»¥åœ¨ä¸‹é¢æ‰¾åˆ°å®ƒã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "ç¬¬ä¹æ­¥",
      "tips": ""
    },
    "This Image view displays the image that you changed in the Data file.": {
      "zh": "è¿™ä¸ª Image è§†å›¾æ˜¾ç¤ºä½ ä¿®æ”¹çš„ Data æ–‡ä»¶ä¸­çš„å›¾ç‰‡ã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "ç¬¬åæ­¥",
      "tips": ""
    },
    "This Image view has several common modifiers. The first one, .resizable, is very important to remember.": {
      "zh": "è¿™ä¸ª Image è§†å›¾æœ‰å¤šç§å¸¸ç”¨ä¿®é¥°ç¬¦ã€‚ç¬¬ä¸€ä¸ª .resizable éå¸¸é‡è¦éœ€è¦è®°ä½ã€‚",
      "tips": ""
    },
    "Step 11": {
      "zh": "ç¬¬åä¸€æ­¥",
      "tips": ""
    },
    "It allows the image to adapt to the available space on the screen; otherwise the image appears at its full size, which may be very large.": {
      "zh": "å®ƒå…è®¸å›¾ç‰‡é€‚åº”å¯ç”¨ç©ºé—´ï¼Œå¦åˆ™å›¾ç‰‡ä¼šæ˜¾ç¤ºä¸ºå®Œæ•´å°ºå¯¸ï¼Œè¿™å¯èƒ½ä¼šå¾ˆå¤§ã€‚",
      "tips": ""
    },
    "Step 12": {
      "zh": "ç¬¬åäºŒæ­¥",
      "tips": ""
    },
    "The .aspectRatio modifier requires the image to maintain its aspect ratio. By specifying .fit, youâ€™re asking SwiftUI to resize the image so it fits within the available space.": {
      "zh": ".aspectRatio ä¿®é¥°ç¬¦éœ€è¦å›¾ç‰‡ä¿æŒå…¶æ¯”ä¾‹ã€‚é€šè¿‡æŒ‡å®š .fitï¼Œæ¥è¦æ±‚ SwiftUI å°†å›¾ç‰‡å°ºå¯¸é€‚åº”å¯ç”¨ç©ºé—´ã€‚",
      "tips": ""
    },
    "Step 13": {
      "zh": "ç¬¬åä¸‰æ­¥",
      "tips": ""
    },
    "To see the effect of this modifier, try changing .fit to .fill, or comment out the line entirely.": {
      "zh": "è¦æŸ¥çœ‹è¿™ä¸ªä¿®é¥°ç¬¦çš„æ•ˆæœï¼Œå°è¯•æ›´æ”¹ .fit ä¸º .fill æˆ–å®Œå…¨æ³¨é‡Šæ•´è¡Œã€‚",
      "tips": ""
    },
    "Step 14": {
      "zh": "ç¬¬åå››æ­¥",
      "tips": ""
    },
    "You can give any view rounded corners with the .cornerRadius modifier. Try changing the value to make the corners larger or smaller.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ .cornerRadius ä¿®é¥°ç¬¦ç»™ä»»ä½•è§†å›¾æ·»åŠ åœ†è§’ã€‚å°è¯•æ›´æ”¹å€¼æ¥æ”¹å˜åœ†è§’å¤§å°ã€‚",
      "tips": ""
    },
    "Story Tab": {
      "zh": "Story æ ‡ç­¾é¡µ",
      "tips": ""
    },
    "Learn how to use a scroll view to create a scrolling narrative.": {
      "zh": "äº†è§£å¦‚ä½•ä½¿ç”¨ä¸€ä¸ªæ»šåŠ¨è§†å›¾æ¥åˆ›å»ºæ»šåŠ¨æ•…äº‹ã€‚",
      "tips": ""
    },
    "This is the StoryView, where you can display a story about anything you want.": {
      "zh": "è¿™æ˜¯ä¸€ä¸ª StoryViewï¼Œä½ å¯ä»¥æ˜¾ç¤ºä»»ä½•æƒ³è¦çš„æ•…äº‹ã€‚",
      "tips": ""
    },
    "To let your story scroll if the text gets too long, wrap your Text view in a ScrollView.": {
      "zh": "æƒ³è¦åœ¨æ–‡æœ¬å¾ˆé•¿çš„æƒ…å†µä¸‹æ»šåŠ¨ï¼Œå¯ä»¥ä½¿ç”¨ ScrollView æ¥åŒ…è£¹æ–‡æœ¬è§†å›¾ã€‚",
      "tips": ""
    },
    "This text view extracts information that you have in the Data file to build your story.": {
      "zh": "è¿™ä¸ªæ–‡æœ¬è§†å›¾ä» Data æ–‡ä»¶ä¸­æå–ä¿¡æ¯æ¥æ„å»ºæ•…äº‹ã€‚",
      "tips": ""
    },
    "To test the scroll view, open Data and edit the story text between the red quotation marks. Try writing a long story of your own, then come back to this preview and test how your page scrolls.": {
      "zh": "è¦æµ‹è¯•æ»šåŠ¨è§†å›¾ï¼Œæ‰“å¼€ Data æ–‡ä»¶å¹¶ç¼–è¾‘çº¢å¼•å·å†…çš„æ•…äº‹æ–‡æœ¬ã€‚å°è¯•å†™ä¸€ä¸ªé•¿é•¿çš„æ•…äº‹ï¼Œç„¶åè¿”å›é¢„è§ˆå¹¶æµ‹è¯•ä½ çš„é¡µé¢æ»šåŠ¨ã€‚",
      "tips": ""
    },
    "Favorites Tab": {
      "zh": "Favorites æ ‡ç­¾é¡µ",
      "tips": ""
    },
    "Build your UI using various stacks and loops.": {
      "zh": "ä½¿ç”¨å„ç§å †æ ˆå’Œå¾ªç¯æ„å»ºä½ çš„ UIã€‚",
      "tips": ""
    },
    "The FavoritesView shows your favorite hobbies, foods, and colors.": {
      "zh": "FavoritesView å±•ç¤ºä½ å–œæ¬¢çš„å…´è¶£ã€é£Ÿç‰©å’Œé¢œè‰²ã€‚",
      "tips": ""
    },
    "Each of the three sections are organized the same way. You have a title at the top, and an HStack below it that displays the images, text, or colors horizontally.": {
      "zh": "è¿™ä¸‰ä¸ªéƒ¨åˆ†æ˜¯åŒæ ·ç»„ç»‡æ–¹å¼ã€‚åœ¨é¡¶éƒ¨æœ‰ä¸€ä¸ªæ ‡é¢˜ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªæ˜¾ç¤ºå›¾ç‰‡ã€æ–‡å­—æˆ–é¢œè‰²çš„ HStackã€‚",
      "tips": ""
    },
    "The ForEach uses the global information data and iterates through the hobbies array. Because ForEach needs to know how to tell the items apart from each other, you pass \\.self as the argument to id.": {
      "zh": "ForEach ä½¿ç”¨å…¨å±€ information æ•°æ®å¹¶ä¸”è¿­ä»£éå† hobbies æ•°ç»„ã€‚å› ä¸º ForEach éœ€è¦çŸ¥é“å¦‚ä½•åŒºåˆ†æ¯ä¸€ä¸ªé¡¹ç›®ï¼Œæ‰€ä»¥ä½ éœ€è¦ä¼ é€’ \\.self ä½œä¸ºå‚æ•°å½“åš idã€‚",
      "tips": ""
    },
    "In the hobbies example, you create an image inside the HStack using modifiers to adjust its size. For example, .resizable allows you to resize the images.": {
      "zh": "åœ¨ hobbies ç¤ºä¾‹ä¸­ï¼Œä½ ä½¿ç”¨ä¿®é¥°ç¬¦æ¥è°ƒæ•´å›¾ç‰‡çš„å¤§å°ã€‚ä¾‹å¦‚ï¼š.resizable è®©å›¾ç‰‡è‡ªé€‚åº”ã€‚",
      "tips": ""
    },
    "Try replacing the .frame modifier with .scaledToFit or .scaledToFill, or removing the .resizable modifier. Did anything happen to your images?": {
      "zh": "å°è¯•æ›¿æ¢ .frame ä¿®é¥°ç¬¦ä¸º .scaledToFit æˆ– .scaledToFillï¼Œæˆ–è€…åˆ é™¤ .resizable ä¿®é¥°ç¬¦ã€‚è§‚å¯Ÿå›¾ç‰‡æ˜¯å¦å‘ç”Ÿäº†ä»€ä¹ˆå˜åŒ–ï¼Ÿ",
      "tips": ""
    },
    "Fun Facts Tab": {
      "zh": "Fun Facts æ ‡ç­¾é¡µ",
      "tips": ""
    },
    "Make your app interactive by adding a button that displays a random fact about you.": {
      "zh": "é€šè¿‡æ·»åŠ ä¸€ä¸ªæ˜¾ç¤ºéšæœºäº‹å®çš„æŒ‰é’®æ¥è®©ä½ çš„åº”ç”¨æœ‰äº¤äº’æ€§ã€‚",
      "tips": ""
    },
    "In the FunFactsView youâ€™ll use a Button view to change a fun fact string whenever someone taps it.": {
      "zh": "åœ¨ FunFactsView ä¸­ï¼Œä½ å°†ä½¿ç”¨ Button è§†å›¾ï¼Œå½“ç”¨æˆ·ç‚¹å‡»æ—¶æ¥æ”¹å˜ä¸€ä¸ª fun fact å­—ç¬¦ä¸²ã€‚",
      "tips": ""
    },
    "The variable funFact stores the fun fact displayed by this view. Because funFact uses @State, the fun fact Text view automatically updates with a new value whenever its value changes.": {
      "zh": "å˜é‡ funFact ç”¨äºæ˜¾ç¤ºè¿™ä¸ªè§†å›¾ã€‚å› ä¸º funFact ä½¿ç”¨ @Stateï¼Œåªè¦ funFact çš„å€¼æ”¹å˜ï¼Œæ–‡æœ¬è§†å›¾å°±ä¼šè‡ªåŠ¨æ›´æ–°ã€‚",
      "tips": ""
    },
    "When you tap this button, the code assigns funFact a new value, which then changes the string in the Text view above.": {
      "zh": "å½“ä½ ç‚¹å‡»è¿™ä¸ªæŒ‰é’®æ—¶ï¼Œä»£ç å°† funFact çš„å€¼æ”¹å˜ï¼Œç„¶åå°†æ–‡æœ¬è§†å›¾ä¸Šçš„å­—ç¬¦ä¸²æ›´æ”¹ã€‚",
      "tips": ""
    },
    "To edit the look of the button, try adding some modifiers. Add space around the button using .padding(), a background color using .background(Color.cyan), or rounded corners using .cornerRadius(15). Add these below the brace of the buttonâ€™s closure.": {
      "zh": "è¦ç¼–è¾‘æŒ‰é’®çš„å¤–è§‚ï¼Œå°è¯•æ·»åŠ ä¸€äº›ä¿®é¥°ç¬¦ã€‚åœ¨æŒ‰é’®çš„é—­åŒ…ä¸­æ·»åŠ å†…è¾¹è·ï¼Œä½¿ç”¨ .padding()ï¼Œä½¿ç”¨ .background(Color.cyan) æ·»åŠ èƒŒæ™¯é¢œè‰²æˆ–ä½¿ç”¨ .cornerRadius(15) æ¥æ·»åŠ åœ†è§’ã€‚",
      "tips": ""
    },
    "This Text view shows the fun fact. It uses the variable funFact as its argument so it can show a new fun fact whenever the value changes.": {
      "zh": "è¿™ä¸ª Text è§†å›¾æ˜¾ç¤ºçš„æ˜¯ fun factã€‚å®ƒä½¿ç”¨ funFact ä½œä¸ºå…¶å‚æ•°ï¼Œå› æ­¤æ¯å½“å€¼æ”¹å˜æ—¶ï¼Œå®ƒå°±ä¼šæ˜¾ç¤ºä¸€ä¸ªæ–°çš„ fun factã€‚",
      "tips": ""
    },
    "Choose Your Own Story": {
      "zh": "é€‰æ‹©ä½ è‡ªå·±çš„æ•…äº‹",
      "tips": ""
    },
    "Provide dynamic navigation between views.": {
      "zh": "æä¾›è§†å›¾é—´çš„åŠ¨æ€å¯¼èˆªã€‚",
      "tips": ""
    }
  },
  "sample-apps/animatingshapes": {
    "Animating Shapes": {
      "zh": "åŠ¨ç”»å½¢çŠ¶",
      "tips": ""
    },
    "Learn how to use shapes and simple animations in SwiftUI.": {
      "zh": "å­¦ä¹ å¦‚ä½•åœ¨ SwiftUI ä¸­ä½¿ç”¨å½¢çŠ¶å’Œç®€å•åŠ¨ç”»ã€‚",
      "tips": ""
    },
    "First up, youâ€™ll learn to use the SwiftUI Shape protocol to create and modify shape views.": {
      "zh": "é¦–å…ˆï¼Œä½ å°†å­¦ä¹ ä½¿ç”¨ SwiftUI Shape åè®®æ¥åˆ›å»ºå’Œä¿®æ”¹å½¢çŠ¶è§†å›¾ã€‚",
      "tips": ""
    },
    "Youâ€™ll learn the basics of animating views and how to create animations â€“ some easy, some more complex!": {
      "zh": "ä½ å°†å­¦ä¹ åŠ¨ç”»è§†å›¾çš„åŸºç¡€çŸ¥è¯†ä»¥åŠå¦‚ä½•åˆ›å»ºåŠ¨ç”» - æœ‰äº›ç®€å•ï¼Œæœ‰äº›æ›´å¤æ‚ï¼",
      "tips": ""
    },
    "Heart Pulse": {
      "zh": "å¿ƒè„è„‰å†²",
      "tips": ""
    },
    "Discover how to make a heart pulse in this basic animation.": {
      "zh": "æ¢ç´¢å¦‚ä½•åœ¨è¿™ä¸ªåŸºæœ¬åŠ¨ç”»ä¸­ä½¿å¿ƒè„è·³åŠ¨ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "",
      "tips": ""
    },
    "In this walkthrough, you will learn how to create a custom heart shape as well as how to make it pulse. From there, youâ€™ll learn how to scale the pulsing heart up or down.": {
      "zh": "åœ¨è¿™ä¸ªæ¼”ç»ƒä¸­ï¼Œä½ å°†å­¦ä¹ å¦‚ä½•åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰çš„å¿ƒå½¢ï¼Œä»¥åŠå¦‚ä½•è®©å®ƒè·³åŠ¨ã€‚ä»é‚£é‡Œå¼€å§‹ï¼Œä½ å°†å­¦ä¹ å¦‚ä½•å°†è·³åŠ¨çš„å¿ƒè„æ”¾å¤§æˆ–ç¼©å°ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "",
      "tips": ""
    },
    "To create a heart shape, define a structure that adopts the Shape protocol by implementing the required path(in:) method.": {
      "zh": "ä¸ºäº†åˆ›å»ºä¸€ä¸ªå¿ƒå½¢ï¼Œè¿™é‡Œä½ é€šè¿‡å®ç° required path(in:) æ–¹æ³•ï¼Œå®šä¹‰ä¸€ä¸ªé‡‡ç”¨ Shape åè®®çš„ç»“æ„ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "",
      "tips": ""
    },
    "path.move starts the path at the point of the heart.": {
      "zh": "path.move ä»å¿ƒè„çš„ç‚¹å¼€å§‹è·¯å¾„ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "",
      "tips": ""
    },
    "path.addCurve creates a curved line from where your point is to a specified end point. This is what draws the curved sides of the heart shape.": {
      "zh": "path.addCurve ä¼šä»ä½ æŒ‡å®šçš„èµ·ç‚¹åˆ°ç»ˆç‚¹åˆ›å»ºä¸€æ¡æ›²çº¿ã€‚è¿™å°±æ˜¯ç»˜åˆ¶å¿ƒå½¢çš„æ›²çº¿è¾¹çš„æ–¹æ³•ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "",
      "tips": ""
    },
    "path.addArc adds the arcs at the top of the heart shape. By specifying the start and end angles, the path knows where to draw the arc. The arc is drawn off of specific points in the unit circle that you specify for the start and end angles.": {
      "zh": "path.addArc ä¼šåœ¨å¿ƒå½¢çš„é¡¶éƒ¨æ·»åŠ åœ†å¼§ã€‚é€šè¿‡æŒ‡å®šèµ·å§‹è§’åº¦å’Œç»“æŸè§’åº¦ï¼ŒPath å®ä¾‹çŸ¥é“åœ¨å“ªé‡Œç»˜åˆ¶åœ†å¼§ã€‚åœ†å¼§æ˜¯ä»ä½ ä¸ºèµ·å§‹è§’åº¦å’Œç»“æŸè§’åº¦æŒ‡å®šçš„å•ä½åœ†çš„ç‰¹å®šç‚¹ç»˜åˆ¶çš„ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "",
      "tips": ""
    },
    "To make the heart pulse, youâ€™ll tap the play button. When the heart pulses, it scales up and then back down, repeating the animation indefinitely. Your heartPulse state property determines the scale of the heart in this animation.": {
      "zh": "ä¸ºäº†è®©å¿ƒè„è·³åŠ¨ï¼Œä½ å°†ç‚¹å‡»æ’­æ”¾æŒ‰é’®ã€‚å½“å¿ƒè„è·³åŠ¨æ—¶ï¼Œå®ƒä¼šæ”¾å¤§ç„¶åç¼©å°ï¼Œæ— é™æœŸåœ°é‡å¤åŠ¨ç”»ã€‚åœ¨è¿™ä¸ªåŠ¨ç”»ä¸­ï¼Œä½ çš„ heartPulse çŠ¶æ€å±æ€§å†³å®šäº†å¿ƒè„çš„æ¯”ä¾‹ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "",
      "tips": ""
    },
    "When you tap play, the heartPulse value increases. Setting autoreverses to true allows the animation to first play forward, as the heart scales up, and then backward as it scales back down again.": {
      "zh": "å½“ä½ ç‚¹å‡»æ’­æ”¾æ—¶ï¼ŒheartPulse å€¼ä¼šå¢åŠ ã€‚å°† autoreverses è®¾ç½®ä¸º true å…è®¸åŠ¨ç”»é¦–å…ˆæ­£å‘æ’­æ”¾ï¼Œè¿™ä¼šä½¿å¿ƒè„æ”¾å¤§ï¼Œç„¶ååå‘æ’­æ”¾ï¼Œè¿™ä¼šä½¿å®ƒç¼©å°ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "",
      "tips": ""
    },
    "By changing the value of heartPulse inside of a withAnimation closure, you animate any changes to its value with the animation you pass in, resulting in the pulsing effect. ğŸ’—": {
      "zh": "é€šè¿‡åœ¨ withAnimation é—­åŒ…ä¸­æ›´æ”¹ heartPulse çš„å€¼ï¼Œä½ å¯ä»¥ä½¿ç”¨ä¼ å…¥çš„åŠ¨ç”»æ¥åŠ¨ç”»åŒ–å…¶å€¼çš„ä»»ä½•æ›´æ”¹ï¼Œä»è€Œäº§ç”Ÿè·³åŠ¨çš„æ•ˆæœã€‚ğŸ’—",
      "tips": ""
    },
    "Spinning Animation": {
      "zh": "æ—‹è½¬åŠ¨ç”»",
      "tips": ""
    },
    "Discover how to create a spinning effect.": {
      "zh": "æ¢ç´¢å¦‚ä½•åˆ›å»ºæ—‹è½¬æ•ˆæœã€‚",
      "tips": ""
    },
    "Next, youâ€™ll learn to create a spinning animation when you tap a button. Time to get dizzy!": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†å­¦ä¹ å¦‚ä½•åœ¨ç‚¹å‡»æŒ‰é’®æ—¶åˆ›å»ºæ—‹è½¬åŠ¨ç”»ã€‚æ˜¯æ—¶å€™è®©ä½ å¤´æ™•äº†ï¼",
      "tips": ""
    },
    "There is no preset animation that actually causes a shape to spin, but you can create the illusion of spinning by changing the width of the shape. To do this, youâ€™ll use a width state property.": {
      "zh": "è¿™é‡Œæ²¡æœ‰é¢„è®¾çš„åŠ¨ç”»å¯ä»¥è®©å½¢çŠ¶æ—‹è½¬ï¼Œä½†æ˜¯ä½ å¯ä»¥é€šè¿‡æ”¹å˜å½¢çŠ¶çš„å®½åº¦æ¥åˆ¶é€ æ—‹è½¬çš„å¹»è§‰ã€‚ä¸ºæ­¤ï¼Œä½ å°†ä½¿ç”¨ä¸€ä¸ª width çŠ¶æ€å±æ€§ã€‚",
      "tips": ""
    },
    "When you tap the button, the ellipse animates to change its width from 200 to 0. Notice that the Animation used is .easeInOut.repeatForever(autoreverses: true).speed(2). This chains together three animations to create a specific effect. Try to predict how each part of the animation affects the overall effect.": {
      "zh": "å½“ä½ ç‚¹å‡»æŒ‰é’®æ—¶ï¼Œæ¤­åœ†åŠ¨ç”»å°†å…¶å®½åº¦ä» 200 æ”¹å˜ä¸º 0ã€‚æ³¨æ„ï¼Œä½¿ç”¨çš„åŠ¨ç”»æ˜¯ .easeInOut.repeatForever(autoreverses: true).speed(2)ã€‚è¿™å°†ä¸‰ä¸ªåŠ¨ç”»é“¾æ¥åœ¨ä¸€èµ·ï¼Œä»¥åˆ›å»ºä¸€ä¸ªç‰¹å®šçš„æ•ˆæœã€‚ä½ å¯ä»¥è¯•ç€é¢„æµ‹åŠ¨ç”»çš„æ¯ä¸ªéƒ¨åˆ†å¦‚ä½•å½±å“æ•´ä½“æ•ˆæœã€‚",
      "tips": ""
    },
    "Hereâ€™s the sequence: .easeInOut first creates an animation that eases in and eases out. Then .repeatForever(autoreverses: true) takes the .easeInOut animation and puts it in a loop that runs forever. Because autoreverses is true, the animation first runs forward, then in reverse before starting over. And finally, .speed(2) determines how quickly the animation runs. With an argument of 2, it runs at 200 percent of its default speed.": {
      "zh": "åŠ¨ç”»çš„æ‰§è¡Œé¡ºåºå¦‚ä¸‹ï¼š.easeInOut é¦–å…ˆåˆ›å»ºä¸€ä¸ªç¼“å…¥ç¼“å‡ºçš„åŠ¨ç”»ã€‚ç„¶å .repeatForever(autoreverses: true) å°† .easeInOut åŠ¨ç”»æ”¾å…¥ä¸€ä¸ªæ°¸è¿œè¿è¡Œçš„å¾ªç¯ä¸­ã€‚å› ä¸º autoreverses æ˜¯ trueï¼Œæ‰€ä»¥åŠ¨ç”»é¦–å…ˆæ­£å‘è¿è¡Œï¼Œç„¶ååå‘è¿è¡Œï¼Œç„¶åå†é‡æ–°å¼€å§‹ã€‚æœ€åï¼Œ.speed(2) ç¡®å®šåŠ¨ç”»è¿è¡Œçš„é€Ÿåº¦ã€‚ä½¿ç”¨ 2 ä½œä¸ºå‚æ•°ï¼Œå®ƒä»¥å…¶é»˜è®¤é€Ÿåº¦çš„ 200% è¿è¡Œã€‚",
      "tips": ""
    },
    "This animation results in a spinning effect as the circleâ€™s width changes first from 200 to 0, and then from 0 to 200, repeating the entire animation on a recurring loop.": {
      "zh": "è¿™ä¸ªåŠ¨ç”»ä¼šäº§ç”Ÿä¸€ä¸ªæ—‹è½¬çš„æ•ˆæœï¼Œå› ä¸ºåœ†çš„å®½åº¦é¦–å…ˆä» 200 å˜ä¸º 0ï¼Œç„¶åä» 0 å˜ä¸º 200ï¼Œåœ¨ä¸€ä¸ªå¾ªç¯ä¸­é‡å¤æ•´ä¸ªåŠ¨ç”»ã€‚",
      "tips": ""
    },
    "Exploding Animation": {
      "zh": "çˆ†ç‚¸åŠ¨ç”»",
      "tips": ""
    },
    "Learn how to create an explosion effect.": {
      "zh": "å­¦ä¹ å¦‚ä½•åˆ›å»ºçˆ†ç‚¸æ•ˆæœã€‚",
      "tips": ""
    },
    "To create an exploding animation, youâ€™ll replace a rectangle with many small rectangular pieces that animate outward.": {
      "zh": "è¦åˆ›å»ºä¸€ä¸ªçˆ†ç‚¸åŠ¨ç”»ï¼Œä½ å°†ç”¨è®¸å¤šå°çš„çŸ©å½¢å—æ›¿æ¢ä¸€ä¸ªçŸ©å½¢ï¼Œè¿™äº›çŸ©å½¢å—ä¼šä»¥åŠ¨ç”»çš„å½¢å¼å‘å¤–ç§»åŠ¨ã€‚",
      "tips": ""
    },
    "The isExploded state property tracks whether the exploding animation is currently running. Youâ€™ll use this value to start all of the animations when you tap the button.": {
      "zh": "è¿™ä¸ª isExploded çŠ¶æ€å±æ€§ä¼šè·Ÿè¸ªçˆ†ç‚¸åŠ¨ç”»æ˜¯å¦æ­£åœ¨è¿è¡Œã€‚ä½ å°†ä½¿ç”¨è¿™ä¸ªå€¼æ¥åœ¨ç‚¹å‡»æŒ‰é’®æ—¶å¯åŠ¨æ‰€æœ‰çš„åŠ¨ç”»ã€‚",
      "tips": ""
    },
    "In the large Rectangle view, the opacity animates from 1 to 0 when isExploded is set to true; this makes the large rectangle disappear.": {
      "zh": "åœ¨è¿™ä¸ªå¤§çš„ Rectangle è§†å›¾ä¸­ï¼Œå½“ isExploded è®¾ç½®ä¸º true æ—¶ï¼Œä¸é€æ˜åº¦ä» 1 ä»¥åŠ¨ç”»çš„å½¢å¼å˜åŒ–ä¸º 0ï¼›è¿™ä½¿å¾—è¿™ä¸ªå¤§çŸ©å½¢æ¶ˆå¤±ã€‚",
      "tips": ""
    },
    "When the large rectangle disappears, you want many small rectangles to explode outward. To create this effect, youâ€™ll first generate a large number of smaller rectangles using a ForEach. These rectangles are initially hidden behind the large rectangle in a ZStack. When the large rectangle disappears, youâ€™ll see the smaller rectangles.": {
      "zh": "å½“è¿™ä¸ªå¤§çŸ©å½¢æ¶ˆå¤±æ—¶ï¼Œä½ å¸Œæœ›å‡ºç°è®¸å¤šå°çŸ©å½¢å‘å¤–çˆ†ç‚¸ã€‚ä¸ºäº†åˆ›å»ºè¿™ä¸ªæ•ˆæœï¼Œä½ é¦–å…ˆè¦ä½¿ç”¨ ForEach ç”Ÿæˆå¤§é‡çš„å°çŸ©å½¢ã€‚è¿™äº›çŸ©å½¢æœ€åˆè¢«éšè—åœ¨ä¸€ä¸ª ZStack ä¸­çš„å¤§çŸ©å½¢åé¢ã€‚å½“å¤§çŸ©å½¢æ¶ˆå¤±æ—¶ï¼Œä½ ä¼šçœ‹åˆ°è¿™äº›å°çŸ©å½¢ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®éªŒ",
      "tips": ""
    },
    "Try changing the number of small rectangles to see how that affects the animation.": {
      "zh": "å°è¯•æ”¹å˜å°çŸ©å½¢çš„æ•°é‡ï¼Œçœ‹çœ‹è¿™å¯¹åŠ¨ç”»æœ‰ä»€ä¹ˆå½±å“ã€‚",
      "tips": ""
    },
    "For each of these small rectangles, youâ€™ll use a conditional modifier to animate their offsets to random positions in the view. This makes it look like theyâ€™re little shards of the larger rectangle that propel out in different directions.": {
      "zh": "å¯¹äºè¿™äº›å°çŸ©å½¢ï¼Œä½ å°†ä½¿ç”¨ä¸€ä¸ªæ¡ä»¶ä¿®é¥°ç¬¦æ¥å°†å®ƒä»¬çš„åç§»é‡åŠ¨ç”»åˆ°è§†å›¾ä¸­çš„éšæœºä½ç½®ã€‚è¿™ä½¿å¾—å®ƒä»¬çœ‹èµ·æ¥åƒæ˜¯å¤§çŸ©å½¢çš„å°ç¢ç‰‡ï¼Œæœä¸åŒçš„æ–¹å‘å–·å°„å‡ºå»ã€‚",
      "tips": ""
    },
    "Add a twist! Try changing the speed of the ease-in -out animation for the small rectangles and see what happens.": {
      "zh": "åŠ ç‚¹å˜åŒ–ï¼å°è¯•æ”¹å˜å°çŸ©å½¢çš„ç¼“å…¥ç¼“å‡ºåŠ¨ç”»çš„é€Ÿåº¦ï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆã€‚",
      "tips": ""
    },
    "As those little rectangles explode out, youâ€™ll fade their opacity from 1 to 0 so they eventually disappear. And thatâ€™s your explosion animation. Now, you may be thinking, â€œThis isnâ€™t a real explosion, itâ€™s an illusion.â€, and youâ€™re absolutely right. All animations are illusions, and youâ€™re the magician who creates them. ğŸª„": {
      "zh": "å½“è¿™äº›å°çŸ©å½¢çˆ†ç‚¸æ—¶ï¼Œä½ ä¼šå°†å®ƒä»¬çš„ä¸é€æ˜åº¦ä» 1 æ¸å˜ä¸º 0ï¼Œè¿™æ ·å®ƒä»¬æœ€ç»ˆä¼šæ¶ˆå¤±ã€‚è¿™å°±æ˜¯ä½ çš„çˆ†ç‚¸åŠ¨ç”»ã€‚ç°åœ¨ï¼Œä½ å¯èƒ½ä¼šæƒ³ï¼Œâ€œè¿™ä¸æ˜¯ä¸€ä¸ªçœŸæ­£çš„çˆ†ç‚¸ï¼Œè¿™åªæ˜¯ä¸€ä¸ªå¹»è§‰ã€‚â€ï¼Œä½ æ˜¯ç»å¯¹æ­£ç¡®çš„ã€‚æ‰€æœ‰çš„åŠ¨ç”»éƒ½æ˜¯å¹»è§‰ï¼Œè€Œä½ å°±æ˜¯åˆ›é€ å®ƒä»¬çš„é­”æœ¯å¸ˆã€‚ğŸª„",
      "tips": ""
    },
    "Use scaling and animation delays to create a wave effect.": {
      "zh": "ä½¿ç”¨ç¼©æ”¾å’ŒåŠ¨ç”»å»¶è¿Ÿæ¥åˆ›å»ºæ³¢æµªæ•ˆæœã€‚",
      "tips": ""
    },
    "Now that youâ€™ve dabbled with some basic animations, take a look at how you can combine them to create a more advanced interactive effect. Youâ€™ll learn how to animate a grid of circles to form a fabulous wave effect when you tap them. In the preview, try tapping on different circles in the grid. What do you notice?": {
      "zh": "ç°åœ¨ä½ å·²ç»å°è¯•äº†ä¸€äº›åŸºæœ¬çš„åŠ¨ç”»ï¼Œçœ‹çœ‹ä½ å¦‚ä½•å°†å®ƒä»¬ç»“åˆèµ·æ¥åˆ›å»ºä¸€ä¸ªæ›´é«˜çº§çš„äº¤äº’æ•ˆæœã€‚ä½ å°†å­¦ä¹ å¦‚ä½•å¯¹ä¸€ä¸ªåœ†åœˆç½‘æ ¼è¿›è¡ŒåŠ¨ç”»å¤„ç†ï¼Œå½“ä½ ç‚¹å‡»å®ƒä»¬æ—¶ï¼Œå®ƒä»¬ä¼šå½¢æˆä¸€ä¸ªç¥å¥‡çš„æ³¢æµªæ•ˆæœã€‚åœ¨é¢„è§ˆä¸­ï¼Œå°è¯•ç‚¹å‡»ç½‘æ ¼ä¸­çš„ä¸åŒåœ†åœˆã€‚ä½ æ³¨æ„åˆ°äº†ä»€ä¹ˆï¼Ÿ",
      "tips": ""
    },
    "Youâ€™ll need a few state properties to keep track of how the circles change when you tap them. The gridColumns property defines the columns for the grid, and colors provides the color options for the rainbow effect.": {
      "zh": "ä½ å°†éœ€è¦ä¸€äº›çŠ¶æ€å±æ€§æ¥è·Ÿè¸ªåœ†åœˆåœ¨ä½ ç‚¹å‡»å®ƒä»¬æ—¶çš„å˜åŒ–ã€‚gridColumns å±æ€§å®šä¹‰äº†ç½‘æ ¼çš„åˆ—ï¼Œcolors ä¸ºå½©è™¹æ•ˆæœæä¾›äº†é¢œè‰²é€‰é¡¹ã€‚",
      "tips": ""
    },
    "Try changing the number of columns, by changing the value for count in gridColumns. What happens if you change the colors in the colors array?": {
      "zh": "å°è¯•é€šè¿‡æ”¹å˜ gridColumns ä¸­ count çš„å€¼æ¥æ”¹å˜åˆ—æ•°ã€‚å¦‚æœä½ æ”¹å˜ colors æ•°ç»„ä¸­çš„é¢œè‰²ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ",
      "tips": ""
    },
    "The numCircles constant defines the number of circles in your grid. Your LazyVGrid uses gridColumns and numCircles to generate the initial grid of circles.": {
      "zh": "numCircle å¸¸é‡å®šä¹‰äº†ç½‘æ ¼ä¸­åœ†åœˆçš„æ•°é‡ã€‚ä½ çš„ LazyVGrid ä½¿ç”¨ gridColumns å’Œ numCircles æ¥ç”Ÿæˆåœ†åœˆçš„åˆå§‹ç½‘æ ¼ã€‚",
      "tips": ""
    },
    "Try changing the value of numCircles and see how your grid changes.": {
      "zh": "å°è¯•æ”¹å˜ numCircles çš„å€¼ï¼Œçœ‹çœ‹ä½ çš„ç½‘æ ¼å¦‚ä½•å˜åŒ–ã€‚",
      "tips": ""
    },
    "The springAnimation constant defines the animation to use later in the animation modifier.": {
      "zh": "springAnimation å¸¸é‡å®šä¹‰äº†ç¨ååœ¨åŠ¨ç”»ä¿®é¥°ç¬¦ä¸­ä½¿ç”¨çš„åŠ¨ç”»ã€‚",
      "tips": ""
    },
    "Try changing some of these values and tap the grid to see how they affect the animation.": {
      "zh": "å°è¯•æ”¹å˜å…¶ä¸­ä¸€äº›å€¼ï¼Œç„¶åç‚¹å‡»ç½‘æ ¼ï¼Œçœ‹çœ‹å®ƒä»¬å¦‚ä½•å½±å“åŠ¨ç”»ã€‚",
      "tips": ""
    },
    "Your springAnimation is used to animate changes to the scale of the circles in the grid. However, to create a rolling wave effect you want to animate the circles in your grids at different times. Add delay(_:) to springAnimation to specify the duration of the animation delay for each individual circle. To calculate the delay, divide the circleâ€™s index by the number of columns, taking the truncating remainder as a value between 1 and 10 (the number of columns). This creates a per-column animation effect.": {
      "zh": "ä½ çš„ springAnimation ç”¨äºå¯¹ç½‘æ ¼ä¸­åœ†åœˆçš„ç¼©æ”¾è¿›è¡ŒåŠ¨ç”»å¤„ç†ã€‚ç„¶è€Œï¼Œä¸ºäº†åˆ›å»ºä¸€ä¸ªæ»šåŠ¨çš„æ³¢æµªæ•ˆæœï¼Œä½ å¸Œæœ›ä»¥ä¸åŒçš„æ—¶é—´å¯¹ç½‘æ ¼ä¸­çš„åœ†åœˆè¿›è¡ŒåŠ¨ç”»å¤„ç†ã€‚å°† delay(_:) æ·»åŠ åˆ° springAnimation ä¸­ï¼Œä»¥æŒ‡å®šæ¯ä¸ªå•ç‹¬åœ†åœˆçš„åŠ¨ç”»å»¶è¿ŸæŒç»­æ—¶é—´ã€‚ä¸ºäº†è®¡ç®—å»¶è¿Ÿï¼Œå°†åœ†åœˆçš„ç´¢å¼•é™¤ä»¥åˆ—æ•°ï¼Œå°†æˆªæ–­çš„ä½™æ•°ä½œä¸º 1 åˆ° 10 ä¹‹é—´çš„å€¼ï¼ˆåˆ—æ•°ï¼‰ã€‚è¿™æ ·å°±åˆ›å»ºäº†ä¸€ä¸ªæ¯åˆ—åŠ¨ç”»æ•ˆæœã€‚",
      "tips": ""
    },
    "The .animation modifier determines how the circle animates, but the value for scaleFactor and any changes made to scaleFactor are what causes the increase in scale.": {
      "zh": ".animation ä¿®é¥°ç¬¦å†³å®šäº†åœ†åœˆçš„åŠ¨ç”»æ–¹å¼ï¼Œä½†æ˜¯ scaleFactor çš„å€¼å’Œå¯¹ scaleFactor çš„ä»»ä½•æ›´æ”¹æ‰æ˜¯å¯¼è‡´ç¼©æ”¾å¢åŠ çš„åŸå› ã€‚",
      "tips": ""
    },
    "The tapGesture modifier allows you to change the scaleFactor by tapping a circle in the grid. When you tap a circle, the value of scaleFactor is set based on that circleâ€™s index. The further the circleâ€™s position is in the grid, the larger the scaleFactor will be.": {
      "zh": "tapGesture ä¿®é¥°ç¬¦å…è®¸ä½ é€šè¿‡ç‚¹å‡»ç½‘æ ¼ä¸­çš„ä¸€ä¸ªåœ†åœˆæ¥æ”¹å˜ scaleFactorã€‚å½“ä½ ç‚¹å‡»ä¸€ä¸ªåœ†åœˆæ—¶ï¼ŒscaleFactor çš„å€¼æ˜¯åŸºäºè¯¥åœ†åœˆçš„ç´¢å¼•è®¾ç½®çš„ã€‚åœ†åœˆåœ¨ç½‘æ ¼ä¸­çš„ä½ç½®è¶Šè¿œï¼ŒscaleFactor å°±è¶Šå¤§ã€‚",
      "tips": ""
    },
    "Because the index of circles starts at 0, you need to set the scaleFactor using index+1 so you never have to set the scaleFactor to an undefined number.": {
      "zh": "å› ä¸ºåœ†åœˆçš„ç´¢å¼•ä» 0 å¼€å§‹ï¼Œæ‰€ä»¥ä½ éœ€è¦ä½¿ç”¨ index+1 æ¥è®¾ç½® scaleFactorï¼Œè¿™æ ·ä½ å°±æ°¸è¿œä¸éœ€è¦å°† scaleFactor è®¾ç½®ä¸ºä¸€ä¸ªæœªå®šä¹‰çš„æ•°å­—ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "",
      "tips": ""
    },
    "There you have itâ€¦a beautiful rolling rainbow!": {
      "zh": "å°±æ˜¯è¿™æ ·...ä½ å·²ç»æ‹¥æœ‰äº†ç¾ä¸½çš„çš„æ»šåŠ¨å½©è™¹",
      "tips": ""
    },
    "Try tinkering with this animation until itâ€™s exactly as you like it. Good luck!": {
      "zh": "å°è¯•è°ƒæ•´è¿™ä¸ªåŠ¨ç”»ï¼Œç›´åˆ°å®ƒå®Œå…¨ç¬¦åˆä½ çš„å–œå¥½ã€‚ç¥ä½ å¥½è¿ï¼",
      "tips": ""
    },
    "Use a drag gesture to move a grid of dots.": {
      "zh": "ä½¿ç”¨æ‹–åŠ¨æ‰‹åŠ¿æ¥ç§»åŠ¨ä¸€ä¸ªç½‘æ ¼çš„ç‚¹ã€‚",
      "tips": ""
    },
    "Dragginâ€™ Drop Dots is very similar to Rollinâ€™ Rainbow, but with some differences. Instead of changing the scale of the circles when you tap them, the circleâ€™s offset changes based on a drag gesture applied to the entire grid. Time to dive into the code.": {
      "zh": "Dragginâ€™ Drop Dots ä¸ Rollinâ€™ Rainbow éå¸¸ç›¸ä¼¼ï¼Œä½†ä¹Ÿæœ‰ä¸€äº›ä¸åŒä¹‹å¤„ã€‚å½“ä½ ç‚¹å‡»åœ†åœˆæ—¶ï¼Œåœ†åœˆçš„åç§»é‡ä¼šæ ¹æ®åº”ç”¨äºæ•´ä¸ªç½‘æ ¼çš„æ‹–åŠ¨æ‰‹åŠ¿è€Œæ”¹å˜ï¼Œè€Œä¸æ˜¯æ”¹å˜åœ†åœˆçš„ç¼©æ”¾ã€‚æ˜¯æ—¶å€™æ·±å…¥ä»£ç äº†ã€‚",
      "tips": ""
    },
    "This is a much larger grid than Rollinâ€™ Rainbow â€“ there are a lot more circles and columns. See what happens when you change the number of dots in the grid. Do you need more circles in this animation?": {
      "zh": "è¿™æ˜¯ä¸€ä¸ªæ¯” Rollinâ€™ Rainbow å¤§å¾—å¤šçš„ç½‘æ ¼â€”â€”æœ‰æ›´å¤šçš„åœ†åœˆå’Œåˆ—ã€‚çœ‹çœ‹å½“ä½ æ”¹å˜ç½‘æ ¼ä¸­çš„ç‚¹æ•°æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚ä½ éœ€è¦åœ¨è¿™ä¸ªåŠ¨ç”»ä¸­æœ‰æ›´å¤šçš„åœ†åœˆå—ï¼Ÿ",
      "tips": ""
    },
    "Add a drag gesture instead of a tap gesture so the grid moves when you drag it. You can use the translation value in the drag gesture closure to set the offset of each circle, resulting in the entire grid moving to the new drag.translation value.": {
      "zh": "æ·»åŠ ä¸€ä¸ªæ‹–åŠ¨æ‰‹åŠ¿ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç‚¹å‡»æ‰‹åŠ¿ï¼Œè¿™æ ·å½“ä½ æ‹–åŠ¨å®ƒæ—¶ï¼Œç½‘æ ¼å°±ä¼šç§»åŠ¨ã€‚ä½ å¯ä»¥åœ¨æ‹–åŠ¨æ‰‹åŠ¿é—­åŒ…ä¸­ä½¿ç”¨ translation å€¼æ¥è®¾ç½®æ¯ä¸ªåœ†åœˆçš„åç§»é‡ï¼Œä»è€Œå¯¼è‡´æ•´ä¸ªç½‘æ ¼ç§»åŠ¨åˆ°æ–°çš„ drag.translation å€¼ã€‚",
      "tips": ""
    },
    "When the offset changes, youâ€™ll animate the circles to their new positions. Instead of moving all of the dots at the same time, you can use delay on the animation so that each circle moves individually. If you set the delay based on each circleâ€™s index, the circles will have a slightly different delay. This results in the entire grid animating one circle after the other. Because this animation would otherwise be very slow, you can divide the value for delay by the animationSpeed value to speed it up.": {
      "zh": "å½“æ‰‹åŠ¿çš„åç§»é‡å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä½ å°†å¯¹åœ†åœˆè¿›è¡ŒåŠ¨ç”»å¤„ç†ï¼Œä½¿å®ƒä»¬å¤„äºæ–°çš„ä½ç½®ã€‚ä½ å¯ä»¥ä½¿ç”¨åŠ¨ç”»ä¸Šçš„å»¶è¿Ÿï¼Œè€Œä¸æ˜¯åŒæ—¶ç§»åŠ¨æ‰€æœ‰çš„ç‚¹ï¼Œè¿™æ ·æ¯ä¸ªåœ†åœˆå°±å¯ä»¥å•ç‹¬ç§»åŠ¨ã€‚å¦‚æœä½ æ ¹æ®æ¯ä¸ªåœ†åœˆçš„ç´¢å¼•è®¾ç½®å»¶è¿Ÿï¼Œé‚£ä¹ˆåœ†åœˆçš„å»¶è¿Ÿå°±ä¼šç•¥æœ‰ä¸åŒã€‚è¿™å¯¼è‡´æ•´ä¸ªç½‘æ ¼ä¼šåœ¨ä¸€ä¸ªåœ†åœˆä¹‹ååŠ¨ç”»æ‰§è¡Œç»“æŸä¹‹åå†æ‰§è¡Œå¦ä¸€ä¸ªåœ†åœˆçš„åŠ¨ç”»ã€‚å› ä¸ºè¿™ä¸ªåŠ¨ç”»æœ¬æ¥ä¼šéå¸¸æ…¢ï¼Œæ‰€ä»¥ä½ å¯ä»¥å°†å»¶è¿Ÿçš„å€¼é™¤ä»¥ animationSpeed çš„å€¼æ¥åŠ å¿«é€Ÿåº¦ã€‚",
      "tips": ""
    },
    "Try changing the animationSpeed to something very low, like 20. How does the animation change?": {
      "zh": "å°è¯•å°† animationSpeed æ›´æ”¹ä¸ºéå¸¸ä½çš„å€¼ï¼Œæ¯”å¦‚ 20ã€‚åŠ¨ç”»ä¼šå¦‚ä½•å˜åŒ–ï¼Ÿ",
      "tips": ""
    },
    "Dancing Dots": {
      "zh": "è·³èˆçš„ç‚¹",
      "tips": ""
    },
    "Make the circles boogie!": {
      "zh": "è®©åœ†åœˆè·³èˆï¼",
      "tips": ""
    },
    "Animate more complex model data in cool and interesting ways using observable objects.": {
      "zh": "è®©æ›´å¤šå¤æ‚çš„æ¨¡å‹æ•°æ®ä»¥æœ‰è¶£çš„æ–¹å¼ä½¿ç”¨ observable å¯¹è±¡è¿›è¡ŒåŠ¨ç”»å¤„ç†ã€‚",
      "tips": ""
    },
    "What if the changes you want to animate arenâ€™t coming from user actions? SwiftUI has a way of animating published values in observable objects. Create an observable object BigDot that publishes an offset, color, scale, and an array of small dot observable objects. Youâ€™ll use this object to model the view animations you want in your view.": {
      "zh": "å¦‚æœä½ æƒ³è¦åŠ¨ç”»å¤„ç†çš„å˜åŒ–ä¸æ˜¯æ¥è‡ªç”¨æˆ·çš„æ“ä½œæ€ä¹ˆåŠï¼ŸSwiftUI æœ‰ä¸€ç§æ–¹æ³•å¯ä»¥å¯¹ observable å¯¹è±¡ä¸­å‘å¸ƒçš„å€¼è¿›è¡ŒåŠ¨ç”»å¤„ç†ã€‚åˆ›å»ºä¸€ä¸ª observable å¯¹è±¡ BigDotï¼Œå®ƒå‘å¸ƒä¸€ä¸ªåç§»é‡ã€é¢œè‰²ã€æ¯”ä¾‹å’Œä¸€ä¸ªå°ç‚¹ observable å¯¹è±¡çš„æ•°ç»„ã€‚ä½ å°†ä½¿ç”¨è¿™ä¸ªå¯¹è±¡æ¥æ¨¡æ‹Ÿä½ åœ¨è§†å›¾ä¸­æƒ³è¦çš„è§†å›¾åŠ¨ç”»ã€‚",
      "tips": ""
    },
    "Add a SmallDot observable object that publishes a color and an offset.": {
      "zh": "æ·»åŠ ä¸€ä¸ª SmallDot observable å¯¹è±¡ï¼Œå®ƒå°†å‘å¸ƒä¸€ä¸ªé¢œè‰²å’Œä¸€ä¸ªåç§»é‡ã€‚",
      "tips": ""
    },
    "When you create a bigDot, you also need to create an array of small dots that are linked to the big dot.": {
      "zh": "å½“ä½ åˆ›å»ºä¸€ä¸ª bigDot æ—¶ï¼Œä½ è¿˜éœ€è¦åˆ›å»ºä¸€ä¸ªä¸ bigDot ç›¸å…³è”çš„ smallDot æ•°ç»„ã€‚",
      "tips": ""
    },
    "Now, a grid of big dots needs to populate the grid with five small dots for every big dot. Because there are so many dots, youâ€™ll use a DotTracker class when publishing an array of BigDots. This is the published value youâ€™ll track to create your animations. What happens to the animation if you increase or decrease the number of smallDots in the array?": {
      "zh": "ç°åœ¨ï¼Œä¸€ä¸ªå¤§ç‚¹çš„ç½‘æ ¼éœ€è¦ä¸ºæ¯ä¸ªå¤§ç‚¹å¡«å……äº”ä¸ªå°ç‚¹ã€‚å› ä¸ºæœ‰è¿™ä¹ˆå¤šçš„ç‚¹ï¼Œæ‰€ä»¥åœ¨å‘å¸ƒä¸€ä¸ª BigDots æ•°ç»„æ—¶ï¼Œä½ å°†ä½¿ç”¨ä¸€ä¸ª DotTracker ç±»ã€‚è¿™æ˜¯ä½ å°†è·Ÿè¸ªçš„å‘å¸ƒå€¼ï¼Œä»¥åˆ›å»ºä½ çš„åŠ¨ç”»ã€‚å¦‚æœä½ å¢åŠ æˆ–å‡å°‘æ•°ç»„ä¸­çš„ smallDots æ•°é‡ï¼ŒåŠ¨ç”»ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ",
      "tips": ""
    },
    "Your bigDots array has 100 BigDot instances that appear in the grid view.": {
      "zh": "ä½ çš„ bigDots æ•°ç»„æœ‰ 100 ä¸ª BigDot å®ä¾‹ï¼Œå®ƒä»¬å‡ºç°åœ¨ç½‘æ ¼è§†å›¾ä¸­ã€‚",
      "tips": ""
    },
    "You may notice that the BigDot class and DotTracker both include a randomizePositions() function that do almost the same thing. The function in BigDot creates random positions for each SmallDot in its smallDot array, while the function in DotTracker creates random positions for each BigDot. Together, these functions create the changes in the offset, color, and scale values reflected by animations in your grid view.": {
      "zh": "ä½ å¯èƒ½ä¼šæ³¨æ„åˆ°ï¼ŒBigDot ç±»å’Œ DotTracker éƒ½åŒ…å«ä¸€ä¸ª randomizePositions() å‡½æ•°ï¼Œå®ƒä»¬å‡ ä¹åšäº†ç›¸åŒçš„äº‹æƒ…ã€‚BigDot ä¸­çš„å‡½æ•°ä¸ºå…¶ smallDot æ•°ç»„ä¸­çš„æ¯ä¸ª SmallDot åˆ›å»ºéšæœºä½ç½®ï¼Œè€Œ DotTracker ä¸­çš„å‡½æ•°ä¸ºæ¯ä¸ª BigDot åˆ›å»ºéšæœºä½ç½®ã€‚è¿™äº›å‡½æ•°ä¸€èµ·åœ¨ç½‘æ ¼è§†å›¾ä¸­åˆ›å»ºäº†åç§»é‡ã€é¢œè‰²å’Œæ¯”ä¾‹å€¼çš„å˜åŒ–ï¼Œè¿™äº›å˜åŒ–åæ˜ åœ¨åŠ¨ç”»ä¸­ã€‚",
      "tips": ""
    },
    "Try changing the value of the scale in the randomizePositions() function. What happens to the animation when you lower the scale value?": {
      "zh": "å°è¯•ä¿®æ”¹ randomizePositions() å‡½æ•°ä¸­çš„ scale å€¼ã€‚å½“ä½ é™ä½ scale å€¼æ—¶ï¼ŒåŠ¨ç”»ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ",
      "tips": ""
    },
    "Add a resetPositions() function, so the dots reset to their original positions when you tap the reset button. This is very similar to the randomizePositions() function used to place circles in random locations around the view.": {
      "zh": "æ·»åŠ ä¸€ä¸ª resetPositions() å‡½æ•°ï¼Œè¿™æ ·å½“ä½ ç‚¹å‡»é‡ç½®æŒ‰é’®æ—¶ï¼Œç‚¹ä¼šé‡ç½®åˆ°å®ƒä»¬çš„åŸå§‹ä½ç½®ã€‚è¿™ä¸ç”¨äºåœ¨è§†å›¾å‘¨å›´éšæœºä½ç½®æ”¾ç½®åœ†åœˆçš„ randomizePositions() å‡½æ•°éå¸¸ç›¸ä¼¼ã€‚",
      "tips": ""
    },
    "The randomizePositions() function calls bigDot.randomizePositions(). This puts every SmallDot in the smallDot array defined in the BigDot class into random positions.": {
      "zh": "randomizePositions() å‡½æ•°ä¼šè°ƒç”¨ bigDot.randomizePositions()ã€‚è¿™å°† BigDot ç±»ä¸­å®šä¹‰çš„ smallDot æ•°ç»„ä¸­çš„æ¯ä¸ª SmallDot æ”¾ç½®åœ¨éšæœºä½ç½®ã€‚",
      "tips": ""
    },
    "The DancingDotsView needs to define an instance of the DotTracker as a @StateObject so SwiftUI redraws its contents whenever any of the viewâ€™s dots change color or position.": {
      "zh": "DansingDotsView éœ€è¦å°† DotTracker çš„å®ä¾‹å®šä¹‰ä¸º @StateObjectï¼Œè¿™æ · SwiftUI å°±ä¼šåœ¨è§†å›¾çš„ä»»ä½•ç‚¹çš„é¢œè‰²æˆ–ä½ç½®å‘ç”Ÿå˜åŒ–æ—¶é‡æ–°ç»˜åˆ¶å…¶å†…å®¹ã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "",
      "tips": ""
    },
    "Add in this ForEach loop to place each BigDot tracked by the tracker into the grid.": {
      "zh": "å°†è¿™ä¸ª ForEach å¾ªç¯æ·»åŠ åˆ° tracker ä¸­ï¼Œä»¥å°†æ¯ä¸ªè¢« tracker è¿½è¸ªçš„ BigDot æ”¾ç½®åˆ°ç½‘æ ¼ä¸­ã€‚",
      "tips": ""
    },
    "Step 11": {
      "zh": "",
      "tips": ""
    },
    "For each BigDot, you can create a circle view with its offset, color, and scale.": {
      "zh": "å¯¹äºæ¯ä¸ª BigDotï¼Œä½ å¯ä»¥é€šè¿‡é…ç½®å®ƒçš„åç§»é‡ã€é¢œè‰²å’Œæ¯”ä¾‹æ¥åˆ›å»ºä¸€ä¸ªåœ†å½¢è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 12": {
      "zh": "",
      "tips": ""
    },
    "Because every BigDot has five SmallDots, you can do the same thing for the small dots.": {
      "zh": "å› ä¸ºæ¯ä¸ª BigDot éƒ½æœ‰äº”ä¸ª SmallDotï¼Œæ‰€ä»¥ä½ å¯ä»¥å¯¹å°ç‚¹åšåŒæ ·çš„äº‹æƒ…ã€‚",
      "tips": ""
    },
    "Step 13": {
      "zh": "",
      "tips": ""
    },
    "When you tap the play button, the circles animate and the randomizePositions() function is called. This causes the circlesâ€™ offsets to change, creating a dancing effect for the dots.": {
      "zh": "å½“ä½ ç‚¹å‡»æ’­æ”¾æŒ‰é’®æ—¶ï¼Œåœ†åœˆä¼šæ‰§è¡ŒåŠ¨ç”»ï¼ŒåŒæ—¶ randomizePositions() å‡½æ•°ä¼šè¢«è°ƒç”¨ã€‚è¿™ä¼šå¯¼è‡´åœ†åœˆçš„åç§»é‡å‘ç”Ÿå˜åŒ–ï¼Œä¸ºç‚¹åˆ›å»ºä¸€ä¸ªè·³èˆæ•ˆæœã€‚",
      "tips": ""
    },
    "Step 14": {
      "zh": "",
      "tips": ""
    },
    "Add this isAnimating state property, which calls the resetPositions() method and resets the circleâ€™s positions when you tap Reset.": {
      "zh": "æ·»åŠ è¿™ä¸ª isAnimating çŠ¶æ€å±æ€§ï¼Œå®ƒä¼šè°ƒç”¨ resetPositions() æ–¹æ³•ï¼Œå¹¶åœ¨ä½ ç‚¹å‡»é‡ç½®æ—¶é‡ç½®åœ†åœˆçš„ä½ç½®ã€‚",
      "tips": ""
    },
    "Step 15": {
      "zh": "",
      "tips": ""
    },
    "Because everything is animating, adding drawingGroup() helps to make the animation render smoothly.": {
      "zh": "å› ä¸ºä¸€åˆ‡å†…å®¹éƒ½åœ¨æ‰§è¡ŒåŠ¨ç”»ï¼Œæ‰€ä»¥æ·»åŠ  drawingGroup() æœ‰åŠ©äºä½¿åŠ¨ç”»æ¸²æŸ“å¹³æ»‘ã€‚",
      "tips": ""
    },
    "Step 16": {
      "zh": "",
      "tips": ""
    },
    "Now you know how to create more complex animations with shapes. Time to take what youâ€™ve learned in this guide and use it to make some cool Swift apps!": {
      "zh": "ç°åœ¨ä½ çŸ¥é“å¦‚ä½•ä½¿ç”¨å½¢çŠ¶åˆ›å»ºæ›´å¤æ‚çš„åŠ¨ç”»äº†ã€‚ç°åœ¨æ˜¯æ—¶å€™å°†ä½ åœ¨æœ¬æŒ‡å—ä¸­å­¦åˆ°çš„çŸ¥è¯†ç”¨äºåˆ¶ä½œä¸€äº›å¾ˆé…·çš„ Swift åº”ç”¨äº†ï¼",
      "tips": ""
    },
    "Previewing the Camera Output": {
      "zh": "é¢„è§ˆç›¸æœºè¾“å‡º",
      "tips": ""
    },
    "Preview the output from the camera.": {
      "zh": "é¢„è§ˆæ¥è‡ªç›¸æœºçš„è¾“å‡ºã€‚",
      "tips": ""
    },
    "Rollin Rainbow": {
      "zh": "",
      "tips": ""
    },
    "Draggin Drop It": {
      "zh": "",
      "tips": ""
    }
  },
  "sample-apps/bubblelevel": {
    "Bubble Level": {
      "zh": "",
      "tips": ""
    },
    "Access and display device sensor data by subscribing to notifications.": {
      "zh": "é€šè¿‡è®¢é˜…é€šçŸ¥æ¥è®¿é—®å’Œæ˜¾ç¤ºè®¾å¤‡ä¼ æ„Ÿå™¨æ•°æ®ã€‚",
      "tips": ""
    },
    "Welcome to Bubble Level.": {
      "zh": "æ¬¢è¿æ¥åˆ°â€œæ°”æ³¡æ°´å¹³ä»ªâ€è¿™å ‚è¯¾ã€‚",
      "tips": ""
    },
    "A bubble level helps you determine whether something is level or tilted.": {
      "zh": "æ°”æ³¡æ°´å¹³ä»ªå¯å¸®åŠ©æ‚¨ç¡®å®šä¸€ä¸ªç‰©ä½“æ˜¯æ°´å¹³è¿˜æ˜¯å€¾æ–œã€‚",
      "tips": ""
    },
    "This app displays the orientation of your device as numbers and as a graphical version of a bubble level. Try tilting your device and watch the bubble move. Try to make your device level by centering the bubble in the crosshairs. Or place it on a surface like your bedroom floor to determine whether the floor is level.": {
      "zh": "è¿™ä¸ª App å°†ä¼šåˆ†åˆ«ä»¥æ•°å­—å’Œå¯è§†åŒ–çš„æ°”æ³¡æ°´å¹³ä»ªæ¥æ˜¾ç¤ºä½ è®¾å¤‡çš„æ–¹å‘ã€‚ä½ å¯ä»¥å°è¯•å€¾æ–œä½ çš„è®¾å¤‡å¹¶è§‚å¯Ÿæ°”æ³¡ç§»åŠ¨ï¼Œé€šè¿‡å°†æ°”æ³¡ç½®äºåå­—å‡†çº¿ä¸­å¿ƒæ¥ä½¿è®¾å¤‡ä¿æŒæ°´å¹³ã€‚æˆ–è€…å°†å…¶æ”¾åœ¨å§å®¤åœ°æ¿ç­‰è¡¨é¢ä¸Šï¼Œä»¥ç¡®å®šåœ°æ¿æ˜¯å¦æ°´å¹³ã€‚",
      "tips": ""
    },
    "Motion Detector": {
      "zh": "",
      "tips": ""
    },
    "You can use the MotionDetector class to observe the motion of your device.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨è¿™ä¸ª MotionDetector ç±»æ¥è§‚å¯Ÿä½ çš„è®¾å¤‡çš„è¿åŠ¨ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "",
      "tips": ""
    },
    "Your device has sensors such as accelerometers and gyroscopes that it uses to sense motion and orientation. The Core Motion framework gives you access to data from these and other sensors.": {
      "zh": "ä½ çš„è®¾å¤‡æœ‰åŠ é€Ÿè®¡å’Œé™€èºä»ªç­‰ä¼ æ„Ÿå™¨ï¼Œå®ƒä»¬ç”¨äºæ„ŸçŸ¥è¿åŠ¨å’Œæ–¹å‘ã€‚Core Motion æ¡†æ¶å¯ä»¥è®©ä½ è®¿é—®è¿™äº›ä¼ æ„Ÿå™¨å’Œå…¶ä»–ä¼ æ„Ÿå™¨çš„æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "",
      "tips": ""
    },
    "You use a CMMotionManager object to get motion data from sensors, such as the accelerometer. It gathers information from the sensors and translates their data into values that you can understand.": {
      "zh": "ä½ å°†ä¼šä½¿ç”¨ CMMotionManager å¯¹è±¡æ¥è·å–ä¼ æ„Ÿå™¨çš„è¿åŠ¨æ•°æ®ï¼Œä¾‹å¦‚åŠ é€Ÿè®¡ã€‚å®ƒä¼šä»ä¼ æ„Ÿå™¨ä¸­æ”¶é›†ä¿¡æ¯ï¼Œå¹¶å°†å®ƒä»¬çš„æ•°æ®è½¬æ¢ä¸ºä½ å¯ä»¥ç†è§£çš„å€¼ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "",
      "tips": ""
    },
    "The timer property stores a Timer instance. A timer waits for a period of time that you specify before running some code. The MotionDetector uses the timer to update its pitch, roll, and zAcceleration values at regular intervals, defined by the updateInterval property.": {
      "zh": "timer è¿™ä¸ªå±æ€§å­˜å‚¨äº†ä¸€ä¸ª Timer å®ä¾‹ã€‚Timer ä¼šåœ¨ä½ æŒ‡å®šçš„æ—¶é—´æ®µä¹‹åè¿è¡Œä¸€äº›ä»£ç ã€‚MotionDetector ä½¿ç”¨ timer æ¥åœ¨ updateInterval å±æ€§å®šä¹‰çš„æ—¶é—´é—´éš”å†…æ›´æ–°å®ƒçš„ pitchã€roll å’Œ zAcceleration å€¼ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "",
      "tips": ""
    },
    "You can choose an update interval that makes sense for your app. For example, youâ€™ll want a short update interval for the bubble level in this project because the interface presents real-time data as the device moves.": {
      "zh": "ä½ å¯ä»¥é€‰æ‹©ä¸€ä¸ªå¯¹ä½ çš„åº”ç”¨ç¨‹åºæœ‰æ„ä¹‰çš„æ›´æ–°é—´éš”ã€‚ä¾‹å¦‚ï¼Œä½ å°†å¸Œæœ›è¿™ä¸ªé¡¹ç›®ä¸­çš„æ°”æ³¡æ°´å¹³ä»ªæœ‰ä¸€ä¸ªçŸ­çš„æ›´æ–°é—´éš”ï¼Œå› ä¸ºç•Œé¢ä¼šéšç€è®¾å¤‡çš„ç§»åŠ¨è€Œå®æ—¶æ˜¾ç¤ºæ•°æ®ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "",
      "tips": ""
    },
    "These three properties store data for the tilt of your device in two dimensions (roll and pitch), as well as its vertical acceleration (zAcceleration).": {
      "zh": "è¿™ä¸‰ä¸ªå±æ€§å­˜å‚¨äº†ä½ çš„è®¾å¤‡åœ¨ä¸¤ä¸ªç»´åº¦ä¸Šçš„å€¾æ–œæ•°æ®ï¼ˆroll å’Œ pitchï¼‰ï¼Œä»¥åŠå®ƒçš„å‚ç›´åŠ é€Ÿåº¦ï¼ˆzAccelerationï¼‰ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "",
      "tips": ""
    },
    "These properties have a @Published property wrapper, which means that any SwiftUI view that depends on their values updates when they change. You make a view dependent on a published property by referring to it in the viewâ€™s code. The BubbleLevel, LevelView, and OrientationDataView views use these properties, which enables them to update when the MotionDetector detects a change to the roll, pitch, or zAcceleration values.": {
      "zh": "è¿™äº›å±æ€§æœ‰ä¸€ä¸ª @Published å±æ€§åŒ…è£…å™¨ï¼Œè¿™æ„å‘³ç€ä»»ä½•ä¾èµ–äºå®ƒä»¬å€¼çš„ SwiftUI è§†å›¾ä¼šåœ¨å®ƒä»¬æ”¹å˜æ—¶æ›´æ–°ã€‚ä½ å¯ä»¥é€šè¿‡åœ¨è§†å›¾çš„ä»£ç ä¸­å¼•ç”¨å®ƒæ¥ä½¿è§†å›¾ä¾èµ–äºå·²å‘å¸ƒçš„å±æ€§ã€‚BubbleLevelã€LevelView å’Œ OrientationDataView è§†å›¾ä½¿ç”¨è¿™äº›å±æ€§ï¼Œè¿™ä½¿å®ƒä»¬èƒ½å¤Ÿåœ¨ MotionDetector æ£€æµ‹åˆ° rollã€pitch æˆ– zAcceleration å€¼çš„å˜åŒ–æ—¶æ›´æ–°ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "",
      "tips": ""
    },
    "This property stores code that runs when the MotionDetector updates its motion data. If you want to execute custom actions every time the motion data changes, you can put your own code into onUpdate in your instance of MotionDetector.": {
      "zh": "è¿™ä¸ªå±æ€§å­˜å‚¨äº†å½“ MotionDetector æ›´æ–°å…¶è¿åŠ¨æ•°æ®æ—¶éœ€è¦è¿è¡Œçš„ä»£ç ã€‚å¦‚æœä½ æƒ³åœ¨æ¯æ¬¡è¿åŠ¨æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶æ‰§è¡Œè‡ªå®šä¹‰æ“ä½œï¼Œä½ å¯ä»¥å°†è‡ªå·±çš„ä»£ç æ”¾åˆ° MotionDetector çš„ onUpdate ä¸­ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "",
      "tips": ""
    },
    "This method starts updating the motion detector.": {
      "zh": "è¿™ä¸ªæ–¹æ³•ä¼šå¼€å§‹ç”¨ä¼ æ„Ÿå™¨çš„æ•°æ®æ›´æ–°æˆ‘ä»¬çš„è¿åŠ¨æ£€æµ‹å™¨çš„æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "",
      "tips": ""
    },
    "Always use isDeviceMotionAvailable to verify that motion data is available before you try to access it.": {
      "zh": "åœ¨ä½ æƒ³è¦è®¿é—®è¿åŠ¨æ•°æ®ä¹‹å‰ï¼Œè®°å¾—å§‹ç»ˆä½¿ç”¨ isDeviceMotionAvailable æ¥éªŒè¯è¿åŠ¨æ•°æ®æ˜¯å¦å¯ç”¨ã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "",
      "tips": ""
    },
    "This method tells the CMMotionManager to start updating motion data.": {
      "zh": "è¿™ä¸ªæ–¹æ³•ä¼šå‘Šè¯‰ CMMotionManager å¼€å§‹æ›´æ–°è¿åŠ¨æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 11": {
      "zh": "",
      "tips": ""
    },
    "This code creates a new timer and schedules it to run. The updateInterval property tells the timer how long to wait between updates, and repeats is set to true so that the timer runs forever until you stop it. (If you pass false to repeats, the timer only runs once.)": {
      "zh": "è¿™æ®µä»£ç åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„è®¡æ—¶å™¨å¹¶è®¾å®šäº†å…¶è¿ä½œæ–¹å¼ã€‚updateInterval å±æ€§ä¼šå‘Šè¯‰è®¡æ—¶å™¨åœ¨æ¯æ¬¡æ•°æ®æ›´æ–°ä¹‹é—´éœ€è¦ç­‰å¾…å¤šé•¿æ—¶é—´ï¼Œå°† repeats è®¾ç½®ä¸º true åï¼Œè®¡æ—¶å™¨å°±ä¼šä¸€ç›´è¿è¡Œï¼Œç›´åˆ°ä½ åœæ­¢å®ƒã€‚ï¼ˆå¦‚æœä½ ä¼ é€’ false ç»™ repeatsï¼Œè®¡æ—¶å™¨åªä¼šè¿è¡Œä¸€æ¬¡ã€‚ï¼‰",
      "tips": ""
    },
    "Step 12": {
      "zh": "",
      "tips": ""
    },
    "The block of code at the end of the line that reads { _ in is the start of a closure containing the code that the timer runs. The closure calls updateMotionData().": {
      "zh": "ç¬¬ä¸€è¡Œæœ€æœ«ç«¯çš„ { _ in æ˜¯ä¸€ä¸ªé—­åŒ…çš„å¼€å§‹ï¼ŒåŒ…å«äº†å®šæ—¶å™¨è¿è¡Œçš„ä»£ç ã€‚è¿™ä¸ªé—­åŒ…ä¼šè°ƒç”¨ updateMotionData() æ–¹æ³•ã€‚",
      "tips": ""
    },
    "Step 13": {
      "zh": "",
      "tips": ""
    },
    "This method does the core work of the motion detector. Itâ€™s responsible for updating all the published properties with current data from the sensors, as well as calling the code in onUpdate.": {
      "zh": "è¿™ä¸ªæ–¹æ³•æ˜¯è¿åŠ¨æ£€æµ‹å™¨çš„æ ¸å¿ƒå·¥ä½œã€‚å®ƒè´Ÿè´£ä½¿ç”¨ä¼ æ„Ÿå™¨çš„å½“å‰æ•°æ®æ›´æ–°æ‰€æœ‰å·²å‘å¸ƒçš„å±æ€§ï¼Œä»¥åŠè°ƒç”¨ onUpdate",
      "tips": ""
    },
    "Step 14": {
      "zh": "",
      "tips": ""
    },
    "The deviceMotion data may not be there in certain conditions. The way you can tell if the data exists is to try to assign it to a variable or constant using if let. If the motion data exists, itâ€™s assigned to data and the code inside the braces runs. Otherwise, it skips the entire if statement.": {
      "zh": "åœ¨ä¸€äº›æƒ…å†µä¸‹ï¼ŒdeviceMotion æ•°æ®å¯èƒ½ä¸å­˜åœ¨ã€‚ä½ å¯ä»¥é€šè¿‡ if let æ¥åˆ¤æ–­æ•°æ®æ˜¯å¦å­˜åœ¨ã€‚å¦‚æœ motion æ•°æ®å­˜åœ¨ï¼Œå®ƒä¼šè¢«èµ‹å€¼ç»™ data å¹¶ä¸”å¤§æ‹¬å·å†…çš„ä»£ç ä¼šè¢«æ‰§è¡Œã€‚å¦åˆ™ï¼Œæ•´ä¸ª if è¯­å¥ä¼šè¢«è·³è¿‡ã€‚",
      "tips": ""
    },
    "Step 15": {
      "zh": "",
      "tips": ""
    },
    "A CMDeviceMotion instance represents device motion, stored here in data. It has quite a few properties describing the input from the motion sensors.": {
      "zh": "CMDeviceMotion å®ä¾‹ä»£è¡¨è®¾å¤‡çš„è¿åŠ¨ï¼Œå­˜å‚¨åœ¨ data ä¸­ã€‚å®ƒæœ‰å¾ˆå¤šå±æ€§æ¥æè¿°ä¼ æ„Ÿå™¨çš„è¾“å…¥ã€‚",
      "tips": ""
    },
    "Step 16": {
      "zh": "",
      "tips": ""
    },
    "Use the attitude property to get the deviceâ€™s tilt in three directions. You may be familiar with X, Y, and Z axes in 3D space. Pitch, roll, and yaw are numbers that describe rotation along those axes.": {
      "zh": "ä½¿ç”¨ attitude å±æ€§æ¥è·å–è®¾å¤‡åœ¨ä¸‰ä¸ªæ–¹å‘ä¸Šçš„å€¾æ–œã€‚ä½ å¯èƒ½ç†Ÿæ‚‰ 3D ç©ºé—´ä¸­çš„ Xã€Y å’Œ Zã€‚Pitchï¼ˆä¿¯ä»°ï¼‰ã€rollï¼ˆç¿»æ»šï¼‰å’Œ yawï¼ˆåèˆªï¼‰æ˜¯æè¿°æ²¿è¿™äº›è½´æ—‹è½¬ç¨‹åº¦çš„æ•°å­—ã€‚",
      "tips": ""
    },
    "Step 17": {
      "zh": "",
      "tips": ""
    },
    "Use the userAcceleration property to get the deviceâ€™s acceleration after accounting for the downward pull of gravity. If itâ€™s at rest, this number is 0. If itâ€™s accelerating upward, the number is negative, and if itâ€™s accelerating downward, the number is positive.": {
      "zh": "ä½¿ç”¨ userAcceleration å±æ€§æ¥è·å–è®¾å¤‡åœ¨è€ƒè™‘åˆ°é‡åŠ›å‘ä¸‹æ‹‰çš„æƒ…å†µä¸‹çš„åŠ é€Ÿåº¦ã€‚å¦‚æœå®ƒå¤„äºé™æ­¢çŠ¶æ€ï¼Œè¿™ä¸ªæ•°å€¼ä¸º 0ã€‚å¦‚æœå®ƒå‘ä¸ŠåŠ é€Ÿï¼Œè¿™ä¸ªæ•°å€¼ä¸ºè´Ÿæ•°ï¼Œå¦‚æœå®ƒå‘ä¸‹åŠ é€Ÿï¼Œè¿™ä¸ªæ•°å€¼ä¸ºæ­£æ•°ã€‚",
      "tips": ""
    },
    "Step 18": {
      "zh": "",
      "tips": ""
    },
    "You run the code in onUpdate just as youâ€™d call any function, with a set of parentheses following its name.": {
      "zh": "ä½ å¯ä»¥åƒè°ƒç”¨ä»»ä½•å‡½æ•°ä¸€æ ·è°ƒç”¨ onUpdate ä¸­çš„ä»£ç ï¼Œåªéœ€è¦åœ¨å‡½æ•°ååé¢åŠ ä¸Šä¸€å¯¹æ‹¬å·ã€‚",
      "tips": ""
    },
    "Step 19": {
      "zh": "",
      "tips": ""
    },
    "This method stops updating the motion data. It does two important things:": {
      "zh": "è¿™ä¸ªæ–¹æ³•ä¼šåœæ­¢æ›´æ–°è¿åŠ¨æ•°æ®ã€‚å®ƒåšäº†ä¸¤ä»¶é‡è¦çš„äº‹æƒ…ï¼š",
      "tips": ""
    },
    "Step 20": {
      "zh": "",
      "tips": ""
    },
    "First, it tells the CMMotionManager to stop updating its values by calling stopDeviceMotionUpdates(), then it stops the timer by calling invalidate().": {
      "zh": "é¦–å…ˆï¼Œå®ƒä¼šé€šè¿‡è°ƒç”¨ stopDeviceMotionUpdates() æ¥å‘Šè¯‰ CMMotionManager åœæ­¢æ›´æ–°å®ƒçš„å€¼ï¼Œç„¶åé€šè¿‡è°ƒç”¨ invalidate() æ¥åœæ­¢å®šæ—¶å™¨ã€‚",
      "tips": ""
    },
    "Step 21": {
      "zh": "",
      "tips": ""
    },
    "This deinitializer runs when a MotionDetector instance is about to go away. Itâ€™s important to clean up here; otherwise the timer would continue to run even after the motion detector is gone.": {
      "zh": "è¿™ä¸ªææ„å™¨ä¼šåœ¨ MotionDetector å®ä¾‹å³å°†æ¶ˆå¤±æ—¶è¿è¡Œã€‚åœ¨è¿™é‡Œåšä¸€äº›å–„åå·¥ä½œæ˜¯å¾ˆé‡è¦çš„ï¼Œå¦åˆ™è®¡æ—¶å™¨ä¼šåœ¨ motion detector æ¶ˆå¤±åç»§ç»­è¿è¡Œã€‚",
      "tips": ""
    },
    "Orientation Data View": {
      "zh": "æœå‘æ•°æ®è§†å›¾",
      "tips": ""
    },
    "Learn to display motion data as string values in the view.": {
      "zh": "å­¦ä¹ å°†è¿åŠ¨æ•°æ®æ˜¾ç¤ºä¸ºè§†å›¾ä¸­çš„å­—ç¬¦ä¸²å€¼ã€‚",
      "tips": ""
    },
    "The OrientationDataView displays the roll and pitch of your iPad as numbers. Roll is the degree of left and right tilt, and pitch is the degree of forward and backward tilt.": {
      "zh": "OrientationDataView ä¼šå°†ä½ çš„ iPad çš„ç¿»æ»šè§’å’Œä¿¯ä»°è§’ä»¥æ•°å­—çš„å½¢å¼æ˜¾ç¤ºå‡ºæ¥ã€‚ç¿»æ»šè§’æ˜¯å·¦å³å€¾æ–œçš„è§’åº¦ï¼Œä¿¯ä»°è§’æ˜¯å‰åå€¾æ–œçš„è§’åº¦ã€‚",
      "tips": ""
    },
    "This property holds a MotionDetector instance. The motion detector senses changes in your deviceâ€™s motion and provides that data for you to use in your code.": {
      "zh": "è¿™ä¸ªå±æ€§ä¼šæŒæœ‰ä¸€ä¸ª MotionDetector å®ä¾‹ã€‚è¿åŠ¨æ£€æµ‹å™¨ä¼šæ„ŸçŸ¥ä½ çš„è®¾å¤‡è¿åŠ¨çš„å˜åŒ–ï¼Œå¹¶ä¸ºä½ æä¾›è¿™äº›æ•°æ®ï¼Œä»¥ä¾¿ä½ åœ¨ä»£ç ä¸­ä½¿ç”¨ã€‚",
      "tips": ""
    },
    "Because detector is an observable object, any changes made to its published values cause SwiftUI to automatically update any views using those values. In this case, changes from the deviceâ€™s sensors update the Text view with the latest values for the pitch and roll.": {
      "zh": "å› ä¸º detector æ˜¯ä¸€ä¸ªå¯è§‚å¯Ÿå¯¹è±¡ï¼Œæ‰€ä»¥å¯¹å®ƒçš„ published å€¼æ‰€åšçš„ä»»ä½•æ›´æ”¹éƒ½ä¼šå¯¼è‡´ SwiftUI è‡ªåŠ¨æ›´æ–°ä½¿ç”¨è¿™äº›å€¼çš„ä»»ä½•è§†å›¾ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ¥è‡ªè®¾å¤‡ä¼ æ„Ÿå™¨çš„æ›´æ”¹ä¼šä½¿ç”¨æœ€æ–°çš„ roll å’Œ pitch çš„å€¼æ›´æ–° Text è§†å›¾ä¸Šçš„å­—ç¬¦ã€‚",
      "tips": ""
    },
    "These two computed properties provide the strings used in the view. They take the roll or pitch value from the motion detector and format that number as a string with a fixed number of digits. The describeAsFixedLengthString() method is a custom method on the Double type. You can learn how it works in DoubleExtension.swift.": {
      "zh": "è¿™ä¸¤ä¸ªè®¡ç®—å±æ€§æä¾›äº†è§†å›¾ä¸­ä½¿ç”¨çš„å­—ç¬¦ä¸²ã€‚å®ƒä»¬ä» motion detector ä¸­è·å– roll æˆ– pitch çš„å€¼ï¼Œå¹¶å°†è¯¥æ•°å­—æ ¼å¼åŒ–ä¸ºå…·æœ‰å›ºå®šä½æ•°çš„å­—ç¬¦ä¸²ã€‚describeAsFixedLengthString() æ–¹æ³•æ˜¯ Double ç±»å‹çš„è‡ªå®šä¹‰æ–¹æ³•ã€‚ä½ å¯ä»¥åœ¨ DoubleExtension.swift ä¸­äº†è§£å®ƒçš„å·¥ä½œåŸç†ã€‚",
      "tips": ""
    },
    "Here is the value for the roll of the device, presented as text.": {
      "zh": "è¿™é‡Œæ˜¯è®¾å¤‡çš„ç¿»æ»šè§’çš„å€¼ï¼Œä»¥æ–‡æœ¬å½¢å¼å‘ˆç°ã€‚",
      "tips": ""
    },
    "Because this view uses a published value from detector, SwiftUI updates it any time the motion detectorâ€™s roll value changes.": {
      "zh": "å› ä¸ºè¿™ä¸ªè§†å›¾ä½¿ç”¨äº† detector çš„ä¸€ä¸ª published valueï¼Œæ‰€ä»¥ SwiftUI ä¼šåœ¨ detecotr çš„ roll å€¼å‘ç”Ÿå˜åŒ–æ—¶æ›´æ–°å®ƒã€‚",
      "tips": ""
    },
    "The .font modifier formats this Text view with a monospaced font. By default, a Text view uses a system font with proportional width, but that causes the text view to change its width as the numbers change.": {
      "zh": ".font ä¿®é¥°ç¬¦ä½¿ç”¨ç­‰å®½å­—ä½“æ ¼å¼åŒ–è¿™ä¸ª Text è§†å›¾ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼ŒText è§†å›¾ä½¿ç”¨ç³»ç»Ÿå­—ä½“ï¼Œå®ƒçš„å®½åº¦æ˜¯æ¯”ä¾‹å®½åº¦ï¼Œä½†è¿™ä¼šå¯¼è‡´ Text è§†å›¾åœ¨æ•°å­—å˜åŒ–æ—¶æ”¹å˜å®ƒçš„å®½åº¦ã€‚",
      "tips": ""
    },
    "With a monospaced font, each character has the same width. (For example, the strings 1.01 and 3.14 have different widths with a proportional font like Helvetica or Times, but 1.01 and 3.14 have the same width with a monospaced font like Courier or Menlo.)": {
      "zh": "åœ¨ç­‰å®½å­—ä½“ä¸‹ï¼Œæ¯ä¸ªå­—ç¬¦çš„å®½åº¦éƒ½æ˜¯ç›¸åŒçš„ã€‚ï¼ˆä¾‹å¦‚ï¼Œ1.01 å’Œ 3.14 è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²åœ¨ Helvetica æˆ– Times ç­‰æ¯”ä¾‹å­—ä½“ä¸‹çš„å®½åº¦æ˜¯ä¸åŒçš„ï¼Œä½†åœ¨ Courier æˆ– Menlo ç­‰ç­‰å®½å­—ä½“ä¸‹ï¼Œ1.01 å’Œ 3.14 çš„å®½åº¦æ˜¯ç›¸åŒçš„ã€‚ï¼‰",
      "tips": ""
    },
    "Bubble Level View": {
      "zh": "æ³¡æ³¡æ°´å¹³ä»ª.preè§†å›¾",
      "tips": ""
    },
    "Learn to display the tilt of your device using a bubble level UI.": {
      "zh": "å­¦ä¹ ä½•ä½¿ç”¨ æ°”æ³¡æ°´å¹³ä»ªçš„ UI æ¥æ˜¾ç¤ºè®¾å¤‡çš„å€¾æ–œã€‚",
      "tips": ""
    },
    "This view displays the tilt of your device by drawing a circle within a larger circular boundary with crosshairs to indicate its centerpoint. When your device is level, the bubble rests at the center of the frame. Try tilting your device to see how the bubble moves.": {
      "zh": "è¿™ä¸ªåœ¨è‡ªå®šä¹‰è§†å›¾é€šè¿‡åœ¨ä¸€ä¸ªè¾ƒå¤§çš„åœ†å½¢è¾¹ç•Œå†…ç»˜åˆ¶ä¸€ä¸ªåœ†åœˆï¼Œå¹¶ç”¨åå­—çº¿æ¥æŒ‡ç¤ºå®ƒçš„ä¸­å¿ƒç‚¹ï¼Œæ¥æ˜¾ç¤ºä½ çš„è®¾å¤‡çš„å€¾æ–œã€‚å½“ä½ çš„è®¾å¤‡æ°´å¹³æ—¶ï¼Œæ°”æ³¡ä¼šåœç•™åœ¨æ¡†æ¶çš„ä¸­å¿ƒã€‚è¯•ç€å€¾æ–œä½ çš„è®¾å¤‡ï¼Œçœ‹çœ‹æ°”æ³¡æ˜¯å¦‚ä½•ç§»åŠ¨çš„ã€‚",
      "tips": ""
    },
    "This property holds a MotionDetector instance, which senses changes in your deviceâ€™s motion. You can access this instance in your code to update the user interface as the motion data changes.": {
      "zh": "è¿™ä¸ªå±æ€§æŒæœ‰ä¸€ä¸ª MotionDetector å®ä¾‹ï¼Œå®ƒå¯ä»¥æ„ŸçŸ¥ä½ çš„è®¾å¤‡è¿åŠ¨çš„å˜åŒ–ã€‚ä½ å¯ä»¥åœ¨ä½ çš„ä»£ç ä¸­è®¿é—®è¿™ä¸ªå®ä¾‹ï¼Œä»¥ä¾¿åœ¨è¿åŠ¨æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶æ›´æ–°ç”¨æˆ·ç•Œé¢ã€‚",
      "tips": ""
    },
    "Because detector is an observable object, any changes to its published values allows SwiftUI to automatically update any views using those values. In this case, youâ€™ll update the bubbleâ€™s position.": {
      "zh": "å› ä¸º detector æ˜¯ä¸€ä¸ªå¯è§‚å¯Ÿå¯¹è±¡ï¼Œæ‰€ä»¥ä»»ä½•å¯¹å®ƒçš„ published å€¼çš„æ›´æ”¹éƒ½ä¼šä½¿ SwiftUI è‡ªåŠ¨æ›´æ–°ä½¿ç”¨è¿™äº›å€¼çš„ä»»ä½•è§†å›¾ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ å°†æ›´æ–°æ°”æ³¡çš„ä½ç½®ã€‚",
      "tips": ""
    },
    "This property represents the range of values the motion detector reports as you tilt the device (assuming you donâ€™t turn it upside down). Negative values indicate a tilt to the left, and positive values indicate a tilt to the right. (You could assign the value 3.14 to this property, but Double.pi is convenient shorthand for the mathematical constant Ï€, and itâ€™s a closer approximation because it includes many digits of precision.)": {
      "zh": "è¿™ä¸ªå±æ€§è¡¨ç¤ºè¿åŠ¨æ£€æµ‹å™¨åœ¨ä½ å€¾æ–œè®¾å¤‡æ—¶æŠ¥å‘Šçš„å€¼çš„èŒƒå›´ï¼ˆå‡è®¾ä½ æ²¡æœ‰æŠŠå®ƒå€’è¿‡æ¥ï¼‰ã€‚è´Ÿå€¼è¡¨ç¤ºå‘å·¦å€¾æ–œï¼Œæ­£å€¼è¡¨ç¤ºå‘å³å€¾æ–œã€‚ï¼ˆä½ å¯ä»¥ç»™è¿™ä¸ªå±æ€§èµ‹å€¼ 3.14ï¼Œä½† Double.pi æ˜¯æ•°å­¦å¸¸é‡ Ï€ çš„æ–¹ä¾¿ç®€å†™ï¼Œå®ƒæ˜¯ä¸€ä¸ªæ›´æ¥è¿‘çš„è¿‘ä¼¼å€¼ï¼Œå› ä¸ºå®ƒçš„ç²¾åº¦æ›´é«˜ã€‚ï¼‰",
      "tips": ""
    },
    "This is the size of the level display, both width and height. You can change this value to make the display larger or smaller.": {
      "zh": "è¿™å°±æ˜¯æ°´å¹³ä»ªæ˜¾ç¤ºçš„å¤§å°ï¼Œå®½åº¦å’Œé«˜åº¦ã€‚ä½ å¯ä»¥æ”¹å˜è¿™ä¸ªå€¼æ¥ä½¿å…¶æ˜¾ç¤ºå¾—æ›´å¤§æˆ–æ›´å°ã€‚",
      "tips": ""
    },
    "Itâ€™s useful to define and use constants like these for important values in your code, rather than using the values themselves. When you read the code, youâ€™ll have a better idea of what it does than if you see a lot of numbers with no context.": {
      "zh": "æ¯”èµ·æ¥ç›´æ¥ä½¿ç”¨è¿™äº›å€¼ï¼Œå®šä¹‰å’Œä½¿ç”¨è¿™æ ·çš„å¸¸é‡æ¥è¡¨ç¤ºä»£ç ä¸­çš„é‡è¦å€¼æ›´æœ‰ç”¨ã€‚å½“ä½ é˜…è¯»ä»£ç æ—¶ï¼Œçœ‹åˆ°è¿™æ ·çš„å¸¸é‡é€šå¸¸æ¯”çœ‹åˆ°ä¸€å †æ²¡æœ‰ä¸Šä¸‹æ–‡çš„æ•°å­—æ›´å®¹æ˜“ç†è§£å®ƒçš„ä½œç”¨ã€‚",
      "tips": ""
    },
    "This property calculates the horizontal placement of the bubble using three steps.": {
      "zh": "è¿™ä¸ªå±æ€§ä½¿ç”¨ä¸‰ä¸ªæ­¥éª¤æ¥è®¡ç®—æ°”æ³¡çš„æ°´å¹³ä½ç½®ã€‚",
      "tips": ""
    },
    "First, adjust the roll value from the detector so that it has a minimum of 0 and goes up to the value of Ï€, and store the adjusted value in zeroBasedRoll. This helps with the next part of the calculation, which needs values greater than 0.": {
      "zh": "é¦–å…ˆï¼Œè°ƒæ•´æ£€æµ‹å™¨çš„ roll å€¼ï¼Œä½¿å…¶æœ€å°å€¼ä¸º 0ï¼Œæœ€å¤§å€¼ä¸º Ï€ï¼Œå¹¶å°†è°ƒæ•´åçš„å€¼å­˜å‚¨åœ¨ zeroBasedRoll ä¸­ã€‚è¿™æœ‰åŠ©äºä¸‹ä¸€éƒ¨åˆ†çš„è®¡ç®—ï¼Œè¯¥è®¡ç®—éœ€è¦å¤§äº 0 çš„å€¼ã€‚",
      "tips": ""
    },
    "Then, use this adjusted value to calculate the roll as a fraction of the entire range of roll values, so that full tilt left is 0.0, flat is 0.5, and full tilt right is 1.0.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½¿ç”¨è¿™ä¸ªè°ƒæ•´åçš„å€¼æ¥è®¡ç®— roll ä½œä¸ºæ•´ä¸ª roll å€¼èŒƒå›´çš„ä¸€ä¸ªåˆ†æ•°ï¼Œè¿™æ ·å®Œå…¨å‘å·¦å€¾æ–œå°±æ˜¯ 0.0ï¼Œæ°´å¹³å°±æ˜¯ 0.5ï¼Œå®Œå…¨å‘å³å€¾æ–œå°±æ˜¯ 1.0ã€‚",
      "tips": ""
    },
    "Multiplying the fraction with the size of the level gives you the X position of the bubble.": {
      "zh": "å°†è¿™ä¸ªåˆ†æ•°ä¹˜ä»¥æ°´å¹³ä»ªçš„å¤§å°ï¼Œå°±å¾—åˆ°äº†æ°”æ³¡çš„ X ä½ç½®ã€‚",
      "tips": ""
    },
    "Because all of these calculations are hidden in a property, your viewâ€™s body code remains simple and readable.": {
      "zh": "å› ä¸ºæ‰€æœ‰è¿™äº›è®¡ç®—éƒ½éšè—åœ¨ä¸€ä¸ªå±æ€§ä¸­ï¼Œæ‰€ä»¥ä½ çš„è§†å›¾çš„ body ä»£ç ä¿æŒç®€å•å’Œå¯è¯»ã€‚",
      "tips": ""
    },
    "While you can write all of the code here in a longer mathematical expression, decomposing the code makes it easier to understand. (Can you imagine having to explain this code if it were written in one line?!)": {
      "zh": "è™½ç„¶ä½ å¯ä»¥åœ¨è¿™é‡Œå†™æ‰€æœ‰çš„ä»£ç ï¼Œä½†æ˜¯æŠŠä»£ç åˆ†è§£å¼€æ¥ä¼šæ›´å®¹æ˜“ç†è§£ã€‚ï¼ˆä½ èƒ½æƒ³è±¡å¦‚æœè¿™æ®µä»£ç å†™åœ¨ä¸€è¡Œé‡Œï¼Œä½ è¦æ€ä¹ˆè§£é‡Šè¿™æ®µä»£ç å—ï¼Ÿï¼ï¼‰",
      "tips": ""
    },
    "This property calculates the vertical position of the bubble in the same way that bubbleXPosition works.": {
      "zh": "è¿™ä¸ªå±æ€§ä»¥ä¸ bubbleXPosition ç›¸åŒçš„æ–¹å¼è®¡ç®—æ°”æ³¡çš„å‚ç›´ä½ç½®ã€‚",
      "tips": ""
    },
    "This property returns a vertical line that you use to draw the bubble level display. Because there are multiple identical vertical lines, you can use this property whenever you need one rather than repeating the more complex code inside it.": {
      "zh": "è¿™ä¸ªå±æ€§è¿”å›ä¸€ä¸ªå‚ç›´çº¿ï¼Œä½ å¯ä»¥ç”¨å®ƒæ¥ç»˜åˆ¶æ°”æ³¡æ°´å¹³ä»ªçš„æ˜¾ç¤ºã€‚å› ä¸ºæœ‰å¤šä¸ªç›¸åŒçš„å‚ç›´çº¿ï¼Œæ‰€ä»¥ä½ å¯ä»¥åœ¨éœ€è¦ä¸€ä¸ªå‚ç›´çº¿æ—¶ä½¿ç”¨è¿™ä¸ªå±æ€§ï¼Œè€Œä¸æ˜¯é‡å¤å…¶ä¸­çš„æ›´å¤æ‚çš„ä»£ç ã€‚",
      "tips": ""
    },
    "Hereâ€™s a circle with a gray foreground color that provides a visual boundary for the display.": {
      "zh": "è¿™é‡Œæ˜¯ä¸€ä¸ªåœ†ï¼Œå®ƒæœ‰ä¸€ä¸ªç°è‰²çš„å‰æ™¯è‰²ï¼Œä¸ºæ˜¾ç¤ºæä¾›äº†ä¸€ä¸ªè§†è§‰è¾¹ç•Œã€‚",
      "tips": ""
    },
    "You can use a .frame modifier to give the circle a fixed width and height, which is important to draw the other components correctly.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ .frame ä¿®é¥°ç¬¦ç»™åœ†ä¸€ä¸ªå›ºå®šçš„å®½åº¦å’Œé«˜åº¦ï¼Œè¿™å¯¹äºæ­£ç¡®ç»˜åˆ¶å…¶ä»–ç»„ä»¶å¾ˆé‡è¦ã€‚",
      "tips": ""
    },
    "The .overlay modifier adds a view on top of the circle that occupies the same area.": {
      "zh": ".overlay ä¿®é¥°ç¬¦åœ¨åœ†ä¸Šé¢æ·»åŠ ä¸€ä¸ªè§†å›¾ï¼Œè¯¥è§†å›¾å ç”¨ç›¸åŒçš„åŒºåŸŸã€‚",
      "tips": ""
    },
    "The overlay is useful here because it positions the levelâ€™s components relative to the circle theyâ€™re drawn in.": {
      "zh": "overlay åœ¨è¿™é‡Œå¾ˆæœ‰ç”¨ï¼Œå› ä¸ºå®ƒå°†æ°´å¹³ä»ªçš„ç»„ä»¶ç›¸å¯¹äºå®ƒä»¬ç»˜åˆ¶çš„åœ†è¿›è¡Œå®šä½ã€‚",
      "tips": ""
    },
    "A ZStack view allows you to draw the components of the level over each other.": {
      "zh": "ä¸€ä¸ª ZStack .preè§†å›¾å…è®¸ä½ å°†æ°´å¹³ä»ªçš„ç»„ä»¶ç»˜åˆ¶åœ¨å½¼æ­¤ä¸Šé¢ã€‚",
      "tips": ""
    },
    "The first circle represents the bubble. Notice that the bubbleXPosition and bubbleYPosition values position the bubble inside the overlay view.": {
      "zh": "ç¬¬ä¸€ä¸ªä»£è¡¨æ°” æ³¡ã€‚æ³¨æ„ï¼ŒbubbleXPosition å’Œ bubbleYPosition å€¼å°†æ°”æ³¡å®šä½åœ¨è¦†ç›–è§†å›¾å†…ã€‚",
      "tips": ""
    },
    "Because these properties use published values from MotionDetector, SwiftUI updates the bubble viewâ€™s position each time they change.": {
      "zh": "å› ä¸ºè¿™åœ¨è‡ªå®šä¹‰äº›å±æ€§ä½¿ç”¨äº† MotionDetector çš„ published å€¼ï¼Œæ‰€ä»¥ SwiftUI åœ¨æ¯æ¬¡å®ƒä»¬æ”¹å˜æ—¶éƒ½ä¼šæ›´æ–°æ°”æ³¡è§†å›¾çš„ä½ç½®ã€‚",
      "tips": ""
    },
    "Step 22": {
      "zh": "",
      "tips": ""
    },
    "In the center are a smaller circle and a crosshair made of two lines: one horizontal and one vertical.": {
      "zh": "åœ¨ä¸­å¿ƒæ˜¯ä¸€ä¸ªè¾ƒå°çš„åœ†å’Œä¸€ä¸ªç”±ä¸¤æ¡çº¿ç»„æˆçš„åå­—çº¿ï¼šä¸€æ¡æ°´å¹³çº¿å’Œä¸€æ¡å‚ç›´çº¿ã€‚",
      "tips": ""
    },
    "Step 23": {
      "zh": "",
      "tips": ""
    },
    "There are four other lines on the edge of the frame of the bubble level display. You can use the .position modifier to move them relative to their default position at the center of the overlay view.": {
      "zh": "è¿™é‡Œè¿˜æœ‰å…¶ä»–å››æ¡çº¿åœ¨æ°”æ³¡æ°´å¹³ä»ªæ˜¾ç¤ºçš„è¾¹æ¡†ä¸Šã€‚ä½ å¯ä»¥ä½¿ç”¨ .position ä¿®é¥°ç¬¦å°†å®ƒä»¬ç›¸å¯¹äºå®ƒä»¬åœ¨è¦†ç›–è§†å›¾ä¸­å¿ƒçš„é»˜è®¤ä½ç½®ç§»åŠ¨ã€‚",
      "tips": ""
    },
    "Double Extension": {
      "zh": "ç»™ Double ç±»å‹å¢åŠ æ‰©å±•",
      "tips": ""
    },
    "Investigate using an extension on Double to format them in an easy to read way.": {
      "zh": "ç ”ç©¶ä½¿ç”¨ Double çš„æ‰©å±•ä»¥ä¸€ç§æ˜“äºé˜…è¯»çš„æ–¹å¼æ ¼å¼åŒ–å®ƒä»¬ã€‚",
      "tips": ""
    },
    "An extension is a way to make custom behavior for existing types. Declaring extension Double means youâ€™re adding new capabilities to the Double type. Any time you use a Double value in your code, you can access anything defined in this extension.": {
      "zh": "æ‰©å±•æ˜¯ä¸ºç°æœ‰ç±»å‹æ·»åŠ è‡ªå®šä¹‰è¡Œä¸ºçš„ä¸€ç§æ–¹å¼ã€‚å£°æ˜æ‰©å±• Double æ„å‘³ç€ä½ æ­£åœ¨ä¸º Double ç±»å‹æ·»åŠ æ–°çš„åŠŸèƒ½ã€‚ä»»ä½•æ—¶å€™ä½ åœ¨ä»£ç ä¸­ä½¿ç”¨ Double å€¼ï¼Œä½ éƒ½å¯ä»¥è®¿é—®åœ¨è¿™ä¸ªæ‰©å±•ä¸­å®šä¹‰çš„ä»»ä½•ä¸œè¥¿ã€‚",
      "tips": ""
    },
    "This method returns a string describing the value of a Double using a fixed number of digits. You can pass in the number of integer digits and fraction digits you want, or leave those arguments out for the default values of 2.": {
      "zh": "è¿™ä¸ªæ–¹æ³•è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæè¿°ä¸€ä¸ª Double çš„å€¼ï¼Œä½¿ç”¨å›ºå®šæ•°é‡çš„æ•°å­—ã€‚ä½ å¯ä»¥ä¼ å…¥ä½ æƒ³è¦çš„æ•´æ•°ä½æ•°å’Œå°æ•°ä½æ•°ï¼Œæˆ–è€…å¿½ç•¥è¿™äº›å‚æ•°ï¼Œä½¿ç”¨é»˜è®¤å€¼ 2ã€‚",
      "tips": ""
    },
    "The formatted() method operates on a number of basic types such as Date, Int, and Double, which are all commonly represented as strings in an app. Because there are so many ways to format these strings, the formatted() method gives you ways to customize how theyâ€™re represented. For example, does a number represent a percentage, or a simple value, or maybe a price?": {
      "zh": "formatted() æ–¹æ³•å¯¹ä¸€äº›åŸºæœ¬ç±»å‹è¿›è¡Œæ“ä½œï¼Œæ¯”å¦‚ Dateã€Int å’Œ Doubleï¼Œå®ƒä»¬åœ¨åº”ç”¨ä¸­éƒ½é€šå¸¸è¡¨ç¤ºä¸ºå­—ç¬¦ä¸²ã€‚å› ä¸ºæœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥æ ¼å¼åŒ–è¿™äº›å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥ formatted() æ–¹æ³•æä¾›äº†ä¸€äº›æ–¹æ³•æ¥è‡ªå®šä¹‰å®ƒä»¬çš„è¡¨ç¤ºæ–¹å¼ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªæ•°å­—ä»£è¡¨ä¸€ä¸ªç™¾åˆ†æ¯”ï¼Œè¿˜æ˜¯ä¸€ä¸ªç®€å•çš„å€¼ï¼Œæˆ–è€…ä¸€ä¸ªä»·æ ¼ï¼Ÿ",
      "tips": ""
    },
    "The argument to formatted() is a format style.": {
      "zh": "formatted() çš„å‚æ•°æ˜¯ä¸€ä¸ª format styleã€‚",
      "tips": ""
    },
    "The .number style gives you a string describing this Double value as a simple number, as opposed to a percentage or a price.": {
      "zh": ".number style ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæè¿°è¿™ä¸ª Double å€¼ä½œä¸ºä¸€ä¸ªç®€å•çš„æ•°å­—ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç™¾åˆ†æ¯”æˆ–ä¸€ä¸ªä»·æ ¼ã€‚",
      "tips": ""
    },
    "The .number style has modifiers much like those for SwiftUI views.": {
      "zh": ".number style æœ‰ç±»ä¼¼äº SwiftUI è§†å›¾çš„ä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    },
    "The .sign modifier lets you format the number so that itâ€™s always preceded by a sign, even when the number is positive.": {
      "zh": ".sign ä¿®é¥°ç¬¦è®©ä½ å¯ä»¥æ ¼å¼åŒ–æ•°å­—ï¼Œè¿™æ ·å³ä½¿æ•°å­—æ˜¯æ­£æ•°ï¼Œå®ƒä¹Ÿæ€»æ˜¯ä»¥ä¸€ä¸ªç¬¦å·å¼€å¤´ã€‚",
      "tips": ""
    },
    "The .precision modifier lets you specify exactly how many digits to use.": {
      "zh": ".precision ä¿®é¥°ç¬¦è®©ä½ å¯ä»¥æŒ‡å®šè¦ä½¿ç”¨å¤šå°‘ä½æ•°å­—ã€‚",
      "tips": ""
    },
    "Seismometer": {
      "zh": "åœ°éœ‡ä»ª",
      "tips": ""
    },
    "Present dynamic data in custom views.": {
      "zh": "åœ¨è‡ªå®šä¹‰è§†å›¾ä¸­å‘ˆç°åŠ¨æ€æ•°æ®ã€‚",
      "tips": ""
    }
  },
  "sample-apps/capturingphotos-browsephotos": {
    "Browsing Your Photos": {
      "zh": "æµè§ˆä½ çš„ç…§ç‰‡",
      "tips": ""
    },
    "Browse the photos in your photo library.": {
      "zh": "æµè§ˆä½ ç…§ç‰‡åº“ä¸­çš„ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "Enjoy taking photos? Most of us do, and itâ€™s easy to end up with hundreds or thousands of photos in your library. ğŸ": {
      "zh": "å–œæ¬¢æ‹ç…§å—ï¼Ÿæˆ‘ä»¬å¤§å¤šæ•°äººéƒ½å–œæ¬¢ï¼Œè€Œä¸”å¾ˆå®¹æ˜“åœ¨ä½ çš„ç…§ç‰‡åº“ä¸­ç§¯ç´¯æˆç™¾ä¸Šåƒçš„ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "Follow your photos as theyâ€™re retrieved from your photo library and displayed in a scrolling gallery you can browse.": {
      "zh": "è®©æˆ‘ä»¬ä¸€æ­¥æ­¥çœ‹ç…§ç‰‡æ˜¯å¦‚ä½•ä»ä½ çš„ç…§ç‰‡åº“ä¸­è¢«æ£€ç´¢å‡ºæ¥ï¼Œå¹¶è®©ä½ å¯ä»¥åœ¨ä¸€ä¸ªæ»šåŠ¨çš„ç”»å»Šä¸­æŸ¥çœ‹å®ƒä»¬ã€‚",
      "tips": ""
    },
    "Using the Photo Collection": {
      "zh": "ä½¿ç”¨ PhotoCollection å¯¹è±¡",
      "tips": ""
    },
    "Learn about the photo collection in your data model and how it provides the photos for your gallery.": {
      "zh": "äº†è§£ä½ æ•°æ®æ¨¡å‹ä¸­çš„ PhotoCollection å¯¹è±¡ï¼Œä»¥åŠå®ƒå¦‚ä½•ä¸ºç”»å»Šæä¾›ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "Your data model has a photoCollection property that can represent any collection of items in your photo library. This could be your entire photo library, or just one album, or even the results from a search. You can include all of your photos in your library by initializing photoCollection with a Smart Album .smartAlbumUserLibrary.": {
      "zh": "ä½ çš„æ•°æ®æ¨¡å‹ä¸­æœ‰ä¸€ä¸ª photoCollection å±æ€§ï¼Œå®ƒå¯ä»¥è¡¨ç¤ºä½ ç…§ç‰‡åº“ä¸­ä»»ä½•ä¸€ç§é¡¹ç›®çš„é›†åˆã€‚è¿™å¯ä»¥æ˜¯ä½ æ•´ä¸ªç…§ç‰‡åº“ï¼Œä¹Ÿå¯ä»¥åªæ˜¯ä¸€ä¸ªç›¸å†Œï¼Œç”šè‡³å¯ä»¥æ˜¯æœç´¢çš„ç»“æœã€‚ ä½ å¯ä»¥é€šè¿‡æŒ‡å®š smartAlbum å‚æ•°ä¸º .smartAlbumUserLibrary æ¥åˆå§‹åŒ– photoCollectionï¼Œä»è€Œå°†ç…§ç‰‡åº“ä¸­çš„æ‰€æœ‰ç…§ç‰‡éƒ½åŒ…å«è¿›æ¥ã€‚",
      "tips": ""
    },
    "Fetching the Photo Assets": {
      "zh": "è·å–ç…§ç‰‡èµ„æº",
      "tips": ""
    },
    "Each item in your photo collection is known as a photo asset. Find out how to fetch those assets.": {
      "zh": "PhotoCollection ä¸­çš„æ¯ä¸€ä¸ªé¡¹ç›®éƒ½è¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªç…§ç‰‡èµ„æºã€‚äº†è§£å¦‚ä½•è·å–è¿™äº›èµ„æºã€‚",
      "tips": ""
    },
    "Your data modelâ€™s photoCollection has a photoAssets property that enables use of the photo assets collection just like you would an array. You can fetch a photo asset using its index: photoAssets[4], or use photoAssets.count to get the number of photos in the collection.": {
      "zh": "åœ¨ä½ æ•°æ®æ¨¡å‹çš„ photoCollection å±æ€§ä¸­æ˜¯æœ‰ä¸€ä¸ª photoAssets å±æ€§çš„ï¼Œå®ƒå¯ä»¥è®©ä½ åƒä½¿ç”¨æ•°ç»„ä¸€æ ·ä½¿ç”¨ç…§ç‰‡èµ„æºé›†åˆã€‚ ä½ å¯ä»¥åƒè¿™æ ·ä½¿ç”¨ç´¢å¼•è·å–ç…§ç‰‡èµ„æºï¼šphotoAssets[4]ï¼›æˆ–è€…è°ƒç”¨ photoAssets.count æ¥è·å–é›†åˆä¸­çš„ç…§ç‰‡æ•°é‡ã€‚",
      "tips": ""
    },
    "Tip": {
      "zh": "æ³¨é‡Š",
      "tips": ""
    },
    "You can also iterate over the assets in photoAssets using a loop. Youâ€™ll find this incredibly useful for building your gallery.": {
      "zh": "ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨å¾ªç¯æ¥éå† photoAssets ä¸­çš„æ‰€æœ‰èµ„æºã€‚ä½ ä¼šå‘ç°è¿™å¯¹æ„å»ºç”»å»Šéå¸¸æœ‰ç”¨ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "Youâ€™ll notice that photoAssets is a published property of PhotoCollection, which is an observable object. This means that you can respond to changes in the photo assets, such as when photos are added or deleted.": {
      "zh": "ä½ ä¼šæ³¨æ„åˆ° PhotoCollection ä¸­çš„ photoAssets å±æ€§è¢« @Published ä¿®é¥°äº†ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¯è§‚å¯Ÿå¯¹è±¡ã€‚è¿™æ„å‘³ç€æ¯”å¦‚å½“ç…§ç‰‡è¢«æ·»åŠ æˆ–åˆ é™¤æ—¶ï¼Œä½ å¯ä»¥å“åº”è¿™äº›ç…§ç‰‡èµ„æºçš„å˜åŒ–ã€‚",
      "tips": ""
    },
    "Navigating to the Photo Gallery": {
      "zh": "å¯¼èˆªåˆ°ç…§ç‰‡ç”»å»Š",
      "tips": ""
    },
    "Find out how to navigate to the photo gallery and connect it to your photo library.": {
      "zh": "äº†è§£å¦‚ä½•å¯¼èˆªåˆ°ç…§ç‰‡ç”»å»Šå¹¶å°†å…¶ä¸ä½ çš„ç…§ç‰‡åº“è¿æ¥èµ·æ¥ã€‚",
      "tips": ""
    },
    "In your camera view, use a navigation link to take you to your photo gallery. A navigation link is just like a button â€” you can even give it a label and an icon. You place this button to the left of the shutter button.": {
      "zh": "åœ¨ä½ ç›¸æœºè§†å›¾ä¸­ï¼Œä½¿ç”¨ä¸€ä¸ª NavigationLink æ¥è¿›å…¥ç…§ç‰‡ç”»å»Šã€‚NavigationLink å°±åƒä¸€ä¸ªæŒ‰é’®ï¼Œä½ ç”šè‡³å¯ä»¥ç»™å®ƒè®¾ç½®ä¸€ä¸ªæ ‡ç­¾å’Œå›¾æ ‡ã€‚ä½ å¯ä»¥å°†è¿™ä¸ªæŒ‰é’®æ”¾åœ¨å¿«é—¨æŒ‰é’®çš„å·¦è¾¹ã€‚",
      "tips": ""
    },
    "When you tap or click a navigation link, SwiftUI takes you to another view â€” in this case, the photo collection view â€” that you use to display your photo gallery. If you use navigation links within a NavigationStack, SwiftUI manages the presentation of your views so you can easily navigate between them.": {
      "zh": "å½“ä½ ç‚¹å‡»æˆ–æŒ‰ä¸‹ä¸€ä¸ª NavigationLink æ—¶ï¼ŒSwiftUI ä¼šå¸¦ä½ è¿›å…¥å¦ä¸€ä¸ªè§†å›¾ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­æ˜¯ PhotoCollectionViewï¼Œä½ å¯ä»¥ä½¿ç”¨å®ƒæ¥æ˜¾ç¤ºä½ çš„ç…§ç‰‡ç”»å»Šã€‚ å¦‚æœä½ åœ¨ NavigationStack ä¸­ä½¿ç”¨ NavigationLink çš„è¯ï¼ŒSwiftUI ä¼šè´Ÿè´£ç®¡ç†ä½ è§†å›¾çš„å‘ˆç°ï¼Œä½¿ä½ å¯ä»¥åœ¨è§†å›¾ä¹‹é—´è½»æ¾åœ°å¯¼èˆªã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "By passing your modelâ€™s photoCollection to the PhotoCollectionView when you initialize it, you provide the collection of photos that you want to display in your gallery.": {
      "zh": "å½“ä½ åˆå§‹åŒ– PhotoCollectionView æ—¶ï¼Œé€šè¿‡ä¼ é€’ä½ æ¨¡å‹çš„ photoCollection ç»™å®ƒï¼Œä½ ä¾¿æä¾›äº†æƒ³åœ¨ç”»å»Šä¸­å±•ç¤ºçš„ç…§ç‰‡é›†åˆã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "When you open the gallery, youâ€™ll no longer see the viewfinder, so thereâ€™s no need to keep updating it. Instead, youâ€™d rather concentrate the deviceâ€™s performance on displaying your photos. To control when the cameraâ€™s preview stream is active, use the navigation linkâ€™s onAppear(perform:) modifier to pause it when the gallery appears, and onDisappear(perform:) to resume it again when you navigate back to the camera.": {
      "zh": "å½“ä½ æ‰“å¼€ç”»å»Šæ—¶ï¼Œå–æ™¯å™¨å°†ä¸ä¼šè¢«çœ‹åˆ°ï¼Œæ‰€ä»¥æ²¡æœ‰å¿…è¦ç»§ç»­æ›´æ–°å®ƒã€‚ç›¸åï¼Œä½ æ›´å¸Œæœ›å°†è®¾å¤‡çš„æ€§èƒ½é›†ä¸­ä½¿ç”¨åœ¨æ˜¾ç¤ºä½ çš„ç…§ç‰‡ä¸Šã€‚ ä¸ºäº†æ§åˆ¶æ‘„åƒå¤´é¢„è§ˆæµæ˜¯å¦æ¿€æ´»çš„çŠ¶æ€ï¼Œä½¿ç”¨ NavigationLink çš„ onAppear(perform:) ä¿®é¥°ç¬¦åœ¨ç”»å»Šå‡ºç°æ—¶æš‚åœå®ƒï¼Œå¹¶åœ¨å›åˆ°æ‘„åƒå¤´è§†å›¾æ—¶åœ¨ onDisappear(perform:) ä¿®é¥°ç¬¦ä¸­æ¢å¤å®ƒã€‚",
      "tips": ""
    },
    "Building the Photo Gallery": {
      "zh": "æ„å»ºç…§ç‰‡ç”»å»Š",
      "tips": ""
    },
    "Discover how to display your photos in a scrolling grid.": {
      "zh": "æ¢ç´¢å¦‚ä½•åœ¨ä¸€ä¸ªæ»šåŠ¨ç½‘æ ¼ä¸­æ˜¾ç¤ºä½ çš„ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "You use a PhotoCollectionView to display your photos in a scrolling grid, with the most recent photos at the top.": {
      "zh": "ä½ ä½¿ç”¨ä¸€ä¸ª PhotoCollectionView å¯¹è±¡å°†ä½ çš„ç…§ç‰‡åœ¨ä¸€ä¸ªå¯æ»šåŠ¨çš„ç½‘æ ¼ä¸­å±•ç¤ºå‡ºæ¥ï¼Œæœ€æ–°çš„ç…§ç‰‡ä¼šæ”¾åœ¨æœ€å‰é¢ã€‚",
      "tips": ""
    },
    "When you create your PhotoCollectionView, the photoCollection property initializes with a reference to your modelâ€™s photoCollection. It provides all of the data you need to build your photo gallery. By making photoCollection an observed object, SwiftUI updates your photo collection view in response to changes in the collectionâ€™s published values.": {
      "zh": "å½“ä½ åˆ›å»º PhotoCollectionView æ—¶ï¼ŒphotoCollection å±æ€§ä¼šè¢«åˆå§‹åŒ–ä¸ºä¸€ä¸ªæŒ‡å‘ä½ æ¨¡å‹çš„ photoCollection å¼•ç”¨ã€‚å®ƒæä¾›äº†æ„å»ºä½ ç…§ç‰‡ç”»å»Šæ‰€éœ€çš„æ‰€æœ‰æ•°æ®ã€‚ é€šè¿‡å°† photoCollection è®¾ç½®ä¸ºä¸€ä¸ªå¯è§‚å¯Ÿçš„å¯¹è±¡ï¼ŒSwiftUI ä¼šé€šè¿‡å“åº” photoCollection çš„å€¼å˜åŒ–ï¼Œæ¥æ›´æ–°ä½ çš„ PhotoCollectionViewã€‚",
      "tips": ""
    },
    "You use a lazy vertical grid (LazyVGrid) to display your photos as items in a grid layout. Because the layout uses a vertical grid, you only need to decide how many columns you want and the spacing between each item. After the grid has the number of columns, it expands vertically to add enough rows for displaying all of your photos.": {
      "zh": "ä½ ä½¿ç”¨ä¸€ä¸ª LazyVGrid æ¥å°†ç…§ç‰‡ä½œä¸ºç½‘æ ¼å¸ƒå±€ä¸­çš„é¡¹ç›®è¿›è¡Œå±•ç¤ºã€‚ç”±äºå¸ƒå±€ä½¿ç”¨çš„æ˜¯å‚ç›´ç½‘æ ¼ï¼Œæ‰€ä»¥åªéœ€è¦å†³å®šéœ€è¦å¤šå°‘åˆ—å’Œæ¯ä¸ªé¡¹ç›®ä¹‹é—´çš„é—´éš”ã€‚ ç½‘æ ¼æœ‰äº†åˆ—æ•°ä¹‹åï¼Œå®ƒä¼šå‚ç›´æ‰©å±•ä»¥æ·»åŠ è¶³å¤Ÿçš„è¡Œæ¥æ˜¾ç¤ºæ‰€æœ‰çš„ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨é‡Š",
      "tips": ""
    },
    "Why lazy? Well, if the grid is larger than its containing view, the view only displays the items that are currently visible. This â€œlazinessâ€ actually enhances the performance of your app, especially as you scroll through the grid of photos.": {
      "zh": "ä¸ºä»€ä¹ˆé€‰æ‹©å»¶è¿ŸåŠ è½½å‘¢ï¼Ÿå¦‚æœç½‘æ ¼æ¯”å…¶å®¹å™¨è§†å›¾å¤§ï¼Œé‚£ä¹ˆè§†å›¾åªéœ€è¦æ˜¾ç¤ºå½“å‰å¯è§çš„é¡¹ç›®ã€‚è¿™ç§ â€œæ‡’æƒ°æ€§â€ å®é™…ä¸Šå¢å¼ºäº†ä½  app çš„æ€§èƒ½ï¼Œå°¤å…¶æ˜¯åœ¨æ»šåŠ¨ç…§ç‰‡ç½‘æ ¼æ—¶ã€‚",
      "tips": ""
    },
    "You could use a fixed number of columns in your grid, but a more responsive approach is to display as many columns as you can, depending on the width of the view. This creates a much better experience as people resize your app. To create a grid that adapts to the width of your view, define an adaptive GridItem and specify the size and spacing you want it to maintain.": {
      "zh": "ä½ å¯ä»¥æŠŠç½‘æ ¼ä¸­çš„åˆ—è®¾ç½®æˆå›ºå®šæ•°é‡ï¼Œä½†æ›´çµæ´»çš„æ–¹æ³•æ˜¯æ ¹æ®è§†å›¾çš„å®½åº¦æ˜¾ç¤ºå°½å¯èƒ½å¤šçš„åˆ—ã€‚å½“ç”¨æˆ·è°ƒæ•´ä½  app çš„å¤§å°æ—¶ï¼Œè¿™å°†åˆ›é€ å‡ºæ›´å¥½çš„ç”¨æˆ·ä½“éªŒã€‚ ä¸ºäº†åˆ›å»ºä¸€ä¸ªé€‚åº”è§†å›¾å®½åº¦çš„ç½‘æ ¼ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªè‡ªé€‚åº”çš„ GridItemï¼Œå¹¶æŒ‡å®šä½ å¸Œæœ›å®ƒä¿æŒçš„å¤§å°å’Œé—´è·ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "Imagine having hundreds â€” or thousands â€” of photos. Even with adaptive layout, your grid can get very tall â€” way taller than the space you have to display it! Make your grid scrollable by placing it inside a ScrollView. This makes it so your grid can have as many rows as it needs, and youâ€™ll be able to scroll up and down through your photos.": {
      "zh": "æƒ³è±¡ä¸€ä¸‹ï¼Œä½ æœ‰å‡ ç™¾ï¼Œç”šè‡³å‡ åƒå¼ çš„ç…§ç‰‡ã€‚å³ä½¿æ˜¯è‡ªé€‚åº”å¸ƒå±€ï¼Œç½‘æ ¼ä¹Ÿå¯èƒ½ä¼šå˜å¾—éå¸¸é•¿ï¼Œè¿œè¿œè¶…è¿‡ä½ ç”¨æ¥æ˜¾ç¤ºå®ƒçš„ç©ºé—´ï¼ é€šè¿‡å°†å®ƒæ”¾åœ¨ ScrollView ä¸­ï¼Œä½¿å…¶å¯æ»šåŠ¨ã€‚è¿™å°±ä½¿å¾—ä½ çš„ç½‘æ ¼å¯ä»¥æœ‰å°½å¯èƒ½å¤šçš„è¡Œï¼Œå¹¶èƒ½å¤Ÿé€šè¿‡ä¸Šä¸‹æ»šåŠ¨æŸ¥çœ‹ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "Inside your grid, use ForEach to iterate over the photo assets in your collection and generate a view for each asset â€” these views populate your grid. Because your grid is lazy, as you scroll, ForEach only operates on the visible photo assets.": {
      "zh": "åœ¨ç½‘æ ¼å†…ï¼Œåˆ™ä½¿ç”¨ ForEach å¯¹é›†åˆä¸­çš„ç…§ç‰‡èµ„æºè¿›è¡Œè¿­ä»£ï¼Œå¹¶ä¸ºæ¯ä¸ªèµ„æºç”Ÿæˆä¸€ä¸ªè§†å›¾ï¼Œç”¨è¿™äº›è§†å›¾æ¥å¡«å……ç½‘æ ¼ã€‚ç”±äºç½‘æ ¼æ˜¯å»¶è¿ŸåŠ è½½çš„ï¼Œæ‰€ä»¥å½“ä½ æ»šåŠ¨æ—¶ï¼ŒForEach ä»…å¯¹å¯è§çš„ç…§ç‰‡èµ„æºè¿›è¡Œæ“ä½œã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ä¸ƒæ­¥",
      "tips": ""
    },
    "Create a NavigationLink for each grid item that, when tapped or clicked, displays the individual photo at full size using the destination PhotoView initialized with the photo asset.": {
      "zh": "ä¸ºæ¯ä¸ªç½‘æ ¼é¡¹åˆ›å»ºä¸€ä¸ª NavigationLinkï¼Œå½“ç‚¹å‡»å®ƒæ—¶ï¼Œé€šè¿‡ä½¿ç”¨ç‚¹å‡»çš„é‚£ä¸ªç…§ç‰‡èµ„æºæ¥åˆå§‹åŒ–ç›®æ ‡è§†å›¾ PhotoView ï¼Œæ¥ä»¥å…¨å°ºå¯¸æ˜¾ç¤ºå•ä¸ªç…§ç‰‡ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "ç¬¬å…«æ­¥",
      "tips": ""
    },
    "The photoItemView(asset:) method creates a view that displays a small image thumbnail for a photo asset. Youâ€™ll use this view as the label for the navigation link, displaying each link as a thumbnail-sized image of the photo.": {
      "zh": "photoItemView(asset:) æ–¹æ³•ç”¨äºåˆ›å»ºä¸€ä¸ªè§†å›¾ï¼Œå…¶æ˜¾ç¤ºç…§ç‰‡èµ„æºçš„å°å°ºå¯¸ç¼©ç•¥å›¾ã€‚ä½ å°†ä½¿ç”¨æ­¤è§†å›¾ä½œä¸º NavigationLink çš„æ ‡ç­¾ï¼Œå°†æ¯ä¸ª NavigationLink ä»¥ç…§ç‰‡çš„ç¼©ç•¥å›¾å¤§å°æ¥æ˜¾ç¤ºå‡ºæ¥ã€‚",
      "tips": ""
    },
    "Displaying a Photo": {
      "zh": "æ˜¾ç¤ºä¸€ä¸ªç…§ç‰‡",
      "tips": ""
    },
    "Learn how the photo view loads and displays your photo.": {
      "zh": "äº†è§£ç…§ç‰‡è§†å›¾æ˜¯å¦‚ä½•åŠ è½½å’Œæ˜¾ç¤ºç…§ç‰‡çš„ã€‚",
      "tips": ""
    },
    "When it comes to displaying a photo on its own, youâ€™ll use PhotoView. In your photo view, you display a high-resolution image that you request from the photo. You also have an overlay with buttons for favoriting or deleting the photo.": {
      "zh": "å½“éœ€è¦å•ç‹¬å±•ç¤ºä¸€å¼ ç…§ç‰‡æ—¶ï¼Œä½ ä¼šä½¿ç”¨ PhotoViewã€‚åœ¨ PhotoView ä¸­ï¼Œä¼šæ˜¾ç¤ºä¸€å¼ ä» cache ä¸­è¯·æ±‚çš„é«˜åˆ†è¾¨ç‡å›¾åƒã€‚å¦å¤–è¿˜æœ‰ä¸€ä¸ªæ”¾ç½®æ”¶è—æˆ–åˆ é™¤ç…§ç‰‡æŒ‰é’®çš„å åŠ å±‚ã€‚",
      "tips": ""
    },
    "Your photo view has a photoAsset property for the photo it displays. You pass this in when you initialize the PhotoView.": {
      "zh": "ä½ çš„ PhotoView ä¸­æœ‰ä¸€ä¸ªåä¸º photoAsset çš„å±æ€§ï¼Œå…¶ç”¨äºæ˜¾ç¤ºç…§ç‰‡ã€‚å½“ä½ åˆå§‹åŒ– PhotoView æ—¶ï¼Œéœ€è¦ä¼ å…¥è¿™ä¸ªå€¼ã€‚",
      "tips": ""
    },
    "You also initialize the view with a cache property that holds a reference to your image cache. You can request an image of a specified size from the image cache. After loading the image from the photo asset, the cache delivers it back to you. The image cache also keeps recently-requested images in memory, so it doesnâ€™t have to reload them if you request them again.": {
      "zh": "ä½ è¿˜éœ€è¦åœ¨åˆå§‹åŒ–è§†å›¾æ—¶è®¾ç½®ä¸€ä¸ª cache å±æ€§ï¼Œè¯¥å±æ€§æŒæœ‰ä¸€ä¸ªæŒ‡å‘ä½ å›¾åƒç¼“å­˜çš„å¼•ç”¨ã€‚ä½ å¯ä»¥ä»ç¼“å­˜ä¸­æŒ‰æŒ‡å®šçš„å¤§å°è¯·æ±‚å›¾åƒã€‚ åœ¨ä»ç…§ç‰‡èµ„æºåŠ è½½å›¾åƒåï¼Œç¼“å­˜ä¼šå°†å…¶è¿”å›ç»™ä½ ã€‚æ­¤ç¼“å­˜è¿˜ä¼šåœ¨å†…å­˜ä¸­ä¿ç•™æœ€è¿‘è¯·æ±‚çš„å›¾åƒï¼Œæ‰€ä»¥å¦‚æœä½ å†æ¬¡è¯·æ±‚å®ƒä»¬ï¼Œå°±ä¸éœ€è¦é‡æ–°åŠ è½½ã€‚",
      "tips": ""
    },
    "Your view has an image state property ready to hold the image after loading it. Itâ€™s an optional type â€” Image? â€” because you want it to start off without any value.": {
      "zh": "ä½ çš„è§†å›¾æœ‰ä¸€ä¸ªåä¸º image çš„çŠ¶æ€å±æ€§ï¼Œç”¨æ¥ä¿å­˜åŠ è½½åçš„å›¾åƒã€‚å› ä¸ºä½ å¸Œæœ›å®ƒåœ¨å¼€å§‹æ—¶æ²¡æœ‰ä»»ä½•å€¼ï¼Œæ‰€ä»¥æ˜¯ä¸€ä¸ª Image? å¯é€‰ç±»å‹ã€‚",
      "tips": ""
    },
    "A view can use its task(priority:_:) modifier to run some code asynchronously whenever the view loads.": {
      "zh": "è§†å›¾å¯ä»¥åœ¨åŠ è½½æ—¶ï¼Œä½¿ç”¨å…¶ task(priority:_:) ä¿®é¥°ç¬¦æ¥å¼‚æ­¥è¿è¡Œä¸€äº›ä»£ç ã€‚",
      "tips": ""
    },
    "This is where you add code to request a high-resolution image from the cache for the photo asset, specifying the size you want. You also provide the cache with a closure that contains code it can call when it has a result.": {
      "zh": "è¿™å—å°±æ˜¯ä½ æ·»åŠ çš„å¼‚æ­¥ä»£ç ï¼Œä½œç”¨æ˜¯ä»ç¼“å­˜ä¸­è¯·æ±‚ç…§ç‰‡èµ„æºçš„é«˜åˆ†è¾¨ç‡å›¾åƒï¼Œå¹¶æŒ‡å®šéœ€è¦çš„å¤§å°ã€‚ä½ è¿˜éœ€è¦æä¾›ä¸€ä¸ªé—­åŒ…ç»™ç¼“å­˜ï¼Œæ­¤é—­åŒ…ä¼šåœ¨è¯·æ±‚å›¾åƒæœ‰ç»“æœçš„æ—¶å€™è¢«è°ƒç”¨ã€‚",
      "tips": ""
    },
    "Your result closure receives one or more calls from the cache. If the cache already contains the image you requested, it immediately calls your closure with the image in its result. If the cache doesnâ€™t have the requested image, then it loads the image from the photo asset and caches it. While loading the image, the cache may first call your closure with a low-resolution image, before finally delivering the high-resolution image in the result.": {
      "zh": "è¿™ä¸ªé—­åŒ…ä¼šè¢«ç¼“å­˜è°ƒç”¨ä¸€æ¬¡æˆ–å¤šæ¬¡ã€‚å¦‚æœç¼“å­˜ä¸­å·²ç»æœ‰ä½ æ‰€è¯·æ±‚çš„å›¾åƒï¼Œé‚£ä¹ˆå®ƒä¼šç«‹å³ç”¨è¿™ä¸ªå›¾åƒä½œä¸ºå‚æ•°æ¥è°ƒç”¨æ­¤é—­åŒ…ã€‚åä¹‹åˆ™ä¼šä»ç…§ç‰‡èµ„æºä¸­åŠ è½½å›¾åƒå¹¶å°†å…¶ç¼“å­˜ã€‚ åœ¨åŠ è½½å›¾åƒæ—¶ï¼Œè·å¾—é«˜åˆ†è¾¨ç‡å›¾åƒä¹‹å‰ï¼Œç¼“å­˜å¯èƒ½å…ˆç”¨ä½åˆ†è¾¨ç‡å›¾åƒæ¥è°ƒç”¨ä½ çš„é—­åŒ…ã€‚",
      "tips": ""
    },
    "Your result closure looks for an image in the result. If it finds one, it updates your image property.": {
      "zh": "ä½ åœ¨é—­åŒ…ä¸­ä¼šè¯•å›¾è§£åŒ… resultã€‚å¦‚æœè§£åŒ…æˆåŠŸï¼Œåˆ™ä¼šæ›´æ–°è§†å›¾çš„ image å±æ€§ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "ç¬¬ä¹æ­¥",
      "tips": ""
    },
    "Because youâ€™ve made image a state property, SwiftUI updates your view when its value changes. If image contains a value, you unwrap the image and display it in your view.": {
      "zh": "å› ä¸º image æ˜¯ä¸€ä¸ªçŠ¶æ€å±æ€§ï¼Œæ‰€ä»¥å½“å…¶å€¼æ”¹å˜æ—¶ï¼ŒSwiftUI ä¼šè‡ªåŠ¨æ›´æ–°è§†å›¾ã€‚å¦‚æœ image ä¸ä¸ºç©ºï¼Œåˆ™è§£åŒ… image å¹¶åœ¨è§†å›¾ä¸­æ˜¾ç¤ºå®ƒã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "ç¬¬åæ­¥",
      "tips": ""
    },
    "However, if image doesnâ€™t have a value, you use a ProgressView to display a spinner as a placeholder. Look very carefully, and you might just see this spinner when your view first loads, before the cache has a chance to load an image from the photo asset.": {
      "zh": "ç„¶è€Œï¼Œå¦‚æœ image ä¸ºç©ºï¼Œåˆ™ä¼šä½¿ç”¨ ProgressView æ¥æ˜¾ç¤ºä¸€ä¸ªä½œä¸ºå ä½ç¬¦çš„æŒ‡ç¤ºå™¨ã€‚å¦‚æœä½ ä»”ç»†çœ‹çš„è¯ï¼Œå¯èƒ½ä¼šåœ¨è§†å›¾é¦–æ¬¡åŠ è½½ï¼Œå¹¶ä¸”ç¼“å­˜è¿˜åœ¨ä»ç…§ç‰‡èµ„æºåŠ è½½å›¾åƒæ—¶ï¼Œçœ‹åˆ°è¿™ä¸ªæŒ‡ç¤ºå™¨ã€‚",
      "tips": ""
    }
  },
  "sample-apps/capturingphotos-camerapreview": {
    "Previewing the Camera Output": {
      "zh": "é¢„è§ˆæ‘„åƒå¤´è¾“å‡º",
      "tips": ""
    },
    "Preview the output from the camera.": {
      "zh": "é¢„è§ˆæ‘„åƒå¤´çš„è¾“å‡ºã€‚",
      "tips": ""
    },
    "Your cameraâ€™s video output sends a continuous stream of individual images (video frames). You display these in a viewfinder so you can see exactly what the camera is looking at before composing your shot and taking a photo.": {
      "zh": "æ‘„åƒå¤´çš„è§†é¢‘è¾“å‡ºä¼šå‘é€è¿ç»­çš„å•ç‹¬å›¾åƒæµï¼ˆè§†é¢‘å¸§ï¼‰ã€‚ä½ å¯ä»¥åœ¨å–æ™¯å™¨ä¸­æ˜¾ç¤ºè¿™äº›å›¾åƒï¼Œä»¥ä¾¿åœ¨æ„å›¾å’Œæ‹ç…§å‰èƒ½å‡†ç¡®åœ°çœ‹åˆ°æ‘„åƒå¤´æ­£åœ¨æ˜¾ç¤ºçš„å†…å®¹ã€‚",
      "tips": ""
    },
    "Discover more about how this works. ğŸ": {
      "zh": "äº†è§£æ›´å¤šå…³äºè¿™æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ä¸€èŠ‚",
      "tips": ""
    },
    "Using the Camera": {
      "zh": "ä½¿ç”¨æ‘„åƒå¤´",
      "tips": ""
    },
    "Learn about the camera in your data model.": {
      "zh": "äº†è§£åœ¨ä½ æ•°æ®æ¨¡å‹ä¸­çš„ç›¸æœºã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "Your data model has a camera property that represents one of the physical cameras â€” or capture devices â€” available to your device.": {
      "zh": "ä½ çš„æ•°æ®æ¨¡å‹ä¸­æœ‰ä¸€ä¸ª camera å±æ€§ï¼Œå…¶ä»£è¡¨ä½ è®¾å¤‡ä¸­å¯ç”¨çš„ä¸€ä¸ªç‰©ç†æ‘„åƒå¤´æˆ–æ•æ‰è®¾å¤‡ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨é‡Š",
      "tips": ""
    },
    "Your device may have access to several capture devices â€” for example, the front and back cameras on iPad â€” and you can switch between these using the cameraâ€™s switchCaptureDevice() method. Learn more about capture devices in Cameras and Media Capture.": {
      "zh": "ä½ çš„è®¾å¤‡å¯èƒ½å¯ä»¥è®¿é—®å¤šä¸ªæ•æ‰è®¾å¤‡ï¼ˆä¾‹å¦‚ï¼ŒiPad çš„å‰åæ‘„åƒå¤´ï¼‰ï¼Œå¹¶ä¸”ä½ è¿˜å¯ä»¥é€šè¿‡å®ƒçš„ switchCaptureDevice() æ–¹æ³•åœ¨è¿™äº›è®¾å¤‡ä¹‹é—´è¿›è¡Œåˆ‡æ¢ã€‚ åœ¨ â€œCameras and Media Captureâ€ ä¸­äº†è§£æ›´å¤šå…³äºæ•æ‰è®¾å¤‡çš„ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Tip": {
      "zh": "æç¤º",
      "tips": ""
    },
    "To start using the camera, you call its start() method: await model.camera.start()": {
      "zh": "ä¸ºäº†å¼€å§‹ä½¿ç”¨æ‘„åƒå¤´ï¼Œä½ éœ€è¦è¿™æ ·è°ƒç”¨å®ƒçš„ start() æ–¹æ³•ï¼šawait model.camera.start()",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬äºŒèŠ‚",
      "tips": ""
    },
    "Exploring the Preview Stream": {
      "zh": "æ¢ç´¢é¢„è§ˆæµ",
      "tips": ""
    },
    "Learn about the stream of preview images from your camera.": {
      "zh": "äº†è§£æ¥è‡ªäºä½ æ‘„åƒå¤´çš„å›¾åƒé¢„è§ˆæµã€‚",
      "tips": ""
    },
    "After calling the cameraâ€™s start() method, its video output produces a stream of low-resolution preview images (video frames), at rates of up to 60 frames a second.": {
      "zh": "åœ¨è°ƒç”¨ Camera çš„ start() æ–¹æ³•åï¼Œå®ƒçš„è§†é¢‘è¾“å‡ºä¼šä»¥æ¯ç§’æœ€å¤š60å¸§çš„é€Ÿåº¦äº§ç”Ÿä¸€ä¸ªä½åˆ†è¾¨ç‡çš„å›¾åƒé¢„è§ˆæµï¼ˆè§†é¢‘å¸§ï¼‰ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "You receive these preview images through the cameraâ€™s previewStream property, as an asynchronous stream of CIImage (Core Image) objects.": {
      "zh": "ä½ é€šè¿‡ Camera çš„ previewStream å±æ€§æ¥æ”¶è¿™äº›é¢„è§ˆå›¾åƒï¼ŒpreviewStream çš„ç±»å‹æ˜¯ä¸€ä¸ªåŒ…å« CIImage å¯¹è±¡çš„å¼‚æ­¥æµã€‚",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ä¸‰èŠ‚",
      "tips": ""
    },
    "Processing the Preview Stream": {
      "zh": "å¤„ç†é¢„è§ˆæµ",
      "tips": ""
    },
    "Learn how to process the preview stream so that itâ€™s ready to display in the viewfinder.": {
      "zh": "å­¦ä¹ å¦‚ä½•å¤„ç†é¢„è§ˆæµï¼Œä½¿å…¶å¯ä»¥åœ¨å–æ™¯å™¨ä¸­æ˜¾ç¤ºã€‚",
      "tips": ""
    },
    "Your data model has a dedicated task to handle the stream of preview images from the camera, using its handleCameraPreviews function.": {
      "zh": "ä½ çš„æ•°æ®æ¨¡å‹æœ‰ä¸€ä¸ªä¸“é—¨çš„ Task æ¥å¤„ç†ä»æ‘„åƒå¤´è¿‡æ¥çš„å›¾åƒé¢„è§ˆæµï¼Œè¿™ä¸ª Task åˆ™ç›´æ¥è°ƒç”¨ handleCameraPreviews å‡½æ•°ã€‚",
      "tips": ""
    },
    "You can learn more about Tasks in the Swift standard library.": {
      "zh": "ä½ å¯ä»¥åœ¨ Swift æ ‡å‡†åº“ä¸­äº†è§£æ›´å¤šå…³äº Task çš„ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "In handleCameraPreviews, turn the preview stream of CIImage objects from the camera into a stream of Image views, ready for display.": {
      "zh": "åœ¨ handleCameraPreviews ä¸­ï¼Œå°† camera äº§ç”Ÿçš„ç±»å‹ä¸º CIImage å¯¹è±¡çš„é¢„è§ˆæµè½¬åŒ–ä¸ºä¸€ç³»åˆ—çš„ Image è§†å›¾ï¼Œè®©å…¶å‡†å¤‡å¥½è¿›è¡Œæ˜¾ç¤ºã€‚",
      "tips": ""
    },
    "An AsyncStream is a stream of values that are produced at time intervals. The values form a sequence, but with its values arriving asynchronously â€” an AsyncSequence. You can do many of the same things you can do with any other sequence of values, such as with an array.": {
      "zh": "AsyncStream æ˜¯ä¸€ä¸ªæ¯éš”ä¸€æ®µæ—¶é—´å°±ä¼šäº§ç”Ÿå€¼çš„æµã€‚è¿™äº›å€¼ä¼šå½¢æˆä¸€ä¸ªç±»å‹ä¸º AsyncSequence çš„åºåˆ—ï¼Œå…¶å€¼æ˜¯å¼‚æ­¥åˆ°è¾¾çš„ã€‚ä½ å¯ä»¥å¯¹å®ƒåšè®¸å¤šä¸å…¶ä»–å€¼åºåˆ—ï¼ˆä¾‹å¦‚æ•°ç»„ï¼‰ç›¸åŒçš„æ“ä½œã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "In this case you use the streamâ€™s map(_:) function to convert each element â€” $0 â€” into an Image instance using an image property extension of CIImage. This transforms the stream of CIImage instances into a stream of Image instances.": {
      "zh": "åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä½ ä½¿ç”¨ stream çš„ map(_:) å‡½æ•°å°†æ¯ä¸ªå…ƒç´ ï¼ˆä¹Ÿå°±æ˜¯ $0ï¼‰ï¼Œé€šè¿‡ CIImage çš„ image å±æ€§æ‰©å±•è½¬æ¢ä¸º Image å®ä¾‹ã€‚è¿™æ˜¯å°† CIImage å®ä¾‹çš„æµè½¬æ¢ä¸ºä¸€ä¸ª Image å®ä¾‹çš„æµã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "Your for-await loop waits for each image in your transformed imageStream before doing something with it.": {
      "zh": "åœ¨å¯¹å¾—åˆ°çš„å›¾åƒåšç‚¹ä»€ä¹ˆä¹‹å‰ï¼Œä½ çš„ for-await å¾ªç¯ä¼šåœ¨é‚£é‡Œç­‰å¾…è½¬æ¢åçš„ imageStream ä¸­äº§ç”Ÿæ¯ä¸€ä¸ªå›¾åƒã€‚",
      "tips": ""
    },
    "Learn more about working with asynchronous sequences in the Swift Programming Language Guide.": {
      "zh": "ä½ å¯ä»¥åœ¨ â€œSwift Programming Language Guideâ€ ä¸­äº†è§£æ›´å¤šå…³äºå¤„ç†å¼‚æ­¥åºåˆ—çš„ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "You use the image from the preview stream to update your data modelâ€™s viewfinderImage property. SwiftUI makes sure that any views using this property get updated when the viewfinderImage value changes.": {
      "zh": "ä½ ä½¿ç”¨ä»é¢„è§ˆæµä¸­å¾—åˆ°çš„å›¾åƒæ¥æ›´æ–°ä½ æ•°æ®å±‚çš„ viewfinderImage å±æ€§ã€‚å½“ viewfinderImage å€¼æ”¹å˜æ—¶ï¼ŒSwiftUI ç¡®ä¿ä»»ä½•ä½¿ç”¨æ­¤å±æ€§çš„è§†å›¾éƒ½å¾—åˆ°æ›´æ–°ã€‚",
      "tips": ""
    },
    "Section 4": {
      "zh": "ç¬¬å››èŠ‚",
      "tips": ""
    },
    "Viewing the Preview Stream": {
      "zh": "æŸ¥çœ‹é¢„è§ˆæµ",
      "tips": ""
    },
    "See how you can connect your viewfinder view to the processed preview stream.": {
      "zh": "äº†è§£å¦‚ä½•å°†ä½ çš„å–æ™¯å™¨è§†å›¾ä¸å¤„ç†åçš„é¢„è§ˆæµè¿æ¥èµ·æ¥ã€‚",
      "tips": ""
    },
    "Your CameraView has a ViewfinderView that it uses to display live video from the camera.": {
      "zh": "ä½ çš„ CameraView æœ‰ä¸€ä¸ª ViewfinderViewï¼Œå…¶ç”¨äºæ˜¾ç¤ºæ‘„åƒå¤´çš„å®æ—¶è§†é¢‘ã€‚",
      "tips": ""
    },
    "By binding the the modelâ€™s viewfinderImage property to your ViewfinderView, you ensure that the viewfinder updates whenever the view receives a new preview image. Because the preview image updates many times per second, your eyes see it as live video in the viewfinder.": {
      "zh": "é€šè¿‡å°† model çš„ viewfinderImage å±æ€§ç»‘å®šåˆ°ä½ çš„ ViewfinderView ä¸Šï¼Œç¡®ä¿æ¯å½“è§†å›¾æ¥æ”¶åˆ°æ–°çš„é¢„è§ˆå›¾åƒæ—¶ï¼Œå–æ™¯å™¨éƒ½ä¼šæ›´æ–°ã€‚ ç”±äºé¢„è§ˆå›¾åƒæ¯ç§’ä¼šæ›´æ–°å¤šæ¬¡ï¼Œæ‰€ä»¥ä½ çš„çœ¼ç›ä¼šè®¤ä¸ºåœ¨å–æ™¯å™¨ä¸­çœ‹åˆ°çš„æ˜¯å®æ—¶è§†é¢‘ã€‚",
      "tips": ""
    }
  },
  "sample-apps/capturingphotos-captureandsave": {
    "Capturing and Saving a Photo": {
      "zh": "æ‹æ‘„å’Œä¿å­˜ç…§ç‰‡",
      "tips": ""
    },
    "Take photos with the camera, add them to your photo library, and display them in your app.": {
      "zh": "ä½¿ç”¨æ‘„åƒå¤´æ‹ç…§ï¼Œå°†ç…§ç‰‡æ·»åŠ åˆ°ä½ çš„ç…§ç‰‡åº“ä¸­ï¼Œå¹¶åœ¨ä½ çš„ app ä¸­æ˜¾ç¤ºå®ƒä»¬ã€‚",
      "tips": ""
    },
    "Smile! Click! A lot happens in quick succession when you take a photo. ğŸ“¸": {
      "zh": "å¾®ç¬‘ï¼ç‚¹å‡»ï¼åœ¨æ‹ç…§æ—¶ä¼šè¿…é€Ÿå‘ç”Ÿå¾ˆå¤šäº‹æƒ…ã€‚",
      "tips": ""
    },
    "Follow the action after you tap or click the shutter button, to investigate what happens from that moment to when the photo shows up in your photo library.": {
      "zh": "éšç€ä½ ç‚¹å‡»ç›¸æœºè§†å›¾æˆ–ç‚¹å‡»å¿«é—¨ä¹‹åï¼Œæ¥æ¢ç´¢ä»è¿™ä¸€åˆ»åˆ°ç…§ç‰‡å‡ºç°åœ¨ä½ ç…§ç‰‡åº“ä¸­æ‰€å‘ç”Ÿçš„è¿‡ç¨‹ã€‚",
      "tips": ""
    },
    "Responding to the Shutter Button": {
      "zh": "å“åº”å¿«é—¨æŒ‰é’®",
      "tips": ""
    },
    "Learn how to handle the shutter button action, and request the camera to take a photo.": {
      "zh": "å­¦ä¹ å¦‚ä½•å¤„ç†å¿«é—¨æŒ‰é’®çš„æ“ä½œï¼Œå¹¶è¯·æ±‚æ‘„åƒå¤´æ‹æ‘„ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "When you tap or click the shutter button in your camera view, things start happening!": {
      "zh": "å½“ä½ ç‚¹å‡»ç›¸æœºè§†å›¾æˆ–ç‚¹å‡»å¿«é—¨æŒ‰é’®æ—¶ï¼Œäº‹æƒ…å°±å¼€å§‹å‘ç”Ÿäº†ï¼",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "The button springs into action, grabs the modelâ€™s camera object, then calls its takePhoto() method. Keep going to find out how it takes a photo!": {
      "zh": "æŒ‰é’®è¿…é€Ÿå“åº”ï¼Œè·å–æ¨¡å‹ä¸­çš„ camera å¯¹è±¡ï¼Œç„¶åè°ƒç”¨å®ƒçš„ takePhoto() æ–¹æ³•ã€‚ä¸‹é¢æˆ‘ä»¬ä¼šè§£é‡Šå®ƒæ˜¯å¦‚ä½•èƒ½æ‹æ‘„ä¸€å¼ ç…§ç‰‡çš„ï¼",
      "tips": ""
    },
    "Capturing a Photo": {
      "zh": "æ‹æ‘„ä¸€å¼ ç…§ç‰‡",
      "tips": ""
    },
    "When you take a photo, the camera captures image data from its sensor. Learn how to initiate this, and handle the resulting captured photo.": {
      "zh": "å½“ä½ æ‹ç…§æ—¶ï¼Œæ‘„åƒå¤´ä¼šä»å…¶ä¼ æ„Ÿå™¨ä¸­æ•è·å›¾åƒæ•°æ®ã€‚å­¦ä¹ å¦‚ä½•å‘èµ·æ‹ç…§ï¼Œå¹¶å¤„ç†æ•è·åˆ°çš„ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "When you take a photo, you want to capture an image with the highest possible resolution. This contrasts with the preview images, which tend to have a lower resolution to facilitate rapidly updating previews in the viewfinder. Your camera has a special photo output that its takePhoto() method uses to capture high-resolution images of what you see in the viewfinder.": {
      "zh": "å½“ä½ æ‹æ‘„ç…§ç‰‡æ—¶ï¼Œä½ å¸Œæœ›ä»¥å°½å¯èƒ½é«˜çš„åˆ†è¾¨ç‡æ•è·å›¾åƒã€‚è¿™ä¸é¢„è§ˆå›¾åƒå½¢æˆäº†å¯¹æ¯”ï¼Œé¢„è§ˆå›¾åƒé€šå¸¸å…·æœ‰è¾ƒä½çš„åˆ†è¾¨ç‡ï¼Œä»¥ä¾¿åœ¨å–æ™¯å™¨ä¸­å¿«é€Ÿæ›´æ–°é¢„è§ˆã€‚ ä½ çš„æ‘„åƒå¤´å…·æœ‰ä¸€ä¸ªä¸“é—¨çš„ç…§ç‰‡è¾“å‡ºï¼Œè¿™é‡Œçš„ takePhoto() æ–¹æ³•å°±ä½¿ç”¨è¯¥è¾“å‡ºæ¥æ•è·åœ¨å–æ™¯å™¨ä¸­æ‰€è§çš„é«˜åˆ†è¾¨ç‡å›¾åƒã€‚",
      "tips": ""
    },
    "You start the real work of taking the photo by requesting the photo output to capture a photo. If all goes well, this is when you hear a reassuring shutter sound to let you â€” and anyone nearby â€” know that youâ€™ve just taken a photo.": {
      "zh": "é€šè¿‡è¯·æ±‚ç…§ç‰‡è¾“å‡ºæ¥æ‹æ‘„ç…§ç‰‡ï¼Œä½ ä¾¿å¼€å§‹äº†å®é™…çš„æ‹ç…§å·¥ä½œã€‚å¦‚æœä¸€åˆ‡é¡ºåˆ©ï¼Œè¿™æ—¶ä½ ä¼šå¬åˆ°ä»¤äººæ”¾å¿ƒçš„å¿«é—¨å£°éŸ³ï¼Œè®©ä½ å’Œå‘¨å›´çš„äººéƒ½çŸ¥é“ä½ åˆšåˆšæ‹æ‘„äº†ä¸€å¼ ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "You might wonder why capturePhoto doesnâ€™t just return the photo. Thatâ€™s because capturing a photo takes time: the camera may need to focus, or wait for the flash, and then thereâ€™s the exposure time. The capturePhoto method is asynchronous, with the captured photo typically arriving a short time after you tap or click the shutter button.": {
      "zh": "ä½ å¯èƒ½ä¼šæƒ³çŸ¥é“ä¸ºä»€ä¹ˆ capturePhoto æ–¹æ³•ä¸ç›´æ¥è¿”å›ç…§ç‰‡ã€‚è¿™æ˜¯å› ä¸ºæ‹æ‘„ç…§ç‰‡éœ€è¦æ—¶é—´ï¼šç›¸æœºå¯èƒ½éœ€è¦å¯¹ç„¦ï¼Œæˆ–è€…ç­‰å¾…é—ªå…‰ç¯ï¼Œä»¥åŠè¿˜æœ‰æ›å…‰æ—¶é—´ã€‚ capturePhoto æ–¹æ³•æ˜¯å¼‚æ­¥çš„ï¼Œé€šå¸¸åœ¨ä½ ç‚¹å‡»ç›¸æœºè§†å›¾æˆ–ç‚¹å‡»å¿«é—¨æŒ‰é’®åçš„çŸ­æš‚æ—¶é—´å†…å°±ä¼šæ”¶åˆ°ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "After the photo capture has completed, you receive a callback to another method in your camera object: photoOutput(_:didFinishProcessingPhoto:error:). Its first argument receives the captured photo as an instance of AVCapturePhoto.": {
      "zh": "åœ¨æ•è·ç…§ç‰‡å®Œæˆåï¼Œcamera å¯¹è±¡çš„å¦ä¸€ä¸ªå›è°ƒæ–¹æ³•ï¼šphotoOutput(_:didFinishProcessingPhoto:error:) ä¼šè¢«è°ƒç”¨ã€‚å®ƒçš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªç±»å‹ä¸º AVCapturePhoto çš„å®ä¾‹ï¼Œå…¶å°±æ˜¯è¢«æ•è·çš„ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "Now that youâ€™ve got the captured photo, you add it into the cameraâ€™s photo stream. Itâ€™s then available to any object in your app waiting for a photo, like the data model.": {
      "zh": "ç°åœ¨ä½ å·²ç»è·å¾—äº†ç…§ç‰‡ï¼Œå¹¶å°†å®ƒæ·»åŠ åˆ° camera çš„ç…§ç‰‡æµä¸­ã€‚ç„¶åä½  app ä¸­ä»»ä½•ä¸€ä¸ªç­‰å¾…ç…§ç‰‡æ•°æ®çš„å¯¹è±¡ï¼ˆä¾‹å¦‚æ•°æ®æ¨¡å‹ï¼‰éƒ½å¯ä»¥ä½¿ç”¨å®ƒã€‚",
      "tips": ""
    },
    "Processing and Saving a Photo": {
      "zh": "å¤„ç†å’Œä¿å­˜ç…§ç‰‡",
      "tips": ""
    },
    "Discover how to unpack a captured photo and save it to your photo library.": {
      "zh": "äº†è§£å¦‚ä½•è§£åŒ…æ•è·çš„ç…§ç‰‡å¹¶å°†å…¶ä¿å­˜åˆ°ç…§ç‰‡åº“ä¸­ã€‚",
      "tips": ""
    },
    "Your data model is patiently awaiting newly-captured photos. Just as for preview images, it has a dedicated task for handling the captured photo stream from the camera, using its handleCameraPhotos method.": {
      "zh": "ä½ çš„æ•°æ®æ¨¡å‹æ­£åœ¨è€å¿ƒåœ°ç­‰å¾…æ–°æ•è·åˆ°çš„ç…§ç‰‡ã€‚å°±åƒå¤„ç†é¢„è§ˆå›¾åƒä¸€æ ·ï¼Œå®ƒä¹Ÿæœ‰ä¸€ä¸ªä¸“é—¨çš„ Task å¤„ç†æ¥è‡ª camera å¯¹è±¡çš„è¢«æ•è·çš„ç…§ç‰‡æµï¼Œè¿™ä¸ª Task è°ƒç”¨ handleCameraPhotos æ–¹æ³•ã€‚",
      "tips": ""
    },
    "Tip": {
      "zh": "æ³¨é‡Š",
      "tips": ""
    },
    "You can learn more about Tasks in the Swift standard library.": {
      "zh": "ä½ å¯ä»¥åœ¨ Swift æ ‡å‡†åº“ä¸­äº†è§£æ›´å¤šå…³äº Task çš„ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Each AVCapturePhoto element in the cameraâ€™s photoStream may contain several images at different resolutions, as well as other metadata about the image, such as its size and the date and time the image was captured. You have to unpack it to get the images and metadata that you want. The first thing you do in handleCameraPhotos is to convert photoStream into a more useful unpackedPhotoStream, in which each element is an instance of the PhotoData structure that contains the data you want.": {
      "zh": "camera çš„ photoStream ä¸­çš„æ¯ä¸ª AVCapturePhoto å…ƒç´ å¯èƒ½åŒ…å«æœ‰å¤šä¸ªä¸åŒåˆ†è¾¨ç‡çš„å›¾åƒï¼Œä»¥åŠå…³äºè¿™ä¸ªå›¾åƒçš„å…¶ä»–å…ƒæ•°æ®ï¼Œå¦‚å¤§å°ä»¥åŠå›¾åƒæ•è·çš„æ—¥æœŸå’Œæ—¶é—´ã€‚ ä½ éœ€è¦è§£åŒ…å®ƒä»¥è·å–ä½ æƒ³è¦çš„å›¾åƒå’Œå…ƒæ•°æ®ã€‚åœ¨ handleCameraPhotos ä¸­çš„ç¬¬ä¸€ä»¶äº‹å°±æ˜¯å°† photoStream è½¬æ¢ä¸ºä¸€ä¸ªæ›´æœ‰ç”¨çš„ unpackedPhotoStreamï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ PhotoData ç»“æ„çš„å®ä¾‹ï¼Œå…¶åŒ…å«ä½ æƒ³è¦çš„é‚£äº›æ•°æ®ã€‚",
      "tips": ""
    },
    "To unpack the photoStream, youâ€™ll use the unpackPhoto(_:) function, which takes a captured photo and returns a PhotoData instance that contains a low-resolution image thumbnail as an Image, the size of the image thumbnail, a high-resolution image as Data, and the size of the high-resolution image.": {
      "zh": "ä½ ä¼šä½¿ç”¨ unpackPhoto(_:) æ–¹æ³•æ¥è§£åŒ… photoStreamï¼Œå®ƒæ¥å—ä¸€ä¸ªæ•è·çš„ç…§ç‰‡ä½œä¸ºå‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ª PhotoData å®ä¾‹ã€‚ è¯¥å®ä¾‹åŒ…å«ä¸€ä¸ªç±»å‹ä¸º Image çš„ä½åˆ†è¾¨ç‡å›¾åƒä½œä¸ºç¼©ç•¥å›¾ï¼Œä»¥åŠè¿™ä¸ªç¼©ç•¥å›¾çš„å¤§å°ï¼›è¿˜æœ‰ä¸€ä¸ªç±»å‹ä¸º Data çš„é«˜åˆ†è¾¨ç‡å›¾åƒï¼Œå’Œæ­¤å›¾åƒçš„å¤§å°ã€‚",
      "tips": ""
    },
    "Youâ€™ll recall that, as an asynchronous stream, photoStream is very much like a Sequence. You can use its compactMap(_:) method to call unpackPhoto(_:) for each photo ($0) in the stream. This transforms the stream of AVCapturePhoto instances into a much more useful stream of PhotoData instances.": {
      "zh": "ä½ å¯èƒ½è¿˜è®°å¾—ï¼Œä½œä¸ºä¸€ä¸ªå¼‚æ­¥æµï¼ŒphotoStream æ˜¯éå¸¸ç±»ä¼¼äºä¸€ä¸ªæ™®é€šåºåˆ—çš„ã€‚ä½ å¯ä»¥ä½¿ç”¨å®ƒçš„ compactMap(:) æ–¹æ³•æ¥å¯¹æµä¸­çš„æ¯ä¸ªç…§ç‰‡ï¼ˆä¹Ÿå°±æ˜¯ä¾‹å­ä¸­çš„ $0ï¼‰è°ƒç”¨ unpackPhoto(:)ã€‚ è¿™å°†æŠŠ AVCapturePhoto å®ä¾‹çš„æµè½¬æ¢ä¸ºä¸€ä¸ªæ›´æœ‰ç”¨çš„ PhotoData å®ä¾‹çš„æµã€‚",
      "tips": ""
    },
    "The for-await loop now waits for a photoData element to arrive in your unpacked stream before processing it.": {
      "zh": "ç°åœ¨ï¼Œfor-await å¾ªç¯ä¼šç­‰å¾…ä¸€ä¸ª photoData å…ƒç´ åˆ°è¾¾ä½ çš„ unpackedPhotoStream ä¸­ï¼Œç„¶åå¤„ç†å®ƒã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "You use the thumbnail image in photoData to update your modelâ€™s thumbnailImage property.": {
      "zh": "ä½ ä½¿ç”¨ photoData ä¸­çš„ç¼©ç•¥å›¾æ¥æ›´æ–°æ¨¡å‹çš„ thumbnailImage å±æ€§ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ä¸ƒæ­¥",
      "tips": ""
    },
    "Call your modelâ€™s savePhoto(imageData:) method to save the image data from photoData as a new photo in your photo library.": {
      "zh": "è°ƒç”¨ä½ æ¨¡å‹çš„ savePhoto(imageData:) æ–¹æ³•ï¼Œå°† photoData ä¸­çš„å›¾åƒæ•°æ®ä¿å­˜ä¸ºç…§ç‰‡åº“ä¸­çš„æ–°ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "ç¬¬å…«æ­¥",
      "tips": ""
    },
    "The savePhoto(imageData:) method creates a task and passes on the real work of saving the photo data to the photoCollection object by calling its addImage(_:) method. And thatâ€™s fine! The data modelâ€™s job is to coordinate data flow between the appâ€™s data objects.": {
      "zh": "savePhoto(imageData:) æ–¹æ³•åˆ›å»ºäº†ä¸€ä¸ª Taskï¼Œå¹¶é€šè¿‡è°ƒç”¨ photoCollection å¯¹è±¡çš„ addImage(_:) æ–¹æ³•å°†çœŸæ­£ä¿å­˜ç…§ç‰‡æ•°æ®çš„å·¥ä½œå§”æ‰˜ç»™å®ƒã€‚ è¿™æ˜¯å®Œå…¨å¯ä»¥çš„ï¼æ•°æ®æ¨¡å‹çš„å·¥ä½œä¹‹ä¸€å°±æ˜¯åè°ƒ app æ•°æ®å¯¹è±¡ä¹‹é—´çš„æ•°æ®æµã€‚",
      "tips": ""
    }
  },
  "sample-apps/chooseyourownstory": {
    "Choose Your Own Story": {
      "zh": "é€‰æ‹©ä½ è‡ªå·±çš„æ•…äº‹",
      "tips": ""
    },
    "Provide dynamic navigation between views.": {
      "zh": "æä¾›è§†å›¾é—´çš„åŠ¨æ€å¯¼èˆªã€‚",
      "tips": ""
    },
    "In this sample, you can write a story with many different paths and outcomes. Your reader can make choices at important points in the narrative, resulting in different experiences based on their responses.": {
      "zh": "åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œä½ å¯ä»¥å†™ä¸€æ®µåŒ…æ‹¬å¤šç§è·¯å¾„å’Œç»“æœçš„æ•…äº‹ã€‚ä½ çš„è¯»è€…å¯ä»¥åœ¨å…³é”®ç‚¹å¤„é€‰æ‹©ï¼Œç»“æœä¼šå½±å“æ•…äº‹çš„ä¸åŒä½“éªŒã€‚",
      "tips": ""
    },
    "There are several parts to this app. StoryData contains the story itself, including the text on each page and the choices the reader can make.": {
      "zh": "è¿™ä¸ªåº”ç”¨ç¨‹åºæœ‰å‡ ä¸ªéƒ¨åˆ†ã€‚ StoryData åŒ…å«æ•…äº‹æœ¬èº«ï¼ŒåŒ…æ‹¬æ¯é¡µæ•…äº‹æè¿°æ–‡æœ¬å’Œè¯»è€…å¯ä»¥é€‰æ‹©çš„é€‰é¡¹ã€‚",
      "tips": ""
    },
    "StoryView sets up the navigation for the app, and StoryPageView displays the contents of one page of the story.": {
      "zh": "StoryView è®¾ç½®å¯¼èˆªï¼Œå¹¶ä½¿ç”¨ StoryPageView å±•ç¤ºæ•…äº‹çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "You can start in StoryData and write your own narrative, or you can learn about and modify the look and feel of the app in StoryView and StoryPageView.": {
      "zh": "ä½ å¯ä»¥ä» StoryData å¼€å§‹ï¼Œå†™ä½ è‡ªå·±çš„æ•…äº‹ï¼Œæˆ–è€…ä½ å¯ä»¥åœ¨ StoryView å’Œ StoryPageView ä¸­äº†è§£å­¦ä¹ å’Œä¿®æ”¹åº”ç”¨ç¨‹åºçš„å¤–è§‚å’Œé£æ ¼ã€‚",
      "tips": ""
    },
    "Create Your Own Story": {
      "zh": "åˆ›é€ ä½ è‡ªå·±çš„æ•…äº‹",
      "tips": ""
    },
    "Customize the story to create a narrative of your own.": {
      "zh": "è‡ªå®šä¹‰æ•…äº‹å†…å®¹æ¥åˆ›å»ºè‡ªå·±çš„å™äº‹ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "To construct your narrative, the app needs an instance of Story, which takes an array of StoryPage instances. Each page of your story contains some narrative text and an array of choices to select from. That choice takes you to another story page with more choices that take you to another story page, and so on.": {
      "zh": "ä¸ºäº†æ„å»ºæ•…äº‹ï¼Œåº”ç”¨ç¨‹åºéœ€è¦ä¸€ä¸ª Story å®ä¾‹ï¼Œå®ƒåŒ…æ‹¬ä¸€ä¸ª StoryPage æ•°ç»„ã€‚æ¯ä¸ªé¡µé¢çš„æ•…äº‹åŒ…å«æ•…äº‹æ–‡æœ¬å’Œé€‰é¡¹ï¼Œé€‰é¡¹ä¼šå¯¼å‘å¦ä¸€ä¸ªæ•…äº‹é¡µé¢ï¼Œä»¥æ­¤ç±»æ¨ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "Hereâ€™s the text of your first story page. Try changing it to something new, and notice how the app preview changes. When youâ€™re ready, you can edit this text to start creating your story.": {
      "zh": "è¿™æ˜¯ç¬¬ä¸€ä¸ªæ•…äº‹é¡µé¢çš„æ–‡æœ¬ã€‚è¯•ç€æ”¹å˜å®ƒï¼Œå¹¶æ³¨æ„ï¼Œåº”ç”¨ç¨‹åºé¢„è§ˆä¼šæ”¹å˜ã€‚å½“ä½ å‡†å¤‡å¥½æ—¶ï¼Œç¼–è¾‘æ–‡æœ¬æ¥å¼€å§‹åˆ›å»ºæ•…äº‹ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "Notice the three quotation marks above and below the text? This is a special way to create a String value. You can read and edit your story much more easily with this special syntax because you can include multiple lines and quotation marks in the text.": {
      "zh": "æ³¨æ„åˆ°æ–‡æœ¬ä¸Šä¸‹çš„ä¸‰ä¸ªå¼•å·äº†å—ï¼Ÿè¿™æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æ–¹å¼æ¥åˆ›å»ºå­—ç¬¦ä¸²å€¼ã€‚ä½ å¯ä»¥ä½¿ç”¨è¿™ç§ç‰¹æ®Šçš„è¯­æ³•æ¥ç¼–è¾‘æ•…äº‹ï¼Œç”¨ä¸‰ä¸ªå¼•å·åŒ…ä½å¤šè¡Œæ–‡æœ¬ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "In addition to the intro text, each page offers readers some choices for what happens next in the story. The page displays these choices as buttons below the text.": {
      "zh": "é™¤äº†ä»‹ç»æ–‡æœ¬ä¹‹å¤–ï¼Œæ¯ä¸ªé¡µé¢éƒ½æœ‰è¯»è€…å¯ä»¥é€‰æ‹©çš„é€‰é¡¹ã€‚é¡µé¢å°†è¿™äº›é€‰é¡¹æ˜¾ç¤ºåœ¨æ–‡æœ¬ä¸‹é¢ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®è·µ",
      "tips": ""
    },
    "Try customizing the text of each choice to see how the app preview updates the buttons.": {
      "zh": "å°è¯•è‡ªå®šä¹‰æ¯ä¸ªé€‰é¡¹çš„æ–‡æœ¬æ¥çœ‹åº”ç”¨ç¨‹åºé¢„è§ˆå¦‚ä½•æ›´æ–°æŒ‰é’®ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "The destination property of the choice is the key to story navigation. The number is the index of the page for the app to display when a reader taps to select that choice. Arrays start counting at 0, so the index of the first page is 0, the second page is 1, and so on.": {
      "zh": "é€‰æ‹©çš„ destination å±æ€§æ˜¯æ•…äº‹å¯¼èˆªçš„å…³é”®ã€‚æ•°å­—æ˜¯åº”ç”¨ç¨‹åºæ˜¾ç¤ºçš„é¡µé¢çš„ç´¢å¼•ã€‚æ•°ç»„è®¡æ•°ä» 0 å¼€å§‹ï¼Œæ‰€ä»¥ç¬¬ä¸€ä¸ªé¡µé¢çš„ç´¢å¼•æ˜¯ 0ï¼Œç¬¬äºŒä¸ªé¡µé¢æ˜¯ 1ã€‚ä»¥æ­¤ç±»æ¨ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "Try changing the destination of one of these choices and then test where the button navigates to in the app preview. Be careful, though. You have 21 story pages, so using an index higher than 20 causes the app to crash due to an index out of range error.": {
      "zh": "å°è¯•ä¿®æ”¹å…¶ä¸­ä¸€ä¸ªé€‰é¡¹çš„ç›®æ ‡ï¼Œç„¶åæµ‹è¯•åœ¨åº”ç”¨ç¨‹åºé¢„è§ˆä¸­æŒ‰é’®å¯¼èˆªçš„é¡µé¢ã€‚ä¸è¿‡è¦æ³¨æ„ï¼Œæˆ‘ä»¬æœ‰ 21 ä¸ªæ•…äº‹é¡µé¢ï¼Œå› æ­¤ä½¿ç”¨ä¸€ä¸ªå¤§äº 20 çš„ç´¢å¼•å¯èƒ½ä¼šå¯¼è‡´åº”ç”¨ç¨‹åºå´©æºƒã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ä¸ƒæ­¥",
      "tips": ""
    },
    "To add a new page to the story, copy an existing story page, such as this one, and paste it below the last story page in the array.": {
      "zh": "è¦ç»™æ•…äº‹æ·»åŠ æ–°é¡µé¢ï¼Œå¤åˆ¶ä¸€ä¸ªç°æœ‰æ•…äº‹é¡µé¢ï¼Œå¹¶å°†å…¶æ”¾åœ¨æ•…äº‹æ•°ç»„çš„æœ€åä¸€ä¸ªé¡µé¢ä¹‹åã€‚",
      "tips": ""
    },
    "Try adding a new page and customizing its text and choices. Youâ€™re now ready to start writing the adventure!": {
      "zh": "å°è¯•æ·»åŠ ä¸€ä¸ªæ–°é¡µé¢å¹¶è‡ªå®šä¹‰å®ƒçš„æ–‡æœ¬å’Œé€‰é¡¹ã€‚ä½ ç°åœ¨å·²ç»å¯ä»¥å¼€å§‹å†™æ•…äº‹äº†!",
      "tips": ""
    },
    "Story Data Model": {
      "zh": "æ•…äº‹æ•°æ®æ¨¡å‹",
      "tips": ""
    },
    "Learn how to structure the story data for your readerâ€™s adventure.": {
      "zh": "äº†è§£å¦‚ä½•ä¸ºè¯»è€…çš„æ•…äº‹æ„å»ºæ•°æ®ã€‚",
      "tips": ""
    },
    "Youâ€™ll use the custom types defined here to model the story data. Your app uses an instance of the Story type to display a series of story pages, each with some narrative text and a number of choices for the reader.": {
      "zh": "ä½ å°†ä½¿ç”¨è¿™é‡Œçš„è‡ªå®šä¹‰ç±»å‹æ¥å¯¹æ•…äº‹æ•°æ®è¿›è¡Œå»ºæ¨¡ã€‚æ‚¨çš„åº”ç”¨ç¨‹åºä½¿ç”¨ Story ç±»æ¥æ˜¾ç¤ºæ•…äº‹é¡µé¢ï¼Œæ¯ä¸ªé¡µé¢éƒ½æœ‰æ•…äº‹æ–‡æœ¬å’Œè¯»è€…å¯ä»¥é€‰æ‹©çš„é€‰é¡¹ã€‚",
      "tips": ""
    },
    "The pages property holds an array of StoryPage values, each corresponding to a page of your story.": {
      "zh": "pages å±æ€§åŒ…å«ä¸€ä¸ª StoryPage æ•°ç»„ï¼Œæ¯ä¸ªæ•°ç»„å…ƒç´ å¯¹åº”ä¸€ä¸ªæ•…äº‹é¡µé¢ã€‚",
      "tips": ""
    },
    "The StoryPage type contains a text value for the narrative text on the page, and a choices array that contains an array of StoryChoice options that a reader can choose from to navigate to another page.": {
      "zh": "StroyPage ç±»åŒ…å«æ•…äº‹æ–‡æœ¬çš„å€¼ï¼Œä»¥åŠä¸€ä¸ªé€‰é¡¹æ•°ç»„ï¼Œè¯»è€…å¯ä»¥é€‰æ‹©æ¥å¯¼èˆªåˆ°å¦ä¸€ä¸ªé¡µé¢ã€‚",
      "tips": ""
    },
    "The Choice type defines a choice readers can make while reading a story.": {
      "zh": "Choice ç±»å®šä¹‰è¯»è€…å¯ä»¥åœ¨æ•…äº‹ä¸­é€‰æ‹©çš„é€‰é¡¹ã€‚",
      "tips": ""
    },
    "The text property holds a String that describes the choice readers can make.": {
      "zh": "text å±æ€§åŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²æè¿°è¯»è€…å¯ä»¥é€‰æ‹©çš„é€‰é¡¹ã€‚",
      "tips": ""
    },
    "The destination property stores an Int. The value is the index of the page that the choice navigates to.": {
      "zh": "destination å±æ€§å­˜å‚¨ä¸€ä¸ªæ•´æ•°ã€‚è¿™ä¸ªå€¼æ˜¯é€‰é¡¹å¯¼èˆªåˆ°æ•…äº‹é¡µé¢çš„ç´¢å¼•ã€‚",
      "tips": ""
    },
    "Creating a Navigation View": {
      "zh": "åˆ›å»ºä¸€ä¸ªå¯¼èˆªè§†å›¾",
      "tips": ""
    },
    "To manage navigation through the story, the app wraps each story page in a NavigationStack.": {
      "zh": "ä¸ºäº†ç®¡ç†æ•…äº‹ä¸­çš„å¯¼èˆªï¼Œåº”ç”¨ç¨‹åºå°†æ¯ä¸ªæ•…äº‹é¡µé¢åŒ…è£…åœ¨ NavigationStack ä¸­ã€‚",
      "tips": ""
    },
    "StoryView is the top-level view of your app. When your app runs, this is the first view it displays.": {
      "zh": "StoryView æ˜¯åº”ç”¨ç¨‹åºçš„é¡¶çº§è§†å›¾ã€‚å½“åº”ç”¨ç¨‹åºè¿è¡Œæ—¶ï¼Œä»–æ˜¯ç¬¬ä¸€ä¸ªæ˜¾ç¤ºçš„è§†å›¾ã€‚",
      "tips": ""
    },
    "To display and navigate between each story page, youâ€™ll use a NavigationStack. This view acts as a container to display one StoryPageView at a time and transition to the next view when the reader taps a NavigationLink.": {
      "zh": "è¦æ˜¾ç¤ºå’Œå¯¼èˆªæ¯ä¸ªæ•…äº‹é¡µé¢ï¼Œä½ å°†ä½¿ç”¨ NavigationStackã€‚å°†å®ƒä½œä¸ºå®¹å™¨ä¸€æ¬¡æ˜¾ç¤ºä¸€ä¸ª StoryPageViewï¼Œå½“è¯»è€…ç‚¹å‡» NavigationLink æ—¶ï¼Œå®ƒä¼šæ˜¾ç¤ºä¸‹ä¸€ä¸ªè§†å›¾ã€‚",
      "tips": ""
    },
    "The navigation view displays StoryPageView as its content. Notice that you initialize this view with the global variable story from the StoryData file, and you show the first page, with an index of 0.": {
      "zh": "å¯¼èˆªè§†å›¾æ˜¾ç¤º StoryPageView ä½œä¸ºå…¶å†…å®¹ã€‚è¦æ³¨æ„ï¼Œä½ ä½¿ç”¨ StoryData æ–‡ä»¶ä¸­çš„å…¨å±€å˜é‡åˆå§‹åŒ–è¿™ä¸ªè§†å›¾ï¼Œå¹¶æ˜¾ç¤ºç¬¬ä¸€ä¸ªé¡µé¢ï¼Œç´¢å¼•ä¸º 0ã€‚",
      "tips": ""
    },
    "Displaying a Story Page": {
      "zh": "æ˜¾ç¤ºæ•…äº‹é¡µé¢",
      "tips": ""
    },
    "Explore and modify the storyâ€™s user interface (UI) using basic SwiftUI views.": {
      "zh": "ä½¿ç”¨åŸºæœ¬ SwiftUI è§†å›¾æ¢ç´¢å’Œä¿®æ”¹æ•…äº‹çš„ç”¨æˆ·ç•Œé¢(UI)ã€‚",
      "tips": ""
    },
    "StoryPageView displays your story so readers can navigate by making choices provided on each page.": {
      "zh": "StoryPageView å±•ç¤ºæ•…äº‹ï¼Œè¯»è€…å¯ä»¥é€šè¿‡æä¾›çš„é€‰é¡¹æ¥å¯¼èˆªã€‚",
      "tips": ""
    },
    "To display a story, the app uses an instance of the Story type that contains all of the storyâ€™s data. To change this data, go to the StoryData.swift file and look for the global variable story.": {
      "zh": "ä¸ºäº†æ˜¾ç¤ºæ•…äº‹ï¼Œåº”ç”¨ç¨‹åºä½¿ç”¨ Story ç±»ä¸­åŒ…å«æ•…äº‹æ•°æ®çš„å®ä¾‹ã€‚è¦æ”¹å˜æ•…äº‹æ•°æ®ï¼Œè¯·æŸ¥çœ‹ StoryData.swift æ–‡ä»¶å¹¶åœ¨å…¶ä¸­æ‰¾åˆ°å…¨å±€å˜é‡ storyã€‚",
      "tips": ""
    },
    "This property stores the index of the current story page.": {
      "zh": "è¿™ä¸ªå±æ€§å­˜å‚¨å½“å‰æ•…äº‹é¡µé¢çš„ç´¢å¼•ã€‚",
      "tips": ""
    },
    "A VStack arranges content vertically onscreen. At the top is the text of the current page, and at the bottom are the choices the reader can make on the page. When the reader taps to select a choice, the app navigates to another page.": {
      "zh": "VStack åœ¨å±å¹•ä¸Šå‚ç›´æ’åˆ—å†…å®¹ã€‚åœ¨é¡¶éƒ¨æ˜¯å½“å‰é¡µé¢çš„æ–‡æœ¬ï¼Œåœ¨åº•éƒ¨æ˜¯è¯»è€…å¯ä»¥é€‰æ‹©çš„é€‰é¡¹ã€‚å½“è¯»è€…é€‰æ‹©é€‰é¡¹æ—¶ï¼Œåº”ç”¨ç¨‹åºå¯¼èˆªåˆ°å¦ä¸€ä¸ªé¡µé¢ã€‚",
      "tips": ""
    },
    "The ScrollView lets you display content thatâ€™s bigger than the screen. Because a story page might have a lot of text, you want the reader to be able to scroll through it.": {
      "zh": "ScrollView ä½¿è¯»è€…èƒ½å¤Ÿåœ¨å±å¹•ä¸Šæ»šåŠ¨ã€‚å› ä¸ºæ•…äº‹é¡µé¢å¯èƒ½ä¼šæœ‰å¾ˆå¤šæ–‡æœ¬ï¼Œä½ å¸Œæœ›è¯»è€…èƒ½å¤Ÿæ»šåŠ¨æµè§ˆå®ƒã€‚",
      "tips": ""
    },
    "The Text view displays the story text from the current page.": {
      "zh": "æ–‡æœ¬è§†å›¾æ˜¾ç¤ºå½“å‰é¡µé¢çš„æ•…äº‹æ–‡æœ¬ã€‚",
      "tips": ""
    },
    "The ForEach structure generates views for a collection of things. In this case, the collection is the choices array of the current page in the story. The code within the braces runs once for each choice.": {
      "zh": "ForEach ç»“æ„ç”Ÿæˆé›†åˆè§†å›¾ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œé›†åˆæ˜¯å½“å‰é¡µé¢çš„é€‰é¡¹æ•°ç»„ï¼Œå¤§æ‹¬å·å†…çš„ä»£ç é’ˆå¯¹æ¯ä¸ªé€‰é¡¹è¿è¡Œä¸€æ¬¡ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨æ„",
      "tips": ""
    },
    "SwiftUI uses the id argument to tell the choices apart from each other. Because each choice has different text, you can use the text property to identify them.": {
      "zh": "SwiftUI ä½¿ç”¨ id å‚æ•°æ¥åŒºåˆ†é€‰é¡¹ã€‚å› ä¸ºæ¯ä¸ªé€‰é¡¹æœ‰ä¸åŒçš„æ–‡æœ¬ï¼Œä½ å¯ä»¥ä½¿ç”¨ text å±æ€§æ¥åŒºåˆ†å®ƒä»¬ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "ç¬¬å…«æ­¥",
      "tips": ""
    },
    "The ForEach view passes each item of the choices collection into its body. You can use the choice to create a NavigationLink.": {
      "zh": "ForEach è§†å›¾ä¼ é€’æ¯ä¸ªé€‰é¡¹åˆ° body ä¸­ã€‚ä½ å¯ä»¥ä½¿ç”¨é€‰é¡¹åˆ›å»º NavigationLinkã€‚",
      "tips": ""
    },
    "A NavigationLink needs two things: a destination and content to display. The destination of the navigation link is the page that the choice navigates to.": {
      "zh": "NavigationLink éœ€è¦ä¸¤ä¸ªä¸œè¥¿ï¼šç›®çš„åœ°å’Œè¦æ˜¾ç¤ºçš„å†…å®¹ã€‚å¯¼èˆªé“¾æ¥çš„ç›®çš„åœ°æ˜¯é€‰é¡¹å¯¼èˆªåˆ°çš„é¡µé¢ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "ç¬¬ä¹æ­¥",
      "tips": ""
    },
    "The code between the braces is what the navigation link displays as its content â€” what the user taps.": {
      "zh": "å¤§æ‹¬å·å†…çš„ä»£ç æ˜¯å¯¼èˆªé“¾æ¥æ˜¾ç¤ºçš„å†…å®¹ â€” ç”¨æˆ·ç‚¹å‡»çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "Navigation links donâ€™t work if they arenâ€™t inside a navigation view (either a NavigationStack or NavigationSplitView), so youâ€™ll notice that the preview for this view wonâ€™t let you navigate to the next page. The StoryView creates the navigation view that contains the StoryPageView. Use the app preview, or the preview for the StoryView, to test your story navigation.": {
      "zh": "å¦‚æœå¯¼èˆªé“¾æ¥ä¸æ˜¯åœ¨ä¸€ä¸ª NavigationViewï¼ˆå¦‚ NavigationStack æˆ– NavigationSplitViewï¼‰å†…ï¼Œé‚£ä¹ˆå®ƒä»¬å°†ä¸èµ·ä½œç”¨ï¼Œä½ å¯ä»¥æ³¨æ„åˆ°é¢„è§ˆä¸ä¼šå¯¼èˆªåˆ°ä¸‹ä¸€é¡µã€‚StoryView åˆ›å»ºäº† StoryPageView çš„å¯¼èˆªè§†å›¾ã€‚ä½¿ç”¨ App é¢„è§ˆï¼Œæˆ– StoryView çš„é¢„è§ˆæ¥æµ‹è¯•æ•…äº‹å¯¼èˆªã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "ç¬¬åæ­¥",
      "tips": ""
    },
    "The most important thing in this label is the Text for displaying the choices. But itâ€™d be nice to match the text alignment with the story page text. To align the text, youâ€™ll use two modifiers: .multilineTextAlignment and frame. Applying the .multilineTextAlignment modifier to the Text view aligns the text to its leading edge.": {
      "zh": "é‡è¦çš„æ˜¯æ˜¾ç¤ºé€‰é¡¹çš„æ–‡æœ¬ï¼Œéœ€è¦ä¸æ•…äº‹é¡µé¢æ–‡æœ¬å¯¹é½ã€‚è¦å¯¹æ–‡æœ¬è¿›è¡Œå¯¹é½ï¼Œä½ å°†ä½¿ç”¨ä¸¤ä¸ªä¿®é¥°ç¬¦: .multilineTextAlignment å’Œ frameã€‚åº”ç”¨ä»–ä»¬æ¥å¯¹æ–‡æœ¬è¿›è¡Œé¡ºåºå¯¹é½ã€‚",
      "tips": ""
    },
    "Step 11": {
      "zh": "ç¬¬åä¸€æ­¥",
      "tips": ""
    },
    "The .frame modifier puts the text inside an invisible frame. By specifying maxWidth: .infinity, youâ€™re telling the frame to expand as wide as itâ€™s allowed, and alignment: .leading aligns the text inside the frame to the leading edge.": {
      "zh": ".frame ä¿®é¥°ç¬¦å°†æ–‡æœ¬æ”¾åœ¨ä¸å¯è§çš„åŒºåŸŸä¸­ã€‚é€šè¿‡æŒ‡å®š maxWidth: .infinityï¼Œä½ å‘Šè¯‰è§†å›¾å¯ä»¥æ‰©å±•åˆ°æœ€å¤§å®½åº¦ï¼Œalignment: .leading ä½¿æ–‡æœ¬åœ¨åŒºåŸŸå†…é¡ºåºå¯¹é½ã€‚",
      "tips": ""
    },
    "Try removing or changing these modifiers to see how they affect the choice text.": {
      "zh": "å°è¯•åˆ é™¤æˆ–è€…æ›´æ”¹è¿™äº›ä¿®é¥°ç¬¦æ¥çœ‹å¦‚ä½•å½±å“é€‰é¡¹æ–‡æœ¬ã€‚",
      "tips": ""
    },
    "Step 12": {
      "zh": "ç¬¬åäºŒæ­¥",
      "tips": ""
    },
    "These next three modifiers provide a pleasing visual style to the NavigationLink view for each choice. The .padding modifier adds some space around the linkâ€™s contents. The .background modifier applies a gray color with 25 percent opacity, and the .cornerRadius modifer rounds its corners.": {
      "zh": "æ¥ä¸‹æ¥çš„ä¸‰ä¸ªä¿®é¥°ç¬¦ä¸ºæ¯ä¸ªé€‰é¡¹æ·»åŠ ä¸€äº›ç¾è§‚çš„è§†è§‰æ ·å¼ã€‚ .padding ä¿®é¥°ç¬¦ä¸ºé“¾æ¥çš„å†…å®¹æ·»åŠ ä¸€äº›ç©ºç™½è¾¹è·ã€‚ .background ä¿®é¥°ç¬¦ä¸ºèƒŒæ™¯è‰²åº”ç”¨ 25% çš„é€æ˜åº¦ï¼Œ.cornerRadius ä¿®é¥°ç¬¦ä¸ºåœ†è§’ã€‚",
      "tips": ""
    },
    "You can experiment with these modifiers to change how the choice links look. For example, try removing or changing the padding, or changing the background color.": {
      "zh": "ä½ å¯ä»¥å°è¯•ä¿®æ”¹è¿™äº›ä¿®é¥°ç¬¦æ¥æ”¹å˜é€‰é¡¹é“¾æ¥çš„æ ·å¼ã€‚ä¾‹å¦‚ï¼Œå°è¯•åˆ é™¤æˆ–è€…æ›´æ”¹å¡«å……ï¼Œæˆ–æ›´æ”¹èƒŒæ™¯é¢œè‰²ã€‚",
      "tips": ""
    },
    "Step 13": {
      "zh": "ç¬¬åä¸‰æ­¥",
      "tips": ""
    },
    "These two modifiers apply to a view when itâ€™s enclosed in a navigation view. A navigation view provides a navigation bar at the top of the screen that can display a title and a back button, along with other items you can customize, such as extra buttons and text.": {
      "zh": "å½“è§†å›¾è¢«åŒ…å«åœ¨ NavigationView ä¸­æ—¶ï¼Œè¿™ä¸¤ä¸ªä¿®é¥°ç¬¦é€‚ç”¨äºè§†å›¾ã€‚å®ƒæä¾›äº†å¯¼èˆªæ ï¼Œåœ¨å±å¹•é¡¶éƒ¨æ˜¾ç¤ºæ ‡é¢˜å’Œè¿”å›æŒ‰é’®ï¼Œä»¥åŠå…¶ä»–ä½ å¯ä»¥è‡ªå®šä¹‰çš„é¡¹ç›®ï¼Œä¾‹å¦‚é¢å¤–æŒ‰é’®å’Œæ–‡æœ¬ã€‚",
      "tips": ""
    },
    "Step 14": {
      "zh": "ç¬¬åå››æ­¥",
      "tips": ""
    },
    "You can display the current page number in the navigation bar by setting its title using the .navigationTitle modifier. Because people expect page numbers to begin at 1, but array indices start at 0, youâ€™ll need to add 1 to the pageIndex property.": {
      "zh": "ä½ å¯ä»¥é€šè¿‡ä½¿ç”¨ .navigationTitle æ¥åœ¨å¯¼èˆªæ ä¸­æ˜¾ç¤ºå½“å‰é¡µé¢çš„ç´¢å¼•ã€‚å› ä¸ºäººä»¬æœŸæœ›é¡µé¢çš„ç´¢å¼•ä» 1 å¼€å§‹ï¼Œä½†æ•°ç»„ç´¢å¼•å§‹ç»ˆä» 0 å¼€å§‹ï¼Œæ‰€ä»¥ä½ éœ€è¦åœ¨ pageIndex å±æ€§ä¸­æ·»åŠ  1ã€‚",
      "tips": ""
    },
    "Step 15": {
      "zh": "ç¬¬åäº”æ­¥",
      "tips": ""
    },
    "The .navigationBarTitleDisplayMode modifier controls how the title appears in the navigation bar. Providing .inline as the modifierâ€™s value makes the title smaller in size. You can try the other two possible values â€” .automatic and .large â€” to see how they make the app look.": {
      "zh": ".navigationBarTitleDisplayMode æŒ‡å®šå¦‚ä½•æ˜¾ç¤ºæ ‡é¢˜ã€‚.inline ä½œä¸ºå€¼ï¼Œè®©æ ‡é¢˜å˜å°ã€‚å°è¯•å…¶ä»–ä¸¤ç§å€¼ï¼š.automatic å’Œ .large æ¥çœ‹çœ‹å®ƒä»¬å¦‚ä½•æ”¹å˜åº”ç”¨ç¨‹åºçš„æ ·å¼ã€‚",
      "tips": ""
    },
    "Date Planner": {
      "zh": "æ—¥æœŸè®¡åˆ’",
      "tips": ""
    },
    "Present hierarchical information in a list.": {
      "zh": "åœ¨åˆ—è¡¨ä¸­å‘ˆç°å±‚æ¬¡åŒ–ä¿¡æ¯ã€‚",
      "tips": ""
    }
  },
  "sample-apps/dateplanner": {
    "Date Planner": {
      "zh": "æ—¥æœŸè§„åˆ’",
      "tips": ""
    },
    "Present hierarchical information in a list.": {
      "zh": "åœ¨åˆ—è¡¨ä¸­å‘ˆç°å±‚æ¬¡åŒ–ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Welcome to the Date Planner app. Use this app to organize and plan a series of events, organized by date.": {
      "zh": "æ¬¢è¿ä½¿ç”¨ Date Planner åº”ç”¨ç¨‹åºã€‚ä½¿ç”¨è¯¥åº”ç”¨ç¨‹åºæ¥ç»„ç»‡å’Œè®¡åˆ’ä¸€ç³»åˆ—æŒ‰æ—¥æœŸæ’åˆ—çš„æ´»åŠ¨ã€‚",
      "tips": ""
    },
    "This walkthrough teaches you how to use lists and an observable data model to create dynamic lists of events and tasks. Time to jump in.": {
      "zh": "æœ¬æ¬¡è®²è§£æ•™ä½ å¦‚ä½•ä½¿ç”¨åˆ—è¡¨å’Œå¯è§‚å¯Ÿæ•°æ®æ¨¡å‹æ¥åˆ›å»ºäº‹ä»¶å’Œä»»åŠ¡çš„åŠ¨æ€åˆ—è¡¨ã€‚è®©æˆ‘ä»¬å¼€å§‹å§ã€‚",
      "tips": ""
    },
    "App Configuration": {
      "zh": "åº”ç”¨é…ç½®",
      "tips": ""
    },
    "Learn how the app shares data with its views by creating a single data object and making it available to the entire view hierachy.": {
      "zh": "äº†è§£åº”ç”¨ç¨‹åºå¦‚ä½•é€šè¿‡åˆ›å»ºä¸€ä¸ªå•ä¸€çš„æ•°æ®å¯¹è±¡ï¼Œå¹¶ä¸”è®©æ•´ä¸ªè§†å›¾å±‚æ¬¡ç»“æ„å¯ä»¥å…±äº«æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "To navigate between different views in your app, create a NavigationView as the top-level view in your view hierarchy, inserting the appâ€™s home view. For this app, EventList is that home view and the first view the app displays when it launches.": {
      "zh": "è¦åœ¨ä½ çš„åº”ç”¨ç¨‹åºä¸­å¯¼èˆªåˆ°ä¸åŒè§†å›¾ï¼Œåˆ›å»ºä¸€ä¸ª NavigationViewï¼Œä½œä¸ºå®ƒä»¬çš„é¡¶å±‚è§†å›¾ï¼Œåœ¨è§†å›¾å±‚æ¬¡ç»“æ„ä¸­æ’å…¥åº”ç”¨ç¨‹åºçš„ä¸»é¡µè§†å›¾ã€‚å¯¹äºæ­¤åº”ç”¨ç¨‹åºï¼ŒEventList æ˜¯å®ƒçš„ä¸»é¡µè§†å›¾ï¼Œä¹Ÿå°±æ˜¯åº”ç”¨ç¨‹åºå¯åŠ¨æ—¶æ˜¾ç¤ºçš„ç¬¬ä¸€ä¸ªè§†å›¾ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "In wider app configurations, such full-screen landscape on an iPad, SwiftUI displays the NavigationView content as multiple adjacent columns, rather than a single stack. In this layout, your EventList displays in a sidebar column, and its destination content appears in the primary pane.": {
      "zh": "åœ¨æ›´åŠ å¹¿æ³›çš„åº”ç”¨ç¨‹åºé…ç½®ä¸­ï¼Œå¦‚ iPad ä¸Šçš„å…¨å±ï¼ŒSwiftUI å°†å†…å®¹åˆ†ä¸ºå¤šä¸ªç›¸é‚»çš„åˆ—ï¼Œè€Œä¸æ˜¯å•ä¸ªå †æ ˆã€‚åœ¨è¿™ç§å¸ƒå±€ä¸­ï¼Œäº‹ä»¶åˆ—è¡¨æ˜¾ç¤ºåœ¨ä¾§è¾¹æ åˆ—ï¼Œå¹¶ä¸”ç›®æ ‡å†…å®¹æ˜¾ç¤ºåœ¨ä¸»è¦è§†å›¾ä¸­ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "Adding a Text view is a useful way to give the second column a placeholder view until a person selects an event in the list. When a person selects an event, the app replaces the placeholder view with an EventDetail view.": {
      "zh": "æ·»åŠ  Text è§†å›¾æ˜¯ä¸€ç§æœ‰ç”¨çš„æ–¹æ³•æ¥ç»™ç¬¬äºŒåˆ—æ·»åŠ å ä½è§†å›¾ï¼Œç›´åˆ°ç”¨æˆ·é€‰æ‹©åˆ—è¡¨ä¸­çš„äº‹ä»¶ã€‚å½“ç”¨æˆ·é€‰æ‹©æŸä¸ªäº‹ä»¶æ—¶ï¼Œåº”ç”¨ç¨‹åºå°†å ä½è§†å›¾æ›¿æ¢ä¸º EventDetail è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "The app stores its data using the variable eventData. Itâ€™s defined with the @StateObject property wrapper to create an instance of an observable object, EventData. Because this object is observable, SwiftUI watches it to keep track of any changes to its values. Whenever the data changes, SwiftUI automatically updates all of the views that use (or observe) it.": {
      "zh": "åº”ç”¨ç¨‹åºä½¿ç”¨å˜é‡ eventData å­˜å‚¨å…¶æ•°æ®ã€‚ä½¿ç”¨ @StateObject å±æ€§åŒ…è£…å™¨å®šä¹‰æ­¤å¯¹è±¡ï¼Œä»¥åˆ›å»ºä¸€ä¸ªå¯è§‚å¯Ÿçš„å¯¹è±¡ EventDataã€‚ç”±äºè¯¥å¯¹è±¡æ˜¯å¯è§‚å¯Ÿçš„ï¼Œå› æ­¤ SwiftUI ç›‘è§†å®ƒä»¥è·Ÿè¸ªä»»ä½•å˜æ›´ï¼Œæ¯å½“æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶ï¼Œæ›´æ–°æ‰€æœ‰ä½¿ç”¨ï¼ˆæˆ–è§‚å¯Ÿï¼‰å®ƒçš„è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "To make eventData available to your entire view hierarchy, use the .environmentObject modifier and pass in the eventData instance. Now you can use this data across all of your navigation viewâ€™s child views (and their child views as well).": {
      "zh": "è¦ä½¿ eventData å¯ä»¥åœ¨æ‰€æœ‰çš„å¯¼èˆªè§†å›¾çš„å­è§†å›¾ä¸Šä½¿ç”¨ï¼Œä½¿ç”¨ .environmentObject å±æ€§ä¿®é¥°ç¬¦ä¼ å…¥ eventData å®ä¾‹ã€‚ç°åœ¨ä½ å¯ä»¥åœ¨æ‰€æœ‰çš„å¯¼èˆªè§†å›¾çš„å­è§†å›¾ä¸Šä½¿ç”¨è¯¥æ•°æ®ã€‚",
      "tips": ""
    },
    "Event Model": {
      "zh": "äº‹ä»¶æ¨¡å‹",
      "tips": ""
    },
    "Your event model holds all of the data needed to visualize and organize events in your list. Here youâ€™ll explore how to structure an Event.": {
      "zh": "ä½ çš„äº‹ä»¶æ¨¡å‹ä¿å­˜äº†éœ€è¦åœ¨åˆ—è¡¨ä¸­å‘ˆç°å’Œç»„ç»‡äº‹ä»¶çš„æ‰€æœ‰æ•°æ®ã€‚åœ¨è¿™é‡Œä½ å°†äº†è§£å¦‚ä½•ç»“æ„åŒ–ä¸€ä¸ªäº‹ä»¶ã€‚",
      "tips": ""
    },
    "To organize its data, Event planner uses a collection of Event objects, each of which represent a specific event, such as a camping trip or birthday party. By conforming to the Identifiable protocol, you ensure that when you create a list of events, SwiftUI can identify and update each row.": {
      "zh": "ä¸ºäº†ç»„ç»‡æ•°æ®ï¼ŒEvent planner ä½¿ç”¨ä¸€ä¸ªé›†åˆï¼Œæ¯ä¸ªäº‹ä»¶éƒ½ä»£è¡¨ä¸€æ¬¡äº‹ä»¶ï¼Œä¾‹å¦‚ä¸€ä¸ªéœ²è¥æ—…è¡Œæˆ–ç”Ÿæ—¥æ´¾å¯¹ã€‚é€šè¿‡ç¬¦åˆ Identifiable åè®®ï¼Œä½ ç¡®ä¿ SwiftUI å¯ä»¥è¯†åˆ«å’Œæ›´æ–°æ¯è¡Œã€‚",
      "tips": ""
    },
    "The Event type contains all of the information you need to populate an event, including a symbol, color, title, date, and collection of tasks. Each task is a specific to-do item for the event, such as â€œGet a camping lanternâ€œ.": {
      "zh": "Event ç±»åŒ…å«ä½ éœ€è¦å¡«å……äº‹ä»¶çš„æ‰€æœ‰ä¿¡æ¯ï¼ŒåŒ…æ‹¬ç¬¦å·ã€é¢œè‰²ã€æ ‡é¢˜ã€æ—¥æœŸå’Œä»»åŠ¡é›†åˆã€‚æ¯ä¸ªä»»åŠ¡æ˜¯äº‹ä»¶çš„å…·ä½“ä»£åŠäº‹é¡¹ï¼Œä¾‹å¦‚â€œæ‹¿ä¸€ä¸ªéœ²è¥ç¯â€œã€‚",
      "tips": ""
    },
    "Youâ€™ll also notice a list of computed properties for Event. These help people organize the sections of their lists based on the date and the number of tasks to complete.": {
      "zh": "ä½ è¿˜ä¼šæ³¨æ„åˆ°ä¸€ä¸ªè®¡ç®—å±æ€§åˆ—è¡¨ã€‚è¿™äº›å¸®åŠ©äººä»¬æ ¹æ®æ—¥æœŸå’Œä»»åŠ¡æ•°æ¥ç»„ç»‡åˆ—è¡¨çš„å„ä¸ªéƒ¨åˆ†ã€‚",
      "tips": ""
    },
    "For instance, the isPast property checks to see if the date property is less than Date.now, which is the current date and time. The property returns true when the event date is in the past, which allows people to sort any past events into their own category.": {
      "zh": "ä¾‹å¦‚ï¼ŒisPast å±æ€§æ£€æŸ¥ date æ˜¯å¦å°äºå½“å‰æ—¥æœŸå’Œæ—¶é—´ã€‚å½“äº‹ä»¶æ—¥æœŸæ˜¯è¿‡å»æ—¶é—´ï¼Œè¯¥å±æ€§è¿”å› trueï¼Œå®ƒå…è®¸äººä»¬å°†ä»»ä½•è¿‡å»çš„äº‹ä»¶åˆ†ç±»åˆ°è‡ªå·±çš„ç±»åˆ«ä¸­ã€‚",
      "tips": ""
    },
    "Take a moment to examine some of the other properties defined here. Can you figure out how they might help organize the list of events?": {
      "zh": "èŠ±ç‚¹æ—¶é—´æ£€æŸ¥ä¸€ä¸‹æ­¤å¤„å®šä¹‰çš„å…¶ä»–å±æ€§ã€‚ä½ èƒ½æƒ³åˆ°æ€æ ·å®ƒä»¬ä¼šæ€ä¹ˆæ ·å¸®åŠ©ç»„ç»‡åˆ—è¡¨çš„äº‹ä»¶å‘¢?",
      "tips": ""
    },
    "Event Task": {
      "zh": "äº‹ä»¶ä»»åŠ¡",
      "tips": ""
    },
    "An event task represents a to-do item for an event. Here, youâ€™ll learn how how to model the tasks.": {
      "zh": "æ—¶é—´ä»»åŠ¡è¡¨ç¤ºäº‹ä»¶çš„ä»£åŠäº‹é¡¹ã€‚åœ¨è¿™é‡Œï¼Œä½ å°†äº†è§£å¦‚ä½•ä¸ºä»»åŠ¡æ„å»ºæ¨¡å‹ã€‚",
      "tips": ""
    },
    "An EventTask represents one of a collection of to-do items for an event. Like Event, an EventTask is also Identifiable, which lets SwiftUI manage and update its appearance in a list.": {
      "zh": "EventTask è¡¨ç¤ºä¸€ä¸ªäº‹ä»¶çš„ä»£åŠäº‹é¡¹ã€‚ä¸ Event ç±»å‹ä¸€æ ·ï¼ŒEventTask æ˜¯ Identifiable åè®®ï¼Œè®© SwiftUI ç®¡ç†å’Œæ›´æ–°å®ƒåœ¨åˆ—è¡¨ä¸­çš„å¤–è§‚ã€‚",
      "tips": ""
    },
    "EventTask contains properties for text, completion state, and an isNew property. When a person marks a task as completed, you set isCompleted to true, which allows your app to track the remaining tasks for each event.": {
      "zh": "EventTask åŒ…å«æ–‡æœ¬ã€å®ŒæˆçŠ¶æ€å’Œ isNew å±æ€§ã€‚å½“ç”¨æˆ·å°†ä¸€ä¸ªä»»åŠ¡è®¾ä¸ºå·²å®Œæˆæ—¶ï¼Œä½ å°† isCompleted è®¾ç½®ä¸º trueï¼Œå®ƒå…è®¸ä½ çš„åº”ç”¨ç¨‹åºè·Ÿè¸ªæ¯ä¸ªäº‹ä»¶çš„å‰©ä½™ä»»åŠ¡ã€‚",
      "tips": ""
    },
    "Event Data": {
      "zh": "äº‹ä»¶æ•°æ®",
      "tips": ""
    },
    "You use the EventData observable object to populate the data in your event list. Here youâ€™ll learn how to structure and update the data.": {
      "zh": "ä½¿ç”¨ EventData å¯è§‚å¯Ÿå¯¹è±¡æ¥å¡«å……ä½ çš„äº‹ä»¶åˆ—è¡¨ã€‚åœ¨è¿™é‡Œä½ å°†äº†è§£å¦‚ä½•ç»“æ„åŒ–å’Œæ›´æ–°æ•°æ®ã€‚",
      "tips": ""
    },
    "This is the EventData type, which stores and modifies all of the events that your app displays in its UI. EventData conforms to the ObservableObject protocol, which means that if any of its published values change, SwiftUI notifies all observers (views using those values) and updates those views automatically.": {
      "zh": "è¿™æ˜¯ EventData ç±»å‹ï¼Œå®ƒå°†åŒ…å«æ‰€æœ‰ä½ æ˜¾ç¤ºåœ¨ UI ä¸­çš„äº‹ä»¶å­˜å‚¨å’Œä¿®æ”¹ã€‚EventData ç¬¦åˆ ObservableObject åè®®ï¼Œå› æ­¤å¦‚æœä»»ä½•è¢« @Publish ä¿®é¥°çš„å€¼æ”¹å˜ï¼ŒSwiftUI ä¼šé€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…å¹¶è‡ªåŠ¨æ›´æ–°å®ƒä»¬çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "EventData contains a property called events that stores a prepopulated array of Event values, such as game night or a doctorâ€™s appointment. By using the @Published property wrapper when defining this property, you instruct SwiftUI to notify all observers and update their views whenever the events array changes. This allows you to add and delete events from the array and see the change instantly in your UI.": {
      "zh": "EventData åŒ…å«ä¸€ä¸ªåä¸º events çš„å±æ€§ï¼Œè¯¥å±æ€§å­˜å‚¨é¢„å¡«å……çš„ Event æ•°ç»„ï¼Œä¾‹å¦‚æ¯”èµ›å¤œæˆ–è€…åŒ»ç”Ÿçš„é¢„çº¦ã€‚é€šè¿‡åœ¨å®šä¹‰æ­¤å±æ€§æ—¶ä½¿ç”¨ @Published å±æ€§ä¿®é¥°ç¬¦ï¼Œä½ å¯ä»¥æŒ‡ç¤º SwiftUI é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…å¹¶è‡ªåŠ¨æ›´æ–°å®ƒä»¬çš„è§†å›¾ï¼Œä»¥ä¾¿ä½ å¯ä»¥åœ¨æ•°ç»„ä¸­æ·»åŠ å’Œåˆ é™¤äº‹ä»¶å¹¶ç«‹å³çœ‹åˆ°æ”¹å˜ã€‚",
      "tips": ""
    },
    "EventData provides methods for adding and deleting events. In addition, sortedEvents(period:) returns an array of sorted events based on the requested time period. Use this method in EventList to create sections based upon the eventâ€™s date, such as Next 7 Days.": {
      "zh": "EventData æä¾›æ·»åŠ å’Œåˆ é™¤äº‹ä»¶çš„æ–¹æ³•ã€‚æ­¤å¤–ï¼ŒsortedEvents(period:) è¿”å›åŸºäºè¯·æ±‚çš„æ—¶é—´æ®µçš„æ’åºäº‹ä»¶æ•°ç»„ã€‚åœ¨ EventList ä¸­ä½¿ç”¨è¯¥æ–¹æ³•æ ¹æ®äº‹ä»¶çš„æ—¥æœŸåˆ›å»ºåˆ†ç»„ï¼Œä¾‹å¦‚â€œæ¥ä¸‹æ¥ 7 å¤©â€ã€‚",
      "tips": ""
    },
    "The Period enumeration provides each of the time categories that youâ€™ll use to sort the list. The categories are nextSevenDays, nextThirtyDays, future, and past.": {
      "zh": "Period æšä¸¾æä¾›äº†ä½ å°†ä½¿ç”¨æ¥æ’åºåˆ—è¡¨çš„å„ç§æ—¶é—´åˆ†ç±»ã€‚åˆ†åˆ«æ˜¯ nextSevenDaysï¼ˆä¸‹å‘¨ï¼‰, nextThirtyDaysï¼ˆä¸‹æœˆï¼‰, futureï¼ˆæœªæ¥ï¼‰, å’Œ pastï¼ˆè¿‡å»ï¼‰ã€‚",
      "tips": ""
    },
    "Event List": {
      "zh": "æ´»åŠ¨åˆ—è¡¨",
      "tips": ""
    },
    "Learn how to construct the primary UI for the app, the event list, using a List view.": {
      "zh": "äº†è§£å¦‚ä½•ä½¿ç”¨ List è§†å›¾æ„å»ºåº”ç”¨ç¨‹åºçš„ä¸»åˆ—è¡¨ç•Œé¢ã€‚",
      "tips": ""
    },
    "The EventList view creates a grouped listing of events using a List view.": {
      "zh": "EventList è§†å›¾ä½¿ç”¨ List è§†å›¾åˆ›å»ºä¸€ä¸ªåˆ†ç»„åˆ—è¡¨ã€‚",
      "tips": ""
    },
    "In DatePlannerApp, the top-level navigation view uses the .environmentObject modifier to pass in an instance of EventData, making it accessible to all of its child views. You can now access that data in this child view by declaring a variable with the @EnvironmentObject property wrapper and giving it the EventData type. You now have access to all of the prepopulated event data to create your list.": {
      "zh": "åœ¨ DataPlannerApp ä¸­ï¼Œæœ€å¤–å±‚å¯¼èˆªè§†å›¾ä½¿ç”¨ .environmentObject ä¿®é¥°ç¬¦ä¼ å…¥ EventData çš„å®ä¾‹ï¼Œä½¿å…¶å¯ç”¨äºæ‰€æœ‰å­è§†å›¾ã€‚ç°åœ¨ä½ å¯ä»¥åœ¨æ­¤å­è§†å›¾ä¸­è®¿é—®è¯¥æ•°æ®ï¼Œå¹¶å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œå®ƒçš„ç±»å‹æ˜¯ EventDataã€‚ç°åœ¨ä½ å¯ä»¥ä½¿ç”¨é¢„å…ˆå¡«å……çš„æ•°æ®æ¥åˆ›å»ºåˆ—è¡¨ã€‚",
      "tips": ""
    },
    "To make your list, create a List view and use a ForEach loop to iterate over all of the time periods (nextSevenDays, nextThirtyDays, future, and past).": {
      "zh": "è¦åˆ›å»ºåˆ—è¡¨ï¼Œåˆ›å»º List è§†å›¾å¹¶ä½¿ç”¨ ForEach å¾ªç¯è¿­ä»£æ‰€æœ‰æ—¶é—´æ®µ(ä¸‹å‘¨ï¼Œä¸‹æœˆï¼Œæœªæ¥å’Œè¿‡å»)ã€‚",
      "tips": ""
    },
    "Next, check that the current time period contains at least one event, otherwise, donâ€™t show any data for it.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œæ£€æŸ¥å½“å‰æ—¶é—´æ®µè‡³å°‘åŒ…å«ä¸€ä¸ªäº‹ä»¶ï¼Œå¦åˆ™ä¸æ˜¾ç¤ºä»»ä½•æ•°æ®ã€‚",
      "tips": ""
    },
    "When you know there are events in a section, create a Section view and use ForEach to iterate over all events in that time period. Use the method sortedEvents(period:) from EventData to return the events specific to the sectionâ€™s time range.": {
      "zh": "å½“ä½ çŸ¥é“åœ¨æŸä¸ªæ—¶é—´æ®µä¸­æœ‰äº‹ä»¶æ—¶ï¼Œåˆ›å»º Section è§†å›¾å¹¶ä½¿ç”¨ ForEach è¿­ä»£æ‰€æœ‰äº‹ä»¶ã€‚ä½¿ç”¨ EventData çš„æ–¹æ³• sortedEvents(period:) æ¥è¿”å›ç‰¹å®šäºæ—¶é—´æ®µçš„äº‹ä»¶ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "Inside the ForEach, create the EventRow views for each event in the time period. To do this, use a NavigationLink, then add an EventRow as the label (the part that you see), and an EventEditor as the destination (the part you navigate to when tapped). The event editor is where youâ€™ll see all the tasks for each event and edit the event details.": {
      "zh": "åœ¨ ForEach å†…ï¼Œä¸ºè¯¥æ—¶é—´æ®µå†…çš„æ¯ä¸ªäº‹ä»¶éƒ½åˆ›å»ºä¸€ä¸ª EventRow è§†å›¾ï¼Œç„¶åæ·»åŠ ä¸€ä¸ª EventRow ä½œä¸ºæ ‡ç­¾å’Œä¸€ä¸ª EventEditor ä½œä¸ºç›®çš„åœ°(ç‚¹å‡»è·³è½¬)ã€‚ä½ å¯ä»¥åœ¨æ´»åŠ¨ç¼–è¾‘å™¨ä¸­æŸ¥çœ‹æ¯ä¸ªæ´»åŠ¨çš„æ‰€æœ‰ä»»åŠ¡å¹¶ç¼–è¾‘æ´»åŠ¨è¯¦ç»†ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ä¸ƒæ­¥",
      "tips": ""
    },
    "To delete events, add the modifier .swipeActions on the event row and define a button that calls the delete method from EventData. You can now swipe on an event and tap the delete button to remove the current event.": {
      "zh": "è¦åˆ é™¤äº‹ä»¶ï¼Œä¸ºäº‹ä»¶è¡Œæ·»åŠ  .swipeActions ä¿®é¥°ç¬¦å¹¶å®šä¹‰ä¸€ä¸ªæŒ‰é’®ï¼Œå®ƒè°ƒç”¨ EventData çš„ delete æ–¹æ³•ã€‚ç°åœ¨ä½ å¯ä»¥åœ¨äº‹ä»¶è¡Œä¸­æ»‘åŠ¨å¹¶ç‚¹å‡»åˆ é™¤æŒ‰é’®æ¥åˆ é™¤å½“å‰äº‹ä»¶ã€‚",
      "tips": ""
    },
    "Organizing with Grids": {
      "zh": "ç”¨ç½‘æ ¼ç»„ç»‡å±•ç¤ºæ•°æ®",
      "tips": ""
    },
    "Display visual content in an arrangement of rows and columns.": {
      "zh": "ä»¥ç½‘æ ¼å½¢å¼å±•ç¤ºå†…å®¹",
      "tips": ""
    }
  },
  "sample-apps/editinggrids": {
    "To display the views for editing or adding a symbol, simply toggle the associated value to true using a toolbar button.": {
      "zh": "",
      "tips": ""
    },
    "Before diving into SymbolGrid, take a look at an example of the data used to populate it. SymbolDetail is a view that uses a property, symbol, to create an image view using an SF Symbol.": {
      "zh": "",
      "tips": ""
    },
    "After you have an image view, you can use modifiers to change how the view looks and behaves. Modifiers in SwiftUI are methods called on a view one after another, but they are arranged vertically on separate lines in your code to make the code more readable. Try changing the .foregroundColor or .symbolRenderingMode modifiers to see how the preview changes.": {
      "zh": "",
      "tips": ""
    },
    "Editing Grids": {
      "zh": "",
      "tips": ""
    },
    "To add a new symbol, the app displays a sheet when isAddingSymbol is true, and that sheet displays the SymbolPicker view. When you dismiss the sheet, addSymbol adds the selected symbol to the grid.": {
      "zh": "",
      "tips": ""
    },
    "Image Gallery": {
      "zh": "",
      "tips": ""
    },
    "Another feature is an editing mode, allowing you to edit the data in your app. Here youâ€™ll learn how to add editing functionality to a grid, including adding and removing grid items.": {
      "zh": "",
      "tips": ""
    },
    "These views are deeply nested. You have an image view inside of a ZStack, inside of a NavigationLink, inside of a ForEach, inside a LazyVGrid, inside a ScrollView. SwiftUI uses composable view elements as building blocks to create the functionality of a dynamic interface. Take a second to think of how changing the order of these views might change the functionality of the grid.": {
      "zh": "",
      "tips": ""
    },
    "Creating the Navigation for Your App": {
      "zh": "",
      "tips": ""
    },
    "To make it easy for people to move around in your app, you need to provide a way for them to navigate between different views. For Editing Grids, youâ€™ll configure the app so people can tap a symbol in the grid to switch views.": {
      "zh": "",
      "tips": ""
    },
    "Let people edit data that your app displays.": {
      "zh": "",
      "tips": ""
    },
    "There are several places in the body where youâ€™ll see isEditing checked with conditional code. This allows you to show the enclosed UI only if isEditing is true. Using these conditional checks, you can create an editing UI within the same view as the grid itself. Again, because isEditing is a @State variable, SwiftUI updates GridView to automatically display or hide the conditional views when that value changes.": {
      "zh": "",
      "tips": ""
    },
    "Step 6": {
      "zh": "",
      "tips": ""
    },
    "To create a grid, use a LazyVGrid. This is a container that lays out views in a grid shape. However, you also want to nest the LazyVGrid inside a ScrollView, so you can scroll through content if it exceeds the vertical space of the grid view.": {
      "zh": "",
      "tips": ""
    },
    "In Organizing with Grids, you learned how to lay out your appâ€™s interface using a grid of colored rectangles. In this sample, youâ€™ll create a similar grid interface populated with SF Symbols. To build on what youâ€™ve learned, Editing Grids takes your app to the next level by teaching you about two important features in app design: navigating within your app, and making it possible for people to edit data that they store in the app.": {
      "zh": "",
      "tips": ""
    },
    "There are multiple ways to create an Image in SwiftUI. One way is to use the argument systemName, which creates an image using the SF Symbol associated with the string passed in.": {
      "zh": "",
      "tips": ""
    },
    "To create the grid of SF Symbols, youâ€™ll set up SymbolGrid with a variable, symbols, to track a collection of Symbol instances for the various symbols. When you mark this variable with @State, SwiftUI manages the storage for the value. Whenever this state value changes, SwiftUI updates any views using the value (the grid, in this case). For instance, if you deleted a symbol, the corresponding symbol image disappears from the grid.": {
      "zh": "",
      "tips": ""
    },
    "Learn how to create data that is uniquely identifiable in SwiftUI.": {
      "zh": "",
      "tips": ""
    },
    "Explore how to add navigation to your app using a NavigationStack.": {
      "zh": "",
      "tips": ""
    },
    "Step 3": {
      "zh": "",
      "tips": ""
    },
    "Step 4": {
      "zh": "",
      "tips": ""
    },
    "Explore how to add editing functionality to your grid, including the ability to add or delete items.": {
      "zh": "",
      "tips": ""
    },
    "The name property contains a String value that corresponds to an SF Symbol. You use the value of name to create the Image views in your grid.": {
      "zh": "",
      "tips": ""
    },
    "After ForEach, youâ€™ll create image views for each symbol in the grid. Create the image view using the name of the symbol, and wrap the image in a NavigationLink. This turns the view into a button that links to the destination view, SymbolDetail, when tapped or clicked. When this happens, the top-level navigation stack displays SymbolDetail, and provides a link to navigate back to SymbolGrid.": {
      "zh": "",
      "tips": ""
    },
    "This code defines your app, SymbolGridApp. Any time you define an app in SwiftUI, you must also provide at least one view inside WindowGroup of the app body property. This view is known as the top-level view, because it sits on the top of your view hierarchy. You can think of the view hierarchy as a structure that defines the layout of views relative to other views. The top-level view may contain any number of subviews, each of which may contain their own subviews, and so on.": {
      "zh": "",
      "tips": ""
    },
    "Adding an Editing Mode": {
      "zh": "",
      "tips": ""
    },
    "The argument to SymbolPicker ($selectedSymbol) is a special type of value, known as a binding. When you pass a binding value into a subview, that subview can modify its value, but only the parent view stores the actual value. Passing selectedSymbol as an argument allows SymbolPicker to modify the value, which modifies the variable selectedSymbolName stored in SymbolGrid.": {
      "zh": "",
      "tips": ""
    },
    "Creating a Symbol": {
      "zh": "",
      "tips": ""
    },
    "To populate the grid, use ForEach to iterate over each uniquely identifiable Symbol in symbols. ForEach usually requires that you provide an ID for each element of the collection so itâ€™s able to track when specific elements in the collection change. However, since Symbol conforms to Identifiable, this requirement has been fulfilled and you no longer need the id parameter. Because you are using the @State variable symbols as the argument to ForEach, the entire grid updates any time the array changes.": {
      "zh": "",
      "tips": ""
    },
    "Building the Navigation Grid": {
      "zh": "",
      "tips": ""
    },
    "Step 1": {
      "zh": "",
      "tips": ""
    },
    "To arrange several views vertically, you can put them inside of a VStack, which is short for vertical stack. In this VStack, thereâ€™s a text view layered on top of the image view with the SF Symbol.": {
      "zh": "",
      "tips": ""
    },
    "When the sheet dismisses, addSymbol inserts the value assigned to selectedSymbol to the symbols array. Because symbols is a @State variable, SwiftUI recognizes the change and updates the grid UI with the new symbol.": {
      "zh": "",
      "tips": ""
    },
    "Retrieve and display images from an asset catalog or a photo library.": {
      "zh": "",
      "tips": ""
    },
    "You populate the grid with many Image views, each created from a Symbol instance such as Symbol(name: \"eyes\"). Because the Symbol type conforms to Identifiable, SwiftUI can uniquely identify each cell of your grid, even if several symbols use the same name value. Adding Identifiable conformance to your data model is a great pattern to follow when using ForEach to populate a grid or list with views.": {
      "zh": "",
      "tips": ""
    },
    "By creating an instance of SymbolGrid inside of your navigation stack, you tell the navigation stack to display SymbolGrid when the app first launches. When a person using your app navigates to another view, SymbolGrid moves down in the view hierarchy to show a different view and its content.": {
      "zh": "",
      "tips": ""
    },
    "To provide navigation functionality in your app, you can create a NavigationStack as your top-level view. The NavigationStack acts as a container that can show any other view. The NavigationStack provides a stack style rather than a column style. This means only a single view displays at any given time.": {
      "zh": "",
      "tips": ""
    },
    "Create a grid of SF Symbols from an array of Symbol values.": {
      "zh": "",
      "tips": ""
    },
    "Learn how to create an image view using an SF Symbol.": {
      "zh": "",
      "tips": ""
    },
    "Defining an Identifiable Type": {
      "zh": "",
      "tips": ""
    },
    "Step 2": {
      "zh": "",
      "tips": ""
    },
    "Now that you have a grid, itâ€™s time to add editing functionality. The first thing to notice here are two @State variables, isAddingSymbol and isEditing. These are Boolean values that, when true, change some of UI of the app to enable you to edit or add photos to the grid.": {
      "zh": "",
      "tips": ""
    },
    "Step 5": {
      "zh": "",
      "tips": ""
    },
    "Your Symbol type contains an id property â€” a requirement of the Identifiable protocol. To ensure that each item is uniquely identifiable, set the id property to a UUID value.": {
      "zh": "",
      "tips": ""
    },
    "At the bottom of the view, youâ€™ll see two modifiers: navigationTitle, which sets the title of the navigation stack, and navigationBarTitleDisplayMode, which determines how to display the title. In this case, the display mode is inline, meaning the title shows in line with the rest of the toolbar at the top of the view.": {
      "zh": "",
      "tips": ""
    }
  },
  "sample-apps/getstartedwithmachinelearning-createmldataset": {
    "Creating Your Own Machine Learning Dataset": {
      "zh": "åˆ›å»ºä½ è‡ªå·±çš„æœºå™¨å­¦ä¹ æ•°æ®é›†",
      "tips": ""
    },
    "Learn how to create a dataset for your own machine learning model.": {
      "zh": "äº†è§£å¦‚ä½•ä¸ºä½ è‡ªå·±çš„æœºå™¨å­¦ä¹ æ¨¡å‹åˆ›å»ºæ•°æ®é›†ã€‚",
      "tips": ""
    },
    "Collect and organize data for your model": {
      "zh": "æ”¶é›†å¹¶æ•´ç†ä½ çš„æ¨¡å‹éœ€è¦çš„æ•°æ®",
      "tips": ""
    },
    "Tips for creating your own dataset.": {
      "zh": "ä¸€äº›å…³äºåˆ›å»ºä½ è‡ªå·±æ¨¡å‹çš„å°æç¤º",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "Computers are great at detecting data patterns when given enough examples. To create a hand pose machine learning (ML) model, youâ€™ll need several images of hands.": {
      "zh": "åªè¦æœ‰è¶³å¤Ÿå¤šçš„ä¾‹å­ï¼Œè®¡ç®—æœºå°±èƒ½å¾ˆå¥½åœ°è¯†åˆ«è¿™äº›æ•°æ®çš„å½¢å¼ã€‚è¦åˆ›å»ºæ‰‹åŠ¿æœºå™¨å­¦ä¹  (ML) æ¨¡å‹ï¼Œä½ éœ€è¦å¤šå¼ å…³äºæ‰‹çš„å›¾åƒã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "In Swift Playgrounds, youâ€™ll be able to gather images of hand poses and label them to your gameâ€™s moves: Rock âœŠ, Paper âœ‹, and Scissors âœŒï¸. These labeled images are the only examples that the machineâ€™s â€œbrainâ€ has ever seen, so make sure theyâ€™re representative of what each hand pose looks like.": {
      "zh": "åœ¨ Swift Playgrounds ä¸­ï¼Œä½ å°†èƒ½å¤Ÿæ”¶é›†æ‰‹åŠ¿å›¾åƒå¹¶å°†å®ƒä»¬æ ‡è®°ä¸ºä½ çš„çŸ³å¤´å‰ªåˆ€å¸ƒæ¸¸æˆé‡Œé¢çš„æ‰‹åŠ¿: çŸ³å¤´ âœŠï¼Œå¸ƒ âœ‹å’Œå‰ªåˆ€ âœŒï¸ã€‚è¿™äº›è¢«æ ‡è®°çš„å›¾åƒæ˜¯æœºå™¨â€œå¤§è„‘â€è§è¿‡çš„å”¯ä¸€ä¾‹å­ï¼Œæ‰€ä»¥è¦ç¡®ä¿å®ƒä»¬ä»£è¡¨äº†æ¯ä¸ªæ‰‹çš„å§¿åŠ¿ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "ML engineers often need to examine their datasets to ensure they always contain the best possible sources to return quality results. This process is called data cleaning, and itâ€™s one of the most important steps in ML since it dramatically affects how your ML model performs.": {
      "zh": "æœºå™¨å­¦ä¹ å·¥ç¨‹å¸ˆç»å¸¸éœ€è¦æ£€æŸ¥ä»–ä»¬çš„æ•°æ®é›†ï¼Œç¡®ä¿ä»–ä»¬æ€»æ˜¯åŒ…å«æœ€å¥½çš„æ•°æ®ï¼Œä»¥ä¿è¯é«˜è´¨é‡çš„ç»“æœã€‚è¿™ä¸ªè¿‡ç¨‹è¢«ç§°ä¸ºæ•°æ®æ¸…ç†ï¼Œå®ƒæ˜¯ ML ä¸­æœ€é‡è¦çš„æ­¥éª¤ä¹‹ä¸€ï¼Œå› ä¸ºå®ƒä¼šæå¤§åœ°å½±å“æ‚¨çš„ ML æ¨¡å‹çš„è¡¨ç°ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®è·µ",
      "tips": ""
    },
    "Clean your dataset to ensure that the image contains a hand pose, that the pose isnâ€™t too close to or far from the camera, that images arenâ€™t mislabeled (like a Rock image accidentally labeled as Scissors), that the dataset doesnâ€™t include any exact duplicate images, and that the dataset contains (roughly) equal amounts of images for each hand gesture.": {
      "zh": "æ¸…ç†ä½ çš„æ•°æ®é›†ï¼Œç¡®ä¿å›¾åƒä¸­åŒ…å«æ‰‹çš„å§¿åŠ¿ï¼Œå§¿åŠ¿ä¸ä¼šç¦»æ‘„åƒå¤´å¤ªè¿‘æˆ–å¤ªè¿œï¼Œå›¾åƒä¸ä¼šè¢«é”™è¯¯æ ‡è®°ï¼ˆå¦‚ \"çŸ³å¤´ \"å›¾åƒè¢«æ„å¤–æ ‡è®°ä¸º \"å‰ªåˆ€ \"ï¼‰ï¼Œæ•°æ®é›†ä¸­ä¸åŒ…å«ä»»ä½•å®Œå…¨é‡å¤çš„å›¾åƒï¼Œå¹¶ä¸”æ•°æ®é›†ä¸­æ¯ä¸ªæ‰‹åŠ¿åŒ…å«çš„å›¾åƒæ•°é‡ï¼ˆå¤§è‡´ï¼‰ç›¸ç­‰ã€‚",
      "tips": ""
    },
    "Increase the size of your training dataset artificially": {
      "zh": "äººä¸ºå¢åŠ è®­ç»ƒæ•°æ®é›†çš„å¤§å°",
      "tips": ""
    },
    "Automatically add image rotation, translation, and flipping to your training dataset.": {
      "zh": "åœ¨è®­ç»ƒæ•°æ®é›†ä¸­è‡ªåŠ¨æ·»åŠ å›¾åƒæ—‹è½¬ã€å¹³ç§»å’Œç¿»è½¬ã€‚",
      "tips": ""
    },
    "Adding in these options before a training session creates four new images per option you use. For example, using the .rotate option generates four new images and applies a random rotation angle to the new images.": {
      "zh": "åœ¨è®­ç»ƒä¹‹å‰æ·»åŠ ä¸€äº›é€‰é¡¹ï¼Œæ¯ä¸ªé€‰é¡¹éƒ½ä¼šç”Ÿæˆå››ä¸ªæ–°å›¾åƒã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨ .rotate é€‰é¡¹ä¼šç”Ÿæˆå››ä¸ªæ–°å›¾åƒï¼Œè¿™äº›æ–°å›¾åƒä¼šè¢«éšæœºæ—‹è½¬è§’åº¦ã€‚",
      "tips": ""
    },
    "Here, the trainer is augmenting the training data by adding these three options: .rotate, .translate, .horizontallyFlip. When you train a new ML model, the training session automatically uses these augmentations to improve the modelâ€™s predictions.": {
      "zh": "åœ¨è¿™é‡Œï¼Œè®­ç»ƒå™¨é€šè¿‡æ·»åŠ ä»¥ä¸‹ä¸‰ä¸ªé€‰é¡¹æ¥å¢å¼ºè®­ç»ƒæ•°æ®ï¼š.rotateã€.translate å’Œ .horizontallyFlipã€‚å½“ä½ è®­ç»ƒä¸€ä¸ªæ–°çš„ ML æ¨¡å‹æ—¶ï¼Œä¼šè‡ªåŠ¨ä½¿ç”¨è¿™äº›å¢å¼ºæ¥æ”¹è¿›æ¨¡å‹çš„é¢„æµ‹ã€‚",
      "tips": ""
    },
    "Collect your own dataset in Swift Playgrounds": {
      "zh": "åœ¨ Swift Playgrounds ä¸­æ”¶é›†è‡ªå·±çš„æ•°æ®é›†",
      "tips": ""
    },
    "Now that youâ€™ve learned how to collect datasets for ML models, try it yourself by going to the Swift Playgrounds App to collect images and create a dataset for use with your own personalized ML model!": {
      "zh": "ç°åœ¨ï¼Œä½ å·²ç»å­¦ä¼šäº†å¦‚ä½•æ”¶é›†ç”¨äº ML æ¨¡å‹è®­ç»ƒçš„æ•°æ®é›†ï¼Œé‚£ä¹ˆç°åœ¨ä½ å¯ä»¥äº²è‡ªå°è¯•ä¸€ä¸‹ï¼Œåˆ° Swift Playgrounds åº”ç”¨ç¨‹åºä¸­æ”¶é›†å›¾åƒå¹¶åˆ›å»ºä¸€ä¸ªæ•°æ®é›†ï¼Œå¹¶ç”¨äºåˆ›å»ºä½ è‡ªå·±çš„ä¸ªæ€§åŒ– ML æ¨¡å‹ï¼",
      "tips": ""
    },
    "If you donâ€™t plan to use dozens of images to train the model, thatâ€™s OK. One way you can increase your training dataset is by using MLImageClassifier.ImageAugmentationOptions.": {
      "zh": "å¦‚æœä½ ä¸æ‰“ç®—ä½¿ç”¨å‡ åå¼ å›¾åƒæ¥è®­ç»ƒæ¨¡å‹ï¼Œä¹Ÿæ²¡å…³ç³»ã€‚å¢åŠ è®­ç»ƒæ•°æ®é›†çš„ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨å›¾åƒå¢å¼ºé€‰é¡¹ã€‚",
      "tips": ""
    }
  },
  "sample-apps/getstartedwithmachinelearning-debugmlmodel": {
    "Debugging Your Machine Learning Model": {
      "zh": "è°ƒè¯•æ‚¨çš„æœºå™¨å­¦ä¹ æ¨¡å‹",
      "tips": ""
    },
    "Learn how to debug your machine learning model and make improvements in its predictions.": {
      "zh": "å­¦ä¹ å¦‚ä½•è°ƒè¯•ä½ çš„æœºå™¨å­¦ä¹ æ¨¡å‹å¹¶æ”¹è¿›å…¶é¢„æµ‹ç»“æœã€‚",
      "tips": ""
    },
    "See what your camera sees by drawing an overlay of nodes": {
      "zh": "é€šè¿‡ç»˜åˆ¶ç»˜åˆ¶èŠ‚ç‚¹å åŠ å›¾ï¼Œæ´å¯Ÿä½ çš„ç›¸æœºçœ‹åˆ°äº†ä»€ä¹ˆ",
      "tips": ""
    },
    "Visualize the 2D array of nodes extracted by the Vision framework.": {
      "zh": "å°†ç”±Vision æ¡†æ¶æå–çš„ 2D èŠ‚ç‚¹æ•°ç»„å¯è§†åŒ–ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "Itâ€™s helpful to get more insight into the data that your machine learning (ML) model uses to generate its predictions to understand what your camera â€œseesâ€.": {
      "zh": "ç†è§£æ‘„åƒæœº \"çœ‹åˆ°\" äº†ä»€ä¹ˆæœ‰åŠ©äºæ›´æ·±å…¥åœ°äº†è§£é‚£äº›æœºå™¨å­¦ä¹  (ML) æ¨¡å‹ç”¨äºç”Ÿæˆé¢„æµ‹è€Œä½¿ç”¨çš„æ•°æ®",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "To create this visualization, youâ€™ll take the MLMultiArray that Vision extracts from an image frame and transform it into coordinates overlayed on top of your cameraâ€™s viewfinder.": {
      "zh": "ä¸ºäº†å®ç°è¿™äº›å¯è§†åŒ–ï¼Œä½ éœ€è¦ä½¿ç”¨ Vision ä»å›¾ç‰‡ä¸­æå–å‡ºæ¥çš„ MLMultiArrayï¼Œå¹¶å°†å…¶åæ ‡ç³»è½¬æ¢ä¸ºä½ çš„ç›¸æœºå–æ™¯å™¨ç•Œé¢çš„åæ ‡ç³»ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "This overlay in your ViewFinderView code to shows the node visualization when showNodes is true.": {
      "zh": "è¿™ä¸ªåœ¨ä½  ViewFinderView ä»£ç ä¸­çš„ overlay ä¼šåœ¨ showNodes ä¸º true çš„æ—¶å€™æ˜¾ç¤ºèŠ‚ç‚¹å¯è§†åŒ–ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®è·µ",
      "tips": ""
    },
    "Cover part of your hand with something close by â€” like a piece of paper, a book, or a piece of cloth â€” and place your partially-covered hand in front of the camera. What happens with the accuracy of the prediction for that hand pose?.": {
      "zh": "ç”¨é™„è¿‘çš„ä¸œè¥¿ç›–ä½ä½ çš„æ‰‹çš„ä¸€éƒ¨åˆ†â€”â€”æ¯”å¦‚ä¸€å¼ çº¸ã€ä¸€æœ¬ä¹¦æˆ–ä¸€å—å¸ƒâ€”â€”ç„¶åæŠŠä½ é‚£éƒ¨åˆ†è¢«ç›–ä½çš„æ‰‹æ”¾åœ¨ç›¸æœºå‰ï¼Œçœ‹çœ‹æ‰‹éƒ¨å§¿åŠ¿çš„é¢„æµ‹å‡†ç¡®åº¦ä¼šæ€æ ·?",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "Learn how to handle these low-ranking predictions in the next section!": {
      "zh": "åœ¨ä¸‹ä¸€èŠ‚ä¸­äº†è§£å¦‚ä½•å¤„ç†è¿™äº›ä¸å¤ªå‡†çš„é¢„æµ‹!",
      "tips": ""
    },
    "Test your ML model": {
      "zh": "æµ‹è¯•ä½ çš„ ML æ¨¡å‹",
      "tips": ""
    },
    "Ensure your machine learning model is identifying the different hand poses by testing it.": {
      "zh": "é€šè¿‡æµ‹è¯•ç¡®ä¿æœºå™¨å­¦ä¹ æ¨¡å‹èƒ½å¤Ÿè¯†åˆ«ä¸åŒçš„æ‰‹éƒ¨å§¿åŠ¿ã€‚",
      "tips": ""
    },
    "You can use DebugModeView to evaluate and debug your ML model.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ DebugModeView æ¥è¯„ä¼°å’Œè°ƒè¯•ä½ çš„ ML æ¨¡å‹ã€‚",
      "tips": ""
    },
    "Show a hand pose to the camera and then slowly transition to a different hand pose. How does the bar chart change?": {
      "zh": "å‘é•œå¤´å±•ç¤ºä½ çš„æ‰‹åŠ¿ï¼Œç„¶åæ…¢æ…¢è½¬æ¢åˆ°ä¸€ä¸ªä¸åŒçš„æ‰‹åŠ¿ï¼Œè§‚å¯Ÿæ¡å½¢å›¾æœ‰ä»€ä¹ˆå˜åŒ–ï¼Ÿ",
      "tips": ""
    },
    "As you debug the model, youâ€™ll discover that some camera conditions â€” like lighting, angle, and focus â€” also influence your modelâ€™s predictions.": {
      "zh": "åœ¨è°ƒè¯•æ¨¡å‹çš„è¿‡ç¨‹ä¸­ï¼Œä½ ä¼šå‘ç°ä¸€äº›ç›¸æœºæ¡ä»¶ï¼ˆå¦‚å…‰çº¿ã€è§’åº¦å’Œç„¦è·ï¼‰ä¹Ÿä¼šå½±å“æ¨¡å‹çš„é¢„æµ‹ç»“æœã€‚",
      "tips": ""
    },
    "Your model also might work well for you, but not as well for a friend. This can also be the result of overfitting. For instance, your ML model could better recognize one skin tone over another, causing some hand poses to be more accurately predicted than some in other skin tones. This is known as bias, because it favors one type of information over another.": {
      "zh": "ä½ çš„æ¨¡å‹ä¹Ÿå¯èƒ½å¯¹ä½ éå¸¸æœ‰æ•ˆï¼Œä½†å¯¹ä½ çš„æœ‹å‹å¯èƒ½å°±ä¸ä¸€æ ·äº†ã€‚è¿™å¯èƒ½æ˜¯è¿‡åº¦æ‹Ÿåˆçš„ç»“æœã€‚ä¾‹å¦‚ï¼Œæ‚¨çš„ ML æ¨¡å‹å¯ä»¥æ›´å¥½åœ°è¯†åˆ«ä¸€ç§è‚¤è‰²è€Œä¸æ˜¯å¦ä¸€ç§è‚¤è‰²ï¼Œä»è€Œå¯¼è‡´å¯¹æŸäº›è‚¤è‰²çš„æ‰‹åŠ¿é¢„æµ‹æ¯”å¯¹å…¶ä»–è‚¤è‰²çš„é¢„æµ‹æ›´å‡†ç¡®ã€‚è¿™å°±æ˜¯æ‰€è°“çš„åè§æˆ–åå·®ï¼Œå› ä¸ºå®ƒåå‘äºä¸€ç§ä¿¡æ¯è€Œä¸æ˜¯å¦ä¸€ç§ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Your model only affects this app, but what if you were implementing this app on every iPhone around the world? Unfair bias due to overfitting is a serious problem in systems meant for use by everyone. Itâ€™s important to think about how to avoid bias when creating your own datasets and training your ML model.": {
      "zh": "ä½ å¦‚æœä»¥ä¸ºä½ çš„æ¨¡å‹åªä¼šå½±å“åˆ°è¿™ä¸ªåº”ç”¨é‚£å°±å¤§é”™ç‰¹é”™äº†ã€‚å¦‚æœå…¨ä¸–ç•Œæ‰€æœ‰ iPhone ä¸Šéƒ½ä½¿ç”¨è¿™ä¸ªåº”ç”¨ç¨‹åºå‘¢ï¼Ÿåœ¨ç»™æ‰€æœ‰äººä½¿ç”¨çš„ç³»ç»Ÿä¸­ï¼Œè¿‡åº¦æ‹Ÿåˆé€ æˆçš„ä¸å…¬å¹³åå·®å’Œåè§æ˜¯ä¸€ä¸ªä¸¥é‡çš„é—®é¢˜ã€‚åœ¨åˆ›å»ºè‡ªå·±çš„æ•°æ®é›†å’Œè®­ç»ƒ ML æ¨¡å‹æ—¶ï¼Œä½ éœ€è¦è€ƒè™‘å¦‚ä½•é¿å…è¿™äº›åå·®å’Œåè§ï¼Œè¿™ä¸€ç‚¹æ˜¯æ— æ¯”é‡è¦çš„ã€‚",
      "tips": ""
    },
    "Tip": {
      "zh": "æç¤º",
      "tips": ""
    },
    "Remember that ML model development is an iterative process. Create multiple datasets and train more ML models! Only you can decide when your model is good enough for use in your app.": {
      "zh": "è¯·è®°ä½ï¼ŒML æ¨¡å‹å¼€å‘æ˜¯ä¸€ä¸ªä¸åœè¿­ä»£çš„è¿‡ç¨‹ã€‚æ‰€ä»¥å¤šåˆ›å»ºå‡ ä¸ªæ•°æ®é›†ï¼Œè®­ç»ƒæ›´å¤šçš„ ML æ¨¡å‹ï¼åªæœ‰ä½ æ‰èƒ½å†³å®šä½ çš„æ¨¡å‹ç©¶ç«Ÿéœ€è¦å¥½åˆ°ä»€ä¹ˆç¨‹åº¦æ‰èƒ½åœ¨ä½ çš„ App ä¸­ä½¿ç”¨ã€‚ã€‚",
      "tips": ""
    },
    "Creating Your Own Machine Learning Dataset": {
      "zh": "åˆ›å»ºä½ è‡ªå·±çš„æœºå™¨å­¦ä¹ æ•°æ®é›†",
      "tips": ""
    },
    "Learn how to create a dataset for your own machine learning model.": {
      "zh": "äº†è§£å¦‚ä½•ä¸ºä½ è‡ªå·±çš„æœºå™¨å­¦ä¹ æ¨¡å‹åˆ›å»ºæ•°æ®é›†ã€‚",
      "tips": ""
    },
    "To do this, youâ€™ll visualize the 2D array of nodes generated by the Vision when it interprets image data. The nodes you visualize map to the joints in your fingers and thumb.": {
      "zh": "ä¸ºäº†åšåˆ°è¿™ç‚¹ï¼Œä½ éœ€è¦å¯è§†åŒ–ç”± Vision æ¡†æ¶åœ¨è§£é‡Šå›¾ç‰‡æ•°æ®çš„æ—¶å€™ç”Ÿæˆçš„ 2D èŠ‚ç‚¹é˜µåˆ—ã€‚è¿™äº›ä½ å¯è§†åŒ–çš„èŠ‚ç‚¹å°†æ˜¾ç¤ºå’Œæ˜ å°„åˆ°ä½ æ‰‹æŒ‡å’Œæ‹‡æŒ‡çš„å…³èŠ‚ä¸Šã€‚",
      "tips": ""
    },
    "In this view, youâ€™ll have a camera view and a bar Swift Charts that visualizes in real time how confident your ML model is in its prediction. Remember, an ML modelâ€™s prediction accuracy depends on the training data you give it.": {
      "zh": "åœ¨è¿™ä¸ªè§†å›¾ä¸­ï¼Œä½ å°†æœ‰ä¸€ä¸ªæ‘„åƒå¤´è§†å›¾å’Œä¸€ä¸ªæ¥è‡ª Swift Charts çš„æ¡å½¢å›¾ï¼Œå®æ—¶å¯è§†åŒ–ä½ çš„æœºå™¨å­¦ä¹ æ¨¡å‹åœ¨é¢„æµ‹ä¸­çš„è‡ªä¿¡æˆ–å‡†ç¡®ç¨‹åº¦ã€‚ä½†æ˜¯ä½ éœ€è¦è®°ä½ï¼Œæœºå™¨å­¦ä¹ æ¨¡å‹çš„é¢„æµ‹ç²¾åº¦å–å†³äºä½ ç»™å®ƒçš„è®­ç»ƒæ•°æ®ã€‚",
      "tips": ""
    }
  },
  "sample-apps/getstartedwithmachinelearning-recognizegestures": {
    "Recognizing Gestures with Machine Learning": {
      "zh": "é€šè¿‡æœºå™¨å­¦ä¹ è¯†åˆ«æ‰‹åŠ¿",
      "tips": ""
    },
    "Explore how to transform hand pose images from the camera into readable data your machine learning model can use to predict gestures.": {
      "zh": "æ¢ç©¶å¦‚ä½•å°†ç›¸æœºæ‹æ‘„çš„æ‰‹åŠ¿å›¾åƒè½¬æ¢ä¸ºä½ çš„æœºå™¨å­¦ä¹ æ¨¡å‹å¯è¯»çš„æ•°æ®ï¼Œå¹¶ç”¨å…¶é¢„æµ‹æ‰‹åŠ¿ã€‚",
      "tips": ""
    },
    "Explore the fundamentals of machine learning": {
      "zh": "æ¢ç´¢æœºå™¨å­¦ä¹ çš„åŸºæœ¬åŸç†",
      "tips": ""
    },
    "Learn the basics of how machine learning uses data to create a classifier model.": {
      "zh": "å­¦ä¹ ä¸€äº›å¦‚ä½•ä½¿ç”¨æ•°æ®åˆ›å»ºåˆ†ç±»æ¨¡å‹çš„åŸºç¡€æœºå™¨å­¦ä¹ çŸ¥è¯†ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "Machine learning (ML) is the process of how you can â€œteachâ€ computers, like your iPad or Mac, to make educated guesses by providing them with lots of examples, commonly referred to as data.": {
      "zh": "æœºå™¨å­¦ä¹ ï¼ˆMLï¼‰æ˜¯ä½ å¦‚ä½•\"æ•™\"ä½ çš„ç”µè„‘ï¼ˆä¾‹å¦‚ iPad æˆ–è€… Macï¼‰é€šè¿‡æä¾›å¤§é‡çš„æ¡ˆä¾‹ï¼ˆé€šå¸¸è¢«ç§°ä½œä¸ºæ•°æ®ï¼‰æ¥ä½œå‡ºæœ‰ä¾æ®çš„çŒœæµ‹çš„è¿‡ç¨‹ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "Humans are able to see very few examples of hand poses and immediately tell the difference between a rock pose and scissors pose. However, a computer requires many examples of those hand poses to correctly identify them.": {
      "zh": "äººç±»å…·æœ‰ä¸€ç§ä¸ç”Ÿä¿±æ¥çš„èƒ½åŠ›ï¼Œå¯ä»¥åªçœ‹å‡ ä¸ªæ‰‹åŠ¿ç…§ç‰‡çš„ä¾‹å­å°±ç«‹é©¬åˆ†è¾¨å‡ºçŸ³å¤´æ‰‹åŠ¿å’Œå‰ªåˆ€æ‰‹æ‰‹åŠ¿çš„åŒºåˆ«ã€‚ä½†æ˜¯ï¼Œä¸€å°ç”µè„‘éœ€è¦éå¸¸å¤šçš„ä¾‹å­æ‰èƒ½æ­£ç¡®çš„åˆ†è¾¨å®ƒä»¬ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "This is because a computer requires lots of data to accurately identify and distinguish meaningful features of hand poses, something that the human brain can do rather effortlessly.": {
      "zh": "è¿™æ˜¯å› ä¸ºç”µè„‘éœ€è¦éå¸¸å¤šçš„æ•°æ®æ‰èƒ½æ­£ç¡®çš„è¯†åˆ«å’Œåˆ†è¾¨æ‰‹åŠ¿çš„æœ‰æ„ä¹‰çš„ç‰¹å¾ï¼Œè€Œäººç±»åˆ™åœ¨è¿™æ–¹é¢éå¸¸æ“…é•¿ï¼Œæ¯«ä¸è´¹åŠ›ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "This app uses image classification to recognize different hand poses shown in the camera. Classification is a type of ML algorithm that categorizes examples from a dataset into different groups. Youâ€™ll use the MLHandPoseClassifier to classify different hand poses from a stream of images from the camera.": {
      "zh": "è¿™ä¸ªåº”ç”¨ä½¿ç”¨äº†å›¾ç‰‡åˆ†ç±»æ¥è¯†åˆ«ç›¸æœºå†…å±•ç¤ºä¸åŒçš„æ‰‹åŠ¿å›¾ç‰‡ã€‚åˆ†ç±»æ˜¯ä¸€ç§ ML ç®—æ³•ï¼Œè¿™ä¸ªç®—æ³•å¯ä»¥å°†ä¸€ç»„æ•°æ®ä¸­çš„æ¡ˆä¾‹åˆ†ç±»åˆ°ä¸åŒçš„ç»„åˆ«ã€‚ä½ å°†ä¼šä½¿ç”¨ MLHandPoseClassifier æ¥åˆ†è¾¨æ¥è‡ªç›¸æœºå›¾åƒæµçš„ä¸åŒæ‰‹åŠ¿ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "To create an ML model, you need to provide a large amount of data â€” in this case, images â€” to the classifier. This process is known as training your ML model, because youâ€™re teaching it how to recognize different things.": {
      "zh": "ä¸ºäº†åˆ›å»ºä¸€ä¸ª ML æ¨¡å‹ï¼Œä½ éœ€è¦æä¾›å¤§é‡çš„æ•°æ®ï¼Œåœ¨è¿™ä¸ªæ¡ˆä¾‹ä¸­ï¼Œä½ éœ€è¦ç»™åˆ†ç±»å™¨æä¾›å¤§é‡çš„å›¾ç‰‡ã€‚è¿™ä¸ªè¿‡ç¨‹è¢«ç§°ä¹‹ä¸ºè®­ç»ƒ ML æ¨¡å‹ã€‚è¿™ä¸ªåå­—çš„ç”±æ¥æ˜¯å› ä¸ºä½ åœ¨æ•™ä½ çš„æ¨¡å‹å¦‚ä½•è¯†åˆ«ä¸åŒçš„ä¸œè¥¿ã€‚",
      "tips": ""
    },
    "Learn about ML models": {
      "zh": "äº†è§£ ML æ¨¡å‹",
      "tips": ""
    },
    "Learn how a model takes in camera data to generate a prediction.": {
      "zh": "äº†è§£æ¨¡å‹å¦‚ä½•é€šè¿‡ç›¸æœºä¸­çš„æ•°æ®è¿›è¡Œé¢„æµ‹ã€‚",
      "tips": ""
    },
    "You can think of an ML model as a machineâ€™s brain and all the knowledge it knows about a certain type of pattern â€“ in this case, hand poses.": {
      "zh": "ä½ å¯ä»¥å°†ä¸€ä¸ª ML æ¨¡å‹çœ‹ä½œæœºå™¨çš„å¤§è„‘ï¼Œå’Œå®ƒçŸ¥é“å…³äºæ¨¡å‹ç‰¹å®šæ¨¡å¼ï¼ˆåœ¨è¿™ä¸ªä¾‹å­ï¼Œæ˜¯æ‰‹åŠ¿ï¼‰çš„æ‰€æœ‰çŸ¥è¯†ã€‚",
      "tips": ""
    },
    "An ML model receives information as input to produce an educated guess of what that information represents. This is known as a prediction.": {
      "zh": "ä¸€ä¸ª ML æ¨¡å‹æ¥å—ä¿¡æ¯ä½œä¸ºè¾“å…¥ï¼Œç„¶åå¯¹ä¿¡æ¯æ‰€è¡¨ç¤ºçš„å†…å®¹åšå‡ºä¸€ä¸ªæœ‰ä¾æ®çš„çŒœæµ‹ã€‚è¿™ä¸ªè¿‡ç¨‹è¢«ç§°ä½œä¸ºé¢„æµ‹ã€‚",
      "tips": ""
    },
    "The camera in your app is the machineâ€™s eyes. You can use image data from the camera as input for the HandPoseMLModel. Your ML model uses this data to identify the different types of hand poses.": {
      "zh": "ä½ çš„åº”ç”¨ä¸­çš„ç›¸æœºæ˜¯æœºå™¨çš„çœ¼ç›ã€‚ä½ å¯ä»¥å°†ç›¸æœºä¸­çš„å›¾ç‰‡æ•°æ®ä½œä¸º HandPoseMLModel çš„è¾“å…¥ã€‚ä½ çš„ ML æ¨¡å‹é€šè¿‡è¿™ä¸ªæ•°æ®æ¥åˆ†è¾¨ä¸åŒçš„æ‰‹åŠ¿ç±»åˆ«ã€‚",
      "tips": ""
    },
    "If the model successfully receives an input, youâ€™ll receive an output of a label and the confidence, or probability, of that image.": {
      "zh": "å¦‚æœæ¨¡å‹æˆåŠŸæ”¶åˆ°äº†ä¸€ä¸ªè¾“å…¥ï¼Œä½ å°±ä¼šè·å¾—ä¸€ä¸ªè¾“å‡ºã€‚è¿™ä¸ªè¾“å‡ºåŒ…å«å›¾ç‰‡çš„æ ‡ç­¾ï¼ˆä¹Ÿå°±æ˜¯ç±»åˆ«ï¼‰å’Œç½®ä¿¡åº¦ã€‚",
      "tips": ""
    },
    "Providing readable data to your ML model": {
      "zh": "ç»™ä½ çš„ ML æ¨¡å‹æä¾›ä¸€ä¸ªå¯è¯»çš„æ•°æ®",
      "tips": ""
    },
    "Use the Vision framework to pass image data into your ML model.": {
      "zh": "ä½¿ç”¨ Vision æ¡†æ¶å°†å›¾ç‰‡æ•°æ®ä¼ é€’ç»™ä½ çš„ ML æ¨¡å‹ã€‚",
      "tips": ""
    },
    "The Vision Framework makes it easy for your app to convert the cameraâ€™s image data into something the ML model can understand.": {
      "zh": "Vision æ¡†æ¶ä½¿è®©è½¬æ¢ç›¸æœºå›¾ç‰‡æ•°æ®åˆ° ML æ¨¡å‹å¯ä»¥ç†è§£çš„å½¢å¼è¿™ä¸€è¿‡ç¨‹å˜å¾—æ›´åŠ ç®€å•ã€‚",
      "tips": ""
    },
    "Every time your cameraâ€™s frame updates, your app gathers VNHumanHandPoseObservations from the frameâ€™s pixel buffer.": {
      "zh": "æ¯æ¬¡ç›¸æœºå¸§æ›´æ–°æ—¶ï¼Œåº”ç”¨ç¨‹åºéƒ½ä¼šä»å¸§çš„åƒç´ ç¼“å†²åŒºæ”¶é›† VNHumanHandPoseObservationsã€‚",
      "tips": ""
    },
    "Vision then extracts an MLMultiArray from these observations. An MLMultiArray instance provides location coordinates that (in this case) map to the finger joints, giving your ML model a rich set of hand-position data that it uses to train itself.": {
      "zh": "",
      "tips": ""
    },
    "Debugging Your Machine Learning Model": {
      "zh": "è°ƒè¯•æœºå™¨å­¦ä¹ æ¨¡å‹",
      "tips": ""
    },
    "Learn how to debug your machine learning model and make improvements in its predictions.": {
      "zh": "å­¦ä¹ å¦‚ä½•è°ƒè¯•æœºå™¨å­¦ä¹ æ¨¡å‹å¹¶æ”¹è¿›å…¶é¢„æµ‹ã€‚",
      "tips": ""
    },
    "To add ML to your app, youâ€™ll use the Create ML and Core ML frameworks.": {
      "zh": "å¦‚æœè¦å°† ML åŠŸèƒ½åŠ å…¥ä½ çš„åº”ç”¨ï¼Œä½ éœ€è¦ä½¿ç”¨åˆ° Create ML å’Œ Core ML æ¡†æ¶ã€‚",
      "tips": ""
    }
  },
  "sample-apps/imagegallery": {
    "Image Gallery": {
      "zh": "å›¾åº“",
      "tips": ""
    },
    "Retrieve and display images from an asset catalog or a photo library.": {
      "zh": "ä»èµ„æºç›®å½•æˆ–ç…§ç‰‡åº“ä¸­æ£€ç´¢å’Œæ˜¾ç¤ºå›¾ç‰‡ã€‚",
      "tips": ""
    },
    "Welcome to the Image Gallery app. This walkthrough shows how to create a grid of images, complete with photo-picking and -editing functionality.": {
      "zh": "æ¬¢è¿ä½¿ç”¨å›¾ç‰‡åº“åº”ç”¨ã€‚æœ¬æ¼”ç¤ºå±•ç¤ºäº†å¦‚ä½•åˆ›å»ºä¸€ä¸ªå›¾ç‰‡ç½‘æ ¼ï¼ŒåŒæ—¶åˆ›å»ºé€‰æ‹©ç…§ç‰‡å’Œç¼–è¾‘å›¾ç‰‡çš„åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "This sample is an extension of two simpler implementations: Organizing with Grids and Editing Grids. This walkthrough focuses on solving some common issues after your grid displays images, instead of shapes or SF Symbols.": {
      "zh": "è¿™ä¸ªç¤ºä¾‹æ˜¯ä¸¤ä¸ªæ›´ç®€å•çš„å®ç°çš„æ‰©å±•ï¼šç»„ç»‡ç½‘æ ¼å’Œç¼–è¾‘ç½‘æ ¼ã€‚æœ¬æ¼”ç¤ºç€é‡è§£å†³ç½‘æ ¼æ˜¾ç¤ºå›¾ç‰‡åçš„ä¸€äº›å¸¸è§é—®é¢˜ï¼Œè€Œä¸æ˜¯æ˜¾ç¤ºå½¢çŠ¶æˆ– SF Symbolsã€‚",
      "tips": ""
    },
    "Larger images can load slowly, which can cause noticeable delays when loading your appâ€™s UI. This sample focuses on unblocking delays by showing progress indicators until each image loads and keeping your app responsive during the loading process.": {
      "zh": "è¾ƒå¤§çš„å›¾ç‰‡åŠ è½½å¯èƒ½ä¼šè¾ƒæ…¢ï¼Œè¿™å¯èƒ½ä¼šåœ¨åŠ è½½åº”ç”¨ç¨‹åºçš„ç”¨æˆ·ç•Œé¢æ—¶é€ æˆæ˜æ˜¾çš„å»¶è¿Ÿã€‚è¿™ä¸ªç¤ºä¾‹ç€é‡äºåœ¨æ¯ä¸ªå›¾ç‰‡åŠ è½½å®Œæˆå‰æ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºå™¨ï¼Œä»¥åŠåœ¨åŠ è½½è¿‡ç¨‹ä¸­ä¿æŒåº”ç”¨ç¨‹åºå¯å“åº”ï¼Œæ¥é¿å…é˜»å¡å»¶è¿Ÿã€‚",
      "tips": ""
    },
    "Sharing App Data": {
      "zh": "å…±äº«åº”ç”¨æ•°æ®",
      "tips": ""
    },
    "Learn how the app passes photo data from DataModel to its view hierarchy.": {
      "zh": "äº†è§£åº”ç”¨ç¨‹åºå¦‚ä½•ä»æ•°æ®æ¨¡å‹ï¼ˆDataModelï¼‰å‘å…¶è§†å›¾å±‚æ¬¡ç»“æ„ä¼ é€’ç…§ç‰‡æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "Image Gallery loads a gallery of images when you first launch the app. Because the images are so large, and you donâ€™t want the app to lag when loading them all at the same time, youâ€™ll use asynchronous requests to keep the app responsive even when data retrieval is slow.": {
      "zh": "å›¾ç‰‡åº“åœ¨ä½ é¦–æ¬¡å¯åŠ¨åº”ç”¨ç¨‹åºæ—¶ä¼šåŠ è½½ä¸€ç»„å›¾ç‰‡ã€‚ç”±äºå›¾ç‰‡éå¸¸å¤§ï¼Œä½ ä¸å¸Œæœ›åº”ç”¨ç¨‹åºåœ¨åŒæ—¶åŠ è½½æ‰€æœ‰å›¾ç‰‡æ—¶å‡ºç°å»¶è¿Ÿï¼Œæ‰€ä»¥ä½ å°†ä½¿ç”¨å¼‚æ­¥è¯·æ±‚æ¥ä¿æŒåº”ç”¨ç¨‹åºå³ä½¿åœ¨æ•°æ®æ£€ç´¢ç¼“æ…¢æ—¶ä¹Ÿèƒ½ä¿æŒå“åº”ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "To create dataModel as a state object, apply the @StateObject property wrapper and provide an initial value that conforms to the ObservableObject protocol. SwiftUI manages storage for a state object, and updates all of the child views that use the value when the published values change.": {
      "zh": "è¦å°†æ•°æ®æ¨¡å‹ï¼ˆdataModelï¼‰åˆ›å»ºä¸ºçŠ¶æ€å¯¹è±¡ï¼Œåº”ç”¨ @StateObject å±æ€§åŒ…è£…å™¨å¹¶æä¾›ç¬¦åˆ ObservableObject åè®®çš„åˆå§‹å€¼ã€‚SwiftUI ä¼šç®¡ç†çŠ¶æ€å¯¹è±¡çš„å­˜å‚¨ï¼Œå¹¶åœ¨å‘å¸ƒçš„å€¼æ›´æ”¹æ—¶æ›´æ–°æ‰€æœ‰ä½¿ç”¨è¯¥å€¼çš„å­è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "NavigationStack passes in the DataModel instance using the .environmentObject modifier, making the observable object available to all of the NavigationStackâ€™s child views. As a result, those views can access the data from dataModel to perform various tasks, such as loading image views asynchronously or updating the grid view when the data changes.": {
      "zh": "NavigationStack ä½¿ç”¨ .environmentObject ä¿®é¥°ç¬¦ä¼ é€’æ•°æ®æ¨¡å‹ï¼ˆDataModelï¼‰å®ä¾‹ï¼Œä½¿å¯è§‚å¯Ÿå¯¹è±¡ï¼ˆObservableObjectï¼‰å¯¹ NavigationStack çš„æ‰€æœ‰å­è§†å›¾å¯ç”¨ã€‚å› æ­¤ï¼Œè¿™äº›è§†å›¾å¯ä»¥è®¿é—®æ•°æ®æ¨¡å‹ï¼ˆdataModelï¼‰ä¸­çš„æ•°æ®æ¥æ‰§è¡Œå„ç§ä»»åŠ¡ï¼Œä¾‹å¦‚å¼‚æ­¥åŠ è½½å›¾åƒè§†å›¾æˆ–åœ¨æ•°æ®æ›´æ”¹æ—¶æ›´æ–°ç½‘æ ¼è§†å›¾ã€‚",
      "tips": ""
    },
    "Modeling an Item": {
      "zh": "å»ºæ¨¡é¡¹ç›®",
      "tips": ""
    },
    "Explore how the Item type models a grid itemâ€™s data and adds Identifiable conformance.": {
      "zh": "äº†è§£å¦‚ä½•ä½¿ç”¨é¡¹ç›®ç±»å‹ï¼ˆItemï¼‰å¯¹ç½‘æ ¼é¡¹çš„æ•°æ®è¿›è¡Œå»ºæ¨¡å¹¶æ·»åŠ  Identifiable ç¬¦åˆæ€§ã€‚",
      "tips": ""
    },
    "When you use ForEach to construct a collection view, such as a list or grid, SwiftUI wants to uniquely identify each view so it can find and update them. To make this easier, you can create a model that conforms to Identifiable, which creates an id property requirement.": {
      "zh": "å½“ä½ ä½¿ç”¨ ForEach æ„é€ é›†åˆè§†å›¾ï¼ˆå¦‚åˆ—è¡¨æˆ–ç½‘æ ¼ï¼‰æ—¶ï¼ŒSwiftUI æƒ³è¦å”¯ä¸€æ ‡è¯†æ¯ä¸ªè§†å›¾ï¼Œä»¥ä¾¿å®ƒå¯ä»¥æ‰¾åˆ°å¹¶æ›´æ–°å®ƒä»¬ã€‚ä¸ºäº†ç®€åŒ–è¿™ä¸€è¿‡ç¨‹ï¼Œä½ å¯ä»¥åˆ›å»ºç¬¦åˆ Identifiable çš„æ¨¡å‹ï¼Œè¿™ä¸€åè®®è¦æ±‚ id å±æ€§ã€‚",
      "tips": ""
    },
    "Your Item contains an id property that SwiftUI uses to uniquely identify the view.": {
      "zh": "ä½ çš„é¡¹ç›®ç±»å‹ï¼ˆItemï¼‰åŒ…å« SwiftUI ç”¨æ¥æ ‡è¯†è§†å›¾å”¯ä¸€æ€§çš„ id å±æ€§ã€‚",
      "tips": ""
    },
    "Item also has a url property that the app uses to identify the location of the corresponding image using a path to the file. AsyncImage uses this URL in GridItemView to asynchronously load the image.": {
      "zh": "é¡¹ç›®ç±»å‹ï¼ˆItemï¼‰è¿˜å…·æœ‰ url å±æ€§ï¼Œåº”ç”¨ç¨‹åºä½¿ç”¨è¯¥å±æ€§ï¼Œé€šè¿‡æ–‡ä»¶è·¯å¾„æ¥æ ‡è¯†ç›¸åº”å›¾åƒçš„ä½ç½®ã€‚AsyncImage åœ¨ GridItemView ä¸­ä½¿ç”¨è¯¥ URL æ¥å¼‚æ­¥åŠ è½½å›¾åƒã€‚",
      "tips": ""
    },
    "Data Model: Gathering Image URLs": {
      "zh": "æ•°æ®æ¨¡å‹ï¼šæ”¶é›†å›¾åƒ URL",
      "tips": ""
    },
    "Learn how your app uses a data model to load and store all photo data.": {
      "zh": "äº†è§£ä½ çš„åº”ç”¨ç¨‹åºå¦‚ä½•ä½¿ç”¨æ•°æ®æ¨¡å‹åŠ è½½å’Œå­˜å‚¨æ‰€æœ‰ç…§ç‰‡æ•°æ®ã€‚",
      "tips": ""
    },
    "DataModel is an observable object that gathers file URLs from images in your document directory as well as from your bundle resources. It uses these URLs to populate an array of Item instances which display as the content of your grid.": {
      "zh": "æ•°æ®æ¨¡å‹ï¼ˆDataModelï¼‰æ˜¯ä¸€ä¸ªå¯è§‚å¯Ÿå¯¹è±¡ï¼ˆObservableObjectï¼‰ï¼Œå®ƒä»æ–‡æ¡£ç›®å½•ä¸­çš„å›¾åƒä»¥åŠåŒ…èµ„æºä¸­æ”¶é›†æ–‡ä»¶ URLã€‚å®ƒä½¿ç”¨è¿™äº› URL æ¥å¡«å……é¡¹ç›®ç±»å‹ï¼ˆItemï¼‰å®ä¾‹æ•°ç»„ï¼Œè¿™äº›æ•°ç»„å°†æ˜¾ç¤ºä¸ºç½‘æ ¼çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "DataModel publishes an array of item values, each of which correlates to an image in the grid. Because the code marks this value as @Published, any time you add or delete an Item from this array, SwiftUI updates the grid view (and any other views that use this value) to reflect those changes.": {
      "zh": "æ•°æ®æ¨¡å‹ï¼ˆDataModelï¼‰å‘å¸ƒæ•°ç»„ï¼Œæ•°ç»„ä¸­çš„æ¯ä¸ª item å€¼ä¸ç½‘æ ¼ä¸­çš„ä¸€ä¸ªå›¾åƒç›¸å…³è”ã€‚ç”±äºä»£ç å°†æ­¤å€¼æ ‡è®°ä¸º @Publishedï¼Œæ‰€ä»¥æ¯å½“ä½ ä»è¯¥æ•°ç»„ä¸­æ·»åŠ æˆ–åˆ é™¤é¡¹ç›®ç±»å‹ï¼ˆItemï¼‰æ—¶ï¼ŒSwiftUI éƒ½ä¼šæ›´æ–°ç½‘æ ¼è§†å›¾ï¼ˆä»¥åŠä½¿ç”¨æ­¤å€¼çš„ä»»ä½•å…¶ä»–è§†å›¾ï¼‰ä»¥åæ˜ è¿™äº›æ›´æ”¹ã€‚",
      "tips": ""
    },
    "When you initialize DataModel, it searches the document directory for any images youâ€™ve added, gathering their corresponding URLs and appending them to the items array. Your app stores data locally in this directory, so searching here allows you to display any images you added while using the app.": {
      "zh": "åˆå§‹åŒ–æ•°æ®æ¨¡å‹ï¼ˆDataModelï¼‰æ—¶ï¼Œå®ƒä¼šæœç´¢æ–‡æ¡£ç›®å½•ä»¥æŸ¥æ‰¾ä½ æ·»åŠ çš„ä»»ä½•å›¾åƒï¼Œæ”¶é›†å›¾åƒå¯¹åº”çš„ URL å¹¶å°†å…¶è¿½åŠ åˆ° items æ•°ç»„ä¸­ã€‚ä½ çš„åº”ç”¨ç¨‹åºä¼šåœ¨æ­¤ç›®å½•ä¸­æœ¬åœ°å­˜å‚¨æ•°æ®ï¼Œå› æ­¤åœ¨æ­¤å¤„æœç´¢å°†å…è®¸ä½ æ˜¾ç¤ºä½¿ç”¨åº”ç”¨ç¨‹åºæ—¶æ·»åŠ çš„ä»»ä½•å›¾åƒã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "Similarly, youâ€™ll load all image URLs from the bundle resources directory and add them to items. Bundle resources is the directory of images that are included with the project, as opposed to images that you added yourself.": {
      "zh": "åŒæ ·åœ°ï¼Œä½ å°†ä»åŒ…èµ„æºç›®å½•åŠ è½½æ‰€æœ‰å›¾åƒ URL å¹¶å°†å…¶æ·»åŠ åˆ° items æ•°ç»„ä¸­ã€‚åŒ…èµ„æºæ˜¯éšé¡¹ç›®ä¸€èµ·é…é€çš„å›¾åƒç›®å½•ï¼Œä¸ä½ è‡ªå·±æ·»åŠ çš„å›¾åƒç›¸å¯¹ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "DataModel provides methods for adding and removing items from items. addItem adds a new item at the first index of the array so you can see when new images appear in the view.": {
      "zh": "æ•°æ®æ¨¡å‹ï¼ˆDataModelï¼‰ä¸ºä» items æ•°ç»„ä¸­æ·»åŠ å’Œç§»é™¤é¡¹æä¾›æ–¹æ³•ã€‚addItem åœ¨æ•°ç»„çš„ç¬¬ä¸€ä¸ªç´¢å¼•å¤„æ·»åŠ æ–°é¡¹ï¼Œä»¥ä¾¿ä½ å¯ä»¥çœ‹åˆ°è§†å›¾ä¸­å‡ºç°æ–°çš„å›¾åƒã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "removeItem removes an item by finding its index and removing it from the items array. The method also removes the itemâ€™s corresponding image file from the document directory, if it exists there. This ensures that the image wonâ€™t reload from local app storage the next time you launch the app.": {
      "zh": "removeItem é€šè¿‡æŸ¥æ‰¾ç´¢å¼•å¹¶ä» items æ•°ç»„ä¸­ç§»é™¤å®ƒæ¥ç§»é™¤ä¸€ä¸ªé¡¹ã€‚å¦‚æœæ–‡æ¡£ç›®å½•ä¸­å­˜åœ¨å¯¹åº”çš„å›¾åƒæ–‡ä»¶ï¼Œè¯¥æ–¹æ³•ä¹Ÿä¼šå°†å…¶ç§»é™¤ã€‚è¿™ç¡®ä¿åœ¨ä¸‹æ¬¡å¯åŠ¨åº”ç”¨ç¨‹åºæ—¶å›¾åƒä¸ä¼šä»æœ¬åœ°åº”ç”¨ç¨‹åºå­˜å‚¨é‡æ–°åŠ è½½ã€‚",
      "tips": ""
    },
    "Creating a Grid Item": {
      "zh": "åˆ›å»ºç½‘æ ¼é¡¹",
      "tips": ""
    },
    "Find out how to load an image asynchronously from a URL using AsyncImage.": {
      "zh": "äº†è§£å¦‚ä½•ä½¿ç”¨ AsyncImage ä» URL å¼‚æ­¥åŠ è½½å›¾åƒã€‚",
      "tips": ""
    },
    "GridItemView represents a single item of your grid, an image view that displays the photo defined by an Item instance.": {
      "zh": "GridItemView è¡¨ç¤ºç½‘æ ¼çš„å•ä¸ªé¡¹ï¼Œä¸€ä¸ªæ˜¾ç¤ºç”±é¡¹ç›®ç±»å‹ï¼ˆItemï¼‰å®ä¾‹å®šä¹‰çš„ç…§ç‰‡çš„å›¾åƒè§†å›¾ã€‚",
      "tips": ""
    },
    "A GridItemView contains properties for item and size. The item property provides the URL to asynchronously load the image, while the size property provides the value for the height and width of the image and its placeholder.": {
      "zh": "GridItemView åŒ…å« item å’Œ size å±æ€§ã€‚item å±æ€§æä¾›å¼‚æ­¥åŠ è½½å›¾åƒçš„ URLï¼Œè€Œ size å±æ€§æä¾›å›¾åƒåŠå…¶å ä½ç¬¦çš„é«˜åº¦å’Œå®½åº¦çš„å€¼ã€‚",
      "tips": ""
    },
    "In the body of your GridItemView, youâ€™ll create your image view. Since youâ€™ll have a conditional editing UI overlaid on top of your image, wrap the image in a ZStack.": {
      "zh": "åœ¨ GridItemView çš„ä¸»ä½“ä¸­ï¼Œä½ å°†åˆ›å»ºå›¾åƒè§†å›¾ã€‚ç”±äºä½ å°†åœ¨å›¾åƒä¸Šé¢å åŠ æ¡ä»¶ç¼–è¾‘ UIï¼Œå› æ­¤è¯·å°†å›¾åƒåŒ…è£…åœ¨ ZStack ä¸­ã€‚",
      "tips": ""
    },
    "You can initialize an AsyncImage with the item.url value to load the image asynchronously. Because you have many images to load when the app first launches, you can load them asynchronously to allow the app to keep running the rest of its code while it waits for the images to return. This prevents any noticable lag in your UI.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ item.url å€¼åˆå§‹åŒ– AsyncImage ä»¥å¼‚æ­¥åŠ è½½å›¾åƒã€‚ç”±äºåœ¨åº”ç”¨ç¨‹åºé¦–æ¬¡å¯åŠ¨æ—¶æœ‰è®¸å¤šå›¾åƒè¦åŠ è½½ï¼Œå› æ­¤ä½ å¯ä»¥å¼‚æ­¥åŠ è½½å®ƒä»¬ï¼Œä»¥å…è®¸åº”ç”¨ç¨‹åºåœ¨ç­‰å¾…å›¾åƒè¿”å›æ—¶ç»§ç»­è¿è¡Œå…¶ä½™ä»£ç ã€‚è¿™å¯é¿å… UI ä¸­å‡ºç°ä»»ä½•æ˜æ˜¾çš„å»¶è¿Ÿæˆ–å¡é¡¿ã€‚",
      "tips": ""
    },
    "AsyncImage contains a content closure that provides an instance of a SwiftUI Image. Youâ€™ll use this instance to create your image view. Youâ€™ll add the .resizable and .scaledToFill modifiers to scale the image to fill the available space of the view.": {
      "zh": "AsyncImage åŒ…å«ä¸€ä¸ªå†…å®¹é—­åŒ…ï¼Œå®ƒæä¾›äº†ä¸€ä¸ª SwiftUI Image çš„å®ä¾‹ã€‚ä½ å°†ä½¿ç”¨æ­¤å®ä¾‹æ¥åˆ›å»ºå›¾åƒè§†å›¾ã€‚ä½ å°†æ·»åŠ  .resizable å’Œ .scaledToFill ä¿®é¥°ç¬¦æ¥ç¼©æ”¾å›¾åƒä»¥å¡«å……è§†å›¾çš„å¯ç”¨ç©ºé—´ã€‚",
      "tips": ""
    },
    "AsyncImage uses a placeholder to show some content while the image loads. This placeholder uses a SwiftUI ProgressView which displays as a spinning circle.": {
      "zh": "AsyncImage ä½¿ç”¨å ä½ç¬¦åœ¨åŠ è½½å›¾åƒæ—¶æ˜¾ç¤ºä¸€äº›å†…å®¹ã€‚æ­¤å ä½ç¬¦ä½¿ç”¨ SwiftUI çš„ ProgressViewï¼šæ—‹è½¬ç€çš„åœ†åœˆã€‚",
      "tips": ""
    },
    "Creating Your Gallery": {
      "zh": "åˆ›å»ºç›¸å†Œ",
      "tips": ""
    },
    "Learn how to put together a grid view using a series of SwiftUI built-in and composed views.": {
      "zh": "äº†è§£å¦‚ä½•ä½¿ç”¨ä¸€ç³»åˆ— SwiftUI å†…ç½®å’Œç»„åˆè§†å›¾ç»„åˆç½‘æ ¼è§†å›¾ã€‚",
      "tips": ""
    },
    "GridView is where youâ€™ll create your image gallery. If you need to review the basics of creating a grid, check out Color Grid. In this walkthrough, youâ€™ll learn how to implement the grid using a model type, Item, and an observable object, dataModel.": {
      "zh": "GridView æ˜¯ä½ åˆ›å»ºå›¾ç‰‡åº“çš„åœ°æ–¹ã€‚å¦‚æœä½ éœ€è¦å¤ä¹ åˆ›å»ºç½‘æ ¼çš„åŸºç¡€çŸ¥è¯†ï¼Œè¯·æŸ¥çœ‹è‰²å—ç½‘æ ¼ï¼ˆColor Gridï¼‰ã€‚åœ¨æœ¬æ¼”ç¤ºä¸­ï¼Œä½ å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨æ¨¡å‹ç±»å‹ Item å’Œå¯è§‚å¯Ÿå¯¹è±¡ dataModel æ¥å®ç°ç½‘æ ¼ã€‚",
      "tips": ""
    },
    "To access the appâ€™s dataModel, you define an @EnvironmentObject of type DataModel, which gives you access to the environment object passed into the top-level view of the view hierarchy in ImageGalleryApp.swift.": {
      "zh": "è¦è®¿é—®åº”ç”¨ç¨‹åºçš„ dataModelï¼Œä½ å®šä¹‰ä¸€ä¸ªç±»å‹ä¸º DataModel çš„ @EnvironmentObjectï¼Œè¿™ä½¿ä½ å¯ä»¥è®¿é—®ä½äº ImageGalleryApp.swift é¡¶å±‚è§†å›¾çš„ç¯å¢ƒå¯¹è±¡ã€‚",
      "tips": ""
    },
    "The data for populating the grid comes from an array of Item instances (found in dataModel.items), each of which references a single image URL.": {
      "zh": "ç”¨äºå¡«å……ç½‘æ ¼çš„æ•°æ®æ¥è‡ª Item å®ä¾‹æ•°ç»„ï¼ˆä½äº dataModel.items ä¸­ï¼‰ï¼Œæ¯ä¸ªå®ä¾‹éƒ½å¼•ç”¨å•ä¸ªå›¾åƒ URLã€‚",
      "tips": ""
    },
    "To create the grid, youâ€™ll nest a LazyVGrid inside of a ScrollView, which allows the content of the grid to scroll vertically, if necessary.": {
      "zh": "è¦åˆ›å»ºç½‘æ ¼ï¼Œä½ å°†åœ¨ ScrollView å†…åµŒå¥—ä¸€ä¸ª LazyVGridï¼Œè¿™å…è®¸ç½‘æ ¼çš„å†…å®¹åœ¨éœ€è¦æ—¶å‚ç›´æ»šåŠ¨ã€‚",
      "tips": ""
    },
    "Your ForEach loop iterates through dataModel.items, and creates a GridItemView based upon each item value in the array. Because each item instance is Identifiable, you donâ€™t need an id parameter when creating your grid views. Instead, SwiftUI uses the id property of each item to uniquely identify it.": {
      "zh": "ä½ çš„ ForEach å¾ªç¯éå† dataModel.itemsï¼Œå¹¶æ ¹æ®æ•°ç»„ä¸­çš„æ¯ä¸ª item å€¼åˆ›å»ºä¸€ä¸ª GridItemViewã€‚å› ä¸ºæ¯ä¸ª item å®ä¾‹éƒ½æ˜¯å¯è¯†åˆ«ï¼ˆIdentifiableï¼‰çš„ï¼Œæ‰€ä»¥åœ¨åˆ›å»ºç½‘æ ¼è§†å›¾æ—¶ä¸éœ€è¦ id å‚æ•°ã€‚ç›¸åï¼ŒSwiftUI ä½¿ç”¨æ¯ä¸ª item çš„ id å±æ€§ä½œä¸ºå”¯ä¸€æ ‡è¯†ã€‚",
      "tips": ""
    },
    "To provide relative size information of a parent view to its child views, you can use a GeometryReader. This gives you information on the width and height of the parent view depending on how much screen size is available. You can access this information using the closure value and use it to set the size of a size of a child view.": {
      "zh": "è¦å‘å­è§†å›¾æä¾›çˆ¶è§†å›¾çš„ç›¸å¯¹å¤§å°ä¿¡æ¯ï¼Œå¯ä»¥ä½¿ç”¨ GeometryReaderã€‚è¿™å°†ä¸ºä½ æä¾›çˆ¶è§†å›¾çš„å®½åº¦å’Œé«˜åº¦ä¿¡æ¯ï¼Œå…·ä½“å–å†³äºå¯ç”¨çš„å±å¹•å¤§å°ã€‚ä½ å¯ä»¥ä½¿ç”¨é—­åŒ…å€¼è®¿é—®æ­¤ä¿¡æ¯ï¼Œå¹¶ä½¿ç”¨å®ƒæ¥è®¾ç½®å­è§†å›¾çš„å¤§å°ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ä¸ƒæ­¥",
      "tips": ""
    },
    "To simplify the code in GridView, generate each view of the grid using a GridItemView, which handles all of the asynchronous image loading as well as transitions between editing states.": {
      "zh": "ä¸ºäº†ç®€åŒ– GridView ä¸­çš„ä»£ç ï¼Œä½¿ç”¨ GridItemView ç”Ÿæˆç½‘æ ¼çš„æ¯ä¸ªè§†å›¾ï¼Œå®ƒåŒæ—¶ä¹Ÿå°†å¤„ç†æ‰€æœ‰çš„å¼‚æ­¥å›¾åƒåŠ è½½ä»¥åŠçŠ¶æ€ç¼–è¾‘ä¹‹é—´çš„è½¬åœºã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "ç¬¬å…«æ­¥",
      "tips": ""
    },
    "To initialize GridItemView, you pass in the current item from the ForEach loop as well as the width of the parent view provided from GeometryReader. GridItem uses geo.size.width as the value for its height and width, which creates a square-shaped grid item.": {
      "zh": "è¦åˆå§‹åŒ– GridItemViewï¼Œä½ éœ€ä¼ å…¥ ForEach å¾ªç¯ä¸­çš„å½“å‰é¡¹ä»¥åŠä» GeometryReader æä¾›çš„çˆ¶è§†å›¾çš„å®½åº¦ã€‚GridItem å°† geo.size.width ä½œä¸ºå…¶é«˜åº¦å’Œå®½åº¦çš„å€¼ï¼Œè¿™å°†åˆ›å»ºä¸€ä¸ªæ­£æ–¹å½¢çš„ç½‘æ ¼é¡¹ã€‚",
      "tips": ""
    },
    "Adding an Image to the Gallery": {
      "zh": "å‘ç›¸å†Œæ·»åŠ å›¾ç‰‡",
      "tips": ""
    },
    "Explore how to add and edit photos in the gallery.": {
      "zh": "æ¢ç´¢å¦‚ä½•åœ¨ç›¸å†Œä¸­æ·»åŠ å’Œç¼–è¾‘ç…§ç‰‡ã€‚",
      "tips": ""
    },
    "To add a new photo to the grid, youâ€™ll use the state value isAddingPhoto. Youâ€™ll toggle this value to true whenever you press the Add button (+) in the toolbar.": {
      "zh": "è¦å‘ç½‘æ ¼æ·»åŠ æ–°ç…§ç‰‡ï¼Œä½ å°†ä½¿ç”¨çŠ¶æ€å€¼ isAddingPhotoã€‚æ¯å½“ä½ åœ¨å·¥å…·æ ä¸­æŒ‰ Add æŒ‰é’®ï¼ˆ+ï¼‰æ—¶ï¼Œéƒ½ä¼šåˆ‡æ¢æ­¤å€¼ä¸º trueã€‚",
      "tips": ""
    },
    "To edit your photo grid, youâ€™ll use the state value isEditing. Youâ€™ll add a Remove button (X) on top of each image when the value toggles to true.": {
      "zh": "è¦ç¼–è¾‘ç…§ç‰‡ç½‘æ ¼ï¼Œä½ å°†ä½¿ç”¨çŠ¶æ€å€¼ isEditingã€‚å½“è¯¥å€¼åˆ‡æ¢ä¸º true æ—¶ï¼Œä½ ä¼šåœ¨æ¯ä¸ªå›¾åƒä¸Šæ–¹æ·»åŠ  Remove æŒ‰é’®ï¼ˆXï¼‰ã€‚",
      "tips": ""
    },
    "The .toolbar modifier contains two toolbar items: one to edit photos in the grid and one to add a new photo. These buttons toggle the state values isEditing and isAddingPhoto, respectively.": {
      "zh": ".toolbar ä¿®é¥°ç¬¦åŒ…å«ä¸¤ä¸ªå·¥å…·æ é¡¹ï¼šä¸€ä¸ªç”¨äºç¼–è¾‘ç½‘æ ¼ä¸­çš„ç…§ç‰‡ï¼Œä¸€ä¸ªç”¨äºæ·»åŠ æ–°ç…§ç‰‡ã€‚è¿™äº›æŒ‰é’®åˆ†åˆ«åˆ‡æ¢çŠ¶æ€å€¼ isEditing å’Œ isAddingPhotoã€‚",
      "tips": ""
    },
    "When isEditing is true, youâ€™ll show a Remove button (X) on top of the images.": {
      "zh": "å½“ isEditing ä¸º true æ—¶ï¼Œä½ ä¼šåœ¨å›¾ç‰‡ä¸Šæ–¹æ˜¾ç¤º Remove æŒ‰é’®ï¼ˆXï¼‰ã€‚",
      "tips": ""
    },
    "When a person taps the Remove button (X), the code removes the current item from dataModel.items. Because dataModel.items is a published value, this change causes SwiftUI to update the grid viewâ€™s appearance and remove the item.": {
      "zh": "å½“ç”¨æˆ·ç‚¹å‡» Remove æŒ‰é’®ï¼ˆXï¼‰æ—¶ï¼Œä»£ç ä¼šä» dataModel.items ä¸­åˆ é™¤å½“å‰é¡¹ã€‚å› ä¸º dataModel.items æ˜¯ä¸€ä¸ªå·²å‘å¸ƒçš„å€¼ï¼Œæ‰€ä»¥è¿™ä¸ªæ›´æ”¹ä¼šå¯¼è‡´ SwiftUI æ›´æ–°ç½‘æ ¼è§†å›¾çš„å¤–è§‚å¹¶åˆ é™¤è¯¥é¡¹ã€‚",
      "tips": ""
    },
    "When isAddingPhoto is true, a sheet displays the PhotoPicker modally. In PhotoPicker, selecting a new photo adds the corresponding item to DataModel.items. This causes SwiftUI to update the grid view and add the corresponding image.": {
      "zh": "å½“ isAddingPhoto ä¸º true æ—¶ï¼Œsheet ä¼šä»¥æ¨¡å¼æ–¹å¼æ˜¾ç¤º PhotoPickerã€‚åœ¨ PhotoPicker ä¸­ï¼Œé€‰æ‹©æ–°ç…§ç‰‡ä¼šå°†å¯¹åº”çš„é¡¹æ·»åŠ åˆ° DataModel.items ä¸­ã€‚è¿™ä¼šå¯¼è‡´ SwiftUI æ›´æ–°ç½‘æ ¼è§†å›¾å¹¶æ·»åŠ å¯¹åº”çš„å›¾åƒã€‚",
      "tips": ""
    },
    "Laying Out Views": {
      "zh": "å¸ƒå±€è§†å›¾",
      "tips": ""
    },
    "Organize, size and align view layouts.": {
      "zh": "ç»„ç»‡ã€è°ƒæ•´å¤§å°å¹¶å¯¹é½è§†å›¾å¸ƒå±€ã€‚",
      "tips": ""
    }
  },
  "sample-apps/layingoutviews": {
    "Laying Out Views": {
      "zh": "å¸ƒå±€è§†å›¾",
      "tips": ""
    },
    "Organize, size and align view layouts.": {
      "zh": "ç»„ç»‡ã€è°ƒæ•´å¤§å°å’Œå¯¹é½è§†å›¾å¸ƒå±€ã€‚",
      "tips": ""
    },
    "When creating an app, one of the first skills to learn is how to lay out your user interface, or UI. When laying out a UI, there are three major things you need to do:": {
      "zh": "å½“åˆ›å»ºä¸€ä¸ªåº”ç”¨ç¨‹åºæ—¶ï¼Œéœ€è¦å­¦ä¹ çš„ç¬¬ä¸€ä¸ªæŠ€èƒ½å°±æ˜¯å¦‚ä½•å¸ƒå±€ç”¨æˆ·ç•Œé¢ï¼Œä¹Ÿå°±æ˜¯ UIã€‚å½“å¸ƒå±€ä¸€ä¸ª UI æ—¶ï¼Œæœ‰ä¸‰ä»¶ä¸»è¦çš„äº‹æƒ…ï¼š",
      "tips": ""
    },
    "Organize your views in different configurations using container views.": {
      "zh": "ä½¿ç”¨ä¸åŒé…ç½®çš„å®¹å™¨è§†å›¾æ¥ç»„ç»‡ä½ çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "Fine tune the sizing, spacing, alignment, and positioning of your views.": {
      "zh": "ç²¾ç»†è°ƒæ•´è§†å›¾çš„å¤§å°ã€é—´è·ã€å¯¹é½å’Œå®šä½ã€‚",
      "tips": ""
    },
    "Debug your views when something goes wrong.": {
      "zh": "åœ¨å‡ºç°é—®é¢˜æ—¶è°ƒè¯•è§†å›¾ã€‚",
      "tips": ""
    },
    "In this sample, youâ€™ll learn all of these skills and more. Ready to start your journey into view layout?": {
      "zh": "åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œä½ å°†å­¦ä¹ ä»¥ä¸Šæ‰€æœ‰æŠ€èƒ½ä»¥åŠæ›´å¤šæ‹“å±•ã€‚å‡†å¤‡å¼€å§‹ä½ çš„è§†å›¾å¸ƒå±€ä¹‹æ—…äº†å—?",
      "tips": ""
    },
    "Organize your views": {
      "zh": "ç»„ç»‡è§†å›¾",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "A view can act as a container that holds and organizes other views, known as subviews. The VStack that holds all of your code is an example of a container view that organizes the two shape subviews vertically.": {
      "zh": "ä¸€ä¸ªè§†å›¾å¯ä»¥å……å½“å®¹å™¨ä»¥å®¹çº³å’Œç»„ç»‡å…¶ä»–è§†å›¾ï¼Œå…¶è¢«ç§°ä¸ºå­è§†å›¾ã€‚åŒ…å«ä½ æ‰€æœ‰ä»£ç çš„ VStack å°±æ˜¯ä¸€ä¸ªå‚ç›´ç»„ç»‡ä¸¤ä¸ªå­è§†å›¾çš„å®¹å™¨è§†å›¾çš„ä¾‹å­ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "Shape views expand to fill the entire space thatâ€™s offered by the container view. Because there are two shape views that need to share the space in the VStack equally, their sizes adapt accordingly.": {
      "zh": "å½¢çŠ¶è§†å›¾ä¼šæ‰©å±•ä»¥å¡«å……å®¹å™¨è§†å›¾æä¾›çš„æ‰€æœ‰ç©ºé—´ã€‚å› ä¸º VStack ä¸­æœ‰ä¸¤ä¸ªå½¢çŠ¶è§†å›¾éœ€è¦å¹³åˆ†ç©ºé—´ï¼Œå®ƒä»¬çš„å¤§å°ä¼šç›¸äº’é€‚åº”ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "You can also organize your views on top of each other using a ZStack. To stack a circle view on top of a rectangle, the views need to be put into a ZStack.": {
      "zh": "ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ ZStack å°†è§†å›¾ç»„ç»‡åœ¨ä¸€èµ·ã€‚è¦åœ¨çŸ©å½¢è§†å›¾ä¸Šé¢å †å ä¸€ä¸ªåœ†å½¢è§†å›¾ï¼Œè¿™äº›è§†å›¾éœ€è¦æ”¾å…¥ä¸€ä¸ª ZStack ä¸­ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "If you want to organize a pair of circles horizontally, you can use an HStack.": {
      "zh": "å¦‚æœä½ æƒ³è¦æ°´å¹³æ”¾ç½®ä¸€å¯¹åœ†å½¢ï¼Œå¯ä»¥ä½¿ç”¨ HStackã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "You may have noticed that you have stacks that contain other stacks. SwiftUI organizes and tracks the relationships of views using a view hierarchy.": {
      "zh": "ä½ å¯èƒ½å·²ç»æ³¨æ„åˆ°ä½ æœ‰åŒ…å«å…¶ä»–å †æ ˆçš„å †æ ˆã€‚SwiftUI ä½¿ç”¨è§†å›¾å±‚æ¬¡ç»“æ„æ¥ç»„ç»‡å’Œè·Ÿè¸ªè§†å›¾ä¹‹é—´çš„å…³ç³»ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "There are more containers than just HStack, VStack, and ZStack views. To explore different containers and how to use them to lay out your content, see Picking container views for your content": {
      "zh": "é™¤äº† HStackã€VStack å’Œ ZStack è§†å›¾ï¼Œè¿˜æœ‰æ›´å¤šçš„å®¹å™¨ã€‚è¦æ¢ç´¢ä¸åŒçš„å®¹å™¨ä»¥åŠå¦‚ä½•ä½¿ç”¨å®ƒä»¬æ¥å¸ƒå±€ä½ çš„å†…å®¹ï¼Œè¯·å‚é˜… ä¸ºä½ çš„å†…å®¹é€‰æ‹©å®¹å™¨è§†å›¾ï¼ˆPicking container views for your contentï¼‰ã€‚",
      "tips": ""
    },
    "Modify and determine view sizes": {
      "zh": "ä¿®æ”¹å’Œç¡®å®šè§†å›¾å¤§å°",
      "tips": ""
    },
    "A SwiftUI View determines its size based on the space offered by its container view. Thatâ€™s why this rectangle is taking up the entire view â€“ because thatâ€™s what the parent VStack is doing.": {
      "zh": "ä¸€ä¸ª SwiftUI è§†å›¾æ ¹æ®å…¶å®¹å™¨è§†å›¾æä¾›çš„ç©ºé—´æ¥ç¡®å®šå…¶å¤§å°ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆè¿™ä¸ªçŸ©å½¢å æ®äº†æ•´ä¸ªè§†å›¾ - å› ä¸ºè¿™å°±æ˜¯çˆ¶ VStack æ­£åœ¨åšçš„ã€‚",
      "tips": ""
    },
    "Tip": {
      "zh": "æç¤º",
      "tips": ""
    },
    "Different views have different space requirements; not all views take up the same amount of space.": {
      "zh": "ä¸åŒçš„è§†å›¾æœ‰ä¸åŒçš„ç©ºé—´è¦æ±‚ï¼›å¹¶éæ‰€æœ‰è§†å›¾éƒ½å ç”¨ç›¸åŒçš„ç©ºé—´é‡ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨æ„",
      "tips": ""
    },
    "Often times you need to add size constraints to images since they can be extremely large.": {
      "zh": "é€šå¸¸éœ€è¦ä¸ºå›¾åƒæ·»åŠ å¤§å°çº¦æŸï¼Œå› ä¸ºå›¾åƒå¯èƒ½éå¸¸å¤§ã€‚",
      "tips": ""
    },
    "Because all views are unique, different types of views have their own space requirements within a container. This is why the Rectangle view adjusts how much space it takes up, but the Text and Image only take up as much space as they need.": {
      "zh": "å› ä¸ºæ‰€æœ‰è§†å›¾éƒ½æ˜¯ç‹¬ç‰¹çš„ï¼Œæ‰€ä»¥ä¸åŒç±»å‹çš„è§†å›¾åœ¨å®¹å™¨ä¸­çš„ç©ºé—´éœ€æ±‚ä¹Ÿä¸åŒã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆ Rectangle è§†å›¾å ç”¨å…¶æ‰€æ‹¥æœ‰çš„ç©ºé—´å¤§å°ï¼Œè€Œ Text å’Œ Image åªå ç”¨å®ƒä»¬æ‰€éœ€çš„ç©ºé—´ã€‚",
      "tips": ""
    },
    "A view can also maintain a specific size that doesnâ€™t change, like Stepper.": {
      "zh": "ä¸€ä¸ªè§†å›¾ä¹Ÿå¯ä»¥ä¿æŒç‰¹å®šçš„å¤§å°ä¸å˜ï¼Œæ¯”å¦‚ Stepperã€‚",
      "tips": ""
    },
    "To adjust the amount of space views need, you can specify which view needs to take up more space. The frame(width:height:alignment:) allows you to adjust the size of a view. The frame modifier is setting a specific height and width for the rose image view.": {
      "zh": "è¦è°ƒæ•´è§†å›¾æ‰€éœ€çš„ç©ºé—´é‡ï¼Œå¯ä»¥æŒ‡å®šå“ªä¸ªè§†å›¾éœ€è¦å ç”¨æ›´å¤šç©ºé—´ã€‚frame(width:height:alignment:) å…è®¸è°ƒæ•´è§†å›¾çš„å¤§å°ã€‚frame ä¿®é¥°ç¬¦æ­£åœ¨ä¸º rose å›¾åƒè§†å›¾è®¾ç½®ç‰¹å®šçš„é«˜åº¦å’Œå®½åº¦ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ä¸ƒæ­¥",
      "tips": ""
    },
    "Providing fixed values for the width and height limits how adaptive the view can be. ğŸ™ƒ": {
      "zh": "ä¸ºå®½åº¦å’Œé«˜åº¦æä¾›å›ºå®šå€¼ä¼šé™åˆ¶è§†å›¾çš„è‡ªé€‚åº”èƒ½åŠ›ã€‚ğŸ™ƒ",
      "tips": ""
    },
    "A better way to do this is to give a maximum, minimum, or ideal width and height for a view. This allows the view to resize as necessary based on how much space is available in the container.": {
      "zh": "æ›´å¥½çš„æ–¹æ³•æ˜¯ä¸ºè§†å›¾çš„å®½åº¦å’Œé«˜åº¦æä¾›æœ€å¤§å€¼ã€æœ€å°å€¼æˆ–ç†æƒ³å€¼ã€‚è¿™å…è®¸è§†å›¾æ ¹æ®å®¹å™¨ä¸­å¯ç”¨çš„ç©ºé—´è¿›è¡Œå¿…è¦çš„è°ƒæ•´å¤§å°ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "ç¬¬å…«æ­¥",
      "tips": ""
    },
    "When you use the frame modifer on an Image it only affects the size of the displayed image if you first use the .resizable modifier to indicate that you want the image to be resized as its frame changes.": {
      "zh": "å½“ä½ å¯¹ Image ä½¿ç”¨ frame ä¿®é¥°ç¬¦æ—¶ï¼Œå¦‚æœä½ å…ˆä½¿ç”¨ .resizable ä¿®é¥°ç¬¦æ¥æŒ‡æ˜ä½ å¸Œæœ›å›¾åƒéšç€å…¶ frame çš„æ”¹å˜è€Œè°ƒæ•´å¤§å°ï¼Œå®ƒåªä¼šå½±å“æ˜¾ç¤ºå›¾åƒçš„å¤§å°ã€‚",
      "tips": ""
    },
    "Warning": {
      "zh": "è­¦å‘Š",
      "tips": ""
    },
    "Adding resizable after frame causes a compiler error. Applying the frame modifier to the Image actually creates a new view thatâ€™s no longer an Image, so it doesnâ€™t have access to the resizable modifier.": {
      "zh": "åœ¨ frame ä¹‹åæ·»åŠ  resizable ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ã€‚åº”ç”¨ frame ä¿®é¥°ç¬¦å®é™…ä¸Šä¼šåˆ›å»ºä¸€ä¸ªä¸å†æ˜¯ Image çš„æ–°è§†å›¾ï¼Œæ‰€ä»¥å®ƒæ— æ³•è®¿é—® resizable ä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "ç¬¬ä¹æ­¥",
      "tips": ""
    },
    "Using both can help get a precise size for an image that is not distorted or too large.": {
      "zh": "åŒæ—¶ä½¿ç”¨ä¸¤è€…å¯ä»¥å¸®åŠ©è·å¾—å…·æœ‰ç²¾ç¡®å¤§å°çš„å›¾åƒï¼Œä¸ä¼šå˜å½¢æˆ–è¿‡å¤§ã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "ç¬¬åæ­¥",
      "tips": ""
    },
    "If you want to make the text bigger or different than the default, you can add the font(_:) modifier to your Text view.": {
      "zh": "å¦‚æœä½ æƒ³è®©æ–‡æœ¬å˜å¤§æˆ–ä¸é»˜è®¤ä¸åŒï¼Œå¯ä»¥ç»™ Text è§†å›¾æ·»åŠ  font(:) ä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    },
    "If you add the frame to the Text view, the actual text inside the view doesnâ€™t change â€” it makes the view holding the text larger. This allows for more text to fit into the view.": {
      "zh": "å¦‚æœä½ ç»™ Text è§†å›¾æ·»åŠ  frameï¼Œå®é™…æ–‡æœ¬å†…å®¹ä¸ä¼šæ”¹å˜ - å®ƒä½¿æ–‡æœ¬è§†å›¾å˜å¤§ã€‚è¿™å…è®¸æ›´å¤šæ–‡æœ¬é€‚åº”è§†å›¾ã€‚",
      "tips": ""
    },
    "Refine the spacing and alignment of your views": {
      "zh": "è°ƒæ•´è§†å›¾çš„é—´è·å’Œå¯¹é½",
      "tips": ""
    },
    "There are multiple ways to specify alignment in SwiftUI. One way is to specify the alignment inside HStack, VStack, or ZStack. The default alignment for a VStack is centered.": {
      "zh": "åœ¨ SwiftUI ä¸­æœ‰å¤šç§æ–¹å¼æ¥æŒ‡å®šå¯¹é½ã€‚ä¸€ç§æ–¹å¼æ˜¯åœ¨ HStackã€VStack æˆ– ZStack ä¸­æŒ‡å®šå¯¹é½ã€‚VStack çš„é»˜è®¤å¯¹é½æ˜¯å±…ä¸­ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®éªŒ",
      "tips": ""
    },
    "Try adding in the alignment: .leading parameter to your VStack and see what happens.": {
      "zh": "å°è¯•åœ¨ä½ çš„ VStack ä¸­æ·»åŠ  alignment: .leading å‚æ•°,çœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆã€‚",
      "tips": ""
    },
    "Adding the alignment: .leading parameter to your VStack aligns the books to the left edge of the screen. This is because the VStack is the container view and the images and shapes are subviews.": {
      "zh": "åœ¨ VStack ä¸­æ·»åŠ  alignment: .leading å‚æ•°ä¼šä½¿ä¹¦å¯¹é½åˆ°å±å¹•å·¦ä¾§ã€‚è¿™æ˜¯å› ä¸º VStack æ˜¯å®¹å™¨è§†å›¾ï¼Œå›¾åƒå’Œå½¢çŠ¶æ˜¯å­è§†å›¾ã€‚",
      "tips": ""
    },
    "A different way to add a row of books aligned to the right edge of the shelf is by adding a VStack and setting its alignment to .trailing.": {
      "zh": "å°†ä¹¦å¯¹é½åˆ°ä¹¦æ¶å³ä¾§çš„å¦ä¸€ç§æ–¹æ³•æ˜¯æ·»åŠ  VStack å¹¶å°†å…¶å¯¹é½è®¾ç½®ä¸º .trailingã€‚",
      "tips": ""
    },
    "In vertical stacks, you can only set the horizontal alignment, like .leading or .trailing.": {
      "zh": "åœ¨å‚ç›´å †æ ˆä¸­ï¼Œä½ åªèƒ½è®¾ç½®æ°´å¹³å¯¹é½ï¼Œå¦‚ .leading æˆ– .trailingã€‚",
      "tips": ""
    },
    "In horizontal stacks you can only set the vertical alignment, like .top or .bottom.": {
      "zh": "åœ¨æ°´å¹³å †æ ˆä¸­ä½ åªèƒ½è®¾ç½®å‚ç›´å¯¹é½ï¼Œå¦‚ .top æˆ– .bottomã€‚",
      "tips": ""
    },
    "Another way to align books to the other side of the shelf is to use a frame modifier and specify the alignment.": {
      "zh": "å°†ä¹¦å¯¹é½åˆ°ä¹¦æ¶å¦ä¸€ä¾§çš„å¦ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ frame ä¿®é¥°ç¬¦å¹¶æŒ‡å®šå¯¹é½æ–¹å¼ã€‚",
      "tips": ""
    },
    "By setting the maxWidth to .infinity, you stretch the Image view horizontally until it fills the remaining space. Setting alignment parameter to .trailing makes the frame contents align to the .trailing edge.": {
      "zh": "é€šè¿‡å°† maxWidth è®¾ç½®ä¸º .infinityï¼Œä½ å¯ä»¥æ°´å¹³æ‹‰ä¼¸ Image è§†å›¾ç›´åˆ°å¡«æ»¡å‰©ä½™ç©ºé—´ã€‚å°† alignment å‚æ•°è®¾ç½®ä¸º .trailing ä¼šä½¿ frame å†…å®¹å¯¹é½åˆ° .trailing è¾¹ç¼˜ã€‚",
      "tips": ""
    },
    "But wait, thereâ€™s more! You can also create space in a view with a Spacer.": {
      "zh": "ä½†æ˜¯ç­‰ç­‰ï¼ä½ è¿˜å¯ä»¥ä½¿ç”¨ Spacer åœ¨è§†å›¾ä¸­åˆ›å»ºç©ºé—´ã€‚",
      "tips": ""
    },
    "Add a yellow background color to the image next to the Spacer to visualize how much space itâ€™s creating.": {
      "zh": "åœ¨ Spacer æ—è¾¹çš„å›¾åƒæ·»åŠ ä¸€ä¸ªé»„è‰²èƒŒæ™¯è‰²ï¼Œä»¥å¯è§†åŒ–å®ƒåˆ›å»ºäº†å¤šå°‘ç©ºé—´ã€‚",
      "tips": ""
    },
    "Adding a Spacer inside an HStack causes the stack to expand to fill in any remaining horizontal space, and pushes the Image view to the .trailing edge.": {
      "zh": "åœ¨ HStack ä¸­æ·»åŠ  Spacer ä¼šå¯¼è‡´å †æ ˆæ‰©å±•ä»¥å¡«å……ä»»ä½•å‰©ä½™çš„æ°´å¹³ç©ºé—´ï¼Œå¹¶å°† Image è§†å›¾æ¨åˆ° .trailing è¾¹ç¼˜ã€‚",
      "tips": ""
    },
    "The Spacer only fills in the empty space in the HStack. On the contrary, if there is no space available for the spacer, it wonâ€™t render.": {
      "zh": "Spacer åªå¡«å…… HStack ä¸­çš„ç©ºç™½ç©ºé—´ã€‚ç›¸åï¼Œå¦‚æœæ²¡æœ‰å¯ç”¨çš„ç©ºé—´ä¾› spacer ä½¿ç”¨ï¼Œå®ƒå°±ä¸ä¼šæ¸²æŸ“ã€‚",
      "tips": ""
    },
    "You just learned about three different ways to align your views. Using the alignment parameter in the container view, adding a frame modifier with the alignment parameter and utilizing a Spacer are all great ways to align your views.": {
      "zh": "ä½ åˆšæ‰å­¦ä¹ äº†ä¸‰ç§ä¸åŒçš„æ–¹æ³•æ¥å¯¹é½ä½ çš„è§†å›¾ã€‚ä½¿ç”¨å®¹å™¨è§†å›¾ä¸­çš„å¯¹é½å‚æ•°ã€æ·»åŠ å…·æœ‰å¯¹é½å‚æ•°çš„ frame ä¿®é¥°ç¬¦å’Œåˆ©ç”¨ Spacer éƒ½æ˜¯ç”¨æ¥å¯¹é½ä½ çš„è§†å›¾çš„å¥½æ–¹æ³•ã€‚",
      "tips": ""
    },
    "Different types of views and circumstances require different techniques. To learn more about the size and spacing of views, see Laying out a simple view.": {
      "zh": "ä¸åŒç±»å‹çš„è§†å›¾å’Œç¯å¢ƒéœ€è¦ä¸åŒçš„æŠ€æœ¯ã€‚è¦äº†è§£æ›´å¤šå…³äºè§†å›¾å¤§å°å’Œé—´è·çš„ä¿¡æ¯ï¼Œè¯·å‚é˜… å¸ƒå±€ä¸€ä¸ªç®€å•çš„è§†å›¾ï¼ˆLaying out a simple viewï¼‰ã€‚",
      "tips": ""
    },
    "You can also specify the spacing as a parameter for the HStack. This changes the horizontal spacing between every subview inside the HStack.": {
      "zh": "ä½ ä¹Ÿå¯ä»¥å°†é—´è·ä½œä¸ºå‚æ•°æŒ‡å®šç»™ HStackã€‚è¿™ä¼šæ”¹å˜ HStack ä¸­æ¯ä¸ªå­è§†å›¾ä¹‹é—´çš„æ°´å¹³é—´è·ã€‚",
      "tips": ""
    },
    "Step 11": {
      "zh": "ç¬¬ 11 æ­¥",
      "tips": ""
    },
    "You can also add padding to the .trailing edge the image view to position it further from the edge.": {
      "zh": "ä½ ä¹Ÿå¯ä»¥åœ¨å›¾åƒè§†å›¾çš„ .trailing è¾¹ç¼˜æ·»åŠ å¡«å……ï¼Œå°†å…¶ä¸è¾¹ç¼˜éš”å¼€ã€‚",
      "tips": ""
    },
    "Explore other padding options such as .leading, .top, .bottom, .horizontal, and so on.": {
      "zh": "å°è¯•å…¶ä»–å¡«å……é€‰é¡¹ï¼Œå¦‚ .leadingã€.topã€.bottomã€.horizontal ç­‰ã€‚",
      "tips": ""
    },
    "Step 12": {
      "zh": "ç¬¬ 12 æ­¥",
      "tips": ""
    },
    "You could add horizontal padding to every row of shelves and books, but thatâ€™s a lot of work and not easy to maintain. Instead, apply modifiers to the container view. In this case, the container is the VStack.": {
      "zh": "ä½ å¯ä»¥ä¸ºæ¯ä¸ªä¹¦æ¶å’Œä¹¦ç±çš„è¡Œæ·»åŠ æ°´å¹³å¡«å……ï¼Œä½†è¿™éœ€è¦å¾ˆå¤šå·¥ä½œä¸”ä¸æ˜“ç»´æŠ¤ã€‚ç›¸åï¼Œä½ åº”è¯¥å°†ä¿®é¥°ç¬¦åº”ç”¨äºå®¹å™¨è§†å›¾ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œå®¹å™¨æ˜¯ VStackã€‚",
      "tips": ""
    },
    "By applying the padding modifier to the VStack, you only have to add it once instead of adding it to every subview inside the VStack.": {
      "zh": "é€šè¿‡å°†å¡«å……ä¿®é¥°ç¬¦åº”ç”¨åˆ° VStackï¼Œä½ åªéœ€è¦æ·»åŠ ä¸€æ¬¡ï¼Œè€Œä¸å¿…å°†å…¶æ·»åŠ åˆ° VStack å†…çš„æ¯ä¸ªå­è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 13": {
      "zh": "ç¬¬ 13 æ­¥",
      "tips": ""
    },
    "However, if you want your bookshelf to have a specific width, use a frame instead of padding. Adding a border after the frame helps you visualize the frame.": {
      "zh": "ç„¶è€Œ,å¦‚æœä½ å¸Œæœ›ä¹¦æ¶å…·æœ‰ç‰¹å®šçš„å®½åº¦ï¼Œè¯·ä½¿ç”¨ frame è€Œä¸æ˜¯å¡«å……ã€‚åœ¨ frame ä¹‹åæ·»åŠ è¾¹æ¡†æœ‰åŠ©äºå¯è§†åŒ– frameã€‚",
      "tips": ""
    },
    "Step 14": {
      "zh": "ç¬¬ 14 æ­¥",
      "tips": ""
    },
    "Woohoo! Now you have all the tools to create your own views.": {
      "zh": "å¤ªæ£’äº†ï¼ç°åœ¨ä½ å·²ç»æŒæ¡äº†æ‰€æœ‰åˆ›å»ºè‡ªå·±è§†å›¾çš„å·¥å…·ã€‚",
      "tips": ""
    },
    "Debugging views": {
      "zh": "è°ƒè¯•è§†å›¾",
      "tips": ""
    },
    "When your SwiftUI views donâ€™t show up as you expect, youâ€™ll need to flex your debugging skills to fix them. Start by looking at the view displayed in the preview â€” itâ€™s clearly not showing up correctly! ğŸ˜© Can you guess what this view is supposed to be?": {
      "zh": "å½“ä½ çš„ SwiftUI è§†å›¾æ²¡æœ‰æŒ‰é¢„æœŸæ˜¾ç¤ºæ—¶ï¼Œä½ éœ€è¦å‘æŒ¥è°ƒè¯•æŠ€å·§æ¥è§£å†³å®ƒä»¬ã€‚é¦–å…ˆçœ‹é¢„è§ˆä¸­æ˜¾ç¤ºçš„è§†å›¾ - å®ƒæ˜æ˜¾æ²¡æœ‰æ­£ç¡®æ˜¾ç¤ºå‡ºæ¥ï¼ğŸ˜© ä½ èƒ½çŒœå‡ºè¿™ä¸ªè§†å›¾åº”è¯¥æ˜¯ä»€ä¹ˆå—ï¼Ÿ",
      "tips": ""
    },
    "Itâ€™s the queen of hearts playing card (or, itâ€™s supposed to be ğŸ˜µâ€ğŸ’«). As the name suggests, HalfCard contains half a card. You use two HalfCard instances in a VStack to create this view. Then, flip the bottom HalfCard upside down to form a mirror image of the top HalfCard. By combining the top and bottom halves, you create a full playing card.": {
      "zh": "è¿™æ˜¯ä¸€ä¸ªçº¢å¿ƒçš‡åçš„æ‰‘å…‹ç‰Œ(æˆ–è€…ï¼Œåº”è¯¥æ˜¯ä¸€ä¸ªçº¢å¿ƒçš‡åğŸ¤”)ã€‚é¡¾åæ€ä¹‰ï¼ŒHalfCard åŒ…å«åŠå¼ ç‰Œã€‚ä½ åœ¨ VStack ä¸­ä½¿ç”¨ä¸¤ä¸ª HalfCard å®ä¾‹æ¥åˆ›å»ºè¿™ä¸ªè§†å›¾ã€‚ç„¶åï¼Œå°†åº•éƒ¨çš„ HalfCard ç¿»è½¬æˆé¡¶éƒ¨ HalfCard çš„é•œåƒã€‚é€šè¿‡ç»„åˆé¡¶éƒ¨å’Œåº•éƒ¨çš„ä¸€åŠï¼Œä½ å¯ä»¥åˆ›å»ºä¸€æ•´å¼ æ‰‘å…‹ç‰Œã€‚",
      "tips": ""
    },
    "Any code applied to the HalfCard view affects both the top and bottom halves of the card, allowing you to fix issues in both halves at the same time.": {
      "zh": "åº”ç”¨äº HalfCard è§†å›¾çš„ä»»ä½•ä»£ç éƒ½ä¼šå½±å“ç‰Œçš„é¡¶éƒ¨å’Œåº•éƒ¨ä¸¤åŠï¼Œå› æ­¤å¯ä»¥åŒæ—¶ä¿®å¤ä¸¤åŠä¸­çš„é—®é¢˜ã€‚",
      "tips": ""
    },
    "Adding a border to a view is a great debugging tool because it allows you to see how much space a view occupies. You can use this technique to diagnose lots of issues in your code.": {
      "zh": "å‘è§†å›¾æ·»åŠ è¾¹æ¡†æ˜¯å¾ˆå¥½çš„è°ƒè¯•å·¥å…·ï¼Œå› ä¸ºå®ƒå…è®¸ä½ çœ‹åˆ°è§†å›¾å ç”¨äº†å¤šå°‘ç©ºé—´ã€‚ä½ å¯ä»¥ä½¿ç”¨è¿™ç§æŠ€æœ¯æ¥è¯Šæ–­ä»£ç ä¸­çš„è®¸å¤šé—®é¢˜ã€‚",
      "tips": ""
    },
    "The first major problem here is that all of the graphics are squished together. Add a frame in HalfCard and set the maxWidth and maxHeight to .infinity. This allows the frame to expand to fill any available space offered by the container, VStack.": {
      "zh": "è¿™é‡Œçš„ç¬¬ä¸€ä¸ªä¸»è¦é—®é¢˜æ˜¯æ‰€æœ‰å›¾å½¢éƒ½è¢«æŒ¤åœ¨ä¸€èµ·ã€‚åœ¨ HalfCard ä¸­æ·»åŠ  frame å¹¶å°† maxWidth å’Œ maxHeight è®¾ç½®ä¸º .infinityã€‚è¿™å…è®¸ frame æ‰©å±•ä»¥å¡«å……å®¹å™¨ VStack æä¾›çš„ä»»ä½•å¯ç”¨ç©ºé—´ã€‚",
      "tips": ""
    },
    "Even though the frame expanded, all of the graphics are still squished together. Add another border above the frame modifier. This allows you to see the outline of the VStack before you apply the frame.": {
      "zh": "å³ä½¿ frame æ‰©å±•äº†ï¼Œæ‰€æœ‰çš„å›¾å½¢ä»ç„¶æŒ¤åœ¨ä¸€èµ·ã€‚åœ¨ frame ä¿®é¥°ç¬¦ä¸Šé¢å†æ·»åŠ ä¸€ä¸ªè¾¹æ¡†ã€‚è¿™ä½¿ä½ å¯ä»¥çœ‹åˆ°åº”ç”¨ frame ä¹‹å‰ VStack çš„è½®å»“ã€‚",
      "tips": ""
    },
    "You might wonder, why would it make a difference if you apply the border before or after the frame? This is because you actually produce a new view each time you apply a modifier, so the order that you apply them really matters. See Configuring views for more on this.": {
      "zh": "ä½ å¯èƒ½ä¼šæƒ³ï¼Œåœ¨ frame ä¹‹å‰æˆ–ä¹‹åæ·»åŠ è¾¹æ¡†æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿè¿™æ˜¯å› ä¸ºæ¯æ¬¡åº”ç”¨ä¿®é¥°ç¬¦å®é™…ä¸Šä¼šäº§ç”Ÿä¸€ä¸ªæ–°çš„è§†å›¾ï¼Œæ‰€ä»¥åº”ç”¨å®ƒä»¬çš„é¡ºåºçœŸçš„å¾ˆé‡è¦ã€‚æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… é…ç½®è§†å›¾ï¼ˆConfiguring viewsï¼‰ã€‚",
      "tips": ""
    },
    "Look at the difference in the blue and green borders. The blue border surrounds the squished graphics in the VStack, but doesnâ€™t expand into the empty surrounding space of the green frame.": {
      "zh": "çœ‹çœ‹è“è‰²å’Œç»¿è‰²è¾¹æ¡†çš„åŒºåˆ«ã€‚è“è‰²è¾¹æ¡†åŒ…å›´ç€ VStack ä¸­æŒ¤åœ¨ä¸€èµ·çš„å›¾å½¢ï¼Œä½†æ²¡æœ‰æ‰©å±•åˆ°ç»¿è‰² frame å‘¨å›´çš„ç©ºç™½ç©ºé—´ã€‚",
      "tips": ""
    },
    "Can you think of anyway to fix this so the contents of the VStack fill the entire frame?": {
      "zh": "ä½ èƒ½æƒ³åˆ°ä»»ä½•æ–¹æ³•æ¥ä¿®å¤è¿™ä¸ªé—®é¢˜ï¼Œä»¥ä¾¿ VStack çš„å†…å®¹å¡«å……æ•´ä¸ª frame å—ï¼Ÿ",
      "tips": ""
    },
    "What if you switched up the order of the overlay and the frame? That would allow you to expand the frame first, which gives you extra space, then apply the overlay where it fits.": {
      "zh": "å¦‚æœä½ æ”¹å˜ overlay å’Œ frame çš„é¡ºåºä¼šæ€æ ·ï¼Ÿè¿™å°†å…è®¸ä½ å…ˆæ‰©å±• frameï¼Œè¿™ç»™äº†ä½ é¢å¤–çš„ç©ºé—´ï¼Œç„¶ååº”ç”¨é€‚åº”å¤§å°çš„ overlayã€‚",
      "tips": ""
    },
    "Try removing the existing frame and add a new one right below the top-level VStack.": {
      "zh": "å°è¯•åˆ é™¤ç°æœ‰çš„ frameï¼Œå¹¶åœ¨é¡¶å±‚ VStack ä¸‹é¢æ·»åŠ ä¸€ä¸ªæ–°çš„ã€‚",
      "tips": ""
    },
    "There is just one more thing to fix. By default any content inside the frame is center-aligned. However, the crown at the center of the HalfCard needs to align to the bottom edge of HalfCard.": {
      "zh": "åªå‰©ä¸‹ä¸€ä»¶äº‹è¦ä¿®å¤ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œframe å†…çš„ä»»ä½•å†…å®¹éƒ½æ˜¯å±…ä¸­å¯¹é½çš„ã€‚ç„¶è€Œï¼ŒHalfCard ä¸­å¿ƒçš„çš‡å† éœ€è¦å¯¹é½åˆ° HalfCard çš„åº•è¾¹ã€‚",
      "tips": ""
    },
    "Can you figure out a way to make this happen? Remember that you can add a border to visualize how much space your view needs and compare it to how you think the view should behave.": {
      "zh": "ä½ èƒ½æƒ³åˆ°ä»»ä½•åŠæ³•æ¥å®ç°è¿™ä¸€ç›®çš„å—ï¼Ÿè®°ä½ï¼Œä½ å¯ä»¥æ·»åŠ è¾¹æ¡†æ¥å¯è§†åŒ–ä½ çš„è§†å›¾éœ€è¦å¤šå°‘ç©ºé—´ï¼Œå¹¶å°†å…¶ä¸ä½ è®¤ä¸ºçš„è§†å›¾åº”è¯¥å¦‚ä½•è¡¨ç°è¿›è¡Œæ¯”è¾ƒã€‚",
      "tips": ""
    },
    "There are two ways to align the crown to the bottom of your HalfCard view. You can add the alignment parameter to the frameâ€“ .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .bottom) Or, add a Spacer above the crown.": {
      "zh": "æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥å°†çš‡å† å¯¹é½åˆ° HalfCard è§†å›¾çš„åº•éƒ¨ã€‚ä½ å¯ä»¥åœ¨ frame ä¸­æ·»åŠ å¯¹é½å‚æ•° - .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .bottom) æˆ–è€…åœ¨çš‡å† ä¸Šæ–¹æ·»åŠ ä¸€ä¸ª Spacerã€‚",
      "tips": ""
    },
    "Now that you have fixed the alignment in this card, you can remove any borders that youâ€™ve added.": {
      "zh": "ç°åœ¨ä½ å·²ç»ä¿®å¤äº†è¿™å¼ ç‰Œä¸­çš„å¯¹é½ï¼Œå¯ä»¥åˆ é™¤ä½ é¢å¤–æ·»åŠ çš„è¾¹æ¡†ã€‚",
      "tips": ""
    },
    "Look at that beautiful playing card! The next time youâ€™re unsure why your views arenâ€™t displaying the way you want them to, donâ€™t forget that you can add a border or background to help you debug issues with your views.": {
      "zh": "çœ‹é‚£æ¼‚äº®çš„æ‰‘å…‹ç‰Œï¼ä¸‹æ¬¡å½“ä½ ä¸ç¡®å®šè§†å›¾ä¸ºä»€ä¹ˆæ²¡æœ‰æŒ‰ä½ æƒ³è¦çš„æ–¹å¼æ˜¾ç¤ºæ—¶ï¼Œä¸è¦å¿˜è®°ä½ å¯ä»¥æ·»åŠ è¾¹æ¡†æˆ–èƒŒæ™¯æ¥å¸®åŠ©è°ƒè¯•è§†å›¾ä¸­çš„é—®é¢˜ã€‚",
      "tips": ""
    },
    "Bringing it all together": {
      "zh": "æŠŠå®ƒä»¬ç»“åˆåœ¨ä¸€èµ·",
      "tips": ""
    },
    "Now that youâ€™ve gone through all of the different parts for laying out a view, itâ€™s time to bring them all together to see how you can use it when creating a view for a real app.": {
      "zh": "ç°åœ¨ä½ å·²ç»éå†äº†å¸ƒå±€è§†å›¾çš„ä¸åŒéƒ¨åˆ†ï¼Œæ˜¯æ—¶å€™æŠŠå®ƒä»¬ç»“åˆèµ·æ¥ï¼Œçœ‹çœ‹åœ¨ä¸ºçœŸå®åº”ç”¨ç¨‹åºåˆ›å»ºè§†å›¾æ—¶ä½ å¯ä»¥å¦‚ä½•ä½¿ç”¨å®ƒã€‚",
      "tips": ""
    },
    "Start by setting height of your card. There are many different ways to lay out a view and using .frame(minHeight:maxHeight:) is just one way you can set the height.": {
      "zh": "é¦–å…ˆè®¾ç½®å¡ç‰‡çš„é«˜åº¦ã€‚æœ‰è®¸å¤šä¸åŒçš„æ–¹æ³•å¯ä»¥å¸ƒå±€è§†å›¾ï¼Œä½¿ç”¨ .frame(minHeight:maxHeight:) åªæ˜¯è®¾ç½®é«˜åº¦çš„ä¸€ç§æ–¹å¼ã€‚",
      "tips": ""
    },
    "Setting the minHeight and maxHeight allows the view to scale for different screen sizes.": {
      "zh": "è®¾ç½® minHeight å’Œ maxHeight å…è®¸è§†å›¾æ ¹æ®ä¸åŒçš„å±å¹•å°ºå¯¸è¿›è¡Œç¼©æ”¾ã€‚",
      "tips": ""
    },
    "Push the card title to the edge by setting the maximum height to .infinity.": {
      "zh": "é€šè¿‡è®¾ç½®æœ€å¤§é«˜åº¦ä¸º .infinityï¼Œå¯ä»¥å°†å¡ç‰‡æ ‡é¢˜æ¨åˆ°è¾¹ç¼˜ã€‚",
      "tips": ""
    },
    "With the card title aligned, add padding to create space between the title of the view and the edge of the card. By adding padding to the VStack, you are applying padding to every view within the VStack.": {
      "zh": "å¯¹é½å¡ç‰‡æ ‡é¢˜åï¼Œæ·»åŠ å¡«å……ä»¥åœ¨æ ‡é¢˜å’Œå¡ç‰‡è¾¹ç¼˜ä¹‹é—´åˆ›å»ºç©ºé—´ã€‚",
      "tips": ""
    },
    "Having a .frame modifier with a maxWidth of .infinity stretches the Text view horizontally and fills the available space. The alignment parameter ensures that any content inside the frame aligns to the leading edge.": {
      "zh": "å…·æœ‰ .frame ä¿®é¥°ç¬¦çš„ Text è§†å›¾çš„ maxWidth è®¾ç½®ä¸º .infinity ä¼šæ°´å¹³æ‹‰ä¼¸ Text è§†å›¾å¹¶å¡«å……å¯ç”¨ç©ºé—´ã€‚alignment å‚æ•°ç¡®ä¿ frame å†…çš„ä»»ä½•å†…å®¹éƒ½å¯¹é½åˆ° leading è¾¹ç¼˜ã€‚",
      "tips": ""
    },
    "You want the emojis to be in the middle of the view. To make sure they arenâ€™t squished in the middle of the view, set the maxWidth to infinity.": {
      "zh": "ä½ å¸Œæœ›è¡¨æƒ…ç¬¦å·ä½äºè§†å›¾çš„ä¸­é—´ã€‚ä¸ºäº†ç¡®ä¿å®ƒä»¬ä¸ä¼šåœ¨è§†å›¾ä¸­é—´è¢«æŒ¤å‹ï¼Œè¯·å°† maxWidth è®¾ç½®ä¸º infinityã€‚",
      "tips": ""
    },
    "To add a gap between the circular buttons and the emojis you need to add padding below the text.": {
      "zh": "è¦åœ¨åœ†å½¢æŒ‰é’®å’Œè¡¨æƒ…ç¬¦å·ä¹‹é—´æ·»åŠ é—´éš™ï¼Œéœ€è¦åœ¨æ–‡æœ¬ä¸‹æ–¹æ·»åŠ å¡«å……ã€‚",
      "tips": ""
    },
    "You are now on your way to being a SwiftUI view layout expert!": {
      "zh": "ä½ ç°åœ¨åœ¨æˆä¸º SwiftUI è§†å›¾å¸ƒå±€ä¸“å®¶çš„è·¯ä¸Šï¼",
      "tips": ""
    },
    "Try it out yourself by going to the Swift Playgrounds App to practice laying out views for a journal app!": {
      "zh": "å°è¯•ç€å» Swift Playgrounds App ç»ƒä¹ ä¸ºæ—¥è®°åº”ç”¨å¸ƒå±€è§†å›¾å§ï¼â€™",
      "tips": ""
    },
    "Meme Creator": {
      "zh": "Meme åˆ¶ä½œå™¨",
      "tips": ""
    },
    "Fetch structured data from a server asynchronously.": {
      "zh": "ä»æœåŠ¡å™¨å¼‚æ­¥è·å–ç»“æ„åŒ–æ•°æ®ã€‚",
      "tips": ""
    },
    "Notice that there are Text and Image views in your VStack. No matter how big the screen youâ€™re using, the Text and Image views take up exactly the amount of space they need depending on the size of the content.": {
      "zh": "è¯·æ³¨æ„ï¼ŒVStack ä¸­æœ‰ Text å’Œ Image è§†å›¾ã€‚æ— è®ºä½¿ç”¨å¤šå¤§çš„å±å¹•ï¼ŒText å’Œ Image è§†å›¾æ‰€å ç”¨çš„ç©ºé—´è·Ÿå†…å®¹çš„å¤§å°å®Œå…¨ä¸€æ ·ã€‚",
      "tips": ""
    },
    "Views can also resize to fit their content such as Text(â€œSupercalifragilisticexpialidociousâ€) or Image(\"myCoolImage\").": {
      "zh": "è§†å›¾ä¹Ÿå¯ä»¥è°ƒæ•´å¤§å°ä»¥é€‚åº”å…¶å†…å®¹ï¼Œå¦‚ Text(â€œSupercalifragilisticexpialidociousâ€) æˆ– Image(\"myCoolImage\")ã€‚",
      "tips": ""
    },
    "Views are somewhat magical, in that certain view types control how they resize when placed in a container. They can expand to fill the available space, such as Rectangle or other Shape.": {
      "zh": "è§†å›¾æœ‰ç‚¹ç¥å¥‡ï¼ŒæŸäº›è§†å›¾ç±»å‹å¯ä»¥æ§åˆ¶å®ƒä»¬è¢«æ”¾ç½®åœ¨å®¹å™¨ä¸­æ—¶å¦‚ä½•è°ƒæ•´å¤§å°ã€‚å®ƒä»¬å¯ä»¥æ‰©å±•ä»¥å¡«å……å¯ç”¨ç©ºé—´ï¼Œä¾‹å¦‚ Rectangle æˆ–å…¶ä»– Shapeã€‚",
      "tips": ""
    },
    "Adding a frame to an image can sometimes cause it to look stretched even by adding an ideal width and height. For images, itâ€™s often better to use scaledToFill() or scaledToFit() instead of a frame.": {
      "zh": "å³ä½¿æ·»åŠ äº†ç†æƒ³çš„å®½åº¦å’Œé«˜åº¦ï¼Œåœ¨å›¾åƒä¸Šæ·»åŠ  frame æœ‰æ—¶ä¼šå¯¼è‡´å›¾åƒçœ‹èµ·æ¥æ‹‰ä¼¸ã€‚å¯¹äºå›¾åƒï¼Œä½¿ç”¨ scaledToFill() æˆ– scaledToFit() é€šå¸¸æ¯”ä½¿ç”¨ frame æ›´å¥½ã€‚",
      "tips": ""
    }
  },
  "sample-apps/memecreator": {
    "Meme Creator": {
      "zh": "",
      "tips": ""
    },
    "Fetch structured data from a server asynchronously.": {
      "zh": "ä»¥å¼‚æ­¥æ–¹å¼ä»æœåŠ¡å™¨è·å–ç»“æ„åŒ–æ•°æ®ã€‚",
      "tips": ""
    },
    "Welcome to the Meme Creator app, where youâ€™ll learn to fetch data from the internet to create panda memes.": {
      "zh": "æ¬¢è¿æ¥åˆ° Meme Creator åº”ç”¨ç¨‹åºï¼Œæ‚¨å°†å­¦ä¹ ä»ç½‘ç»œä¸­è·å–æ•°æ®æ¥åˆ›å»ºç†ŠçŒ«å¤‡å¿˜å½•ã€‚",
      "tips": ""
    },
    "To create a meme, youâ€™ll load some images from a URL, which could take some time depending on the speed of your internet connection to the server. Youâ€™ll use an asynchronous request so that your app can keep doing other things in the background, like responding to user actions, while waiting for the images to load into the UI.": {
      "zh": "ä¸ºäº†åˆ›å»ºä¸€ä¸ªå¤‡å¿˜ï¼Œä½ éœ€è¦èŠ±è´¹ä¸€äº›æ—¶é—´ä» URL ä¸­åŠ è½½å¤šä¸ªå›¾ç‰‡ï¼Œè€Œè¿™ä¸ªæ—¶é—´å–å†³äºç½‘é€Ÿã€‚æ‚¨å°†ä½¿ç”¨å¼‚æ­¥è¯·æ±‚ï¼Œä»¥ä¾¿æ‚¨çš„åº”ç”¨ç¨‹åºå¯ä»¥ä¿æŒåœ¨åå°è¿ä½œï¼Œä¾‹å¦‚å“åº”ç”¨æˆ·è¡Œä¸ºã€‚",
      "tips": ""
    },
    "In this walkthrough, youâ€™ll learn how asynchronous data fetching works, and how to use it when retrieving panda images and their corresponding data in JSON format.": {
      "zh": "åœ¨è¿™ä¸ªæ¼”ç¤ºä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•å¼‚æ­¥çš„è·å–ç½‘ç»œæ•°æ®ï¼Œä»¥åŠåœ¨ JSON æ ¼å¼çš„æ•°æ®é‡Œè·å–ç†ŠçŒ«å›¾åƒå¹¶æ­£ç¡®çš„ä½¿ç”¨å®ƒä»¬ã€‚",
      "tips": ""
    },
    "Sharing App Data": {
      "zh": "åˆ†äº«åº”ç”¨ç¨‹åºæ•°æ®",
      "tips": ""
    },
    "Explore how the app makes its fetched data available to the entire view hierarchy.": {
      "zh": "æ¢ç©¶å¦‚ä½•è®©æ•´ä¸ªè§†å›¾å±‚æ¬¡ç»“æ„è·å–åˆ°æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ 1 æ­¥",
      "tips": ""
    },
    "To fetch its data, the app uses an observable object, PandaCollectionFetcher. This is where all of the data fetching occurs.": {
      "zh": "ä¸ºäº†è·å–æ•°æ®ï¼Œåº”ç”¨ç¨‹åºä½¿ç”¨å¯è§‚å¯Ÿå¯¹è±¡ PandaCollectionFetcherã€‚è¿™æ˜¯è·å–æ‰€æœ‰æ•°æ®çš„åœ°æ–¹ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬ 2 æ­¥",
      "tips": ""
    },
    "To share its data, MemeCreator passes in PandaCollectionFetcher as an environment object, making it available to all of the child views of MemeCreator. An environment object must also be an observable object, which enables all views observing its data to update whenever that data changes.": {
      "zh": "ä¸ºäº†å…±äº«æ•°æ®ï¼ŒMemeCreator å°† PandaCollectionFetcher ä½œä¸ºä¸€ä¸ªç¯å¢ƒå¯¹è±¡ä¼ å…¥ï¼Œä½¿å¾— MemeCreator çš„æ‰€æœ‰å­è§†å›¾éƒ½å¯ä»¥ä½¿ç”¨å®ƒã€‚ç¯å¢ƒå¯¹è±¡ä¹Ÿå¿…é¡»æ˜¯å¯è§‚å¯Ÿå¯¹è±¡ï¼Œè¿™ä½¿å¾—è§‚å¯Ÿå…¶æ•°æ®çš„æ‰€æœ‰è§†å›¾èƒ½å¤Ÿåœ¨æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶è¿›è¡Œæ›´æ–°ã€‚",
      "tips": ""
    },
    "Creating the Panda Model": {
      "zh": "åˆ›å»ºç†ŠçŒ«æ¨¡å‹",
      "tips": ""
    },
    "Learn how to model structured JSON data from a data source as a Swift structure.": {
      "zh": "å­¦ä¹ å¦‚ä½•å°† JSON ä¸­çš„æ•°æ®ä»¥ Swift ç»“æ„ä½“çš„æ–¹å¼å˜æˆä¸€ä¸ªæ•°æ®æ¨¡å‹ã€‚",
      "tips": ""
    },
    "This is the Panda model object. Itâ€™s structured to mirror the JSON data returned from this URL.": {
      "zh": "è¿™æ˜¯ä¸€ä¸ªç†ŠçŒ«æ¨¡å‹çš„å¯¹è±¡ã€‚å®ƒçš„ç»“æ„ä¸ä» URL è¿”å›çš„ JSON æ•°æ®å½¢æˆæ˜ å°„ã€‚",
      "tips": ""
    },
    "Each panda contains a text description as well as an imageUrl, which points to a panda image. This is the data youâ€™ll use to download a panda image.": {
      "zh": "æ¯ä¸ªç†ŠçŒ«æ•°æ®éƒ½åŒ…å«æ–‡å­—æè¿°å’ŒæŒ‡å‘ç†ŠçŒ«å›¾åƒçš„ imageUrlã€‚æ‚¨å¯ä»¥ä½¿ç”¨è¿™äº›æ•°æ®ä¸‹è½½ç†ŠçŒ«å›¾ç‰‡ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ 3 æ­¥",
      "tips": ""
    },
    "A PandaCollection is composed of an array of Panda model objects. This mirrors the format of the JSON data, which enables you to easily decode URLs and descriptive text from your JSON data into a PandaCollection instance.": {
      "zh": "PandaCollection æ˜¯ç”±å¤šä¸ª Panda æ¨¡å‹å¯¹è±¡ç»„æˆçš„æ•°ç»„ç±»å‹ã€‚è¿™ä¸ JSON çš„æ•°æ®æ ¼å¼ç›¸åŒ¹é…ï¼Œä½¿æ‚¨å¯ä»¥å¾ˆå®¹æ˜“çš„å°† JSON æ•°æ®é‡Œçš„URLå’Œæè¿°æ–‡æœ¬è§£ç æˆ PandaCollection å®ä¾‹ã€‚",
      "tips": ""
    },
    "Fetching Panda Data": {
      "zh": "è·å– Panda æ•°æ®",
      "tips": ""
    },
    "To fetch these images and their metadata, youâ€™ll use an observable object that fetches data asynchronously. Youâ€™ll learn more about how to structure asynchronous functions in this walkthrough.": {
      "zh": "ä¸ºäº†è·å–è¿™äº›å›¾åƒå’Œå®ƒä»¬çš„å…ƒæ•°æ®ï¼Œæ‚¨å°†ä»¥å¼‚æ­¥çš„æ–¹å¼ï¼Œä½¿ç”¨å¯è§‚å¯Ÿå¯¹è±¡è·å–æ•°æ®ã€‚åœ¨è¿™ä¸ªæ¼”ç¤ºä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•æ„å»ºå¼‚æ­¥å‡½æ•°ã€‚",
      "tips": ""
    },
    "PandaCollectionFetcher handles data fetching in your app. Itâ€™s an observable object, which allows it to publish changes to its values to all UI elements observing them. In this case, youâ€™ll have an image view thatâ€™s waiting for new Panda data so it can update its image and description.": {
      "zh": "PandaCollectionFetcher åœ¨ App ä¸­è´Ÿè´£å¤„ç†æ•°æ®è·å–ã€‚å®ƒæ˜¯ä¸€ä¸ªå¯è§‚å¯Ÿå¯¹è±¡ï¼Œè¿™ä½¿å¾—å®ƒå¯ä»¥å°†è‡ªèº«å€¼çš„å˜åŒ–æ¨é€åˆ°æ‰€æœ‰è§‚å¯Ÿå®ƒä»¬çš„ UI å…ƒç´ ä¸­ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œåˆšå¥½æœ‰ä¸€ä¸ªå›¾åƒè§†å›¾ï¼Œæ­£åœ¨ç­‰å¾…æ–°çš„ç†ŠçŒ«æ•°æ®ï¼Œä»¥ä¾¿æ›´æ–°ã€‚",
      "tips": ""
    },
    "There are two published values: imageData, a PandaCollection that you populate with JSON data, and currentPanda, a Panda model object that you display in the appâ€™s UI.": {
      "zh": "è¿™é‡Œæœ‰ä¸¤ä¸ªéœ€è¦ published çš„å€¼: imageData(ç”± JSON æ•°æ®å¡«å……çš„ PandaCollection ç±»å‹) å’Œ currentPanda(éœ€è¦åœ¨ App ä¸­å±•ç¤ºçš„ç†ŠçŒ«æ¨¡å‹æ•°æ®)ã€‚",
      "tips": ""
    },
    "The fetchData function retrieves the JSON data. Notice that itâ€™s marked as async to indicate that the function runs asynchronously. Because it might take a little time to fetch the data from the internet, an async function pauses until the data returns. Meantime, your appâ€™s code continues to run in the background.": {
      "zh": "fetchData å‡½æ•°ç”¨äºå–å› JSON æ•°æ®ã€‚è¯·æ³¨æ„ï¼Œå®ƒè¢«æ ‡è®°ä¸º asyncï¼Œè¿™è¡¨ç¤ºå®ƒæ˜¯å¼‚æ­¥çš„ã€‚å› ä¸ºä»äº’è”ç½‘è·å–æ•°æ®å¯èƒ½éœ€è¦ä¸€ç‚¹æ—¶é—´ï¼Œæ‰€ä»¥å¼‚æ­¥å‡½æ•°ä¼šæš‚åœï¼Œç›´åˆ°æ•°æ®è¿”å›ã€‚æ­¤æ—¶ï¼Œä½ çš„ä»£ç ä¼šåœ¨åå°æŒç»­è¿è¡Œã€‚",
      "tips": ""
    },
    "Tip": {
      "zh": "æç¤º",
      "tips": ""
    },
    "If you didnâ€™t make fetchData asynchronous, the app might experience some lag while it loads images individually.": {
      "zh": "å‡å¦‚æ‚¨æ²¡æœ‰å¼‚æ­¥åŠ è½½æ•°æ®ï¼Œåœ¨åŠ è½½å›¾åƒæ—¶å¯èƒ½ä¼šå¸¦æ¥ä¸€ç‚¹å»¶è¿Ÿã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬ 4 æ­¥",
      "tips": ""
    },
    "The function is also marked throws. This tells you that the function can throw an error when you call it. In MemeCreator, the code handles this error with try? by ignoring any values it throws.": {
      "zh": "è¯¥å‡½æ•°è¿˜æ ‡è®°ä¸º throwsã€‚è¿™å‘Šè¯‰æ‚¨ï¼Œå½“æ‚¨è°ƒç”¨è¯¥å‡½æ•°æ—¶ï¼Œå®ƒå¯èƒ½ä¼šæŠ›å‡ºé”™è¯¯ã€‚åœ¨ MemeCreator ä¸­ï¼Œé€šè¿‡ä½¿ç”¨ try? å…³é”®å­—æ¥å¿½ç•¥æŠ›å‡ºçš„ä»»ä½•å€¼å€¼",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬ 5 æ­¥",
      "tips": ""
    },
    "Inside fetchData, check to see if you have a valid URL.": {
      "zh": "åœ¨ fetchData ä¸­, æ£€æŸ¥ URL æ˜¯å¦æœ‰æ•ˆã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬ 6 æ­¥",
      "tips": ""
    },
    "Call another async function â€” URLSession.shared.data(for:) â€” which passes in a URL request using the URL youâ€™ve defined. This call is also marked await, because this is where the function pauses as it waits for the response from the URL request.": {
      "zh": "è°ƒç”¨å¦ä¸€ä¸ªå¼‚æ­¥å‡½æ•° â€”URLSession.shared.data(for:) â€”ï¼Œåœ¨è¿™ä¸ªå‡½æ•°ä¸­ä¼ å…¥ä¸€ä¸ªæ‚¨å®šä¹‰çš„ URL è¯·æ±‚ã€‚è¿™ä¸ªè°ƒç”¨è¢«æ ‡è®°ä¸º await ç±»å‹ï¼Œå› ä¸ºè¿™æ˜¯å‡½æ•°ç­‰å¾… URL è¯·æ±‚å“åº”æ—¶æš‚åœçš„ä½ç½®ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ 7 æ­¥",
      "tips": ""
    },
    "After your data returns, youâ€™ll check the URL response to verify that you didnâ€™t receive an error. This code generates a badRequest error if the responseâ€™s status code isnâ€™t equal to 200, indicating a successful request.": {
      "zh": "",
      "tips": "å½“ä½ çš„æ•°æ®è¿”å›å, ä½ å¯ä»¥æ£€æŸ¥ URL å“åº”ç¡®ä¿æ²¡æœ‰æ”¶åˆ°é”™è¯¯ã€‚å¦‚æœå“åº”çš„çŠ¶æ€ä»£ç ä¸ç­‰äº200ï¼ˆè¡¨ç¤ºè¯·æ±‚æˆåŠŸï¼‰ï¼Œåˆ™è¯¥ä»£ç ç”Ÿæˆ badRequest é”™è¯¯ã€‚"
    },
    "Step 8": {
      "zh": "ç¬¬ 8 æ­¥",
      "tips": ""
    },
    "Finally, decode the JSON data and assign it to the published variable, imageData. Now you have all of the data you need to create panda memes.": {
      "zh": "æœ€åï¼Œè§£ç  JSON æ•°æ®å¹¶å°†å…¶èµ‹å€¼ç»™ published å˜é‡ imageDataã€‚ç°åœ¨æ‚¨æ‹¥æœ‰äº†åˆ›å»ºç†ŠçŒ«å¤‡å¿˜å½•æ‰€éœ€çš„æ‰€æœ‰æ•°æ®ã€‚",
      "tips": ""
    },
    "Creating Asynchronous Images": {
      "zh": "åˆ›å»ºå¼‚æ­¥å›¾åƒ",
      "tips": ""
    },
    "Investigate how to use a URL to load an image asynchronously.": {
      "zh": "ç ”ç©¶å¦‚ä½•ä½¿ç”¨ URL å¼‚æ­¥åŠ è½½å›¾åƒã€‚",
      "tips": ""
    },
    "When you have the JSON data, you can use it to load panda images. To accomplish this, compose your LoadableImage view from AsyncImage, a view that loads an image asynchronously.": {
      "zh": "å½“æ‚¨è·å¾—JSONæ•°æ®åï¼Œæ‚¨å¯ä»¥ä½¿ç”¨å®ƒæ¥åŠ è½½ç†ŠçŒ«å›¾åƒã€‚è¦å®ç°è¿™ä¸€ç‚¹ï¼Œå¯ä»¥ä½¿ç”¨ AsyncImageï¼ˆä¸€ç§å¼‚æ­¥åŠ è½½å›¾ç‰‡çš„è§†å›¾ï¼‰ç»„æˆ LoadableImage è§†å›¾ã€‚",
      "tips": ""
    },
    "To create an image, LoadableImage needs data about the Panda itâ€™s loading. The metadata supplied here includes the image URL and the description.": {
      "zh": "ä¸ºäº†åˆ›å»ºå›¾åƒï¼ŒLoadableImage éœ€è¦åŠ è½½çš„æ•°æ®ã€‚è¿™é‡Œæä¾›çš„å…ƒæ•°æ®åŒ…æ‹¬å›¾åƒURLå’Œæè¿°ã€‚",
      "tips": ""
    },
    "Inside the view body, create an AsyncImage and pass in the imageUrl to load the panda image. An AsyncImage view loads asynchronously, so youâ€™ll need to show something in its place while the image loads, and show something else if image loading fails. Youâ€™ll handle all of this logic in the following if statement.": {
      "zh": "åœ¨è§†å›¾çš„å±‚çº§ç»“æ„ä¸­ï¼Œåˆ›å»ºä¸€ä¸ª AsyncImage å¹¶ä¼ é€’ imageUrl æ¥åŠ è½½ç†ŠçŒ«å›¾ç‰‡ã€‚AsyncImage è§†å›¾çš„åŠ è½½æ˜¯å¼‚æ­¥çš„ï¼Œæ‰€ä»¥ä½ éœ€è¦åœ¨å›¾ç‰‡åŠ è½½æ—¶æ˜¾ç¤ºä¸€äº›å†…å®¹ï¼Œå¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥åˆ™æ˜¾ç¤ºå…¶ä»–å†…å®¹ã€‚æ‚¨å°†åœ¨ä¸‹é¢çš„ if è¯­å¥ä¸­å¤„ç†æ‰€æœ‰è¿™äº›é€»è¾‘",
      "tips": ""
    },
    "When you create an instance of AsyncImage, SwiftUI provides you with phase data, which updates you on the state of image loading. For example, phase.error provides you with errors that occur, while phase.image provides an image, if available. You can use the phase data to show the appropriate UI based on the phase state.": {
      "zh": "å½“ä½ åˆ›å»ºäº†ä¸€ä¸ª AsyncImage çš„å®ä¾‹, SwiftUI ä¸ºä½ æä¾›äº† phase æ•°æ®,ä½¿æ‚¨äº†è§£å›¾åƒåŠ è½½çš„æœ€æ–°çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œphase.error æä¾›äº†é”™è¯¯ä¿¡æ¯ï¼Œè€Œ phase.image æä¾›å¯ç”¨çš„å›¾åƒã€‚æ ¹æ® phase æ•°æ®æ˜¾ç¤ºç›¸åº”çš„ UI ç•Œé¢ã€‚",
      "tips": ""
    },
    "Check to see if any errors occurred while loading the image. If so, you can provide a view that tells the user something went wrong.": {
      "zh": "æ£€æŸ¥åœ¨åŠ è½½å›¾ç‰‡æ—¶æ˜¯å¦å‘ç”Ÿé”™è¯¯ã€‚å¦‚æœæœ‰ï¼Œæ‚¨å¯ä»¥æä¾›ä¸€ä¸ªè§†å›¾ï¼Œå‘Šè¯‰ç”¨æˆ·å‡ºé”™äº†ã€‚",
      "tips": ""
    },
    "If you havenâ€™t received an image and you donâ€™t have an error, that means the image is loading. To let people know that the image is downloading, use ProgressView to display an animation while the image loads.": {
      "zh": "å¦‚æœæ²¡æœ‰æ”¶åˆ°å›¾åƒå¹¶ä¸”æ²¡æœ‰é”™è¯¯ï¼Œé‚£æ„å‘³ç€å›¾åƒæ­£åœ¨åŠ è½½ã€‚ä¸ºäº†è®©äººçŸ¥é“å›¾åƒæ­£åœ¨ä¸‹è½½ï¼Œå¯ä½¿ç”¨ ProgressView çš„åŠ¨ç”»æ¥è¡¨è¾¾è¿™ä¸€éšå–»ã€‚",
      "tips": ""
    },
    "Making the Meme Creator": {
      "zh": "åˆ›å»ºç†ŠçŒ«å¤‡å¿˜å½•",
      "tips": ""
    },
    "Youâ€™ll use the data from your app to create a meme-generating UI. Explore how to compose this view in this walkthrough.": {
      "zh": "æ‚¨å°†ä½¿ç”¨åº”ç”¨ç¨‹åºä¸­çš„æ•°æ®åˆ›å»ºä¸€ä¸ªå¯ç”Ÿæˆå¤‡å¿˜å½•çš„ç”¨æˆ·ç•Œé¢ã€‚åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæ‚¨å°†äº†è§£å¦‚ä½•æ„å»ºè¯¥è§†å›¾ã€‚",
      "tips": ""
    },
    "MemeCreator is where you bring everything together to make panda memes. As the top-level view of your app, this is where youâ€™ll display the panda image along with tools for adding and editing text.": {
      "zh": "MemeCreator æ˜¯æ‚¨åˆ¶ä½œç†ŠçŒ«å¤‡å¿˜å½•çš„åœ°æ–¹ã€‚ä½œä¸ºåº”ç”¨ç¨‹åºçš„é¡¶å±‚è§†å›¾ï¼Œè¿™é‡Œå°†æ˜¾ç¤ºç†ŠçŒ«å›¾ç‰‡ä»¥åŠç”¨äºæ·»åŠ å’Œç¼–è¾‘æ–‡æœ¬çš„å·¥å…·ã€‚",
      "tips": ""
    },
    "In MemeCreatorApp, you passed in a PandaCollectionFetcher as an environment object to the top level view. Here, you access that environment object by defining a fetcher variable with the @EnvironmentObject property wrapper.": {
      "zh": "åœ¨ MemeCreatorApp ä¸­ï¼Œä½ å°†ä¸€ä¸ª PandaCollectionFetcher ä½œä¸ºç¯å¢ƒå¯¹è±¡ä¼ å…¥é¡¶å±‚è§†å›¾ã€‚åœ¨è¿™é‡Œï¼Œæ‚¨å¯ä»¥é€šè¿‡ @EnvironmentObject å±æ€§åŒ…è£…å™¨å®šä¹‰ä¸€ä¸ª fetcher å˜é‡æ¥è®¿é—®è¯¥ç¯å¢ƒå¯¹è±¡ã€‚",
      "tips": ""
    },
    "Before you start loading panda images, the fetcher needs to retrieve the JSON data. The .task modifier defines a task to complete when the view first appears. This is where youâ€™ll call fetcher.fetchData() to retrieve the JSON data.": {
      "zh": "åœ¨ä½ å¼€å§‹åŠ è½½ç†ŠçŒ«å›¾åƒä¹‹å‰ï¼Œfetcher éœ€è¦è·å– JSON æ•°æ®ã€‚.task ä¿®é¥°ç¬¦å®šä¹‰äº†å½“è§†å›¾ç¬¬ä¸€æ¬¡æ˜¾ç¤ºæ—¶éœ€è¦å®Œæˆçš„ä»»åŠ¡ã€‚è¿™æ˜¯æ‚¨å°†è°ƒç”¨ fetcher.fetchData() æ¥è·å– JSON æ•°æ®çš„æ—¶æœºã€‚",
      "tips": ""
    },
    "In the closure, youâ€™ll insert try? await before calling fetcher.fetchData(). These words correspond to how you defined fetchData() with async throws. Because the function is asynchronous, await means that youâ€™ll wait for the results of the async function to return, and try followed by a question mark - try? - means youâ€™ll try calling the function, but ignore any error that it throws.": {
      "zh": "åœ¨é—­åŒ…ä¸­ï¼Œæ‚¨å°†åœ¨è°ƒç”¨ fetcher.fetchData() ä¹‹å‰æ’å…¥ try? awaitã€‚è¿™äº›å…³é”®å­—å¯¹åº”äº fetchData() å‡½æ•°é‡Œçš„ async throwsã€‚å› ä¸ºå‡½æ•°æ˜¯å¼‚æ­¥çš„ï¼Œawait è¡¨ç¤ºç­‰å¾…å¼‚æ­¥å‡½æ•°è¿”å›ç»“æœï¼Œè€Œ try åé¢çš„é—®å· - try? - è¡¨ç¤ºæ‚¨å°†å°è¯•è°ƒç”¨è¯¥å‡½æ•°ï¼Œä½†å¿½ç•¥å®ƒæŠ›å‡ºçš„ä»»ä½•é”™è¯¯ã€‚",
      "tips": ""
    },
    "In the UI for this view, youâ€™ll use LoadableImage to asynchronously load an image based on the data fetcherâ€™s currentPanda. Even if your JSON data hasnâ€™t loaded yet, the app provides a default currentPanda to load as the first image.": {
      "zh": "åœ¨è¯¥è§†å›¾çš„ç”¨æˆ·ç•Œé¢ä¸­ï¼Œæ‚¨å°†ä½¿ç”¨ LoadableImage æ ¹æ®æ•°æ®è·å–å™¨çš„ currentPanda å¼‚æ­¥åŠ è½½å›¾ç‰‡ã€‚å³ä½¿æ‚¨çš„ JSON æ•°æ®å°šæœªåŠ è½½ï¼Œåº”ç”¨ç¨‹åºä¹Ÿä¼šæä¾›é»˜è®¤çš„ currentPanda ä½œä¸ºç¬¬ä¸€å¼ å›¾ç‰‡åŠ è½½ã€‚",
      "tips": ""
    },
    "The image also has a text overlay, which you can add as a modifier. This overlay shows the meme text. The text field uses three state variables, memeText, textSize, and textColor to dynamically change the data of the text field in response to user editing actions. The text field can become focused by passing the @FocusState variable into the .focused modifier.": {
      "zh": "å›¾ç‰‡è¿˜æœ‰ä¸€ä¸ªæ–‡æœ¬å åŠ ï¼Œæ‚¨å¯ä»¥å°†å…¶æ·»åŠ ä¸ºä¿®æ”¹å™¨ã€‚è¯¥å åŠ æ˜¾ç¤ºå¤‡å¿˜å½•æ–‡æœ¬ã€‚æ–‡æœ¬å­—æ®µä½¿ç”¨ä¸‰ä¸ªå˜é‡ memeTextã€textSize å’Œ textColor æ¥åŠ¨æ€æ”¹å˜æ–‡æœ¬å­—æ®µçš„æ•°æ®ï¼Œä»¥å“åº”ç”¨æˆ·çš„ç¼–è¾‘æ“ä½œã€‚é€šè¿‡å°† @FocusState å˜é‡ä¼ å…¥ .focused ä¿®é¥°ç¬¦ï¼Œæ–‡æœ¬å­—æ®µå¯ä»¥è¿›å…¥èšç„¦çŠ¶æ€ã€‚",
      "tips": ""
    },
    "To change the image, you can push a button that retrieves a random Panda from the PandaCollection and sets it as the currentPanda. Because currentPanda is a published value, the LoadableImage view automatically updates to use the latest currentPanda data whenever it changes.": {
      "zh": "è¦æ”¹å˜å›¾ç‰‡ï¼Œæ‚¨å¯ä»¥æŒ‰ä¸€ä¸ªæŒ‰é’®ä»ç†ŠçŒ«å›¾åº“ä¸­éšæœºè·å–ä¸€ä¸ªç†ŠçŒ«å¹¶è®¾ç½®ä¸ºå½“å‰ç†ŠçŒ«ã€‚å› ä¸º currentPanda æ˜¯ä¸€ä¸ª published ç±»å‹çš„å€¼ï¼ŒLoadableImage è§†å›¾ä¼šè‡ªåŠ¨æ›´æ–°ä½¿ç”¨æœ€æ–°çš„ currentPanda æ•°æ®",
      "tips": ""
    },
    "To add text, use a button that changes the focus state of the text field to true. This automatically inserts the cursor in the text field so you can add text.": {
      "zh": "è¦æ·»åŠ æ–‡æœ¬ï¼Œä½¿ç”¨æŒ‰é’®å°†æ–‡æœ¬å­—æ®µçš„ç„¦ç‚¹çŠ¶æ€æ›´æ”¹ä¸º trueã€‚è¿™å°†è‡ªåŠ¨åœ¨æ–‡æœ¬å­—æ®µä¸­æ’å…¥å…‰æ ‡ï¼Œä»¥ä¾¿æ‚¨æ·»åŠ æ–‡æœ¬ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "ç¬¬ 9 æ­¥",
      "tips": ""
    },
    "Finally, you can modify the state variables textSize and textColor using the slider and color picker at the bottom of the UI. These controls modify the values of those state variables to automatically update the meme text appearance.": {
      "zh": "æœ€åï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ç”¨æˆ·ç•Œé¢åº•éƒ¨çš„æ»‘å—å’Œé¢œè‰²é€‰æ‹©å™¨ä¿®æ”¹çŠ¶æ€å˜é‡textSizeå’ŒtextColorã€‚è¿™äº›æ§ä»¶ä¿®æ”¹è¿™äº›çŠ¶æ€å˜é‡çš„å€¼ï¼Œä»¥è‡ªåŠ¨æ›´æ–°å¤‡å¿˜å½•æ–‡æœ¬å¤–è§‚ã€‚",
      "tips": ""
    },
    "Bubble Level": {
      "zh": "æ³¡æ³¡ç­‰çº§",
      "tips": ""
    },
    "Access and display device sensor data by subscribing to notifications.": {
      "zh": "é€šè¿‡è®¢é˜…é€šçŸ¥è®¿é—®å’Œæ˜¾ç¤ºè®¾å¤‡ä¼ æ„Ÿå™¨æ•°æ®ã€‚",
      "tips": ""
    },
    "Check to see if an image is available. If there is, great â€” this is the panda image youâ€™ll display using the description as the accessibility text.": {
      "zh": "æ£€æŸ¥å›¾ç‰‡æ˜¯å¦å¯ç”¨ã€‚å¦‚æœæœ‰ï¼Œå¾ˆå¥½--è¿™å°±æ˜¯æ‚¨è¦æ˜¾ç¤ºçš„ç†ŠçŒ«å›¾ç‰‡ï¼Œä½¿ç”¨ description ä½œä¸º accessibilityLabel çš„æ–‡æœ¬ã€‚",
      "tips": ""
    }
  },
  "sample-apps/organizingwithgrids": {
    "Organizing with Grids": {
      "zh": "",
      "tips": ""
    },
    "Display visual content in an arrangement of rows and columns.": {
      "zh": "",
      "tips": ""
    },
    "Welcome to the Organizing with Grids sample. This sample shows you how to arrange content using a grid view, and how to use a state variable to track the selection of a color in that grid.": {
      "zh": "",
      "tips": ""
    },
    "Configuring the App": {
      "zh": "",
      "tips": ""
    },
    "Learn the basics of building and configuring an app with SwiftUI.": {
      "zh": "",
      "tips": ""
    },
    "Step 1": {
      "zh": "",
      "tips": ""
    },
    "Before diving into the grid, take a look at how this code gets made into an app. Your ColorGridApp follows a set of guidelines created by the App protocol. This allows your project to run and behave just like any other app.": {
      "zh": "",
      "tips": ""
    },
    "Step 2": {
      "zh": "",
      "tips": ""
    },
    "The code marks ColorGridApp with @main, making it the entry point of the program â€” the code the app starts running first.": {
      "zh": "",
      "tips": ""
    },
    "Step 3": {
      "zh": "",
      "tips": ""
    },
    "When your app runs, it displays whatever content you place in the body property. Notice that this body creates the ContentView. When the app launches, it fills the screen with this view.": {
      "zh": "",
      "tips": ""
    },
    "Step 4": {
      "zh": "",
      "tips": ""
    },
    "When you create a new app, ContentView is configured as your top-level view by default. This is useful because you can go to ContentView to see how an appâ€™s views are put together. However, this view can be renamed, so if youâ€™re unsure what the top-level view of an app is, look here in the body property of the app definition.": {
      "zh": "",
      "tips": ""
    },
    "Creating a Grid": {
      "zh": "",
      "tips": ""
    },
    "Explore how to create and fill the grid view with colored rectangles.": {
      "zh": "",
      "tips": ""
    },
    "This is the ContentView. It creates a grid of rounded rectangles, each a different color. ContentView is a View, so it can contain any number of other views inside of it. The grid is one of those views.": {
      "zh": "",
      "tips": ""
    },
    "To populate the grid with different colors, youâ€™ll use the allColors variable to store an array of color values. The grid iterates over this array and adds a rectangular button for each color in the array.": {
      "zh": "",
      "tips": ""
    },
    "Youâ€™ll add any code that defines a view to the viewâ€™s body. Youâ€™ll define any variables that ContentView needs outside of its body.": {
      "zh": "",
      "tips": ""
    },
    "The first view inside ContentView is a VStack, which arranges its views vertically, with some text above the grid.": {
      "zh": "",
      "tips": ""
    },
    "Step 5": {
      "zh": "",
      "tips": ""
    },
    "The grid might contain more items than it can display at one time, so the code wraps it in a ScrollView to scroll the content vertically, if necessary.": {
      "zh": "",
      "tips": ""
    },
    "Step 6": {
      "zh": "",
      "tips": ""
    },
    "Inside the ScrollView, you create a grid view using LazyVGrid. The grid is â€œlazyâ€ because it doesnâ€™t create its grid items until they are needed. LazyVGrid takes an argument for columns which determines how many columns show up in the grid.": {
      "zh": "",
      "tips": ""
    },
    "Step 7": {
      "zh": "",
      "tips": ""
    },
    "The value assigned to columnLayout specifies a three-column grid. You can change this value any time you want.": {
      "zh": "",
      "tips": ""
    },
    "Step 8": {
      "zh": "",
      "tips": ""
    },
    "Inside the LazyVGrid, you define each item for the grid to display. To do this, you use a ForEach loop to iterate over the allColors array. By using the colorâ€™s name as an identifier, ForEach can find the right element when it needs to update the colorâ€™s view.": {
      "zh": "",
      "tips": ""
    },
    "Step 9": {
      "zh": "",
      "tips": ""
    },
    "Each item in the grid is a Button view, and each button has an action (something that happens when you tap it), and a label (text or an image that tells people what the button does, like â€œSaveâ€ to save a file).": {
      "zh": "",
      "tips": ""
    },
    "Step 10": {
      "zh": "",
      "tips": ""
    },
    "The label for the button uses a RoundedRectangle view, and one of the colors from the ForEach loop. You can see this in the foregroundColor(color) modifer.": {
      "zh": "",
      "tips": ""
    },
    "Using a State Variable": {
      "zh": "",
      "tips": ""
    },
    "Investigate how SwiftUI changes the appearance of a view.": {
      "zh": "",
      "tips": ""
    },
    "If you tap a color in the grid, youâ€™ll notice that the text element on top of the grid changes color.": {
      "zh": "",
      "tips": ""
    },
    "You add @State before a variable to tell SwiftUI to manage the storage for a value. When the value changes, SwiftUI updates any parts of the view that use the value. The state variable selectedColor tracks the most recently selected color, which the text at the top of the view uses for its foreground color.": {
      "zh": "",
      "tips": ""
    },
    "The Text view uses selectedColor for its foreground color. Because selectedColor is a state variable, whenever the state changes, SwiftUI changes the color of this text.": {
      "zh": "",
      "tips": ""
    },
    "When you tap a grid element, the selectedColor value changes to that elementâ€™s color, which also changes the color of the text.": {
      "zh": "",
      "tips": ""
    },
    "Editing Grids": {
      "zh": "",
      "tips": ""
    },
    "Let people edit data that your app displays.": {
      "zh": "",
      "tips": ""
    }
  },
  "sample-apps/recognizinggestures": {
    "Recognizing Gestures": {
      "zh": "è¯†åˆ«æ‰‹åŠ¿",
      "tips": ""
    },
    "Update shapes or other content in response to taps, rotations, or other Multi-Touch gestures.": {
      "zh": "å½“è¯†åˆ«åˆ°ç‚¹å‡»ã€æ—‹è½¬æˆ–å…¶ä»–å¤šç‚¹è§¦æ§æ‰‹åŠ¿æ—¶ï¼Œæ›´æ–°å½¢çŠ¶æˆ–å…¶ä»–å†…å®¹ã€‚",
      "tips": ""
    },
    "Welcome to Recognizing Gestures. In this sample youâ€™ll learn how to add different gestures to your views, like taps, drags, and touch and hold.": {
      "zh": "æ¬¢è¿æ¥åˆ°è¯†åˆ«æ‰‹åŠ¿ã€‚åœ¨æœ¬ç¤ºä¾‹ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•å°†ä¸åŒçš„æ‰‹åŠ¿æ·»åŠ åˆ°è§†å›¾ä¸­ï¼Œä¾‹å¦‚ç‚¹å‡»ã€æ‹–åŠ¨å’Œè§¦æ‘¸å¹¶ä¿æŒã€‚",
      "tips": ""
    },
    "Start by trying out each gesture in the app preview. When youâ€™re ready, dive into the code walkthrough and learn how to add a gesture to your next project.": {
      "zh": "ä½ å¯ä»¥é€šè¿‡åœ¨é¢„è§ˆçª—å£å°è¯•å„ç§æ‰‹åŠ¿æ¥å¼€å§‹ã€‚å½“ä½ å‡†å¤‡å¥½ä¹‹åï¼Œå°±å¯ä»¥æ·±å…¥ä»£ç å¹¶åœ¨ä¸‹ä¸€ä¸ªé¡¹ç›®ä¸­å­¦ä¹ å¦‚ä½•æ·»åŠ æ‰‹åŠ¿äº†",
      "tips": ""
    },
    "Tap": {
      "zh": "ç‚¹å‡»",
      "tips": ""
    },
    "Explore how to apply different colors to a rectangle when tapped.": {
      "zh": "æ¢ç´¢å¦‚ä½•åœ¨ç‚¹å‡»çš„æ—¶å€™ç»™æ­£æ–¹å½¢èµ‹äºˆä¸åŒçš„é¢œè‰²",
      "tips": ""
    },
    "Step 1": {
      "zh": "",
      "tips": ""
    },
    "In SwiftUI, you can add a gesture directly to a view using a .gesture modifier. Here, youâ€™ll explore how to add a tap gesture to a rectangle view so that it changes color when pressed.": {
      "zh": "åœ¨ SwiftUI ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨ .gesture ä¿®é¥°ç¬¦ç›´æ¥å°†æ‰‹åŠ¿æ·»åŠ åˆ°è§†å›¾ä¸­ã€‚åœ¨è¿™é‡Œï¼Œä½ å°†æ¢ç´¢å¦‚ä½•å°†ç‚¹å‡»æ‰‹åŠ¿æ·»åŠ åˆ°çŸ©å½¢è§†å›¾ä¸­ï¼Œä»¥ä¾¿åœ¨æŒ‰ä¸‹æ—¶æ›´æ”¹é¢œè‰²ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "",
      "tips": ""
    },
    "To set up this tap gesture, you need a @State value, color. When you mark the property with @State, SwiftUI updates all views that use this value any time it changes.": {
      "zh": "ä¸ºäº†è®¾ç½®è¿™ä¸ªç‚¹å‡»æ‰‹åŠ¿ï¼Œä½ éœ€è¦ä¸€ä¸ªç”¨ @State ä¿®é¥°çš„å€¼ï¼Œä¹Ÿå°±æ˜¯è¿™é‡Œçš„ color å±æ€§ã€‚å½“ä½ ä½¿ç”¨ @State æ ‡è®°å±æ€§åï¼ŒSwiftUI ä¼šåœ¨è¯¥å€¼å˜åŒ–åæ›´æ–°æ‰€æœ‰ä½¿ç”¨äº†è¿™ä¸ªå€¼çš„è§†å›¾",
      "tips": ""
    },
    "Step 3": {
      "zh": "",
      "tips": ""
    },
    "The color value is set as the foreground color of the rectangle. Whenever this value changes, the color of the rectangle updates.": {
      "zh": "color å˜é‡ç”¨äºè®¾ç½®çŸ©å½¢çš„å‰æ™¯è‰²ã€‚çŸ©å½¢çš„é¢œè‰²ä¼šåœ¨è¿™ä¸ªå˜é‡å˜åŒ–æ—¶æ›´æ–°",
      "tips": ""
    },
    "Step 4": {
      "zh": "",
      "tips": ""
    },
    "This code defines a custom gesture, tapGesture. After youâ€™ve defined a custom gesture, you can attach it to a view using the .gesture modifier.": {
      "zh": "è¿™æ®µä»£ç å®šä¹‰äº†ä¸€ä¸ªè‡ªå®šä¹‰çš„æ‰‹åŠ¿ï¼Œç‚¹å‡»æ‰‹åŠ¿ã€‚åœ¨ä½ å®šä¹‰äº†è‡ªå®šä¹‰æ‰‹åŠ¿åï¼Œä½ å°±å¯ä»¥ä½¿ç”¨ .gesture ä¿®é¥°ç¬¦å°†å…¶æ·»åŠ åˆ°ä¸€ä¸ªè§†å›¾ä¸Š",
      "tips": ""
    },
    "Step 5": {
      "zh": "",
      "tips": ""
    },
    "Your custom gesture uses a TapGesture and defines the event handler for when the tap ends. When the tap ends, you assign a random value to color, and the rectangle automatically updates to reflect the new value.": {
      "zh": "ä½ çš„è‡ªå®šä¹‰æ‰‹åŠ¿ä½¿ç”¨äº† TapGesture ç±»ï¼Œå¹¶å®šä¹‰äº†ä¸€ä¸ªç‚¹å‡»ç»“æŸæ—¶çš„äº‹ä»¶å¤„ç†å™¨ã€‚å½“ç‚¹å‡»ç»“æŸæ—¶ï¼Œä½ ä¼šç»™ color å±æ€§è®¾ç½®ä¸€ä¸ªéšæœºçš„å€¼ï¼Œå¹¶ä¸”çŸ©å½¢ä¼šè‡ªåŠ¨æ›´æ–°ä»¥åæ˜ å‡º color å±æ€§çš„æ–°å€¼ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "",
      "tips": ""
    },
    "By passing tapGesture into the .gesture modifier, the rectangle responds to taps using your custom gesture definition.": {
      "zh": "é€šè¿‡å°† tapGesture ä¼ é€’ç»™ .gesture ä¿®é¥°ç¬¦ï¼ŒçŸ©å½¢ä¼šä½¿ç”¨ä½ è‡ªå®šä¹‰çš„æ‰‹åŠ¿å®šä¹‰æ¥å“åº”ç‚¹å‡»ã€‚",
      "tips": ""
    },
    "Long Press": {
      "zh": "é•¿æŒ‰",
      "tips": ""
    },
    "Touch and hold to change the shape of a capsule.": {
      "zh": "è§¦æ‘¸å¹¶ä¿æŒä»¥æ›´æ”¹èƒ¶å›Šçš„å½¢çŠ¶ã€‚",
      "tips": ""
    },
    "In the LongPressView, youâ€™ll change the height and width of a capsule shape every time you touch and hold on the shape.": {
      "zh": "åœ¨ LongPressView ä¸­ï¼Œä½ å°†åœ¨æ¯æ¬¡è§¦æ‘¸å¹¶ä¿æŒçš„æ—¶å€™æ›´æ”¹èƒ¶å›Šå½¢çŠ¶çš„é«˜åº¦å’Œå®½åº¦ã€‚",
      "tips": ""
    },
    "To change the capsuleâ€™s size, youâ€™ll iterate through an array of size values. Changes to the @State property sizeIndex updates the capsule to a new size in the array.": {
      "zh": "ä¸ºäº†æ”¹å˜èƒ¶å›Šçš„å¤§å°ï¼Œä½ å°†éå†ä¸€ä¸ª size å€¼çš„æ•°ç»„ã€‚å¯¹ @State å±æ€§ sizeIndex çš„æ›´æ”¹ä¼šå°†èƒ¶å›Šæ›´æ–°ä¸ºæ•°ç»„ä¸­çš„æ–°å¤§å°ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®éªŒ",
      "tips": ""
    },
    "Try adding a few sizes of your own. Can you make a really big or really tiny capsule?": {
      "zh": "å°è¯•æ·»åŠ ä¸€äº›è‡ªå·±çš„å°ºå¯¸ã€‚ä½ èƒ½åšä¸€ä¸ªéå¸¸å¤§æˆ–éå¸¸å°çš„èƒ¶å›Šå—ï¼Ÿ",
      "tips": ""
    },
    "The capsule shape uses the sizes value in the frame modifier to set its width and height based on the sizeIndex. If the index changes, this view automatically updates to reflect the new size it references in the array.": {
      "zh": "èƒ¶å›Šå½¢çŠ¶ä½¿ç”¨ frame ä¿®é¥°ç¬¦ä¸­çš„ sizes å€¼æ¥æ ¹æ® sizeIndex è®¾ç½®å…¶å®½åº¦å’Œé«˜åº¦ã€‚å¦‚æœç´¢å¼•å‘ç”Ÿå˜åŒ–ï¼Œè¿™ä¸ªè§†å›¾ä¼šè‡ªåŠ¨æ›´æ–°ä»¥åæ˜ å‡ºå®ƒåœ¨æ•°ç»„ä¸­å¼•ç”¨çš„æ–°å¤§å°ã€‚",
      "tips": ""
    },
    "What happens if you set the widthâ€™s index to 1 with sizes[1].width? What happens each time you touch and hold on the capsule? Try it before moving on.": {
      "zh": "å¦‚æœä½ ä½¿ç”¨ sizes[1].width å°†å®½åº¦çš„ç´¢å¼•è®¾ç½®ä¸º 1ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿæ¯æ¬¡ä½ è§¦æ‘¸å¹¶ä¿æŒèƒ¶å›Šæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿåœ¨ç»§ç»­ä¹‹å‰è¯•ä¸€è¯•ã€‚",
      "tips": ""
    },
    "Here you define your custom gesture using a LongPressGesture.": {
      "zh": "è¿™é‡Œä½ ä½¿ç”¨ LongPressGesture å®šä¹‰äº†ä½ çš„è‡ªå®šä¹‰æ‰‹åŠ¿ã€‚",
      "tips": ""
    },
    "When the long press gesture ends, iterate to the next index in the array. The value increments by 1 until it reaches the last index (sizes.count) before resetting back to 0.": {
      "zh": "å½“é•¿æŒ‰æ‰‹åŠ¿ç»“æŸæ—¶ï¼ŒsizeIndex ä¼šè¿­ä»£åˆ°æ•°ç»„ä¸­çš„ä¸‹ä¸€ä¸ªç´¢å¼•ã€‚è¯¥å€¼å¢åŠ  1ï¼Œç›´åˆ°å®ƒè¾¾åˆ°æœ€åä¸€ä¸ªç´¢å¼•ï¼ˆsizes.countï¼‰ï¼Œç„¶åé‡ç½®ä¸º 0ã€‚",
      "tips": ""
    },
    "The last step is to apply the long press gesture to the capsule shape using the .gesture modifier. The app calls event handlers from longPressGesture when you touch and hold the capsule.": {
      "zh": "æœ€åä¸€æ­¥æ˜¯ä½¿ç”¨ .gesture ä¿®é¥°ç¬¦å°†é•¿æŒ‰æ‰‹åŠ¿åº”ç”¨åˆ°èƒ¶å›Šå½¢çŠ¶ä¸Šã€‚å½“ä½ è§¦æ‘¸å¹¶ä¿æŒèƒ¶å›Šæ—¶ï¼Œåº”ç”¨ç¨‹åºä¼šé€šè¿‡ longPressGesture è°ƒç”¨äº‹ä»¶å¤„ç†å™¨ã€‚",
      "tips": ""
    },
    "Drag": {
      "zh": "æ‹–åŠ¨",
      "tips": ""
    },
    "Learn how to use a drag gesture to move a circle around the screen.": {
      "zh": "å­¦ä¹ å¦‚ä½•ä½¿ç”¨æ‹–åŠ¨æ‰‹åŠ¿åœ¨å±å¹•ä¸Šç§»åŠ¨ä¸€ä¸ªåœ†ã€‚",
      "tips": ""
    },
    "In DragView youâ€™ll use a drag gesture to move a circle shape around the view.": {
      "zh": "åœ¨ DragView ä¸­ï¼Œä½ å°†ä½¿ç”¨æ‹–åŠ¨æ‰‹åŠ¿åœ¨è§†å›¾ä¸­ç§»åŠ¨ä¸€ä¸ªåœ†å½¢ã€‚",
      "tips": ""
    },
    "To keep track of the circleâ€™s position, the @State variable offset stores a CGSize value. This doesnâ€™t refer to the circleâ€™s size, but is instead used as a distance vector to represent its offset from its starting position in the view.": {
      "zh": "ä¸ºäº†è·Ÿè¸ªåœ†çš„ä½ç½®ï¼Œ@State å˜é‡ offset å­˜å‚¨äº†ä¸€ä¸ª CGSize å€¼ã€‚è¿™å¹¶ä¸æ˜¯æŒ‡åœ†çš„å¤§å°ï¼Œè€Œæ˜¯ç”¨ä½œè·ç¦»å‘é‡æ¥è¡¨ç¤ºå®ƒåœ¨è§†å›¾ä¸­çš„èµ·å§‹ä½ç½®çš„åç§»é‡ã€‚",
      "tips": ""
    },
    "Here you pass in offset as the value for the circle viewâ€™s .offset modifier. Any change to this value causes SwiftUI to update the position of the circle relative to its original location in the view. As your gesture updates offset, the circle moves around the view.": {
      "zh": "è¿™é‡Œä½ å°† offset ä½œä¸ºåœ†è§†å›¾çš„ .offset ä¿®é¥°ç¬¦çš„å€¼ä¼ å…¥ã€‚å¯¹è¯¥å€¼çš„ä»»ä½•æ›´æ”¹éƒ½ä¼šå¯¼è‡´ SwiftUI æ›´æ–°åœ†ç›¸å¯¹äºè§†å›¾ä¸­åŸå§‹ä½ç½®çš„ä½ç½®ã€‚å½“ä½ çš„æ‰‹åŠ¿æ›´æ–° offset æ—¶ï¼Œåœ†ä¼šåœ¨è§†å›¾ä¸­ç§»åŠ¨ã€‚",
      "tips": ""
    },
    "Here you define a custom gesture using a DragGesture.": {
      "zh": "è¿™é‡Œä½ ä½¿ç”¨ DragGesture å®šä¹‰äº†ä¸€ä¸ªè‡ªå®šä¹‰æ‰‹åŠ¿ã€‚",
      "tips": ""
    },
    "The system calls the .onChanged event handler any time the position of your drag changes. Each time the handler is called, it assigns a new value to offset using the translation property of the drag value.": {
      "zh": "ç³»ç»Ÿä¼šåœ¨æ‹–åŠ¨ä½ç½®å‘ç”Ÿå˜åŒ–æ—¶è°ƒç”¨ .onChanged äº‹ä»¶å¤„ç†å™¨ã€‚æ¯æ¬¡è°ƒç”¨å¤„ç†å™¨æ—¶ï¼Œå®ƒéƒ½ä¼šä½¿ç”¨æ‹–åŠ¨å€¼çš„ translation å±æ€§ä¸º offset èµ‹ä¸€ä¸ªæ–°å€¼ã€‚",
      "tips": ""
    },
    "Try modifying this formula to see what happens to your circle when you drag it. What happens when you remove the -50 (the radius of the circle) from the width and height? What happens if you remove the start location of the width and height?": {
      "zh": "å°è¯•ä¿®æ”¹è¿™ä¸ªå…¬å¼ï¼Œçœ‹çœ‹å½“ä½ æ‹–åŠ¨å®ƒæ—¶ä½ çš„åœ†ä¼šå‘ç”Ÿä»€ä¹ˆã€‚å½“ä½ ä»å®½åº¦å’Œé«˜åº¦ä¸­åˆ é™¤ -50ï¼ˆåœ†çš„åŠå¾„ï¼‰æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿå¦‚æœä½ åˆ é™¤å®½åº¦å’Œé«˜åº¦çš„èµ·å§‹ä½ç½®ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ",
      "tips": ""
    },
    "To apply the drag gesture to the circle, pass in the dragGesture to the .gesture modifier of the circle.": {
      "zh": "å°†æ‹–åŠ¨æ‰‹åŠ¿åº”ç”¨åˆ°åœ†ä¸Šï¼Œå°† dragGesture ä¼ å…¥åˆ°åœ†çš„ .gesture ä¿®é¥°ç¬¦ä¸­ã€‚",
      "tips": ""
    },
    "Rotate": {
      "zh": "æ—‹è½¬",
      "tips": ""
    },
    "Experiment rotating a square using two fingers.": {
      "zh": "å°è¯•ä½¿ç”¨ä¸¤æ ¹æ‰‹æŒ‡æ—‹è½¬ä¸€ä¸ªæ­£æ–¹å½¢ã€‚",
      "tips": ""
    },
    "In RotateView youâ€™ll use a two-finger rotation gesture to rotate a square shape.": {
      "zh": "åœ¨ RotateView ä¸­ï¼Œä½ å°†ä½¿ç”¨åŒæŒ‡æ—‹è½¬æ‰‹åŠ¿æ¥æ—‹è½¬ä¸€ä¸ªæ­£æ–¹å½¢ã€‚",
      "tips": ""
    },
    "To set up the rotation gesture, you need a starting angle, rotation. This state property enables you to track the change of rotation, and redraws the view every time it changes.": {
      "zh": "ä¸ºäº†è®¾ç½®æ—‹è½¬æ‰‹åŠ¿ï¼Œä½ éœ€è¦ä¸€ä¸ªèµ·å§‹è§’åº¦ rotationã€‚è¿™ä¸ªçŠ¶æ€å±æ€§ä½¿ä½ èƒ½å¤Ÿè·Ÿè¸ªæ—‹è½¬çš„å˜åŒ–ï¼Œå¹¶åœ¨æ¯æ¬¡å˜åŒ–æ—¶é‡æ–°ç»˜åˆ¶è§†å›¾ã€‚",
      "tips": ""
    },
    "You pass in rotation as the value for the .rotationEffect modifier, enabling the view to update the rotation angle as the value changes.": {
      "zh": "ä½ å°† rotation ä½œä¸º .rotationEffect ä¿®é¥°ç¬¦çš„å€¼ä¼ å…¥ï¼Œä½¿è§†å›¾èƒ½å¤Ÿåœ¨å€¼å˜åŒ–æ—¶æ›´æ–°æ—‹è½¬è§’åº¦ã€‚",
      "tips": ""
    },
    "Here you define a custom gesture using a RotationGesture.": {
      "zh": "è¿™é‡Œä½ ä½¿ç”¨ RotationGesture å®šä¹‰äº†ä¸€ä¸ªè‡ªå®šä¹‰æ‰‹åŠ¿ã€‚",
      "tips": ""
    },
    "While you rotate the square, the rotation property constantly updates the value of the @State property, rotation. SwiftUI then detects those changes and tells the square to redraw itself.": {
      "zh": "å½“ä½ æ—‹è½¬æ­£æ–¹å½¢æ—¶ï¼Œrotation å±æ€§ä¸æ–­æ›´æ–° @State å±æ€§ rotation çš„å€¼ã€‚SwiftUI ä¼šæ£€æµ‹åˆ°è¿™äº›å˜åŒ–ï¼Œå¹¶å‘Šè¯‰æ­£æ–¹å½¢é‡æ–°ç»˜åˆ¶è‡ªå·±ã€‚",
      "tips": ""
    },
    "To capture the gestureâ€™s final value, use the onEnded event handler. This updates rotation with the last value from the gesture and draws the square view to perfectly match the angle of your last movement.": {
      "zh": "ä¸ºäº†æ•è·æ‰‹åŠ¿çš„æœ€ç»ˆå€¼ï¼Œä½¿ç”¨ onEnded äº‹ä»¶å¤„ç†å™¨ã€‚è¿™ä¼šä½¿ç”¨æ‰‹åŠ¿çš„æœ€åä¸€ä¸ªå€¼æ›´æ–° rotationï¼Œå¹¶ç»˜åˆ¶æ­£æ–¹å½¢è§†å›¾ä»¥å®Œç¾åŒ¹é…ä½ æœ€åä¸€æ¬¡ç§»åŠ¨çš„è§’åº¦ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨æ„",
      "tips": ""
    },
    "You could remove this whole section of code, and you might not notice any difference when you rotate the square. However, if you record the exact angles, you might notice a small difference between the final angle of your finger movements and the final angle of the square after it stops rotating.": {
      "zh": "ä½ å¯ä»¥åˆ é™¤è¿™æ•´ä¸ªä»£ç éƒ¨åˆ†ï¼Œå½“ä½ æ—‹è½¬æ­£æ–¹å½¢æ—¶ä½ å¯èƒ½ä¸ä¼šæ³¨æ„åˆ°ä»»ä½•ä¸åŒã€‚ç„¶è€Œï¼Œå¦‚æœä½ è®°å½•ä¸‹ç¡®åˆ‡çš„è§’åº¦ï¼Œä½ å¯èƒ½ä¼šæ³¨æ„åˆ°ä½ çš„æ‰‹æŒ‡ç§»åŠ¨çš„æœ€ç»ˆè§’åº¦å’Œæ­£æ–¹å½¢åœæ­¢æ—‹è½¬åçš„æœ€ç»ˆè§’åº¦ä¹‹é—´çš„å¾®å°å·®å¼‚ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "",
      "tips": ""
    },
    "The last step required to make this square rotate is to add the .gesture modifier to the square, passing in rotationGesture so it responds to your touch.": {
      "zh": "æœ€åä¸€æ­¥æ˜¯è®©è¿™ä¸ªæ­£æ–¹å½¢æ—‹è½¬ï¼Œå°† .gesture ä¿®é¥°ç¬¦æ·»åŠ åˆ°æ­£æ–¹å½¢ä¸­ï¼Œä¼ å…¥ rotationGesture ä½¿å®ƒå“åº”ä½ çš„è§¦æ‘¸ã€‚",
      "tips": ""
    },
    "The rotation gesture is only available on Multi-Touch devices (Magic Mouse, Magic Trackpad, MacBook, or iOS devices), and may not be available in some macOS configurations. For more details, see Using Multi-Touch gestures on your Mac.": {
      "zh": "æ—‹è½¬æ‰‹åŠ¿ä»…é€‚ç”¨äºå¤šç‚¹è§¦æ‘¸è®¾å¤‡ï¼ˆMagic Mouseã€Magic Trackpadã€MacBook æˆ– iOS è®¾å¤‡ï¼‰ï¼Œå¹¶ä¸”å¯èƒ½åœ¨æŸäº› macOS é…ç½®ä¸­ä¸å¯ç”¨ã€‚æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…åœ¨ Mac ä¸Šä½¿ç”¨å¤šç‚¹è§¦æ‘¸æ‰‹åŠ¿ã€‚",
      "tips": ""
    },
    "Line Drawing": {
      "zh": "çº¿æ®µç»˜åˆ¶",
      "tips": ""
    },
    "Explore how to draw lines onscreen using a drag gesture.": {
      "zh": "æ¢ç´¢å¦‚ä½•ä½¿ç”¨æ‹–åŠ¨æ‰‹åŠ¿åœ¨å±å¹•ä¸Šç»˜åˆ¶çº¿æ¡ã€‚",
      "tips": ""
    },
    "In SingleLine, youâ€™ll use a drag gesture to draw a line in the view. To do this, youâ€™ll create a Path and redraw it every time you initiate a drag event.": {
      "zh": "åœ¨ SingleLine ä¸­ï¼Œä½ å°†ä½¿ç”¨æ‹–åŠ¨æ‰‹åŠ¿åœ¨è§†å›¾ä¸­ç»˜åˆ¶ä¸€æ¡çº¿ã€‚ä¸ºæ­¤ï¼Œä½ å°†åˆ›å»ºä¸€ä¸ª Pathï¼Œå¹¶åœ¨æ¯æ¬¡å¯åŠ¨æ‹–åŠ¨äº‹ä»¶æ—¶é‡æ–°ç»˜åˆ¶å®ƒã€‚",
      "tips": ""
    },
    "This drag gesture needs two state properties: one to track the start of the line, and one to track the end of the line.": {
      "zh": "è¿™ä¸ªæ‹–åŠ¨æ‰‹åŠ¿éœ€è¦ä¸¤ä¸ªçŠ¶æ€å±æ€§ï¼šä¸€ä¸ªç”¨æ¥è·Ÿè¸ªçº¿çš„èµ·ç‚¹ï¼Œä¸€ä¸ªç”¨æ¥è·Ÿè¸ªçº¿çš„ç»ˆç‚¹ã€‚",
      "tips": ""
    },
    "To draw a line, youâ€™ll use a Path, which creates an outline of a shape. First, youâ€™ll move the path to the lineStart value and then youâ€™ll add a line to the lineEnd value. Because each of these values are @State properties, any changes to their data causes SwiftUI to redraw the path and update the view. As a result, you can see the line updating as you drag around the view.": {
      "zh": "ä¸ºäº†ç»˜åˆ¶ä¸€æ¡çº¿ï¼Œä½ å°†ä½¿ç”¨ Pathï¼Œå®ƒåˆ›å»ºäº†ä¸€ä¸ªå½¢çŠ¶çš„è½®å»“ã€‚é¦–å…ˆï¼Œä½ å°†æŠŠè·¯å¾„ç§»åŠ¨åˆ° lineStart çš„å€¼ï¼Œç„¶åä½ å°†åœ¨ lineEnd çš„å€¼ä¸Šæ·»åŠ ä¸€æ¡çº¿ã€‚å› ä¸ºè¿™äº›å€¼éƒ½æ˜¯ @State å±æ€§ï¼Œæ‰€ä»¥å¯¹å®ƒä»¬çš„æ•°æ®çš„ä»»ä½•æ›´æ”¹éƒ½ä¼šå¯¼è‡´ SwiftUI é‡æ–°ç»˜åˆ¶è·¯å¾„å¹¶æ›´æ–°è§†å›¾ã€‚å› æ­¤ï¼Œä½ å¯ä»¥çœ‹åˆ°å½“ä½ åœ¨è§†å›¾å‘¨å›´æ‹–åŠ¨æ—¶ï¼Œçº¿æ¡åœ¨æ›´æ–°ã€‚",
      "tips": ""
    },
    "This drag gesture example uses a DragGesture, just like the other drag gesture example. However, here you need two event handlers: one thatâ€™s called as the drag value changes in .onChanged, and the other thatâ€™s called when the drag gesture ends in .onEnded.": {
      "zh": "è¿™ä¸ªæ‹–åŠ¨æ‰‹åŠ¿ç¤ºä¾‹ä½¿ç”¨ DragGestureï¼Œå°±åƒå…¶ä»–æ‹–åŠ¨æ‰‹åŠ¿ç¤ºä¾‹ä¸€æ ·ã€‚ç„¶è€Œï¼Œåœ¨è¿™é‡Œä½ éœ€è¦ä¸¤ä¸ªäº‹ä»¶å¤„ç†å™¨ï¼šä¸€ä¸ªåœ¨ .onChanged ä¸­è°ƒç”¨ï¼Œå½“æ‹–åŠ¨å€¼æ”¹å˜æ—¶ï¼Œå¦ä¸€ä¸ªåœ¨ .onEnded ä¸­è°ƒç”¨ï¼Œå½“æ‹–åŠ¨æ‰‹åŠ¿ç»“æŸæ—¶ã€‚",
      "tips": ""
    },
    "When your device detects a drag gesture, lineStart uses the initial location of the drag, and this value remains constant. However, lineEnd updates with a new location for each .onChanged event sent. This allows the line to redraw, making it look like youâ€™re dragging the end of the line wherever you want it to go.": {
      "zh": "å½“ä½ çš„è®¾å¤‡æ£€æµ‹åˆ°æ‹–åŠ¨æ‰‹åŠ¿æ—¶ï¼ŒlineStart ä½¿ç”¨æ‹–åŠ¨çš„åˆå§‹ä½ç½®ï¼Œè¿™ä¸ªå€¼ä¿æŒä¸å˜ã€‚ç„¶è€Œï¼ŒlineEnd ä¼šä½¿ç”¨æ¯ä¸ª .onChanged äº‹ä»¶å‘é€çš„æ–°ä½ç½®è¿›è¡Œæ›´æ–°ã€‚è¿™å°†ä¼šè®©çº¿æ¡é‡æ–°ç»˜åˆ¶ï¼Œä½¿å®ƒçœ‹èµ·æ¥åƒä½ åœ¨æ‹–åŠ¨çº¿æ¡çš„æœ«ç«¯ã€‚",
      "tips": ""
    },
    "The second event handler, .onEnded, captures the last location of your drag and updates the lineEnd property, ensuring your line ends where your touch left the view. After the .onEnded handler recognizes that youâ€™ve stopped drawing, the line stays in place until you start a new drag gesture.": {
      "zh": "ç¬¬äºŒä¸ªäº‹ä»¶å¤„ç†å™¨ .onEnded ä¼šæ•è·ä½ æ‹–åŠ¨çš„æœ€åä½ç½®ï¼Œå¹¶æ›´æ–° lineEnd å±æ€§ï¼Œç¡®ä¿ä½ çš„çº¿æ¡åœ¨ä½ çš„è§¦æ‘¸ç¦»å¼€è§†å›¾çš„åœ°æ–¹ç»“æŸã€‚åœ¨ .onEnded å¤„ç†ç¨‹åºè¯†åˆ«åˆ°ä½ å·²ç»åœæ­¢ç»˜åˆ¶ä¹‹åï¼Œçº¿æ¡ä¼šä¿æŒåœ¨åŸåœ°ï¼Œç›´åˆ°ä½ å¼€å§‹ä¸€ä¸ªæ–°çš„æ‹–åŠ¨æ‰‹åŠ¿ã€‚",
      "tips": ""
    },
    "To assign the gesture, pass in lineDrawingGesture to the .gesture modifier of your Path.": {
      "zh": "ä¸ºäº†è®©æ‰‹åŠ¿ç”Ÿæ•ˆï¼Œå°† lineDrawingGesture ä¼ é€’ç»™ Path çš„ .gesture ä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    },
    "Animating Shapes": {
      "zh": "åŠ¨ç”»å½¢çŠ¶",
      "tips": ""
    },
    "Learn how to use shapes and simple animations in SwiftUI.": {
      "zh": "å­¦ä¹ å¦‚ä½•åœ¨ SwiftUI ä¸­ä½¿ç”¨å½¢çŠ¶å’Œç®€å•çš„åŠ¨ç”»ã€‚",
      "tips": ""
    }
  },
  "sample-apps/seismometer": {
    "Seismometer": {
      "zh": "åœ°éœ‡ä»ª",
      "tips": ""
    },
    "Present dynamic data in custom views.": {
      "zh": "åœ¨è‡ªå®šä¹‰è§†å›¾ä¸­å‘ˆç°åŠ¨æ€æ•°æ®ã€‚",
      "tips": ""
    },
    "Welcome to Seismometer.": {
      "zh": "æ¬¢è¿æ¥åˆ°åœ°éœ‡ä»ªã€‚",
      "tips": ""
    },
    "You can use your iPad to detect vibrations using its built-in motion sensors. This sample shows how to display vibration information in two formats: a needle and a line graph.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ iPad å†…ç½®çš„è¿åŠ¨ä¼ æ„Ÿå™¨æ¥æ£€æµ‹éœ‡åŠ¨ã€‚è¿™ä¸ªä¾‹å­ä¼šå‘ä½ å±•ç¤ºå¦‚ä½•ç”¨ä¸¤ç§æ–¹å¼æ¥å±•ç¤ºéœ‡åŠ¨ï¼šé’ˆå½¢å›¾å’Œçº¿å½¢å›¾",
      "tips": ""
    },
    "Try out Seismometer by placing your iPad on a flat surface and then jostling it a bit. Or you can hold your iPad and move it up and down slowly.": {
      "zh": "ä½ å¯ä»¥å°†ä½ çš„ iPad æ”¾åœ¨ä¸€ä¸ªå¹³å¦çš„å¹³é¢ä¸Šï¼Œç„¶åç¨å¾®æ¨æŒ¤ä¸€ä¸‹æ¥ä½“éªŒâ€œåœ°éœ‡ä»ªâ€è¿™ä¸ª Appã€‚æˆ–è€…ï¼Œä½ å¯ä»¥æ‹¿ç€ä½ çš„ iPad æ…¢æ…¢åœ°ä¸Šä¸‹ç§»åŠ¨ã€‚",
      "tips": ""
    },
    "Motion Detector": {
      "zh": "",
      "tips": ""
    },
    "You can use the MotionDetector class to observe the motion of your device.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ MotionDetector ç±»æ¥è§‚å¯Ÿä½ çš„è®¾å¤‡çš„è¿åŠ¨ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "",
      "tips": ""
    },
    "Step 2": {
      "zh": "",
      "tips": ""
    },
    "A CMMotionManager is the object that you use to get motion data from the sensors in your iPad, such as the accelerometer. It gathers information from the sensors and translates their data into values you can understand.": {
      "zh": "CMotionManager æ˜¯ä½ ç”¨æ¥ä»ä½ çš„ iPad çš„ä¼ æ„Ÿå™¨ä¸­è·å–è¿åŠ¨æ•°æ®çš„å¯¹è±¡ï¼Œæ¯”å¦‚åŠ é€Ÿåº¦è®¡ã€‚å®ƒä¼šä»ä¼ æ„Ÿå™¨ä¸­æ”¶é›†ä¿¡æ¯ï¼Œå¹¶å°†å®ƒä»¬çš„æ•°æ®è½¬æ¢æˆä½ å¯ä»¥ç†è§£çš„å€¼ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "",
      "tips": ""
    },
    "The timer property stores a Timer instance. A timer waits for certain period of time, defined in the updateInterval property, before running some code. The MotionDetector uses the timer to update its pitch, roll, and zAcceleration values at regular intervals.": {
      "zh": "timer å±æ€§å­˜å‚¨äº†ä¸€ä¸ª Timer å®ä¾‹ã€‚Timer ä¼šåœ¨ä¸€æ®µæ—¶é—´åâ€”â€”å³ updateInterval å±æ€§ä¸­å®šä¹‰çš„æ—¶é—´åï¼Œè¿è¡Œä¸€äº›ä»£ç ã€‚MotionDetector ä½¿ç”¨ timer æ¥åœ¨å›ºå®šçš„æ—¶é—´é—´éš”å†…æ›´æ–°å®ƒçš„ pitchã€roll å’Œ zAcceleration å€¼ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨æ„",
      "tips": ""
    },
    "Choose an update interval that makes sense for your app. For example, youâ€™ll want a short update interval for the seismometers in this project because the interface presents real-time data as you move your iPad around.": {
      "zh": "é€‰æ‹©ä¸€ä¸ªå¯¹ä½ çš„ App æ¥è¯´æœ‰æ„ä¹‰çš„æ›´æ–°é—´éš”ã€‚ä¾‹å¦‚ï¼Œä½ ä¼šæƒ³è¦ä¸€ä¸ªçŸ­çš„æ›´æ–°é—´éš”ï¼Œå› ä¸ºè¿™ä¸ªé¡¹ç›®ä¸­çš„åœ°éœ‡ä»ªä¼šåœ¨ä½ ç§»åŠ¨ä½ çš„ iPad æ—¶å®æ—¶æ›´æ–°æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "",
      "tips": ""
    },
    "These three properties store data for the tilt of your device in two dimensions (roll and pitch), as well as its vertical acceleration (zAcceleration).": {
      "zh": "è¿™ä¸‰ä¸ªå±æ€§å­˜å‚¨äº†ä½ çš„è®¾å¤‡åœ¨ä¸¤ä¸ªç»´åº¦ä¸Šçš„å€¾æ–œï¼ˆroll å’Œ pitchï¼‰ï¼Œä»¥åŠå®ƒçš„å‚ç›´åŠ é€Ÿåº¦ï¼ˆzAccelerationï¼‰ã€‚",
      "tips": ""
    },
    "These properties have a @Published property wrapper, which means that any SwiftUI view that depends on their values automatically updates when the values change. You make a view dependent on a published property by using that value in the viewâ€™s code. The NeedleSeismometer and GraphSeismometer samples use these properties to update when the MotionDetector detects changes to the values of roll, pitch, and zAcceleration.": {
      "zh": "è¿™äº›å±æ€§æœ‰ä¸€ä¸ª @Published å±æ€§åŒ…è£…å™¨ï¼Œè¿™æ„å‘³ç€ä»»ä½•ä¾èµ–äºå®ƒä»¬å€¼çš„ SwiftUI è§†å›¾åœ¨å€¼æ”¹å˜æ—¶ä¼šè‡ªåŠ¨æ›´æ–°ã€‚ä½ å¯ä»¥é€šè¿‡åœ¨è§†å›¾çš„ä»£ç ä¸­ä½¿ç”¨è¯¥å€¼æ¥ä½¿è§†å›¾ä¾èµ–äºå·²å‘å¸ƒçš„å±æ€§ã€‚NeedleSeismometer å’Œ GraphSeismometer ç¤ºä¾‹ä¼šä½¿ç”¨è¿™äº›å±æ€§æ¥åœ¨ MotionDetector æ£€æµ‹åˆ° rollã€pitch å’Œ zAcceleration å€¼çš„å˜åŒ–æ—¶æ›´æ–°ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "",
      "tips": ""
    },
    "This property stores code that runs when the MotionDetector updates its motion data. If you want to execute custom actions when the motion data changes, you can put your own code into onUpdate in your instance of MotionDetector.": {
      "zh": "è¿™ä¸ªå±æ€§å­˜å‚¨äº† MotionDetector æ›´æ–°å®ƒçš„è¿åŠ¨æ•°æ®æ—¶è¦è¿è¡Œçš„ä»£ç ã€‚å¦‚æœä½ æƒ³åœ¨è¿åŠ¨æ•°æ®æ”¹å˜æ—¶æ‰§è¡Œè‡ªå®šä¹‰æ“ä½œï¼Œä½ å¯ä»¥å°†ä½ è‡ªå·±çš„ä»£ç æ”¾åˆ° MotionDetector çš„ onUpdate ä¸­ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "",
      "tips": ""
    },
    "This method starts updating the motion detector.": {
      "zh": "è¿™ä¸ªæ–¹æ³•å¼€å§‹æ›´æ–°è¿åŠ¨æ£€æµ‹å™¨ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "",
      "tips": ""
    },
    "Always use isDeviceMotionAvailable to verify that motion data is available before you try to access it.": {
      "zh": "å½“ä½ åœ¨å°è¯•è®¿é—®å®ƒä¹‹å‰ï¼Œæ€»æ˜¯ä½¿ç”¨ isDeviceMotionAvailable æ¥éªŒè¯è¿åŠ¨æ•°æ®æ˜¯å¦å¯ç”¨ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "",
      "tips": ""
    },
    "This method tells the CMMotionManager to start updating motion data.": {
      "zh": "è¿™ä¸ªæ–¹æ³•å‘Šè¯‰ CMMotionManager å¼€å§‹æ›´æ–°è¿åŠ¨æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "",
      "tips": ""
    },
    "This code creates a new timer and schedules it to run. The updateInterval property tells the timer how long to wait between updates, and repeats is set to true so the timer runs forever until you stop it. (If you pass false to repeats, the timer only runs once.) The block of code at the end of the line that reads { _ in is the start of a closure that contains the code run by the timer. The closure calls the updateMotionData() method.": {
      "zh": "è¿™æ®µä»£ç åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„è®¡æ—¶å™¨ï¼Œå¹¶è®¾å®šäº†å®ƒè°ƒç”¨çš„æ—¶æœºã€‚updateInterval å±æ€§ä¼šå‘Šè¯‰è®¡æ—¶å™¨åœ¨æ›´æ–°ä¹‹é—´ç­‰å¾…å¤šé•¿æ—¶é—´ï¼Œç”±äº repeats è¢«è®¾ç½®ä¸º trueï¼Œå› æ­¤è®¡æ—¶å™¨ä¼šä¸€ç›´è¿è¡Œï¼Œç›´åˆ°ä½ åœæ­¢å®ƒï¼ˆå¦‚æœä½ ä¼ é€’ false ç»™ repeatsï¼Œè®¡æ—¶å™¨åªä¼šè¿è¡Œä¸€æ¬¡ã€‚ï¼‰ã€‚ è¡Œæœ«å°¾çš„ä»£ç å— { _ in è®¡æ—¶å™¨ä¼šè°ƒç”¨çš„é—­åŒ…çš„å¼€å§‹éƒ¨åˆ†ã€‚åœ¨è¿™ä¸ªé—­åŒ…ä¸­ï¼Œä»£ç è°ƒç”¨äº† updateMotionData() æ–¹æ³•ã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "",
      "tips": ""
    },
    "The updateMotionData() method does the core work of the motion detector. Itâ€™s responsible for updating all published properties with current data from the sensors, as well as calling the code in onUpdate.": {
      "zh": "updateMotionData() æ–¹æ³•å®Œæˆäº†æ˜¯è¿åŠ¨æ£€æµ‹å™¨çš„æ ¸å¿ƒå·¥ä½œã€‚å®ƒè´Ÿè´£ä½¿ç”¨ä¼ æ„Ÿå™¨çš„å½“å‰æ•°æ®æ›´æ–°æ‰€æœ‰å·²å‘å¸ƒçš„å±æ€§ï¼Œä»¥åŠè°ƒç”¨ onUpdate æ–¹æ³•ã€‚",
      "tips": ""
    },
    "Step 11": {
      "zh": "",
      "tips": ""
    },
    "The deviceMotion data may not be there in certain conditions. To see if the data exists, try to assign deviceMotion to a variable or constant using if let. If the motion data exists, itâ€™s assigned to data and the code inside the braces runs. Otherwise, it skips the entire if statement.": {
      "zh": "deviceMotion æ•°æ®åœ¨æŸäº›æƒ…å†µä¸‹å¯èƒ½ä¸å­˜åœ¨ã€‚è¦æŸ¥çœ‹æ•°æ®æ˜¯å¦å­˜åœ¨ï¼Œè¯·å°è¯•ä½¿ç”¨ if let å°† deviceMotion åˆ†é…ç»™å˜é‡æˆ–å¸¸é‡ã€‚å¦‚æœè¿åŠ¨æ•°æ®å­˜åœ¨ï¼Œå®ƒå°±ä¼šè¢«åˆ†é…ç»™ dataï¼Œç„¶åèŠ±æ‹¬å·å†…çš„ä»£ç å°±ä¼šè¿è¡Œã€‚å¦åˆ™ï¼Œå®ƒå°±ä¼šè·³è¿‡æ•´ä¸ª if è¯­å¥ã€‚",
      "tips": ""
    },
    "Step 12": {
      "zh": "",
      "tips": ""
    },
    "A CMDeviceMotion instance represents device motion, stored in data. The CMDeviceMotion class has quite a few properties for describing the input from the motion sensors. Use the attitude property to get the deviceâ€™s tilt in three directions. You may be familiar with X, Y, and Z axes in 3D space, which relate to pitch, roll, and yaw, respectively.": {
      "zh": "CMDeviceMotion å®ä¾‹è¡¨ç¤ºè®¾å¤‡è¿åŠ¨çŠ¶æ€ï¼Œå­˜å‚¨åœ¨ data å±æ€§ä¸­ã€‚CMDeviceMotion ç±»æœ‰å¾ˆå¤šå±æ€§æ¥æè¿°è¿åŠ¨ä¼ æ„Ÿå™¨çš„è¾“å…¥ã€‚ä½¿ç”¨ attitude å±æ€§æ¥è·å–è®¾å¤‡åœ¨ä¸‰ä¸ªæ–¹å‘ä¸Šçš„å€¾æ–œã€‚ä½ å¯èƒ½ç†Ÿæ‚‰ 3D ç©ºé—´ä¸­çš„ Xã€Y å’Œ Z è½´ï¼Œå®ƒä»¬åˆ†åˆ«ä¸ pitchã€roll å’Œ yaw ç›¸å…³ã€‚",
      "tips": ""
    },
    "Step 13": {
      "zh": "",
      "tips": ""
    },
    "Use the userAcceleration property to get the deviceâ€™s acceleration after accounting for the downward pull of gravity. If your device is still, this number is 0. However, the value changes to a negative number when you lift your iPad upward, or to a positive number when you move your iPad downward.": {
      "zh": "ä½¿ç”¨ userAcceleration å±æ€§æ¥è·å–è®¾å¤‡åœ¨è€ƒè™‘åˆ°é‡åŠ›å‘ä¸‹æ‹‰çš„æƒ…å†µä¸‹çš„åŠ é€Ÿåº¦ã€‚å¦‚æœä½ çš„è®¾å¤‡é™æ­¢ä¸åŠ¨ï¼Œè¿™ä¸ªæ•°å€¼å°±æ˜¯ 0ã€‚ç„¶è€Œï¼Œå½“ä½ å°† iPad å‘ä¸ŠæŠ¬èµ·æ—¶ï¼Œè¿™ä¸ªå€¼ä¼šå˜æˆä¸€ä¸ªè´Ÿæ•°ï¼Œæˆ–è€…å½“ä½ å°† iPad å‘ä¸‹ç§»åŠ¨æ—¶ï¼Œè¿™ä¸ªå€¼ä¼šå˜æˆä¸€ä¸ªæ­£æ•°ã€‚",
      "tips": ""
    },
    "Step 14": {
      "zh": "",
      "tips": ""
    },
    "You run the code in onUpdate just as youâ€™d call any function, with a set of parentheses following its name.": {
      "zh": "ä½ å¯ä»¥åƒè°ƒç”¨ä»»ä½•å‡½æ•°ä¸€æ ·è°ƒç”¨ onUpdate ä¸­çš„ä»£ç ï¼Œåªéœ€è¦åœ¨å‡½æ•°ååé¢åŠ ä¸Šä¸€å¯¹æ‹¬å·ã€‚",
      "tips": ""
    },
    "Step 15": {
      "zh": "",
      "tips": ""
    },
    "The stop() method tells the CMMotionManager class to stop updating its values by calling stopDeviceMotionUpdates(), then it stops the timer by calling invalidate().": {
      "zh": "stop() æ–¹æ³•é€šè¿‡è°ƒç”¨ stopDeviceMotionUpdates() å‘Šè¯‰ CMMotionManager ç±»åœæ­¢æ›´æ–°å®ƒçš„å€¼ï¼Œç„¶åå®ƒé€šè¿‡è°ƒç”¨ invalidate() åœæ­¢è®¡æ—¶å™¨ã€‚",
      "tips": ""
    },
    "Step 16": {
      "zh": "",
      "tips": ""
    },
    "This deinitializer runs when a MotionDetector instance is about to go away. Itâ€™s important to clean up here; otherwise the timer continues to run even after the motion detector is gone.": {
      "zh": "è¿™ä¸ªææ„å™¨åœ¨ MotionDetector å®ä¾‹å³å°†æ¶ˆå¤±æ—¶è¿è¡Œã€‚åœ¨è¿™é‡Œåšä¸€äº›å–„åå·¥ä½œå¾ˆé‡è¦ï¼›å¦åˆ™ï¼Œå³ä½¿ motion detector å¯¹è±¡æ¶ˆå¤±äº†ï¼Œè®¡æ—¶å™¨ä»ç„¶ä¼šç»§ç»­è¿è¡Œã€‚",
      "tips": ""
    },
    "Needle Seismometer": {
      "zh": "æŒ‡é’ˆåœ°éœ‡ä»ª",
      "tips": ""
    },
    "Learn how to display a needle that registers the vibration of your device.": {
      "zh": "å­¦ä¹ å¦‚ä½•æ˜¾ç¤ºä¸€ä¸ªå¯ä»¥è®°å½•ä½ çš„è®¾å¤‡æŒ¯åŠ¨çš„æŒ‡é’ˆã€‚",
      "tips": ""
    },
    "The NeedleSeismometer view displays a needle that moves as your device vibrates. It uses the zAcceleration data from a MotionDetector instance to detect vibration, and translates that data into left and right rotation of the needle.": {
      "zh": "NeedleSeismometer è§†å›¾æ˜¾ç¤ºä¸€ä¸ªéšç€ä½ çš„è®¾å¤‡æŒ¯åŠ¨è€Œç§»åŠ¨çš„æŒ‡é’ˆã€‚å®ƒä½¿ç”¨ MotionDetector å®ä¾‹çš„ zAcceleration æ•°æ®æ¥æ£€æµ‹æŒ¯åŠ¨ï¼Œå¹¶å°†è¿™äº›æ•°æ®è½¬æ¢ä¸ºæŒ‡é’ˆçš„å·¦å³æ—‹è½¬ã€‚",
      "tips": ""
    },
    "The motionDetector property holds a MotionDetector instance. The motion detector senses changes in your deviceâ€™s motion and provides that data for use in your code.": {
      "zh": "motionDetector å±æ€§ä¿å­˜ä¸€ä¸ª MotionDetector å®ä¾‹ã€‚è¿åŠ¨æ£€æµ‹å™¨ä¼šæ„ŸçŸ¥ä½ çš„è®¾å¤‡è¿åŠ¨çš„å˜åŒ–ï¼Œå¹¶æä¾›è¿™äº›æ•°æ®ä¾›ä½ åœ¨ä»£ç ä¸­ä½¿ç”¨ã€‚",
      "tips": ""
    },
    "The property has an @EnvironmentObject property wrapper because this view expects the app to put a motion detector in the environment for it to use.": {
      "zh": "è¯¥å±æ€§æœ‰ä¸€ä¸ª @EnvironmentObject å±æ€§åŒ…è£…å™¨ï¼Œå› ä¸ºè¯¥è§†å›¾æœŸæœ›åº”ç”¨ç¨‹åºå°†ä¸€ä¸ªè¿åŠ¨æ£€æµ‹å™¨æ”¾åœ¨ç¯å¢ƒä¸­ä¾›å®ƒä½¿ç”¨ã€‚",
      "tips": ""
    },
    "The seismometer display is a vertical stack (VStack) with a rotating needle, text that displays the raw values from the sensor, and some instructions for people to follow.": {
      "zh": "åœ°éœ‡ä»ªæ˜¾ç¤ºæ˜¯ä¸€ä¸ªå‚ç›´å †æ ˆï¼ˆVStackï¼‰ï¼Œæœ‰ä¸€ä¸ªæ—‹è½¬çš„æŒ‡é’ˆï¼Œä¸€ä¸ªæ˜¾ç¤ºä¼ æ„Ÿå™¨åŸå§‹å€¼çš„æ–‡æœ¬ï¼Œä»¥åŠä¸€äº›äººä»¬è¦éµå¾ªçš„æŒ‡ç¤ºã€‚",
      "tips": ""
    },
    "You can use a ZStack to layer views on top of each other. Here, the background view for the gauge goes underneath the needle itself. The background draws a semicircle with marks around its edge. Check out the code in GaugeBackground.swift if youâ€™re curious how thatâ€™s done.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ ZStack å°†è§†å›¾å±‚å åœ¨ä¸€èµ·ã€‚åœ¨è¿™é‡Œï¼Œä»ªè¡¨ç›˜çš„èƒŒæ™¯è§†å›¾ä½äºæŒ‡é’ˆæœ¬èº«çš„ä¸‹æ–¹ã€‚èƒŒæ™¯ç»˜åˆ¶äº†ä¸€ä¸ªå¸¦æœ‰æ ‡è®°çš„åŠåœ†ã€‚å¦‚æœä½ æƒ³çŸ¥é“è¿™æ˜¯æ€ä¹ˆåšçš„ï¼Œè¯·æŸ¥çœ‹ GaugeBackground.swift ä¸­çš„ä»£ç ã€‚",
      "tips": ""
    },
    "The needle is just a rectangle with a .frame modifier to give it a narrow, tall shape. It also uses the .foregroundColor modifier to adopt the appâ€™s accent color. Try changing the accent color of this sample to see how it affects the view.": {
      "zh": "æŒ‡é’ˆåªæ˜¯ä¸€ä¸ªçŸ©å½¢ï¼Œæœ‰ä¸€ä¸ª .frame ä¿®é¥°ç¬¦ï¼Œç»™å®ƒä¸€ä¸ªç‹­çª„çš„ã€é«˜çš„å½¢çŠ¶ã€‚å®ƒè¿˜ä½¿ç”¨ .foregroundColor ä¿®é¥°ç¬¦æ¥é‡‡ç”¨åº”ç”¨ç¨‹åºçš„å¼ºè°ƒé¢œè‰²ã€‚å°è¯•æ›´æ”¹æ­¤ç¤ºä¾‹çš„å¼ºè°ƒé¢œè‰²ï¼Œçœ‹çœ‹å®ƒå¦‚ä½•å½±å“è§†å›¾ã€‚",
      "tips": ""
    },
    "Use the .rotationEffect modifier to rotate the rectangle for the needle, and set the rotationAngle and needleAnchor properties to define the needleâ€™s behavior. You pass in rotationAngle as the first argument, which interprets the motion data to calculate the correct needle angle.": {
      "zh": "ä½¿ç”¨ .rotationEffect ä¿®é¥°ç¬¦æ¥æ—‹è½¬æŒ‡é’ˆçš„çŸ©å½¢ï¼Œå¹¶è®¾ç½® rotationAngle å’Œ needleAnchor å±æ€§æ¥å®šä¹‰æŒ‡é’ˆçš„è¡Œä¸ºã€‚ä½ å°† rotationAngle ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ä¼ å…¥ï¼Œå®ƒä¼šè§£é‡Šè¿åŠ¨æ•°æ®æ¥è®¡ç®—æ­£ç¡®çš„æŒ‡é’ˆè§’åº¦ã€‚",
      "tips": ""
    },
    "By default, rotation happens around the center of a view; however, you can use the needleAnchor property as the second argument so the needle rotates at its base.": {
      "zh": "é»˜è®¤æƒ…å†µä¸‹ï¼Œæ—‹è½¬å‘ç”Ÿåœ¨è§†å›¾çš„ä¸­å¿ƒï¼›ç„¶è€Œï¼Œä½ å¯ä»¥ä½¿ç”¨ needleAnchor å±æ€§ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ï¼Œè¿™æ ·æŒ‡é’ˆå°±ä¼šåœ¨å®ƒçš„åº•éƒ¨æ—‹è½¬ã€‚",
      "tips": ""
    },
    "The rotationAngle property returns the amount the needle rotates for a given sensor reading. The rotationEffect property expects an Angle instance, so you can create one using the zAcceleration property of the motion detector. The motion detector represents upward acceleration with a negative number, but youâ€™re multiplying by -1 to make upward acceleration positive, and downward acceleration negative.": {
      "zh": "rotationAngle å±æ€§è¿”å›æŒ‡é’ˆåœ¨ç»™å®šä¼ æ„Ÿå™¨è¯»æ•°ä¸‹æ—‹è½¬çš„é‡ã€‚rotationEffect å±æ€§æœŸæœ›ä¸€ä¸ª Angle å®ä¾‹ï¼Œæ‰€ä»¥ä½ å¯ä»¥ä½¿ç”¨è¿åŠ¨æ£€æµ‹å™¨çš„ zAcceleration å±æ€§åˆ›å»ºä¸€ä¸ªã€‚è¿åŠ¨æ£€æµ‹å™¨ç”¨ä¸€ä¸ªè´Ÿæ•°è¡¨ç¤ºå‘ä¸Šçš„åŠ é€Ÿåº¦ï¼Œä½†æ˜¯ä½ ä¹˜ä»¥ -1 æ¥ä½¿å‘ä¸Šçš„åŠ é€Ÿåº¦ä¸ºæ­£ï¼Œå‘ä¸‹çš„åŠ é€Ÿåº¦ä¸ºè´Ÿã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®éªŒ",
      "tips": ""
    },
    "The amplification constant is useful for controlling the sensitivity of the display. Try changing its value to see how that affects the needle.": {
      "zh": "amplification å¸¸é‡å¯¹äºæ§åˆ¶æ˜¾ç¤ºçš„çµæ•åº¦å¾ˆæœ‰ç”¨ã€‚å°è¯•æ›´æ”¹å®ƒçš„å€¼ï¼Œçœ‹çœ‹å®ƒå¦‚ä½•å½±å“æŒ‡é’ˆã€‚",
      "tips": ""
    },
    "The needleAnchor property defines the point of rotation for the needle as a UnitPoint. A unit point has x and y coordinates like a regular point, but their values only range between 0 and 1.": {
      "zh": "needleAnchor å±æ€§å°†æŒ‡é’ˆçš„æ—‹è½¬ç‚¹å®šä¹‰ä¸º UnitPointã€‚ä¸€ä¸ªå•ä½ç‚¹æœ‰ x å’Œ y åæ ‡ï¼Œå°±åƒä¸€ä¸ªæ™®é€šçš„ point ç±»å‹ï¼Œä½†å®ƒä»¬çš„å€¼åªèƒ½å–åœ¨ 0 å’Œ 1 ä¹‹é—´ã€‚",
      "tips": ""
    },
    "A unit point is useful for defining a point inside any view, regardless of its size. This one defines the midpoint of a view (width-wise) at its bottom. Regardless of the viewâ€™s size, the point is exactly at that location relative to the viewâ€™s width and height.": {
      "zh": "å½“æˆ‘ä»¬ä¸æƒ³å…³å¿ƒè§†å›¾çš„å…·ä½“å¤§å°çš„æ—¶å€™ï¼Œç”¨ unit point æ¥å®šä¹‰è§†å›¾å†…éƒ¨çš„ç‚¹ä¼šéå¸¸æœ‰ç”¨ã€‚åœ¨è¿™é‡Œï¼Œè¿™ä¸ª unit point å®šä¹‰äº†è§†å›¾çš„ä¸­ç‚¹ï¼ˆå®½åº¦æ–¹å‘ï¼‰åœ¨è§†å›¾åº•éƒ¨ã€‚æ— è®ºå…·ä½“è§†å›¾çš„å¤§å°æ˜¯å¤šå°‘ï¼Œè¯¥ç‚¹éƒ½æ°å¥½ä½äºç›¸å¯¹äºè§†å›¾å®½åº¦å’Œé«˜åº¦çš„å›ºå®šä½ç½®ã€‚",
      "tips": ""
    },
    "Without this overlay, youâ€™d get a plain rectangle that rotates at its base. But to make things a little more polished, this overlay adds a small circle at the bottom.": {
      "zh": "å¦‚æœæ²¡æœ‰è¿™ä¸ª overlayï¼Œä½ å°±ä¼šå¾—åˆ°ä¸€ä¸ªåœ¨åº•éƒ¨æ—‹è½¬çš„æ™®é€šçŸ©å½¢ã€‚ä½†æ˜¯ä¸ºäº†è®©çŸ©å½¢çœ‹èµ·æ¥æ›´åŠ ç²¾è‡´ï¼Œè¿™ä¸ª overlay åœ¨çŸ©å½¢åº•éƒ¨æ·»åŠ äº†ä¸€ä¸ªå°åœ†ã€‚",
      "tips": ""
    },
    "You can use an overlay to put content directly on top of a view. The overlay occupies the same area as its parent view. In this overlay, a Spacer pushes a small Circle to the bottom of a VStack so it aligns with the base of the needle.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ overlay å°†å†…å®¹ç›´æ¥æ”¾åœ¨è§†å›¾çš„é¡¶éƒ¨ã€‚overlay å æ®ä¸å…¶çˆ¶è§†å›¾ç›¸åŒçš„åŒºåŸŸã€‚åœ¨è¿™ä¸ª overlay ä¸­ï¼Œä¸€ä¸ª Spacer å°†ä¸€ä¸ªå°åœ†æ¨åˆ° VStack çš„åº•éƒ¨ï¼Œè¿™æ ·å®ƒå°±ä¸æŒ‡é’ˆçš„åº•éƒ¨å¯¹é½äº†ã€‚",
      "tips": ""
    },
    "Graph Seismometer": {
      "zh": "å›¾å½¢åŒ–çš„åœ°éœ‡ä»ª",
      "tips": ""
    },
    "Learn how to display the vibration of your device as an animated line graph.": {
      "zh": "å­¦ä¹ å¦‚ä½•å°†ä½ çš„è®¾å¤‡çš„æŒ¯åŠ¨æ˜¾ç¤ºä¸ºä¸€ä¸ªåŠ¨ç”»çš„æŠ˜çº¿å›¾ã€‚",
      "tips": ""
    },
    "The GraphSeismometer view displays a line graph of your deviceâ€™s vibration. It uses the zAcceleration data from a MotionDetector instance to detect vibration, and translates that data into Y values in the graph; the X values represent time.": {
      "zh": "",
      "tips": "GraphSeismometer è§†å›¾æ˜¾ç¤ºäº†ä½ çš„è®¾å¤‡çš„æŒ¯åŠ¨çš„æŠ˜çº¿å›¾ã€‚å®ƒä½¿ç”¨ MotionDetector å®ä¾‹çš„ zAcceleration æ•°æ®æ¥æ£€æµ‹æŒ¯åŠ¨ï¼Œå¹¶å°†è¯¥æ•°æ®è½¬æ¢ä¸ºå›¾è¡¨ä¸­çš„ Y å€¼ï¼›X å€¼è¡¨ç¤ºæ—¶é—´ã€‚"
    },
    "This property holds a MotionDetector instance. The motion detector senses changes in your deviceâ€™s motion and provides that data for you to use in your code.": {
      "zh": "è¿™ä¸ªå±æ€§ä¿å­˜äº†ä¸€ä¸ª MotionDetector å®ä¾‹ã€‚å®ƒä¼šæ„ŸçŸ¥ä½ çš„è®¾å¤‡è¿åŠ¨çš„å˜åŒ–ï¼Œå¹¶ä¸ºä½ æä¾›è¿™äº›æ•°æ®ï¼Œä»¥ä¾¿ä½ åœ¨ä»£ç ä¸­ä½¿ç”¨ã€‚",
      "tips": ""
    },
    "The data property stores the seismometer data youâ€™ll graph in this view as an array of Double values. It includes a @State property wrapper because you want the line graph to update whenever the data changes.": {
      "zh": "data å±æ€§æ˜¯ä¸€ä¸ªå€¼ä¸º Double çš„æ•°ç»„ï¼Œå®ƒä¼šå­˜å‚¨åœ°éœ‡ä»ªçš„æ•°æ®ï¼Œå¹¶æä¾›ç»™ä½ ä»¥ä¾¿åœ¨è§†å›¾ä¸­ä»¥å›¾å½¢å½¢å¼å‘ˆç°ã€‚å› ä¸ºä½ ä¼šå¸Œå½“æ•°æ®å˜åŒ–æ—¶æŠ˜çº¿å›¾ä¹Ÿè·Ÿç€å˜åŒ–ï¼Œæ‰€ä»¥è¿™ä¸ªå±æ€§è¿˜åŒ…æ‹¬äº†ä¸€ä¸ª @State å±æ€§åŒ…è£…å™¨ã€‚",
      "tips": ""
    },
    "The maxData property represents the maximum number of data points your graph shows. This is vital, because the seismometer updates 100 times per second, which produces a lot of data, and you donâ€™t want to keep that around forever. When you accumulate enough data, youâ€™ll start deleting the old ones.": {
      "zh": "maxData å±æ€§è¡¨ç¤ºä½ çš„å›¾è¡¨æ˜¾ç¤ºçš„æ•°æ®ç‚¹çš„æœ€å¤§æ•°é‡ã€‚è¿™æ˜¯è‡³å…³é‡è¦çš„ï¼Œå› ä¸ºåœ°éœ‡ä»ªæ¯ç§’æ›´æ–° 100 æ¬¡ï¼Œè¿™ä¼šäº§ç”Ÿå¤§é‡çš„æ•°æ®ï¼Œè€Œä½ ä¸å¸Œæœ›æ°¸è¿œä¿ç•™è¿™äº›æ•°æ®ã€‚å½“ä½ ç§¯ç´¯äº†è¶³å¤Ÿçš„æ•°æ®ï¼Œä½ å°±ä¼šå¼€å§‹åˆ é™¤æ—§æ•°æ®ã€‚",
      "tips": ""
    },
    "The sensitivity property controls how sensitive the seismometer is to motion. Sensitivity affects the line graph by expanding it vertically. The higher the sensitivity, the larger the peaks and valleys will appear in the graph.": {
      "zh": "sensitivity å±æ€§æ§åˆ¶åœ°éœ‡ä»ªå¯¹è¿åŠ¨çš„æ•æ„Ÿåº¦ã€‚æ•æ„Ÿåº¦ä¼šé€šè¿‡åœ¨å‚ç›´æ–¹å‘ä¸Šæ‰©å±•æŠ˜çº¿å›¾æ¥å½±å“æŠ˜çº¿å›¾ã€‚æ•æ„Ÿåº¦è¶Šé«˜ï¼Œå›¾è¡¨ä¸­çš„å³°å€¼å’Œè°·å€¼å°±ä¼šè¶Šå¤§ã€‚",
      "tips": ""
    },
    "The graphMaxValueMostSensitive property represents the maximum value the graph displays at its most sensitive, and graphMaxValueLeastSensitive represents the maximum value displayed at its least sensitive. Along with sensitivity, these properties control the graphâ€™s display.": {
      "zh": "graphMaxValueMostSensitive å±æ€§è¡¨ç¤ºå›¾è¡¨åœ¨æœ€æ•æ„Ÿæ—¶æ˜¾ç¤ºçš„æœ€å¤§å€¼ï¼ŒgraphMaxValueLeastSensitive è¡¨ç¤ºåœ¨æœ€ä¸æ•æ„Ÿæ—¶æ˜¾ç¤ºçš„æœ€å¤§å€¼ã€‚è¿™äº›å±æ€§ä¸æ•æ„Ÿåº¦ä¸€èµ·æ§åˆ¶å›¾è¡¨çš„æ˜¾ç¤ºã€‚",
      "tips": ""
    },
    "Try changing these values to affect the range of sensitivity of the graph. (Note that graphMaxValueMostSensitive should always be less than graphMaxValueLeastSensitive.)": {
      "zh": "å°è¯•æ›´æ”¹è¿™äº›å€¼ä»¥å½±å“å›¾è¡¨çš„æ•æ„Ÿåº¦èŒƒå›´ã€‚ï¼ˆæ³¨æ„ï¼ŒgraphMaxValueMostSensitive åº”è¯¥å§‹ç»ˆå°äº graphMaxValueLeastSensitiveã€‚ï¼‰",
      "tips": ""
    },
    "This property represents the maximum value of the graph: the one thatâ€™s represented by the top edge. The calculation uses the sensitivity properties declared above.": {
      "zh": "è¿™ä¸ªå±æ€§è¡¨ç¤ºå›¾è¡¨çš„æœ€å¤§å€¼ï¼šä¹Ÿå°±æ˜¯é¡¶éƒ¨è¾¹ç¼˜æ‰€ä»£è¡¨çš„å€¼ã€‚è®¡ç®—ä½¿ç”¨äº†ä¸Šé¢å£°æ˜çš„æ•æ„Ÿåº¦å±æ€§ã€‚",
      "tips": ""
    },
    "The LineGraph.swift file represents the main view of the seismometer. The initializer for LineGraph has four parameters: the data to display, the maximum amount of data in the graph, and the minimum and maximum values corresponding to its bottom and top edges.": {
      "zh": "LineGraph.swift æ–‡ä»¶è¡¨ç¤ºåœ°éœ‡ä»ªçš„ä¸»è§†å›¾ã€‚LineGraph çš„åˆå§‹åŒ–å™¨æœ‰å››ä¸ªå‚æ•°ï¼šè¦æ˜¾ç¤ºçš„æ•°æ®ã€å›¾è¡¨ä¸­çš„æœ€å¤§æ•°æ®é‡ï¼Œä»¥åŠå¯¹åº”äºå…¶åº•éƒ¨å’Œé¡¶éƒ¨è¾¹ç¼˜çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ã€‚",
      "tips": ""
    },
    "As you explore the seismometer, youâ€™ll notice that the data can contain values outside the minimum and maximum range, but they arenâ€™t displayed because they fall outside the view bounds.": {
      "zh": "å½“ä½ æ¢ç´¢åœ°éœ‡ä»ªæ—¶ï¼Œä½ ä¼šæ³¨æ„åˆ°æ•°æ®å¯èƒ½åŒ…å«åœ¨æœ€å°å€¼å’Œæœ€å¤§å€¼èŒƒå›´ä¹‹å¤–çš„å€¼ï¼Œä½†å®ƒä»¬ä¸ä¼šè¢«æ˜¾ç¤ºï¼Œå› ä¸ºå®ƒä»¬è¶…å‡ºäº†è§†å›¾è¾¹ç•Œã€‚",
      "tips": ""
    },
    "These five modifiers configure the line graph display. The .clipped modifier prevents the line from drawing outside its frame. You can use .background to set the background color. By using .accentColor the display can adapt to your appâ€™s theme. Using opacity makes the color less bold.": {
      "zh": "è¿™äº”ä¸ªä¿®é¥°ç¬¦é…ç½®äº†æŠ˜çº¿å›¾çš„æ˜¾ç¤ºã€‚.clipped ä¿®é¥°ç¬¦é˜²æ­¢çº¿æ¡åœ¨å…¶æ¡†æ¶ä¹‹å¤–ç»˜åˆ¶ã€‚ä½ å¯ä»¥ä½¿ç”¨ .background æ¥è®¾ç½®èƒŒæ™¯é¢œè‰²ã€‚é€šè¿‡ä½¿ç”¨ .accentColorï¼Œæ˜¾ç¤ºå¯ä»¥é€‚åº”ä½ çš„åº”ç”¨ç¨‹åºçš„ä¸»é¢˜ã€‚ä½¿ç”¨ opacity ä½¿é¢œè‰²ä¸é‚£ä¹ˆé†’ç›®ã€‚",
      "tips": ""
    },
    "Try commenting out the .clipped modifier to see what happens with the graph display.": {
      "zh": "å°è¯•æ³¨é‡Šæ‰ .clipped ä¿®é¥°ç¬¦ï¼Œçœ‹çœ‹å›¾è¡¨æ˜¾ç¤ºä¼šå‘ç”Ÿä»€ä¹ˆã€‚",
      "tips": ""
    },
    "You can curve the points of the graph by adding .cornerRadius to the line. Change the number to make the curves broader or narrower. The .padding modifier adds some space around the edges to keep it away from other views.": {
      "zh": "ä½ å¯ä»¥é€šè¿‡åœ¨çº¿æ¡ä¸Šæ·»åŠ  .cornerRadius æ¥ä½¿å›¾è¡¨çš„ç‚¹å˜æˆæ›²çº¿ã€‚æ›´æ”¹æ•°å­—å¯ä»¥ä½¿æ›²çº¿å˜å®½æˆ–å˜çª„ã€‚.padding ä¿®é¥°ç¬¦åœ¨è¾¹ç¼˜å‘¨å›´æ·»åŠ äº†ä¸€äº›ç©ºé—´ï¼Œä½¿å…¶è¿œç¦»å…¶ä»–è§†å›¾ã€‚",
      "tips": ""
    },
    "The modifier .aspectRatio gives it a square shape.": {
      "zh": ".aspectRatio ä¿®é¥°ç¬¦ä½¿å…¶å‘ˆæ­£æ–¹å½¢ã€‚",
      "tips": ""
    },
    "Try changing the number to 2, or 0.3, to see how that affects the display.": {
      "zh": "å°è¯•å°†æ•°å­—æ›´æ”¹ä¸º 2 æˆ– 0.3ï¼Œçœ‹çœ‹å®ƒå¦‚ä½•å½±å“æ˜¾ç¤ºã€‚",
      "tips": ""
    },
    "The Slider control affects the sensitivity of the graph display. Its first parameter, value: $sensitivity, is a binding to the sensitivity state property.": {
      "zh": "Slider æ§ä»¶ä¼šå½±å“å›¾è¡¨æ˜¾ç¤ºçš„æ•æ„Ÿåº¦ã€‚å®ƒçš„ç¬¬ä¸€ä¸ªå‚æ•° value: $sensitivity æ˜¯å¯¹æ•æ„Ÿåº¦çŠ¶æ€å±æ€§çš„ç»‘å®šã€‚",
      "tips": ""
    },
    "You use bindings to let other views control state properties. In this case, youâ€™re telling the slider it can update the value of sensitivity as the user interacts with it.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ç»‘å®šæ¥è®©å…¶ä»–è§†å›¾æ§åˆ¶çŠ¶æ€å±æ€§ã€‚åœ¨å½“å‰åœºæ™¯ä¸­ï¼Œä½ ä¼šåœ¨ç”¨æˆ·å’Œæ»‘å—äº¤äº’æ—¶å‘Šè¯‰å®ƒå¯ä»¥æ›´æ–° sensitivity å˜é‡çš„å€¼ã€‚",
      "tips": ""
    },
    "The next three parameters control features of the slider. in: 0...1: specifies the sliderâ€™s range of values, from minimum to maximum. Use the minimumValueLabel and maximumValueLabel parameters to add labels at the left and right ends of the slider, respectively.": {
      "zh": "æ¥ä¸‹æ¥çš„ä¸‰ä¸ªå‚æ•°æ§åˆ¶æ»‘å—çš„ç‰¹æ€§ã€‚in: 0...1ï¼šæŒ‡å®šæ»‘å—çš„å€¼èŒƒå›´ï¼Œä»æœ€å°å€¼åˆ°æœ€å¤§å€¼ã€‚minimumValueLabel å’Œ maximumValueLabel å‚æ•°ä¼šåˆ†åˆ«åœ¨æ»‘å—çš„å·¦ç«¯å’Œå³ç«¯æ·»åŠ æ ‡ç­¾ã€‚",
      "tips": ""
    },
    "To store a history of motion values to draw the line graph, assign the code inside the braces to the onUpdate property. This tells the motion detector to run that code whenever thereâ€™s new data to display. This code takes the latest motion data and adds it to the data array.": {
      "zh": "ä¸ºäº†å­˜å‚¨ç»˜åˆ¶æŠ˜çº¿å›¾æ‰€éœ€çš„è¿åŠ¨å€¼å†å²è®°å½•ï¼Œå°†å¤§æ‹¬å·å†…çš„ä»£ç åˆ†é…ç»™ onUpdate å±æ€§ã€‚è¿™ä¼šå‘Šè¯‰è¿åŠ¨æ£€æµ‹å™¨åœ¨æœ‰æ–°æ•°æ®è¦æ˜¾ç¤ºæ—¶è¿è¡Œè¯¥ä»£ç ã€‚è¯¥ä»£ç ä¼šè·å–æœ€æ–°çš„è¿åŠ¨æ•°æ®å¹¶å°†å…¶æ·»åŠ åˆ°æ•°æ®æ•°ç»„ä¸­ã€‚",
      "tips": ""
    },
    "Append the zAcceleration of the device to the data array with every motion detector update. Use zAcceleration to chart up- and downward motion of the device. That makes the graph correspond visually to the movement of the device. When you lift your iPad, the line goes upward on the graph.": {
      "zh": "æ¯æ¬¡ motion detector æ›´æ–°æ—¶ï¼Œè®¾å¤‡çš„ zAcceleration ä¼šè¢«è¿½åŠ åˆ° data æ•°ç»„ä¸­ã€‚ä½¿ç”¨ zAcceleration æ¥ç»˜åˆ¶è®¾å¤‡çš„ä¸Šä¸‹è¿åŠ¨ã€‚è¿™ä½¿å¾—å›¾è¡¨åœ¨è§†è§‰ä¸Šä¸è®¾å¤‡çš„è¿åŠ¨ç›¸å¯¹åº”ã€‚å½“ä½ æŠ¬èµ· iPad æ—¶ï¼Œçº¿æ¡åœ¨å›¾è¡¨ä¸Šå‘ä¸Šç§»åŠ¨ã€‚",
      "tips": ""
    },
    "Hereâ€™s where the maxData property comes into play. After youâ€™ve reached the limit, youâ€™ll drop the first item in the array (the oldest data point) and make a new array out of the result.": {
      "zh": "è¿™é‡Œå°±æ˜¯ maxData å±æ€§å‘æŒ¥ä½œç”¨çš„åœ°æ–¹ã€‚åœ¨è¾¾åˆ°é™åˆ¶åï¼Œä½ å°†åˆ é™¤æ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ªé¡¹ç›®ï¼ˆæœ€æ—§çš„æ•°æ®ç‚¹ï¼‰ï¼Œå¹¶å°†ç»“æœåˆ¶ä½œæˆä¸€ä¸ªæ–°æ•°ç»„ã€‚",
      "tips": ""
    },
    "Seismometer Browser": {
      "zh": "åœ°éœ‡ä»ªæµè§ˆå™¨",
      "tips": ""
    },
    "Learn how the top-level view of the app passes motion data to its child views.": {
      "zh": "å­¦ä¹ å¦‚ä½•å°†åº”ç”¨çš„é¡¶çº§è§†å›¾ä¸­çš„è¿åŠ¨æ•°æ®ä¼ é€’ç»™å…¶å­è§†å›¾ã€‚",
      "tips": ""
    },
    "The SeismometerBrowser view displays the two options for seismometer display in a list. When you choose a display from the list, the app displays that view. The browser is a container for the other two views, so it also acts as the manager of the MotionDetector instance that gathers motion data from the device.": {
      "zh": "SeismometerBrowser è§†å›¾åœ¨åˆ—è¡¨ä¸­æ˜¾ç¤ºåœ°éœ‡ä»ªçš„ä¸¤ä¸ªé€‰é¡¹ã€‚å½“ä½ ä»åˆ—è¡¨ä¸­é€‰æ‹©ä¸€ä¸ªæ˜¾ç¤ºæ—¶ï¼Œåº”ç”¨ä¼šæ˜¾ç¤ºè¯¥è§†å›¾ã€‚æµè§ˆå™¨æ˜¯å…¶ä»–ä¸¤ä¸ªè§†å›¾çš„å®¹å™¨ï¼Œå› æ­¤å®ƒä¹Ÿå……å½“ä»è®¾å¤‡æ”¶é›†è¿åŠ¨æ•°æ®çš„ MotionDetector å®ä¾‹çš„ç®¡ç†å™¨ã€‚",
      "tips": ""
    },
    "The detector property holds the MotionDetector instance thatâ€™s shared throughout the app. The code annotates the property with @StateObject to indicate that SwiftUI keeps track of its updates. You can share state objects with other views, but this view is its owner.": {
      "zh": "detector å±æ€§ä¿å­˜äº†åœ¨æ•´ä¸ªåº”ç”¨ç¨‹åºä¸­å…±äº«çš„ MotionDetector å®ä¾‹ã€‚ä»£ç ä½¿ç”¨ @StateObject ä»¥æŒ‡ç¤º SwiftUI ä¼šè·Ÿè¸ªå…¶æ›´æ–°ã€‚ä½ å¯ä»¥ä¸å…¶ä»–è§†å›¾å…±äº«è¯¥å±æ€§ï¼Œä½†æ˜¯è¯¥è§†å›¾æ˜¯å…¶æ‰€æœ‰è€…ã€‚",
      "tips": ""
    },
    "To give other views access to the motion detector, you can use the .environmentObject modifier to add it to the appâ€™s environment. Any child view of this view can use it by declaring a property of the same type and annotating it with @EnvironmentObject.": {
      "zh": "ä¸ºäº†è®©å…¶ä»–è§†å›¾è®¿é—®è¿åŠ¨æ£€æµ‹å™¨ï¼Œä½ å¯ä»¥ä½¿ç”¨ .environmentObject ä¿®é¥°ç¬¦å°†å…¶æ·»åŠ åˆ°åº”ç”¨ç¨‹åºçš„ç¯å¢ƒä¸­ã€‚è¯¥è§†å›¾çš„ä»»ä½•å­è§†å›¾éƒ½å¯ä»¥é€šè¿‡å£°æ˜å…·æœ‰ç›¸åŒç±»å‹çš„å±æ€§å¹¶ä½¿ç”¨ @EnvironmentObject è¿›è¡Œæ³¨é‡Šæ¥ä½¿ç”¨å®ƒã€‚",
      "tips": ""
    },
    "You can use the .onAppear modifier to perform actions when this view first appears. Itâ€™s the perfect place to start the motion detector. Use the .onDisappear modifier to stop the detector when the view isnâ€™t visible.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ .onAppear ä¿®é¥°ç¬¦åœ¨è¯¥è§†å›¾é¦–æ¬¡å‡ºç°æ—¶æ‰§è¡Œæ“ä½œã€‚è¿™æ˜¯å¯åŠ¨è¿åŠ¨æ£€æµ‹å™¨çš„ç†æƒ³ä½ç½®ã€‚ä½¿ç”¨ .onDisappear ä¿®é¥°ç¬¦åœ¨è§†å›¾ä¸å¯è§æ—¶åœæ­¢æ£€æµ‹å™¨ã€‚",
      "tips": ""
    },
    "Double Extension": {
      "zh": "Double ç±»å‹çš„æ‰©å±•",
      "tips": ""
    },
    "Investigate using an extension on Double to format text in an easy to read way.": {
      "zh": "æ¢ç©¶ä½¿ç”¨ Double ç±»å‹çš„æ‰©å±•ä»¥ä¾¿ä»¥æ˜“äºé˜…è¯»çš„æ–¹å¼æ ¼å¼åŒ–æ–‡æœ¬ã€‚",
      "tips": ""
    },
    "You can use an extension to create custom behaviors for existing types. Declaring extension Double means youâ€™re adding new capabilities to the Double type. When you use a Double value, you can access anything defined in this extension.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨æ‰©å±•ä¸ºç°æœ‰ç±»å‹åˆ›å»ºè‡ªå®šä¹‰è¡Œä¸ºã€‚å£°æ˜ Double æ‰©å±•æ„å‘³ç€ä½ æ­£åœ¨ä¸º Double ç±»å‹æ·»åŠ æ–°åŠŸèƒ½ã€‚å½“ä½ ä½¿ç”¨ Double å€¼æ—¶ï¼Œå¯ä»¥è®¿é—®åœ¨æ­¤æ‰©å±•ä¸­å®šä¹‰çš„ä»»ä½•å†…å®¹ã€‚",
      "tips": ""
    },
    "This method returns a string that describes the value of a Double with a fixed number of digits. You can pass in the number of integer digits and fraction digits you want, or leave those arguments out for the default values of 2.": {
      "zh": "è¿™ä¸ªæ–¹æ³•è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯¥å­—ç¬¦ä¸²ç”¨å›ºå®šæ•°é‡çš„æ•°å­—æè¿° Double çš„å€¼ã€‚ä½ å¯ä»¥ä¼ å…¥ä½ æƒ³è¦çš„æ•´æ•°ä½æ•°å’Œå°æ•°ä½æ•°ï¼Œæˆ–è€…å¿½ç•¥è¿™äº›å‚æ•°ä»¥ä½¿ç”¨é»˜è®¤å€¼ 2ã€‚",
      "tips": ""
    },
    "The formatted() method operates on a number of basic types such as Date, Int, and Double, all of which are commonly represented as strings in an app. Because there are so many ways to format these strings, the formatted() method gives you ways to customize how theyâ€™re represented. For example, does a number represent a percentage, a simple value, or maybe a price?": {
      "zh": "formatted() æ–¹æ³•å¯¹è®¸å¤šåŸºæœ¬ç±»å‹ï¼ˆå¦‚ Dateã€Int å’Œ Doubleï¼‰è¿›è¡Œæ“ä½œï¼Œæ‰€æœ‰è¿™äº›ç±»å‹åœ¨åº”ç”¨ç¨‹åºä¸­é€šå¸¸è¡¨ç¤ºä¸ºå­—ç¬¦ä¸²ã€‚å› ä¸ºæœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥æ ¼å¼åŒ–è¿™äº›å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥ formatted() æ–¹æ³•æä¾›äº†ä¸€äº›æ–¹æ³•æ¥è‡ªå®šä¹‰å®ƒä»¬çš„è¡¨ç¤ºæ–¹å¼ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªæ•°å­—è¡¨ç¤ºä¸€ä¸ªç™¾åˆ†æ¯”ã€ä¸€ä¸ªç®€å•çš„å€¼ï¼Œæˆ–è€…å¯èƒ½æ˜¯ä¸€ä¸ªä»·æ ¼ï¼Ÿ",
      "tips": ""
    },
    "The argument to formatted() is a format style. The .number style gives you a string that describes this Double value as a simple number, as opposed to a percentage or a price.": {
      "zh": "formatted() çš„å‚æ•°æ˜¯ä¸€ä¸ª format style ç±»å‹ã€‚.number æ ·å¼ä¸ºä½ æä¾›äº†ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯¥å­—ç¬¦ä¸²å°†æ­¤ Double å€¼æè¿°ä¸ºä¸€ä¸ªç®€å•çš„æ•°å­—ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç™¾åˆ†æ¯”æˆ–ä»·æ ¼ã€‚",
      "tips": ""
    },
    "The .number style has modifiers much like those for SwiftUI views. For example, the .sign modifier lets you format the number so that itâ€™s always preceded by a sign, even when the number is positive. You can also use the .precision modifier to specify exactly how many digits to use.": {
      "zh": ".number è¿™ç§å˜æˆé£æ ¼å…·æœ‰ä¸ SwiftUI è§†å›¾ç›¸ä¼¼çš„ä¿®é¥°ç¬¦ã€‚ä¾‹å¦‚ï¼Œ.sign ä¿®é¥°ç¬¦å…è®¸ä½ æ ¼å¼åŒ–æ•°å­—ï¼Œä»¥ä¾¿å³ä½¿æ•°å­—ä¸ºæ­£æ•°ï¼Œå®ƒä¹Ÿæ€»æ˜¯ä»¥ç¬¦å·å¼€å¤´ã€‚ä½ è¿˜å¯ä»¥ä½¿ç”¨ .precision ä¿®é¥°ç¬¦æ¥æŒ‡å®šè¦ä½¿ç”¨çš„ç²¾åº¦ã€‚",
      "tips": ""
    },
    "Recognizing Gestures": {
      "zh": "è¯†åˆ«æ‰‹åŠ¿",
      "tips": ""
    },
    "Update shapes or other content in response to taps, rotations, or other Multi-Touch gestures.": {
      "zh": "å½“è¯†åˆ«åˆ°ç‚¹å‡»ã€æ—‹è½¬æˆ–å…¶ä»–å¤šç‚¹è§¦æ§æ‰‹åŠ¿æ—¶ï¼Œæ›´æ–°å½¢çŠ¶æˆ–å…¶ä»–å†…å®¹ã€‚",
      "tips": ""
    },
    "Your device has sensors such as accelerometers and gyroscopes which sense its motion and orientation. The Core Motion framework gives you access to data from these and other sensors.": {
      "zh": "ä½ çš„è®¾å¤‡å…·æœ‰åŠ é€Ÿåº¦è®¡å’Œé™€èºä»ªç­‰ä¼ æ„Ÿå™¨ï¼Œè¿™äº›ä¼ æ„Ÿå™¨å¯ä»¥æ„ŸçŸ¥å…¶è¿åŠ¨å’Œæ–¹å‘ã€‚Core Motion æ¡†æ¶ä½¿ä½ å¯ä»¥è®¿é—®æ¥è‡ªè¿™äº›å’Œå…¶ä»–ä¼ æ„Ÿå™¨çš„æ•°æ®ã€‚",
      "tips": ""
    }
  },
  "swiftui/animating-views-and-transitions": {
    "Drag the Hikes folder from the downloaded filesâ€™ Resources folder into your projectâ€™s Views group. Be sure to select â€œCopy items if neededâ€ and â€œCreate groupsâ€ before clicking Finish.": {
      "zh": "å°†ä¸‹è½½æ–‡ä»¶çš„èµ„æºæ–‡ä»¶å¤¹ä¸­çš„ Hikes æ–‡ä»¶å¤¹æ‹–åˆ°æ‚¨çš„é¡¹ç›®çš„â€œViewsâ€ç»„ä¸­ã€‚åœ¨å•å‡»â€œå®Œæˆâ€ä¹‹å‰ï¼Œè¯·ç¡®ä¿é€‰æ‹©â€œå¦‚æœéœ€è¦å¤åˆ¶é¡¹ç›®â€å’Œâ€œåˆ›å»ºæ–‡ä»¶å¤¹â€ã€‚",
      "tips": ""
    },
    "Familiarize yourself with the new views. They work together to display the hike data loaded into your model.": {
      "zh": "ç†Ÿæ‚‰æ–°è§†å›¾ã€‚å®ƒä»¬ä¸€èµ·å·¥ä½œï¼Œæ˜¾ç¤ºåŠ è½½åˆ°æ‚¨çš„æ¨¡å‹ä¸­çš„å¾’æ­¥æ—…è¡Œæ•°æ®ã€‚",
      "tips": ""
    },
    "SwiftUI includes basic animations with predefined or custom easing, as well as spring and fluid animations. You can adjust an animationâ€™s speed, set a delay before an animation starts, or specify that an animation repeats.": {
      "zh": "SwiftUI åŒ…æ‹¬å…·æœ‰é¢„å®šä¹‰æˆ–è‡ªå®šä¹‰ç¼“åŠ¨çš„åŸºæœ¬åŠ¨ç”»ï¼Œä»¥åŠå¼¹ç°§å’Œæµä½“åŠ¨ç”»ã€‚ä½ å¯ä»¥è°ƒæ•´åŠ¨ç”»çš„é€Ÿåº¦ï¼Œä¸ºåŠ¨ç”»è®¾ç½®å¼€å§‹å‰çš„å»¶è¿Ÿï¼Œæˆ–æŒ‡å®šåŠ¨ç”»é‡å¤æ¬¡æ•°ã€‚",
      "tips": ""
    },
    "Create a new Swift file called Hike.swift in your projectâ€™s Model group using the menu item File > New > File.": {
      "zh": "åœ¨é¡¹ç›®çš„ Model æ–‡ä»¶å¤¹ä¸­ï¼Œä½¿ç”¨èœå•é¡¹ File > New > File åˆ›å»ºä¸€ä¸ªåä¸º Hike.swift çš„æ–° Swift æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "Switch to using the move(edge:) transition, so that the graph slides in and out from the same side.": {
      "zh": "åˆ‡æ¢ä¸ºä½¿ç”¨ move(edge:) è¿‡æ¸¡ï¼Œä»¥ä½¿å›¾è¡¨ä»åŒä¸€ä¾§æ»‘å…¥æ»‘å‡ºã€‚",
      "tips": ""
    },
    "This keeps your code clean as you expand the custom transition.": {
      "zh": "è¿™æ ·å¯ä»¥åœ¨æ‰©å±•è‡ªå®šä¹‰è½¬åœºæ—¶ä¿æŒä»£ç çš„æ•´æ´ã€‚",
      "tips": ""
    },
    "Try turning off animation for the rotation by adding another animation modifier just above the scaleEffect modifier.": {
      "zh": "å°è¯•é€šè¿‡åœ¨ scaleEffect ä¿®é¥°ç¬¦ä¸Šæ–¹æ·»åŠ å¦ä¸€ä¸ªåŠ¨ç”»ä¿®é¥°ç¬¦æ¥å…³é—­æ—‹è½¬åŠ¨ç”»ã€‚",
      "tips": ""
    },
    "Customize View Transitions": {
      "zh": "è‡ªå®šä¹‰è§†å›¾è½¬åœº",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Add another animatable change by making the button larger when the graph is visible.": {
      "zh": "å½“å›¾è¡¨å¯è§æ—¶ï¼Œé€šè¿‡ä½¿æŒ‰é’®å˜å¤§æ¥æ·»åŠ å¦ä¸€ä¸ªåŠ¨ç”»ã€‚",
      "tips": ""
    },
    "Drag the hikeData.json file from the downloaded filesâ€™ Resources folder into your projectâ€™s Resources group. Be sure to select â€œCopy items if neededâ€ before clicking Finish.": {
      "zh": "å°†ä¸‹è½½çš„æ–‡ä»¶çš„ Resources æ–‡ä»¶å¤¹ä¸­çš„ hikeData.json æ–‡ä»¶æ‹–åˆ°é¡¹ç›®çš„ Resources æ–‡ä»¶å¤¹ä¸­ã€‚åœ¨å•å‡»â€œå®Œæˆâ€ä¹‹å‰ï¼Œè¯·ç¡®ä¿é€‰æ‹©â€œå¦‚æœ‰éœ€è¦å¤åˆ¶é¡¹ç›®â€ã€‚",
      "tips": ""
    },
    "By default, views transition on- and offscreen by fading in and out. You can customize this transition by using the transition(_:) modifier.": {
      "zh": "é»˜è®¤æƒ…å†µä¸‹ï¼Œè§†å›¾ä¼šé€šè¿‡æ·¡å…¥æ·¡å‡ºçš„æ–¹å¼åœ¨å±å¹•ä¸Šæ˜¾ç¤ºå’Œæ¶ˆå¤±ã€‚ä½ å¯ä»¥ä½¿ç”¨ transition(:) ä¿®é¥°ç¬¦è‡ªå®šä¹‰è¿™ç§è½¬æ¢æ•ˆæœã€‚",
      "tips": ""
    },
    "Speed up the animation a bit, to shorten the time each bar takes to move to its new position.": {
      "zh": "ç¨å¾®åŠ å¿«åŠ¨ç”»é€Ÿåº¦ï¼Œç¼©çŸ­æ¯ä¸ªæŸ±å­ç§»åŠ¨åˆ°æ–°ä½ç½®åŠ¨ç”»æ‰€éœ€çš„æ—¶é—´ã€‚",
      "tips": ""
    },
    "Because youâ€™ll never modify hike data after initially loading it, you donâ€™t need to mark it with the @Published attribute.": {
      "zh": "å› ä¸ºä½ åœ¨æœ€åˆåŠ è½½åæ°¸è¿œä¸ä¼šä¿®æ”¹å¾’æ­¥æ•°æ®ï¼Œæ‰€ä»¥ä¸éœ€è¦ä½¿ç”¨ @Published å±æ€§æ ‡è®°å®ƒã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "æ­¥éª¤ 6",
      "tips": ""
    },
    "Be sure to use the live preview throughout this tutorial so you can experiment with the results of each step.": {
      "zh": "åœ¨æœ¬æ•™ç¨‹ä¸­ä¸€å®šè¦ä½¿ç”¨å®æ—¶é¢„è§ˆï¼Œè¿™æ ·ä½ å°±å¯ä»¥çœ‹åˆ°æ¯ä¸€æ­¥çš„æ•ˆæœã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®éªŒ",
      "tips": ""
    },
    "Change the animation type from easeInOut to spring().": {
      "zh": "å°†åŠ¨ç”»ç±»å‹ä» easeInOut æ›´æ”¹ä¸º spring()ã€‚",
      "tips": ""
    },
    "Pass a four-second long basic animation to the withAnimation function.": {
      "zh": "å°†ä¸ºæ—¶å››ç§’çš„åŸºæœ¬åŠ¨ç”»ä¼ é€’ç»™ withAnimation å‡½æ•°ã€‚",
      "tips": ""
    },
    "In HikeView, change the default value for showDetail to true, and pin the preview to the canvas.": {
      "zh": "åœ¨ HikeView ä¸­ï¼Œå°† showDetail çš„é»˜è®¤å€¼æ›´æ”¹ä¸º trueï¼Œå¹¶å°†é¢„è§ˆå›ºå®šåˆ°ç”»å¸ƒã€‚",
      "tips": ""
    },
    "Download the starter project and follow along with this tutorial, or open the finished project and explore the code on your own.": {
      "zh": "ä¸‹è½½å…¥é—¨é¡¹ç›®æ¥è·Ÿéšæœ¬æ•™ç¨‹æ“ä½œï¼Œæˆ–è€…æ‰“å¼€å·²å®Œæˆçš„é¡¹ç›®ç„¶åè‡ªè¡Œæ¢ç´¢ä»£ç ã€‚",
      "tips": ""
    },
    "Now the graph appears and disappears by sliding in and out of sight.": {
      "zh": "ç°åœ¨ï¼Œå›¾è¡¨é€šè¿‡æ»‘å…¥æ»‘å‡ºçš„æ–¹å¼å‡ºç°å’Œæ¶ˆå¤±ã€‚",
      "tips": ""
    },
    "Before continuing to the next section, restore the withAnimation function to use the default animation by removing the callâ€™s input parameter.": {
      "zh": "åœ¨ç»§ç»­ä¸‹ä¸€èŠ‚ä¹‹å‰ï¼Œè¯·é€šè¿‡åˆ é™¤è°ƒç”¨çš„è¾“å…¥å‚æ•°å°† withAnimation å‡½æ•°æ¢å¤ä¸ºä½¿ç”¨é»˜è®¤åŠ¨ç”»ã€‚",
      "tips": ""
    },
    "Composing Complex Interfaces": {
      "zh": "",
      "tips": ""
    },
    "Now that youâ€™ve learned how to apply animations to individual views, itâ€™s time to add animations in places where you change your stateâ€™s value.": {
      "zh": "æ—¢ç„¶ä½ å·²ç»å­¦ä¼šäº†å¦‚ä½•å°†åŠ¨ç”»åº”ç”¨åˆ°å•ä¸ªè§†å›¾ï¼Œç°åœ¨æ˜¯æ—¶å€™åœ¨æ›´æ”¹çŠ¶æ€å€¼çš„åœ°æ–¹æ·»åŠ åŠ¨ç”»äº†ã€‚",
      "tips": ""
    },
    "Load the hikes array into your model object.": {
      "zh": "å°† hikes æ•°ç»„åŠ è½½åˆ°æ‚¨çš„æ¨¡å‹å¯¹è±¡ä¸­ã€‚",
      "tips": ""
    },
    "You can pass the same kinds of animations to the withAnimation function that you passed to the animation(_:value:) modifier.": {
      "zh": "ä½ å¯ä»¥å°†ä¸ animation(:value:) ä¿®é¥°ç¬¦ç›¸åŒçš„åŠ¨ç”»ä¼ é€’ç»™ withAnimation å‡½æ•°ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "æ­¥éª¤ 3",
      "tips": ""
    },
    "In this tutorial, youâ€™ll animate a view that contains a graph for tracking the hikes a user takes while using the Landmarks app. Using the animation(_:) modifier, youâ€™ll see just how easy it is to animate a view.": {
      "zh": "åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œä½ å°†ä¸ºä¸€ä¸ªæ˜¾ç¤º Landmarks åº”ç”¨ä¸­ç”¨æˆ·è¿›è¡Œå¾’æ­¥æ—…è¡Œçš„å›¾è¡¨è§†å›¾åˆ›å»ºåŠ¨ç”»ã€‚ä½¿ç”¨ animation(:) ä¿®é¥°ç¬¦ï¼Œä½ ä¼šå‘ç°ä¸ºè§†å›¾åˆ›å»ºåŠ¨ç”»æ˜¯å¤šä¹ˆå®¹æ˜“ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "æ­¥éª¤ 4",
      "tips": ""
    },
    "The animation modifier applies to all animatable changes within the views it wraps.": {
      "zh": "åŠ¨ç”»ä¿®é¥°ç¬¦é€‚ç”¨äºå…¶åŒ…è£…è§†å›¾ä¸­çš„æ‰€æœ‰å¯ä»¥æ‰§è¡ŒåŠ¨ç”»çš„æ•°å€¼ä¿®æ”¹ã€‚",
      "tips": ""
    },
    "Both of the views affected by the showDetail property â€” the disclosure button and the HikeDetail view â€” now have animated transitions.": {
      "zh": "å— showDetail å±æ€§å½±å“çš„ä¸¤ä¸ªè§†å›¾ - å±•å¼€æŒ‰é’®å’Œ HikeDetail è§†å›¾ - ç°åœ¨éƒ½æœ‰åŠ¨ç”»è¿‡æ¸¡ã€‚",
      "tips": ""
    },
    "In HikeView.swift, turn on animation for the buttonâ€™s rotation by adding an animation modifier that begins on changes of the showDetail value.": {
      "zh": "åœ¨ HikeView.swift ä¸­ï¼Œé€šè¿‡æ·»åŠ ä¸€ä¸ªåŠ¨ç”»ä¿®é¥°ç¬¦ï¼Œåœ¨ showDetail å€¼æ”¹å˜æ—¶å¯åŠ¨æŒ‰é’®æ—‹è½¬çš„åŠ¨ç”»ã€‚",
      "tips": ""
    },
    "Before you can add animation, youâ€™ll need something to animate. In this section, youâ€™ll import and model hiking data, and then add some prebuilt views for displaying that data statically in a graph.": {
      "zh": "åœ¨æ·»åŠ åŠ¨ç”»ä¹‹å‰ï¼Œä½ éœ€è¦æœ‰ä¸€äº›å†…å®¹æ¥æ‰§è¡ŒåŠ¨ç”»ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œä½ å°†å¯¼å…¥å¹¶å»ºç«‹å¾’æ­¥æ—…è¡Œæ•°æ®ï¼Œç„¶åä¸ºé™æ€æ˜¾ç¤ºæ•°æ®çš„å›¾è¡¨æ·»åŠ ä¸€äº›é¢„å…ˆæ„å»ºçš„è§†å›¾ã€‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬ 2 èŠ‚",
      "tips": ""
    },
    "This makes it possible for you to see the graph in context while you work on the animation in another file.": {
      "zh": "å›ºå®šé¢„è§ˆèƒ½å¤Ÿä½¿ä½ åœ¨å¤„ç†å¦ä¸€ä¸ªæ–‡ä»¶ä¸­çš„åŠ¨ç”»æ—¶ï¼Œä»ç„¶ä¿æŒæŸ¥çœ‹å›ºå®šä½çš„é¢„è§ˆã€‚",
      "tips": ""
    },
    "Animate the Effects of State Changes": {
      "zh": "ä½¿çŠ¶æ€å˜åŒ–çš„æ•ˆæœåŠ¨èµ·æ¥",
      "tips": ""
    },
    "Extract the transition that you just added as a static property of AnyTransition, and access the new property in the viewâ€™s transition modifier.": {
      "zh": "å°†åˆšåˆšæ·»åŠ çš„è¿‡æ¸¡ä½œä¸º AnyTransition çš„é™æ€å±æ€§æå–ï¼Œå¹¶åœ¨è§†å›¾çš„è¿‡æ¸¡ä¿®é¥°ç¬¦ä¸­è®¿é—®æ–°å±æ€§ã€‚",
      "tips": ""
    },
    "Add Hiking Data to the App": {
      "zh": "",
      "tips": ""
    },
    "You can see the effect of the animation by switching between elevation, heart rate, and pace in the live preview.": {
      "zh": "ä½ å¯ä»¥é€šè¿‡åœ¨å®æ—¶é¢„è§ˆä¸­åˆ‡æ¢æµ·æ‹”ã€å¿ƒç‡å’Œé€Ÿåº¦æ¥æŸ¥çœ‹åŠ¨ç”»æ•ˆæœã€‚",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ 3 èŠ‚",
      "tips": ""
    },
    "When you use the animation(_:) modifier on an equatable view, SwiftUI animates any changes to animatable properties of the view. A viewâ€™s color, opacity, rotation, size, and other properties are all animatable. When the view isnâ€™t equatable, you can use the animation(_:value:) modifier to start animations when the specified value changes.": {
      "zh": "å½“ä½ åœ¨å¯æ¯”è¾ƒçš„è§†å›¾ä¸Šä½¿ç”¨ animation(:) ä¿®é¥°ç¬¦æ—¶ï¼ŒSwiftUI ä¼šä¸ºè§†å›¾çš„å¯åŠ¨ç”»å±æ€§çš„ä»»ä½•æ›´æ”¹æ·»åŠ åŠ¨ç”»ã€‚è§†å›¾çš„é¢œè‰²ã€ä¸é€æ˜åº¦ã€æ—‹è½¬ã€å¤§å°ç­‰å±æ€§éƒ½æ˜¯å¯åŠ¨ç”»çš„ã€‚å½“è§†å›¾ä¸å¯ä»¥æ¯”è¾ƒæ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨ animation(_:value:) ä¿®é¥°ç¬¦åœ¨æŒ‡å®šå€¼æ›´æ”¹æ—¶å¯åŠ¨åŠ¨ç”»ã€‚",
      "tips": ""
    },
    "Be sure to unpin the preview before moving on to the next tutorial.": {
      "zh": "åœ¨ç»§ç»­ä¸‹ä¸€ä¸ªæ•™ç¨‹ä¹‹å‰ï¼Œå–æ¶ˆå›ºå®šé¢„è§ˆã€‚",
      "tips": ""
    },
    "Remove both animation modifiers before moving on to the next section.": {
      "zh": "åœ¨ç»§ç»­ä¸‹ä¸€éƒ¨åˆ†ä¹‹å‰ï¼Œè¯·åˆ é™¤ä¸¤ä¸ªåŠ¨ç”»ä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    },
    "Switch the animation to a spring animation, with a reduced damping fraction to make the bars hop.": {
      "zh": "å°†åŠ¨ç”»åˆ‡æ¢ä¸ºå¼¹ç°§åŠ¨ç”»ï¼Œå‡å°é˜»å°¼ç³»æ•°ï¼Œä½¿æ¡å½¢å›¾è·³è·ƒã€‚",
      "tips": ""
    },
    "In HikeView.swift, turn on the live preview and experiment with showing and hiding the graph.": {
      "zh": "åœ¨HikeView.swiftä¸­ï¼Œæ‰“å¼€å®æ—¶é¢„è§ˆå¹¶å°è¯•æ˜¾ç¤ºå’Œéšè—å›¾è¡¨ã€‚",
      "tips": ""
    },
    "Observe how the custom animation provides a rippling effect when transitioning between graphs.": {
      "zh": "è§‚å¯Ÿåœ¨å›¾è¡¨ä¹‹é—´è¿‡æ¸¡æ—¶ï¼Œè‡ªå®šä¹‰åŠ¨ç”»å¦‚ä½•å±•ç¤ºæ³¢çº¹æ•ˆæœã€‚",
      "tips": ""
    },
    "Slow down the animation to see how SwiftUI animations are interruptible.": {
      "zh": "æ”¾æ…¢åŠ¨ç”»é€Ÿåº¦ï¼Œäº†è§£ SwiftUI åŠ¨ç”»æ˜¯å¦‚ä½•å¯ä¸­æ–­çš„ã€‚",
      "tips": ""
    },
    "Experiment with opening and closing the graph view mid-animation.": {
      "zh": "å°è¯•åœ¨åŠ¨ç”»è¿›è¡Œä¸­æ‰“å¼€å’Œå…³é—­å›¾å½¢è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "æ­¥éª¤ 1",
      "tips": ""
    },
    "Use the asymmetric(insertion:removal:) modifier to provide different transitions for when the view appears and disappears.": {
      "zh": "ä½¿ç”¨ asymmetric(insertion:removal:) ä¿®é¥°ç¬¦ä¸ºè§†å›¾å‡ºç°å’Œæ¶ˆå¤±æ—¶æä¾›ä¸åŒçš„è¿‡æ¸¡åŠ¨ç”»ã€‚",
      "tips": ""
    },
    "Animating Views and Transitions": {
      "zh": "",
      "tips": ""
    },
    "The category view for Landmarks shows a vertically scrolling list of horizontally scrolling landmarks. As you build this view and connect it to your existing views, youâ€™ll explore how composed views can adapt to different device sizes and orientations.": {
      "zh": "Landmarksçš„ç±»åˆ«è§†å›¾æ˜¾ç¤ºä¸€ä¸ªå‚ç›´æ»šåŠ¨çš„æ°´å¹³æ»šåŠ¨åœ°æ ‡åˆ—è¡¨ã€‚åœ¨æ„å»ºæ­¤è§†å›¾å¹¶å°†å…¶è¿æ¥åˆ°ç°æœ‰è§†å›¾æ—¶ï¼Œä½ å°†æ¢ç´¢å¦‚ä½•ä½¿ç»„åˆè§†å›¾é€‚åº”ä¸åŒçš„è®¾å¤‡å¤§å°å’Œæ–¹å‘ã€‚",
      "tips": ""
    },
    "The graph switches between three different sets of data when you click the buttons below the bars. In this section, youâ€™ll use a composed animation to give the capsules that make up the graph a dynamic, rippling transition.": {
      "zh": "å½“ä½ ç‚¹å‡»æŸ±å­ä¸‹æ–¹çš„æŒ‰é’®æ—¶ï¼Œå›¾è¡¨ä¼šåœ¨ä¸‰ä¸ªä¸åŒçš„æ•°æ®é›†ä¹‹é—´åˆ‡æ¢ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œä½ å°†ä½¿ç”¨ä¸€ä¸ªç»„åˆåŠ¨ç”»ï¼Œä¸ºæ„æˆå›¾è¡¨çš„èƒ¶å›Šæä¾›åŠ¨æ€çš„æ³¢çº¹è¿‡æ¸¡æ•ˆæœã€‚",
      "tips": ""
    },
    "Add Animations to Individual Views": {
      "zh": "ä¸ºå•ä¸ªè§†å›¾æ·»åŠ åŠ¨ç”»æ•ˆæœ",
      "tips": ""
    },
    "Section 4": {
      "zh": "ç¬¬ 4 èŠ‚",
      "tips": ""
    },
    "Take SwiftUI for a spin. Try combining different animation effects to see whatâ€™s possible.": {
      "zh": "å°è¯•ä½¿ç”¨ SwiftUI å¹¶ç»“åˆä¸åŒçš„åŠ¨ç”»æ•ˆæœï¼Œæ¢ç´¢å…¶æ½œåŠ›ã€‚å°†å„ç§åŠ¨ç”»æ•ˆæœç»„åˆåœ¨ä¸€èµ·ï¼Œçœ‹çœ‹å¯ä»¥å®ç°ä»€ä¹ˆæ ·çš„æ•ˆæœã€‚",
      "tips": ""
    },
    "Compose Animations for Complex Effects": {
      "zh": "ä¸ºå¤æ‚æ•ˆæœåˆ¶ä½œåŠ¨ç”»",
      "tips": ""
    },
    "Section 5": {
      "zh": "ç¬¬ 5 èŠ‚",
      "tips": ""
    },
    "Like the Landmark structure, the Hike structure conforms to Codable and has properties that match the keys in the corresponding data file.": {
      "zh": "ä¸ Landmark ç»“æ„ç±»ä¼¼ï¼Œ Hike ç»“æ„ç¬¦åˆ Codable å¹¶å…·æœ‰ä¸ç›¸åº”æ•°æ®æ–‡ä»¶ä¸­é”®åŒ¹é…çš„å±æ€§ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "æ­¥éª¤ 2",
      "tips": ""
    },
    "When using SwiftUI, you can individually animate changes to views, or to a viewâ€™s state, no matter where the effects are. SwiftUI handles all the complexity of these combined, overlapping, and interruptible animations for you.": {
      "zh": "åœ¨ä½¿ç”¨ SwiftUI æ—¶ï¼Œä½ å¯ä»¥å•ç‹¬ä¸ºè§†å›¾çš„å˜åŒ–æˆ–è§†å›¾çŠ¶æ€çš„å˜åŒ–è®¾ç½®åŠ¨ç”»ï¼Œæ— è®ºè¿™äº›æ•ˆæœè®¾ç½®ã€‚SwiftUI ä¼šè‡ªåŠ¨ä¸ºä½ å¤„ç†è¿™äº›ç»„åˆã€é‡å å’Œå¯ä¸­æ–­åŠ¨ç”»çš„æ‰€æœ‰å¤æ‚ç‰¹æ€§ã€‚",
      "tips": ""
    },
    "Here, youâ€™ll apply animations to all of the changes that occur when a user taps a button and toggles the showDetail state property.": {
      "zh": "åœ¨è¿™é‡Œï¼Œå½“ç”¨æˆ·ç‚¹å‡»æŒ‰é’®å¹¶åˆ‡æ¢ showDetail çŠ¶æ€å±æ€§æ—¶ï¼Œä½ å°†é’ˆå¯¹è¿™ä¸ªå˜åŒ–åº”ç”¨åŠ¨ç”»æ•ˆæœã€‚",
      "tips": ""
    },
    "Add a delay to each animation thatâ€™s based on the capsuleâ€™s position on the graph.": {
      "zh": "æ ¹æ®èƒ¶å›Šåœ¨å›¾è¡¨ä¸Šçš„ä½ç½®ï¼Œç»™æ¯ä¸ªèƒ¶å›ŠåŠ¨ç”»æ·»åŠ ä¸€ç‚¹å»¶è¿Ÿã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "æ­¥éª¤ 5",
      "tips": ""
    },
    "In HikeGraph.swift, define a new ripple animation and apply it to each generated graph capsule.": {
      "zh": "åœ¨ HikeGraph.swift ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªæ–°çš„æ³¢çº¹åŠ¨ç”»ï¼Œå¹¶å°†å®ƒåº”ç”¨åˆ°æ¯ä¸ªç”Ÿæˆçš„å›¾è¡¨èƒ¶å›Šä¸Šã€‚",
      "tips": ""
    },
    "Wrap the call to showDetail.toggle() with a call to the withAnimation function.": {
      "zh": "ç”¨ withAnimation å‡½æ•°åŒ…è£…å¯¹ showDetail.toggle() çš„è°ƒç”¨ã€‚",
      "tips": ""
    },
    "Add a transition(_:) modifier to the conditionally visible HikeView.": {
      "zh": "åœ¨é€šè¿‡æ¡ä»¶åˆ¤æ–­æ˜¯å¦å¯è§çš„ HikeView ä¸Šæ·»åŠ ä¸€ä¸ª transition(_:) ä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    }
  },
  "swiftui/building-lists-and-navigation": {
    "Copy the contents of the body property from ContentView into LandmarkDetail.": {
      "zh": "å°† ContentView ä¸­ body å±æ€§çš„å†…å®¹å¤åˆ¶åˆ° LandmarkDetailã€‚",
      "tips": ""
    },
    "Create a new Swift file in your project and name it ModelData.swift.": {
      "zh": "åœ¨é¡¹ç›®ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„ Swift æ–‡ä»¶ï¼Œå‘½åä¸º ModelData.swiftã€‚",
      "tips": ""
    },
    "The Landmark data already has the id property required by Identifiable protocol; you only need to add a property to decode it when reading the data.": {
      "zh": "Landmark æ•°æ®å·²ç»å…·æœ‰ Identifiable åè®®æ‰€éœ€çš„ id å±æ€§ï¼›ä½ åªéœ€åœ¨è¯»å–æ•°æ®æ—¶æ·»åŠ ä¸€ä¸ªå±æ€§æ¥å¯¹å®ƒè¿›è¡Œè§£ç ã€‚",
      "tips": ""
    },
    "Compute a locationCoordinate property thatâ€™s useful for interacting with the MapKit framework.": {
      "zh": "è®¡ç®—ä¸€ä¸ªä¸ MapKit æ¡†æ¶äº¤äº’æ—¶æœ‰ç”¨çš„ locationCoordinate å±æ€§ã€‚",
      "tips": ""
    },
    "In the LandmarkDetail file, pass the required data to your custom types.": {
      "zh": "åœ¨ LandmarkDetail æ–‡ä»¶ä¸­ï¼Œå°†éœ€è¦çš„æ•°æ®è®¾ç½®åˆ°ä½ çš„è‡ªå®šä¹‰çš„è§†å›¾ä¸Šã€‚",
      "tips": ""
    },
    "To fix the preview, youâ€™ll need to modify the preview provider.": {
      "zh": "è¦ä¿®å¤é¢„è§ˆï¼Œä½ éœ€è¦ä¿®æ”¹é¢„è§ˆæ•°æ®æä¾›ç±»ã€‚",
      "tips": ""
    },
    "Xcodeâ€™s canvas automatically recognizes and displays any type in the current editor that conforms to the PreviewProvider protocol. A preview provider returns one or more views, with options to configure the size and device.": {
      "zh": "Xcode çš„ç”»å¸ƒä¼šè‡ªåŠ¨è¯†åˆ«å¹¶æ˜¾ç¤ºå½“å‰ç¼–è¾‘å™¨ä¸­éµå¾ª PreviewProvider åè®®çš„ä»»ä½•ç±»å‹ã€‚é¢„è§ˆæä¾›ç±»è¿”å›ä¸€ä¸ªæˆ–å¤šä¸ªè§†å›¾ï¼Œå¹¶ä¸”å¯ä»¥é€‰æ‹©å°ºå¯¸å’Œé¢„è§ˆè®¾å¤‡ã€‚",
      "tips": ""
    },
    "Use the previewDisplayName(_:) modifier to add the device names as labels for the previews.": {
      "zh": "ä½¿ç”¨ previewDisplayName(:) ä¿®é¥°ç¬¦è®¾ç½®è®¾å¤‡åç§°ã€‚",
      "tips": ""
    },
    "Add a method that updates the region based on a coordinate value.": {
      "zh": "æ·»åŠ ä¸€ä¸ªæ ¹æ®åæ ‡å€¼æ›´æ–°åŒºåŸŸçš„æ–¹æ³•ã€‚",
      "tips": ""
    },
    "Switch back to LandmarkList.swift and remove the id parameter.": {
      "zh": "åˆ‡æ¢å› LandmarkList.swift å¹¶åˆ é™¤ id å‚æ•°ã€‚",
      "tips": ""
    },
    "Embed the dynamically generated list of landmarks in a NavigationView.": {
      "zh": "å°†åŠ¨æ€ç”Ÿæˆçš„åœ°æ ‡åˆ—è¡¨åµŒå…¥ NavigationViewã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "æ­¥éª¤ 6",
      "tips": ""
    },
    "Download the project files to begin building this project, and follow the steps below.": {
      "zh": "ä¸‹è½½é¡¹ç›®æ–‡ä»¶æ¥å¼€å§‹æ„å»ºæ­¤é¡¹ç›®ï¼Œå¹¶æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ“ä½œã€‚",
      "tips": ""
    },
    "Modify the text view to use the landmark propertyâ€™s name.": {
      "zh": "ä¿®æ”¹æ–‡æœ¬è§†å›¾ä¸ºåœ°æ ‡å±æ€§çš„åç§°ã€‚",
      "tips": ""
    },
    "In the previews static property of LandmarkRow_Previews, add the landmark parameter to the LandmarkRow initializer, specifying the first element of the landmarks array.": {
      "zh": "åœ¨ LandmarkRow_Previews çš„é™æ€å±æ€§ä¸­ï¼Œå‘ LandmarkRow ä¼ å…¥åœ°æ ‡æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ è¿›è¡Œåˆå§‹åŒ–ã€‚",
      "tips": ""
    },
    "In the next few steps, youâ€™ll add navigation among your list and detail views.": {
      "zh": "æ¥ä¸‹æ¥å‡ æ­¥ï¼Œä½ å°†åœ¨åˆ—è¡¨å’Œè¯¦ç»†è§†å›¾ä¹‹é—´æ·»åŠ å¯¼èˆªã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "æ­¥éª¤ 8",
      "tips": ""
    },
    "You can experiment with different devices to compare the renderings of your views, all from the canvas.": {
      "zh": "ä½ å¯ä»¥å°è¯•ä½¿ç”¨ä¸åŒè®¾å¤‡æ¯”è¾ƒè§†å›¾çš„å‘ˆç°æ•ˆæœï¼Œè¿™äº›éƒ½å¯ä»¥åœ¨ç”»å¸ƒä¸Šå±•ç¤ºã€‚",
      "tips": ""
    },
    "Starting with the child views, youâ€™ll convert CircleImage, MapView, and then LandmarkDetail to display data thatâ€™s passed in, rather than hard-coding each row.": {
      "zh": "ä»å­è§†å›¾å¼€å§‹ï¼Œä½ å°†è®© CircleImageã€MapView å’Œ LandmarkDetail æ˜¾ç¤ºä¼ å…¥çš„æ•°æ®ï¼Œè€Œä¸æ˜¯å¯¹æ¯è¡Œè¿›è¡Œç¡¬ç¼–ç ã€‚",
      "tips": ""
    },
    "You make the property private because users of the Landmarks structure care only about the image itself.": {
      "zh": "ä½ å°†å±æ€§è®¾ç½®ä¸ºç§æœ‰ï¼Œå› ä¸º Landmarks ç»“æ„çš„ä½¿ç”¨æ–¹åªå…³å¿ƒå›¾åƒæœ¬èº«ï¼Œä¸éœ€è¦çŸ¥é“å›¾ç‰‡åç§°ã€‚",
      "tips": ""
    },
    "Call the navigationTitle(_:) modifier method to set the title of the navigation bar when displaying the list.": {
      "zh": "åœ¨æ˜¾ç¤ºåˆ—è¡¨æ—¶è°ƒç”¨ navigationTitle(_:) ä¿®é¥°ç¬¦æ–¹æ³•è®¾ç½®å¯¼èˆªæ çš„æ ‡é¢˜ã€‚",
      "tips": ""
    },
    "Create a new SwiftUI view in the Views group named LandmarkRow.swift.": {
      "zh": "åœ¨ Views æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ªåä¸º LandmarkRow.swift çš„æ–° SwiftUI è§†å›¾ã€‚",
      "tips": ""
    },
    "You can provide the name of any device as it appears in Xcodeâ€™s scheme menu.": {
      "zh": "ä½ å¯ä»¥è®¾ç½® Xcode æ–¹æ¡ˆèœå•ä¸­æ˜¾ç¤ºçš„ä»»ä½•è®¾å¤‡çš„åç§°ã€‚",
      "tips": ""
    },
    "Finally, call the navigationTitle(_:) modifier to give the navigation bar a title when showing the detail view, and the navigationBarTitleDisplayMode(_:) modifier to make the title appear inline.": {
      "zh": "æœ€åï¼Œè°ƒç”¨ navigationTitle(:) ä¿®é¥°ç¬¦ä¸ºæ˜¾ç¤ºè¯¦ç»†è§†å›¾æ—¶çš„å¯¼èˆªæ è®¾ç½®æ ‡é¢˜ï¼Œå¹¶ä½¿ç”¨ navigationBarTitleDisplayMode(:) ä¿®é¥°ç¬¦ä½¿æ ‡é¢˜æ˜¾ç¤ºæˆè¡Œå†…çš„æ ·å¼ã€‚",
      "tips": ""
    },
    "When you add the landmark property, the preview stops working, because the LandmarkRow type needs a landmark instance during initialization.": {
      "zh": "å½“ä½ æ·»åŠ  landmark å±æ€§æ—¶ï¼Œé¢„è§ˆä¼šåœæ­¢å·¥ä½œï¼Œå› ä¸º LandmarkRow ç±»å‹åœ¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­éœ€è¦ä¸€ä¸ªåœ°æ ‡å®ä¾‹ã€‚",
      "tips": ""
    },
    "Complete the dynamically-generated list by returning a LandmarkRow from the closure.": {
      "zh": "é€šè¿‡ä»é—­åŒ…è¿”å› LandmarkRow å®ŒæˆåŠ¨æ€ç”Ÿæˆçš„åˆ—è¡¨ã€‚",
      "tips": ""
    },
    "In LandmarkRow_Previews, update the landmark parameter to be the second element in the landmarks array.": {
      "zh": "åœ¨ LandmarkRow_Previews ä¸­ï¼Œå°†åœ°æ ‡å‚æ•°è®¾ç½®ä¸ºåœ°æ ‡æ•°ç»„ä¸­çš„ç¬¬äºŒä¸ªå…ƒç´ ã€‚",
      "tips": ""
    },
    "The preview shows the two landmarks rendered in a list style thatâ€™s appropriate for iOS.": {
      "zh": "é¢„è§ˆæ˜¾ç¤ºäº†é€‚ç”¨äº iOS å¹³å°çš„åˆ—è¡¨æ ·å¼ï¼Œä¸Šé¢å‘ˆç°äº†æˆ‘ä»¬ä¼ å…¥çš„ä¸¤ä¸ªåœ°æ ‡ã€‚",
      "tips": ""
    },
    "The first view youâ€™ll build in this tutorial is a row for displaying details about each landmark. This row view stores information in a property for the landmark it displays, so that one view can display any landmark. Later, youâ€™ll combine multiple rows into a list of landmarks.": {
      "zh": "åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œä½ å°†æ„å»ºçš„ç¬¬ä¸€ä¸ªè§†å›¾æ˜¯ä¸€ä¸ªç”¨äºæ˜¾ç¤ºæ¯ä¸ªåœ°æ ‡è¯¦ç»†ä¿¡æ¯çš„è¡Œã€‚è¿™ä¸ªè¡Œè§†å›¾å°†å®ƒéœ€è¦æ˜¾ç¤ºçš„åœ°æ ‡çš„ä¿¡æ¯å­˜å‚¨åœ¨ä¸€ä¸ªå±æ€§ä¸­ï¼Œè¿™æ ·é€šè¿‡ä¼ å…¥ä¸åŒçš„åœ°æ ‡æ•°æ®ï¼Œä¸€ä¸ªè§†å›¾å°±å¯ä»¥æ˜¾ç¤ºä»»ä½•åœ°æ ‡ã€‚ç¨åï¼Œä½ å°†æŠŠå¤šä¸ªè¡Œè§†å›¾ç»„åˆæˆä¸€ä¸ªåœ°æ ‡åˆ—è¡¨ã€‚",
      "tips": ""
    },
    "When you use SwiftUIâ€™s List type, you can display a platform-specific list of views. The elements of the list can be static, like the child views of the stacks youâ€™ve created so far, or dynamically generated. You can even mix static and dynamically generated views.": {
      "zh": "å½“ä½ ä½¿ç”¨ SwiftUI çš„ List ç±»å‹æ—¶ï¼Œå¯ä»¥æ˜¾ç¤ºä¸€ä¸ªç‰¹å®šå¹³å°ä¸Šçš„è§†å›¾åˆ—è¡¨ã€‚åˆ—è¡¨ä¸­çš„å…ƒç´ å¯ä»¥æ˜¯é™æ€çš„ï¼Œå°±åƒä½ è¿„ä»Šä¸ºæ­¢åˆ›å»ºçš„å †æ ˆçš„å­è§†å›¾ä¸€æ ·ï¼Œä¹Ÿå¯ä»¥æ˜¯åŠ¨æ€ç”Ÿæˆçš„ã€‚ä½ ç”šè‡³å¯ä»¥å°†é™æ€å’ŒåŠ¨æ€ç”Ÿæˆçš„è§†å›¾æ··åˆåœ¨ä¸€èµ·å±•ç¤ºã€‚",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ 1 èŠ‚",
      "tips": ""
    },
    "The navigation changes only have an effect when the view is part of a navigation stack.": {
      "zh": "å¯¼èˆªæ›´æ”¹ä»…åœ¨è§†å›¾æ˜¯å¯¼èˆªå †æ ˆçš„ä¸€éƒ¨åˆ†æ—¶æ‰ä¼šç”Ÿæ•ˆã€‚",
      "tips": ""
    },
    "Building Lists and Navigation": {
      "zh": "",
      "tips": ""
    },
    "Choose File > New > File to create a new Swift file in your project, and name it Landmark.swift.": {
      "zh": "åœ¨é¡¹ç›®ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„Swiftæ–‡ä»¶ï¼Œå‘½åä¸º Landmark.swiftã€‚",
      "tips": ""
    },
    "Start by changing the current list preview to render at the size of an iPhone SE.": {
      "zh": "é¦–å…ˆå°†å½“å‰åˆ—è¡¨é¢„è§ˆæ›´æ”¹ä¸ºä»¥ iPhone SE çš„å¤§å°å‘ˆç°ã€‚",
      "tips": ""
    },
    "Switch to Landmark.swift and declare conformance to the Identifiable protocol.": {
      "zh": "åˆ‡æ¢åˆ° Landmark.swift å¹¶å£°æ˜éµå¾ª Identifiable åè®®ã€‚",
      "tips": ""
    },
    "If the preview isnâ€™t visible already, show the canvas by choosing Editor > Canvas, and then click Resume.": {
      "zh": "å¦‚æœé¢„è§ˆå°šæœªæ˜¾ç¤ºï¼Œè¯·é€‰æ‹© Editor > Canvas æ˜¾ç¤ºç”»å¸ƒï¼Œç„¶åç‚¹å‡» Resumeã€‚",
      "tips": ""
    },
    "Inside the listâ€™s closure, wrap the returned row in a NavigationLink, specifying the LandmarkDetail view as the destination.": {
      "zh": "åœ¨åˆ—è¡¨çš„é—­åŒ…å†…éƒ¨ï¼Œå°† LandmarkRow åŒ…è£…åœ¨ NavigationLink ä¸­ï¼Œå°† LandmarkDetail è§†å›¾æŒ‡å®šä¸ºå¯¼èˆªè·³è½¬çš„ç›®æ ‡ã€‚",
      "tips": ""
    },
    "Create an array of landmarks that you initialize from landmarkData.json.": {
      "zh": "åˆ›å»ºä¸€ä¸ªç”± landmarkData.json åˆå§‹åŒ–çš„åœ°æ ‡æ•°ç»„ã€‚",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "To simplify the code, move the previewLayout(_:) call to the outside of the groupâ€™s child declarations.": {
      "zh": "ä¸ºç®€åŒ–ä»£ç ï¼Œå°† previewLayout(_:) è°ƒç”¨ç§»åˆ° Group çš„å­å£°æ˜ä¹‹å¤–ã€‚",
      "tips": ""
    },
    "You can create groups of existing items by selecting the items to add to the group, and then choosing File > New > Group from Selection in the Xcode menu.": {
      "zh": "ä½ å¯ä»¥å…ˆé€‰ä¸­å¤šä¸ªé¡¹ç›®ï¼Œç„¶ååœ¨ Xcode èœå•ä¸­é€‰æ‹© File > New > Group from Selectionï¼Œå°±èƒ½å°†é€‰æ‹©çš„æ–‡ä»¶æ•´ç†åˆ°ä¸€ä¸ªæ–‡ä»¶å¤¹ä¸­ã€‚",
      "tips": ""
    },
    "Create the List of Landmarks": {
      "zh": "åˆ›å»ºåœ°æ ‡åˆ—è¡¨",
      "tips": ""
    },
    "Create a new SwiftUI view named LandmarkDetail.swift.": {
      "zh": "åˆ›å»ºä¸€ä¸ªåä¸º LandmarkDetail.swift çš„æ–° SwiftUI è§†å›¾ã€‚",
      "tips": ""
    },
    "ForEach operates on collections the same way as the list, which means you can use it anywhere you can use a child view, such as in stacks, lists, groups, and more. When the elements of your data are simple value types â€” like the strings youâ€™re using here â€” you can use \\.self as key path to the identifier.": {
      "zh": "ForEach ä¸åˆ—è¡¨ä¸€æ ·æ“ä½œæ•°ç»„ï¼Œè¿™æ„å‘³ç€ä½ å¯ä»¥åœ¨ä»»ä½•å¯ä»¥ä½¿ç”¨å­è§†å›¾çš„åœ°æ–¹ä½¿ç”¨å®ƒï¼Œä¾‹å¦‚å †æ ˆã€åˆ—è¡¨ã€ç»„ç­‰ã€‚å½“ä½ çš„æ•°æ®å…ƒç´ æ˜¯ç®€å•çš„å€¼ç±»å‹ï¼ˆä¾‹å¦‚è¿™é‡Œä½¿ç”¨çš„å­—ç¬¦ä¸²ï¼‰æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ .self ä½œä¸ºæ ‡è¯†ç¬¦çš„è·¯å¾„ã€‚",
      "tips": ""
    },
    "Create a Landmark Model": {
      "zh": "åˆ›å»ºåœ°æ ‡æ•°æ®æ¨¡å‹",
      "tips": ""
    },
    "In the Landmarks app, a user can flag their favorite places, and filter the list to show just their favorites. To create this feature, youâ€™ll start by adding a switch to the list so users can focus on just their favorites, and then youâ€™ll add a star-shaped button that a user taps to flag a landmark as a favorite.": {
      "zh": "åœ¨ Landmarks åº”ç”¨ä¸­ï¼Œç”¨æˆ·å¯ä»¥æ ‡è®°ä»–ä»¬æœ€å–œæ¬¢çš„åœ°æ–¹ï¼Œå¹¶è¿‡æ»¤åˆ—è¡¨ä»…æ˜¾ç¤ºä»–ä»¬çš„æ”¶è—å¤¹ã€‚è¦åˆ›å»ºæ­¤åŠŸèƒ½ï¼Œä½ å°†é¦–å…ˆåœ¨åˆ—è¡¨ä¸­æ·»åŠ ä¸€ä¸ªå¼€å…³ï¼Œä»¥ä¾¿ç”¨æˆ·ä»…å…³æ³¨ä»–ä»¬çš„æ”¶è—å¤¹ï¼Œç„¶åæ·»åŠ ä¸€ä¸ªæ˜Ÿå½¢æŒ‰é’®ï¼Œç”¨æˆ·ç‚¹å‡»ä»¥å°†åœ°æ ‡æ ‡è®°ä¸ºæ”¶è—ã€‚",
      "tips": ""
    },
    "Add landmark as a stored property of LandmarkRow.": {
      "zh": "æ·»åŠ  landmark ä½œä¸º LandmarkRow çš„å­˜å‚¨å±æ€§ã€‚",
      "tips": ""
    },
    "Pass Data into Child Views": {
      "zh": "å°†æ•°æ®ä¼ åˆ°å­è§†å›¾",
      "tips": ""
    },
    "Step 3": {
      "zh": "æ­¥éª¤ 3",
      "tips": ""
    },
    "This change also affects the build because the detail view has a map view that needs the new parameter. Youâ€™ll fix the detail view soon.": {
      "zh": "æ­¤æ›´æ”¹ä¹Ÿä¼šå½±å“ç¼–è¯‘ï¼Œå› ä¸ºè¯¦ç»†è§†å›¾ä¸­çš„åœ°å›¾è§†å›¾éœ€è¦ä¼ å…¥ä¸€ä¸ªåœ°å›¾å‚æ•°ã€‚ä¸è¿‡åˆ«æ‹…å¿ƒï¼Œä½ å°†å¾ˆå¿«ä¿®å¤è¿™ä¸ªé—®é¢˜ã€‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬ 2 èŠ‚",
      "tips": ""
    },
    "Before moving on, group related files together to make it easier to manage your growing project.": {
      "zh": "åœ¨ç»§ç»­ä¹‹å‰ï¼Œè¯·å°†ç›¸å…³æ–‡ä»¶åˆ†æ–‡ä»¶å¤¹ç®¡ç†ï¼Œè®©é¡¹ç›®ç»“æ„æ›´åŠ æ¸…æ™°ã€‚",
      "tips": ""
    },
    "You can create a list that displays the elements of a collection by passing your collection of data and a closure that provides a view for each element in the collection. The list transforms each element in the collection into a child view by using the supplied closure.": {
      "zh": "ä½ å¯ä»¥é€šè¿‡ä¼ é€’æ•°æ®é›†åˆå’Œæä¾›é›†åˆä¸­æ¯ä¸ªå…ƒç´ çš„è§†å›¾çš„é—­åŒ…æ¥åˆ›å»ºæ˜¾ç¤ºé›†åˆå…ƒç´ çš„åˆ—è¡¨ã€‚åˆ—è¡¨ä½¿ç”¨æä¾›çš„é—­åŒ…å°†é›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ è½¬æ¢ä¸ºå­è§†å›¾ã€‚",
      "tips": ""
    },
    "Instead of specifying a listâ€™s elements individually, you can generate rows directly from a collection.": {
      "zh": "ä½ å¯ä»¥ç›´æ¥ä»é›†åˆç”Ÿæˆè¡Œï¼Œè€Œä¸æ˜¯å•ç‹¬æŒ‡å®šåˆ—è¡¨çš„å…ƒç´ ã€‚",
      "tips": ""
    },
    "In LandmarkList.swift, pass the current landmark to the destination LandmarkDetail.": {
      "zh": "åœ¨ LandmarkList.swift ä¸­ï¼Œå°†å½“å‰åœ°æ ‡ä¼ ç»™ LandmarkDetailã€‚",
      "tips": ""
    },
    "You add navigation capabilities to a list by embedding it in a NavigationView, and then nesting each row in a NavigationLink to set up a transtition to a destination view.": {
      "zh": "ä½ å¯ä»¥å°†åˆ—è¡¨åµŒå…¥ NavigationView ä¸­å¹¶å°†æ¯è¡ŒåµŒå¥—åœ¨ NavigationLink ä¸­ï¼Œæ¥å®ç°åˆ°è¯¦æƒ…è§†å›¾çš„å¯¼èˆªåŠŸèƒ½ã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "æ­¥éª¤ 10",
      "tips": ""
    },
    "Section 4": {
      "zh": "ç¬¬ 4 èŠ‚",
      "tips": ""
    },
    "Lists work with identifiable data. You can make your data identifiable in one of two ways: by passing along with your data a key path to a property that uniquely identifies each element, or by making your data type conform to the Identifiable protocol.": {
      "zh": "åˆ—è¡¨å¯ä»¥å¤„ç†å¯è¯†åˆ«çš„æ•°æ®ã€‚ä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹ä¸¤ç§æ–¹å¼ä¹‹ä¸€ä½¿ä½ çš„æ•°æ®å¯è¯†åˆ«ï¼šä¼ é€’ä¸€ä¸ªèƒ½å¤Ÿæ ‡è¯†æ•°æ®å”¯ä¸€çš„å±æ€§çš„å…³é”®è·¯å¾„ï¼Œæˆ–ä½¿ä½ çš„æ•°æ®ç±»å‹éµå¾ª Identifiable åè®®ã€‚",
      "tips": ""
    },
    "You mark this property as private because youâ€™ll use it only to create a public computed property in the next step.": {
      "zh": "å°†æ­¤å±æ€§æ ‡è®°ä¸ºç§æœ‰ï¼Œå› ä¸ºä½ åªä¼šåœ¨ä¸‹ä¸€æ­¥ä¸­ä½¿ç”¨å®ƒæ¥åˆ›å»ºä¸€ä¸ªå…¬å…±è®¡ç®—å±æ€§ã€‚",
      "tips": ""
    },
    "This creates one LandmarkRow for each element in the landmarks array.": {
      "zh": "è¿™ä¼šä¸ºåœ°æ ‡æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ åˆ›å»ºä¸€ä¸ª LandmarkRowã€‚",
      "tips": ""
    },
    "Generate Previews Dynamically": {
      "zh": "åŠ¨æ€ç”Ÿæˆé¢„è§ˆ",
      "tips": ""
    },
    "Drag the JPG files from the project filesâ€™ Resources folder into your projectâ€™s asset catalog. Xcode creates a new image set for each image.": {
      "zh": "å°†ä¸‹è½½çš„é¡¹ç›®æ–‡ä»¶ä¸­çš„ Resources æ–‡ä»¶å¤¹ä¸­çš„ JPG æ–‡ä»¶æ‹–åˆ°é¡¹ç›®çš„èµ„æºç›®å½•ä¸­ï¼ˆAssets.xcassetsï¼‰ã€‚Xcode ä¼šä¸ºæ¯ä¸ªå›¾åƒåˆ›å»ºä¸€ä¸ªæ–°çš„å›¾åƒé›†åˆã€‚",
      "tips": ""
    },
    "Switch to the live preview to see the detail view show the correct landmarks when you navigate from the list.": {
      "zh": "åˆ‡æ¢åˆ°å®æ—¶é¢„è§ˆï¼ŒæŸ¥çœ‹ä»åˆ—è¡¨å¯¼èˆªæ—¶è¯¦ç»†è§†å›¾æ˜¯å¦æ˜¾ç¤ºæ­£ç¡®çš„åœ°æ ‡ã€‚",
      "tips": ""
    },
    "With all of the connections established, the preview begins working again.": {
      "zh": "åœ¨å»ºç«‹å®Œæ‰€æœ‰è¿æ¥åï¼Œé¢„è§ˆé‡æ–°å¼€å§‹å·¥ä½œã€‚",
      "tips": ""
    },
    "Next, youâ€™ll simplify the List code by adding Identifiable conformance to the Landmark type.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†é€šè¿‡å‘ Landmark ç±»å‹æ·»åŠ  Identifiable åè®®æ¥ç®€åŒ– List ä»£ç ã€‚",
      "tips": ""
    },
    "In LandmarkDetail.swift, add a Landmark property to the LandmarkDetail type.": {
      "zh": "åœ¨ LandmarkDetail.swift ä¸­ï¼Œå°† Landmark å±æ€§æ·»åŠ åˆ° LandmarkDetail ç±»å‹ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "æ­¥éª¤ 7",
      "tips": ""
    },
    "Step 5": {
      "zh": "æ­¥éª¤ 5",
      "tips": ""
    },
    "Customize the Row Preview": {
      "zh": "è‡ªå®šä¹‰è¡Œé¢„è§ˆ",
      "tips": ""
    },
    "Adding Codable conformance makes it easier to move data between the structure and a data file. Youâ€™ll rely on the Decodable component of the Codable protocol later in this section to read data from file.": {
      "zh": "éµå¾ª Codable åè®®å¯ä»¥ä½¿ç»“æ„ä½“å’Œ json æ•°æ®æ–‡ä»¶ä¹‹é—´çš„è½¬æ¢å˜å¾—ç®€å•ã€‚ç¨åï¼Œä½ å°†ä¼šç”¨åˆ° Codable åè®®ä¸­çš„Decodable ç»„ä»¶ä»æ–‡ä»¶ä¸­è¯»å–æ•°æ®ã€‚",
      "tips": ""
    },
    "In MapView.swift, add a coordinate property to MapView and update the preview provider to pass a fixed coordinate.": {
      "zh": "åœ¨ MapView.swift ä¸­ï¼Œå‘ MapView æ·»åŠ ä¸€ä¸ªåæ ‡ï¼ˆcoordinateï¼‰å±æ€§ï¼Œå¹¶ä¿®æ”¹é¢„è§ˆæä¾›ç±»ä¼ å…¥ä¸€ä¸ªå›ºå®šåæ ‡ã€‚",
      "tips": ""
    },
    "Tip": {
      "zh": "æç¤º",
      "tips": ""
    },
    "In the next few steps youâ€™ll model the image associated with each landmark.": {
      "zh": "æ¥ä¸‹æ¥çš„å‡ ä¸ªæ­¥éª¤ä¸­ï¼Œä½ å°†ä¸ºæ¯ä¸ªåœ°æ ‡å…³è”ä¸€ä¸ªå›¾åƒã€‚",
      "tips": ""
    },
    "Use the completed project from the previous tutorial and the resources available from this tutorialâ€™s project files to get started.": {
      "zh": "ä¸ºäº†æœ‰æ›´å¥½çš„å­¦ä¹ æ•ˆæœï¼Œå»ºè®®ä½¿ç”¨ä¸Šä¸€ä¸ªæ•™ç¨‹å·²ç»å®Œæˆçš„é¡¹ç›®ä»¥åŠæœ¬èŠ‚æ•™ç¨‹é¡¹ç›®æ–‡ä»¶å¤¹ä¸­æä¾›çš„èµ„æºã€‚",
      "tips": ""
    },
    "The code you write in a preview provider only changes what Xcode displays in the canvas.": {
      "zh": "ä½ åœ¨é¢„è§ˆæä¾›ç¨‹åºä¸­ç¼–å†™çš„ä»£ç åªä¼šæ›´æ”¹ Xcode åœ¨ç”»å¸ƒä¸­æ˜¾ç¤ºçš„å†…å®¹ã€‚",
      "tips": ""
    },
    "Change the container from a VStack to a ScrollView so the user can scroll through the descriptive content, and delete the Spacer, which you no longer need.": {
      "zh": "å°†å®¹å™¨ä» VStack æ›´æ”¹ä¸º ScrollViewï¼Œä»¥ä¾¿ç”¨æˆ·å¯ä»¥æ»šåŠ¨æŸ¥çœ‹å†…å®¹æè¿°ï¼Œåˆ é™¤ä½ ä¸å†éœ€è¦çš„ Spacerã€‚",
      "tips": ""
    },
    "Even though youâ€™ve fixed the preview logic, the preview fails to update because the build fails. The detail view, which instantiates a circle image, needs an input parameter as well.": {
      "zh": "å°½ç®¡ä½ å·²ç»ä¿®å¤äº†é¢„è§ˆé€»è¾‘ï¼Œä½†ç”±äºç¼–è¯‘å¤±è´¥ï¼Œé¢„è§ˆæ— æ³•æ›´æ–°ã€‚å› ä¸ºè¯¦ç»†è§†å›¾ï¼ˆCircleImageï¼‰ä¹Ÿéœ€è¦è¾“å…¥å‚æ•°ã€‚",
      "tips": ""
    },
    "Step 11": {
      "zh": "æ­¥éª¤ 11",
      "tips": ""
    },
    "Use the previewLayout(_:) modifier to set a size that approximates a row in a list.": {
      "zh": "ä½¿ç”¨ previewLayout(_:) ä¿®é¥°ç¬¦è®¾ç½®é¢„è§ˆçª—å£çš„å¤§å°ã€‚",
      "tips": ""
    },
    "In CircleImage.swift, add a stored image property to CircleImage.": {
      "zh": "åœ¨ CircleImage.swift ä¸­ï¼Œå‘ CircleImage æ·»åŠ ä¸€ä¸ªåä¸º image çš„å­˜å‚¨å±æ€§ã€‚",
      "tips": ""
    },
    "Replace the default Text view with a List, and provide LandmarkRow instances with the first two landmarks as the listâ€™s children.": {
      "zh": "ç”¨ List æ›¿æ¢é»˜è®¤çš„ Text è§†å›¾ï¼Œå¹¶ä¸ºåˆ—è¡¨çš„å­è§†å›¾æä¾›å¸¦æœ‰å‰ä¸¤ä¸ªåœ°æ ‡çš„ LandmarkRow å®ä¾‹ã€‚",
      "tips": ""
    },
    "Make the List Dynamic": {
      "zh": "è®©åˆ—è¡¨æ ¹æ®æ•°æ®åŠ¨æ€å˜åŒ–",
      "tips": ""
    },
    "Embed the existing text view in an HStack.": {
      "zh": "å°†ç°æœ‰æ–‡æœ¬è§†å›¾åµŒå…¥åˆ° HStack ä¸­ã€‚",
      "tips": ""
    },
    "Put ContentView.swift, CircleImage.swift, and MapView.swift into a Views group, landmarkData.json in a Resources group, and Landmark.swift and ModelData.swift into a Model group.": {
      "zh": "å°† ContentView.swiftã€CircleImage.swift å’Œ MapView.swift æ”¾å…¥ä¸€ä¸ª Views åˆ†ç»„ï¼Œå°† landmarkData.json æ”¾å…¥ Resources åˆ†ç»„ï¼Œå°† Landmark.swift å’Œ ModelData.swift æ”¾å…¥ Model åˆ†ç»„ã€‚",
      "tips": ""
    },
    "The list renders properly, but you canâ€™t tap an individual landmark to see that landmarkâ€™s detail page yet.": {
      "zh": "åˆ—è¡¨æ¸²æŸ“æ­£å¸¸ï¼Œä½†ä½ è¿˜ä¸èƒ½ç‚¹å‡»å•ä¸ªåœ°æ ‡æ¥æŸ¥çœ‹è¯¥åœ°æ ‡çš„è¯¦ç»†é¡µé¢ã€‚",
      "tips": ""
    },
    "Section 8": {
      "zh": "ç¬¬ 8 èŠ‚",
      "tips": ""
    },
    "A viewâ€™s children inherit the viewâ€™s contextual settings, such as preview configurations.": {
      "zh": "è§†å›¾çš„å­è§†å›¾ä¼šç»§æ‰¿è§†å›¾çš„ä¸Šä¸‹æ–‡è®¾ç½®ï¼Œä¾‹å¦‚é¢„è§ˆå¤§å°è®¾ç½®ã€‚",
      "tips": ""
    },
    "The LandmarkDetail view still uses hard-coded details to show its landmark. Just like LandmarkRow, the LandmarkDetail type and the views it comprises need to use a landmark property as the source for their data.": {
      "zh": "LandmarkDetail è§†å›¾ä»ç„¶ä½¿ç”¨ç¡¬ç¼–ç çš„æ–¹å¼æ¥å±•ç¤ºåœ°æ ‡ä¿¡æ¯ã€‚å°±åƒ LandmarkRow ä¸€æ ·ï¼ŒLandmarkDetail ç±»å‹åŠå…¶ç»„æˆçš„è§†å›¾éœ€è¦ä½¿ç”¨ landmark å±æ€§ä½œä¸ºæ•°æ®æºã€‚",
      "tips": ""
    },
    "Create a new SwiftUI view in the Views group named LandmarkList.swift.": {
      "zh": "åœ¨ Views æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ªåä¸º LandmarkList.swift çš„æ–° SwiftUI è§†å›¾ã€‚",
      "tips": ""
    },
    "Section 5": {
      "zh": "ç¬¬ 5 èŠ‚",
      "tips": ""
    },
    "Section 6": {
      "zh": "ç¬¬ 6 èŠ‚",
      "tips": ""
    },
    "From now on, youâ€™ll be able to use collections of Landmark elements directly.": {
      "zh": "ä»ç°åœ¨å¼€å§‹ï¼Œä½ å°†èƒ½å¤Ÿç›´æ¥ä½¿ç”¨åœ°æ ‡æ•°ç»„è¿›è¡Œåˆå§‹åŒ–ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "æ­¥éª¤ 2",
      "tips": ""
    },
    "Add an onAppear view modifier to the map that triggers a calculation of the region based on the current coordinate.": {
      "zh": "å‘åœ°å›¾æ·»åŠ ä¸€ä¸ª onAppear è§†å›¾ä¿®é¥°ç¬¦ï¼Œè¯¥ä¿®é¥°ç¬¦ä¼šåœ¨åœ°å›¾è§†å›¾æ˜¾ç¤ºçš„æ—¶å€™æ ¹æ®å½“å‰åæ ‡è®¡ç®—åŒºåŸŸã€‚",
      "tips": ""
    },
    "This is a common pattern when building views using SwiftUI. Your custom views will often wrap and encapsulate a series of modifiers for a particular view.": {
      "zh": "è¿™æ˜¯ä½¿ç”¨ SwiftUI æ„å»ºè§†å›¾æ—¶çš„å¸¸è§æ¨¡å¼ã€‚ä½ çš„è‡ªå®šä¹‰è§†å›¾é€šå¸¸ä¼šåŒ…è£…å¹¶å°è£…ç‰¹å®šè§†å›¾çš„ä¸€ç³»åˆ—ä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    },
    "You can use a Group to return multiple previews from a preview provider.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ Group ä»é¢„è§ˆæä¾›ç¨‹åºè¿”å›å¤šä¸ªé¢„è§ˆã€‚",
      "tips": ""
    },
    "Within the list preview, embed the LandmarkList in a ForEach instance, using an array of device names as the data.": {
      "zh": "åœ¨åˆ—è¡¨é¢„è§ˆä¸­ï¼Œå°† LandmarkList åµŒå…¥åˆ°ä¸€ä¸ª ForEach å®ä¾‹ä¸­ï¼Œå°†è®¾å¤‡åç§°æ•°ç»„ä½œä¸ºæ•°æ®ã€‚",
      "tips": ""
    },
    "Drag landmarkData.json in the downloaded filesâ€™ Resources folder into your projectâ€™s navigation pane; in the dialog that appears, select â€œCopy items if neededâ€ and the Landmarks target, and then click Finish.": {
      "zh": "å°†ä¸‹è½½å¥½çš„ Resources æ–‡ä»¶å¤¹ä¸­çš„ landmarkData.json æ‹–æ”¾åˆ°é¡¹ç›®çš„å¯¼èˆªæ ä¸­ï¼›åœ¨å‡ºç°çš„å¯¹è¯æ¡†ä¸­ï¼Œé€‰æ‹©â€œCopy items if neededâ€å¹¶ä¸”å‹¾é€‰ Landmarks targetï¼Œç„¶åç‚¹å‡»å®Œæˆã€‚",
      "tips": "è¿™ä¸€æ­¥çš„æ„æ€æ˜¯å¦‚æœæœ‰éœ€è¦å°†èµ„æºæ–‡ä»¶æ‹·è´åˆ°æˆ‘ä»¬é¡¹ç›®ç›®å½•ä¸­ã€‚"
    },
    "Create a load(_:) method that fetches JSON data with a given name from the appâ€™s main bundle.": {
      "zh": "åˆ›å»ºä¸€ä¸ª load(_:) æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä»åº”ç”¨ç¨‹åºçš„ä¸»åŒ…ï¼ˆmain bundleï¼‰ä¸­è·å–æŒ‡å®šåç§°çš„ JSON æ•°æ®ã€‚",
      "tips": ""
    },
    "In the first tutorial, you hard-coded information into all of your custom views. Here, youâ€™ll create a model to store data that you can pass into your views.": {
      "zh": "åœ¨ç¬¬ä¸€ä¸ªæ•™ç¨‹ä¸­ï¼Œä½ å°†æ•°æ®å†™æ­»åœ¨æ‰€æœ‰è‡ªå®šä¹‰è§†å›¾ä¸­ã€‚åœ¨æœ¬èŠ‚ï¼Œä½ å°†åˆ›å»ºä¸€ä¸ªæ¨¡å‹æ¥å­˜å‚¨å¯ä»¥ä¼ é€’ç»™è§†å›¾çš„æ•°æ®ã€‚",
      "tips": ""
    },
    "With the basic landmark detail view set up, you need to provide a way for users to see the full list of landmarks, and to view the details about each location.": {
      "zh": "åœ¨åŸºæœ¬åœ°æ ‡è¯¦ç»†ä¿¡æ¯è§†å›¾è®¾ç½®å¥½ä¹‹åï¼Œä½ éœ€è¦æä¾›ä¸€ç§é€”å¾„è®©ç”¨æˆ·æŸ¥çœ‹æ‰€æœ‰åœ°æ ‡åˆ—è¡¨ï¼Œå¹¶æŸ¥çœ‹æ¯ä¸ªåœ°ç‚¹çš„è¯¦ç»†ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "You can try out the navigation directly in the preview by switching to live mode. Click the Live Preview button and tap a landmark to visit the detail page.": {
      "zh": "ä½ å¯ä»¥ç›´æ¥åœ¨é¢„è§ˆä¸­å°è¯•å¯¼èˆªï¼Œæ–¹æ³•æ˜¯åˆ‡æ¢åˆ°å®æ—¶æ¨¡å¼ã€‚ç‚¹å‡»å®æ—¶é¢„è§ˆæŒ‰é’®ï¼Œç‚¹å‡»ä¸€ä¸ªåœ°æ ‡æ¥è®¿é—®è¯¦ç»†é¡µé¢ã€‚",
      "tips": ""
    },
    "Define a Landmark structure with a few properties matching names of some of the keys in the landmarkData.json data file.": {
      "zh": "å®šä¹‰ä¸€ä¸ª Landmark ç»“æ„ä½“ï¼Œå…¶ä¸­åŒ…å«ä¸€äº›ä¸ landmarkData.json æ•°æ®æ–‡ä»¶ä¸­çš„é”®åç›¸å¯¹åº”çš„å±æ€§ã€‚",
      "tips": ""
    },
    "Next, youâ€™ll manage information about the landmarkâ€™s location.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†ç®¡ç†åœ°æ ‡ä½ç½®çš„ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Youâ€™ll use this sample data throughout the remainder of this tutorial, and for all that follow.": {
      "zh": "ä½ å°†åœ¨æœ¬æ•™ç¨‹å‰©ä½™éƒ¨åˆ†å’Œæ‰€æœ‰åç»­æ•™ç¨‹ä¸­ä½¿ç”¨è¿™äº›ç¤ºä¾‹æ•°æ®ã€‚",
      "tips": ""
    },
    "Next, youâ€™ll add code to the LandmarkList_Previews preview provider to render previews of the list view at different device sizes. By default, previews render at the size of the device in the active scheme. You can change the preview device by calling the previewDevice(_:) modifier method.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†ä¸º LandmarkList_Previews æ·»åŠ ä»£ç ï¼Œåœ¨ä¸åŒè®¾å¤‡å¤§å°ä¸Šå‘ˆç°åˆ—è¡¨è§†å›¾çš„é¢„è§ˆã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œé¢„è§ˆä¼šä»¥æ´»åŠ¨æ–¹æ¡ˆä¸­çš„è®¾å¤‡å¤§å°å‘ˆç°ã€‚ä½ å¯ä»¥é€šè¿‡è°ƒç”¨ previewDevice(:) ä¿®é¥°ç¬¦æ–¹æ³•æ›´æ”¹é¢„è§ˆè®¾å¤‡ã€‚",
      "tips": ""
    },
    "Group is a container for grouping view content. Xcode renders the groupâ€™s child views as separate previews in the canvas.": {
      "zh": "Group æ˜¯å¯¹è§†å›¾å†…å®¹è¿›è¡Œåˆ†ç»„çš„å®¹å™¨ã€‚Xcode åœ¨ç”»å¸ƒä¸­å°† Group çš„å­è§†å›¾æ¸²æŸ“ä¸ºå•ç‹¬çš„é¢„è§ˆã€‚",
      "tips": ""
    },
    "Remove the two static landmark rows, and instead pass the model dataâ€™s landmarks array to the List initializer.": {
      "zh": "åˆ é™¤ä¸¤ä¸ªé™æ€åœ°æ ‡è¡Œï¼Œå¹¶å°†æ¨¡å‹æ•°æ®çš„åœ°æ ‡æ•°ç»„ä½œä¸ºå‚æ•°ä¼ é€’ç»™ List çš„åˆå§‹åŒ–å‡½æ•°ã€‚",
      "tips": ""
    },
    "Section 7": {
      "zh": "ç¬¬ 7 èŠ‚",
      "tips": ""
    },
    "Add an imageName property to read the name of the image from the data, and a computed image property that loads an image from the asset catalog.": {
      "zh": "æ·»åŠ ä¸€ä¸ª imageName å±æ€§ï¼Œç”¨äºå¯¹åº” json æ•°æ®ä¸­çš„å›¾åƒåç§°ï¼Œä»¥åŠä¸€ä¸ªè®¡ç®—å±æ€§ imageï¼Œç”¨æ¥ä»èµ„æºç›®å½•ä¸­åŠ è½½å›¾åƒã€‚",
      "tips": ""
    },
    "Wrap the returned row in a Group, and add the first row back again.": {
      "zh": "å°† LandmarkRow åŒ…è£¹åœ¨ Group ä¸­ï¼Œå¹¶å†æ¬¡è®¾ç½®ç¬¬ä¸€ä¸ª landmark æ•°æ®è¿›è¡Œé¢„è§ˆã€‚",
      "tips": ""
    },
    "Change ContentView to instead display LandmarkList.": {
      "zh": "æ›´æ”¹ ContentView æ¥æ˜¾ç¤º LandmarkListã€‚",
      "tips": ""
    },
    "Youâ€™ll create views that can show information about any landmark, and dynamically generate a scrolling list that a user can tap to see a detail view for a landmark. To fine-tune the UI, youâ€™ll use Xcodeâ€™s canvas to render multiple previews at different device sizes.": {
      "zh": "ä½ å°†åˆ›å»ºå¯ä»¥æ˜¾ç¤ºä»»ä½•åœ°æ ‡ä¿¡æ¯çš„è§†å›¾ï¼Œå¹¶åŠ¨æ€ç”Ÿæˆä¸€ä¸ªç”¨æˆ·å¯ä»¥ç‚¹å‡»æŸ¥çœ‹åœ°æ ‡è¯¦ç»†ä¿¡æ¯çš„æ»šåŠ¨åˆ—è¡¨ã€‚ä¸ºäº†å¾®è°ƒ UIï¼Œä½ å°†ä½¿ç”¨ Xcode çš„ç”»å¸ƒé¢„è§ˆä¸åŒè®¾å¤‡å°ºå¯¸ä¸‹çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "æ­¥éª¤ 4",
      "tips": ""
    },
    "You can customize the returned content from a preview provider to render exactly the previews that are most helpful to you.": {
      "zh": "ä½ å¯ä»¥è‡ªå®šä¹‰é¢„è§ˆæä¾›ç±»è¿”å›çš„å†…å®¹ï¼Œæ¥å‘ˆç°å¯¹ä½ æœ€æœ‰å¸®åŠ©çš„é¢„è§ˆã€‚",
      "tips": ""
    },
    "Complete the row by adding an image before the text view, and a spacer after it.": {
      "zh": "åœ¨æ–‡æœ¬è§†å›¾ä¹‹å‰æ·»åŠ ä¸€ä¸ªå›¾ç‰‡ï¼Œåœ¨æ–‡æœ¬è§†å›¾ä¹‹åæ·»åŠ ä¸€ä¸ªé—´éš”ç¬¦ï¼Œå®Œæˆè¿™ä¸€è¡Œçš„æ„å»ºã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "æ­¥éª¤ 9",
      "tips": ""
    },
    "The load method relies on the return typeâ€™s conformance to the Decodable protocol, which is one component of the Codable protocol.": {
      "zh": "load æ–¹æ³•ä½¿ç”¨åˆ°äº† swift è¯­æ³•ä¸­çš„æ³›å‹ï¼Œè¿”å›å€¼éµå¾ª Decodable åè®®ï¼Œå®ƒæ˜¯ Codable åè®®çš„ä¸€ä¸ªç»„æˆéƒ¨åˆ†ã€‚",
      "tips": ""
    },
    "Create the Row View": {
      "zh": "åˆ›å»ºè¡Œè§†å›¾",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ 3 èŠ‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "æ­¥éª¤ 1",
      "tips": ""
    },
    "Set Up Navigation Between List and Detail": {
      "zh": "åœ¨åˆ—è¡¨å’Œè¯¦æƒ…é¡µé¢ä¹‹é—´è®¾ç½®å¯¼èˆª",
      "tips": ""
    },
    "Finally, youâ€™ll create an array initialized with landmarks from a file.": {
      "zh": "æœ€åï¼Œä½ å°†åˆ›å»ºä¸€ä¸ªç”¨ json æ–‡ä»¶ä¸­çš„åœ°æ ‡åˆå§‹åŒ–çš„æ•°ç»„ã€‚",
      "tips": ""
    },
    "Prepare a detail view using the content you created in the previous tutorial and update the main content view to display the list view instead.": {
      "zh": "ä½¿ç”¨ä¸Šä¸€ä¸ªæ•™ç¨‹ä¸­åˆ›å»ºçš„å†…å®¹æ¥å‡†å¤‡æ­å»ºè¯¦ç»†è§†å›¾ï¼Œå¹¶æ›´æ–°ä¸»å†…å®¹è§†å›¾ä¸ºåˆ—è¡¨è§†å›¾ã€‚",
      "tips": ""
    },
    "The preview immediately changes to show the second sample landmark instead of the first.": {
      "zh": "é¢„è§ˆä¼šç«‹å³åˆ·æ–°æ˜¾ç¤ºç¬¬äºŒä¸ªç¤ºä¾‹åœ°æ ‡ã€‚",
      "tips": ""
    },
    "Update the preview provider to pass the image of Turtle Rock.": {
      "zh": "æ›´æ–°é¢„è§ˆæä¾›ç±»ä¼ å…¥ Turtle Rock çš„å›¾åƒæ•°æ®ã€‚",
      "tips": ""
    },
    "Handling User Input": {
      "zh": "",
      "tips": ""
    },
    "With that fixed, you can build the layout for the row.": {
      "zh": "ä¿®å¤æŠ¥é”™åï¼Œä½ å°±å¯ä»¥å¼€å§‹æ„å»ºè¡Œçš„å¸ƒå±€ã€‚",
      "tips": ""
    },
    "Add a coordinates property to the structure using a nested Coordinates type that reflects the storage in the JSON data structure.": {
      "zh": "ä½¿ç”¨åµŒå¥—çš„ Coordinates ç±»å‹ï¼Œå¯¹åº” json æ•°æ®ç»“æ„ä¸­çš„åµŒå¥—ç±»å‹ï¼Œè¿™æ ·å¯ä»¥å°† coordinates å±æ€§æ·»åŠ åˆ°ç»“æ„ä¸­ã€‚",
      "tips": ""
    },
    "The preview displays the text, â€œHello, World!â€.": {
      "zh": "é¢„è§ˆæ˜¾ç¤ºæ–‡æœ¬ï¼šâ€œHello, World!â€ã€‚",
      "tips": ""
    },
    "The new images join the one for Turtle Rock that you added in the previous tutorial.": {
      "zh": "æ–°å›¾åƒåŒ…å«äº†ä¸Šä¸€ä¸ªæ•™ç¨‹ä¸­æ·»åŠ çš„ Turtle Rock å›¾åƒã€‚",
      "tips": ""
    }
  },
  "swiftui/composing-complex-interfaces": {
    "The Landmark.Category case name identifies each item in the list, which must be unique among other categories because itâ€™s an enumeration.": {
      "zh": "Landmark.Category æšä¸¾ä¸­çš„æ¯ä¸ªcaseåç§°ç”¨äºæ ‡è¯†åˆ—è¡¨ä¸­çš„æ¯ä¸€é¡¹ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªæšä¸¾ï¼Œæ‰€ä»¥åœ¨å…¶ä»–ç±»åˆ«ä¸­å¿…é¡»æ˜¯å”¯ä¸€çš„ã€‚",
      "tips": ""
    },
    "Complete the Category View": {
      "zh": "",
      "tips": ""
    },
    "You use navigation views along with NavigationLink instances and related modifiers to build hierarchical navigation structures in your app.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨å¯¼èˆªè§†å›¾ä»¥åŠ NavigationLink å®ä¾‹å’Œç›¸å…³ä¿®é¥°ç¬¦åœ¨åº”ç”¨ä¸­æ„å»ºåˆ†å±‚å¯¼èˆªç»“æ„ã€‚",
      "tips": ""
    },
    "The category item itself is the label for the button, and its destination is the landmark detail view for the landmark represented by the card.": {
      "zh": "ç±»åˆ«é¡¹ä½œä¸ºæŒ‰é’®çš„æ ‡ç­¾ï¼Œå…¶å¯¼èˆªç›®æ ‡æ˜¯å¡ç‰‡æ‰€ä»£è¡¨åœ°æ ‡çš„åœ°æ ‡è¯¦ç»†è§†å›¾ã€‚",
      "tips": ""
    },
    "Add the rows and the featured image to the category home page.": {
      "zh": "å°†è¡Œå’Œç‰¹è‰²å›¾åƒæ·»åŠ åˆ°ç±»åˆ«ä¸»é¡µã€‚",
      "tips": ""
    },
    "In CategoryHome.swift, create a modelData environment object.": {
      "zh": "åœ¨ CategoryHome.swift ä¸­ï¼Œåˆ›å»ºä¸€ä¸ª modelData ç¯å¢ƒå¯¹è±¡ã€‚",
      "tips": ""
    },
    "The landmarkData.json file already includes a category value for each landmark with one of three string values. By matching the names in the data file, you can rely on the structureâ€™s Codable conformance to load the data.": {
      "zh": "landmarkData.json æ–‡ä»¶å·²ç»ä¸ºæ¯ä¸ªåœ°æ ‡åŒ…å«äº†ä¸€ä¸ªç±»åˆ«ï¼ŒåŒ…å«äº†è¿™ä¸‰ä¸ªå±æ€§ã€‚é€šè¿‡åŒ¹é…æ•°æ®æ–‡ä»¶ä¸­çš„åç§°ï¼Œä½ å¯ä»¥ä¾èµ–ç»“æ„ä½“çš„ Codable åè®®æ¥åŠ è½½æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "æ­¥éª¤ 5",
      "tips": ""
    },
    "Create a new custom view called CategoryItem that displays one landmark.": {
      "zh": "åˆ›å»ºä¸€ä¸ªåä¸º CategoryItem çš„æ–°è‡ªå®šä¹‰è§†å›¾ï¼Œç”¨äºæ˜¾ç¤ºä¸€ä¸ªåœ°æ ‡ã€‚",
      "tips": ""
    },
    "In CategoryHome.swift, add the image of the first featured landmark to the top of the list.": {
      "zh": "åœ¨ CategoryHome.swift ä¸­ï¼Œå°†ç¬¬ä¸€ä¸ªç‰¹è‰²åœ°æ ‡çš„å›¾ç‰‡æ·»åŠ åˆ°åˆ—è¡¨é¡¶éƒ¨ã€‚",
      "tips": ""
    },
    "With all of the differently categorized landmarks visible in the view, the user needs a way to reach each section in the app. Use the navigation and presentation APIs to make the category home, the detail view, and favorites list navigable from a tab view.": {
      "zh": "ç”±äºè§†å›¾ä¸­æ˜¾ç¤ºäº†æ‰€æœ‰ä¸åŒåˆ†ç±»çš„åœ°æ ‡ï¼Œå› æ­¤ç”¨æˆ·éœ€è¦ä¸€ç§æ–¹æ³•æ¥è®¿é—®åº”ç”¨ç¨‹åºä¸­çš„æ¯ä¸ªéƒ¨åˆ†ã€‚ä½¿ç”¨å¯¼èˆªå’Œæ¼”ç¤º API ä½¿ç±»åˆ«ä¸»é¡µã€è¯¦ç»†ä¿¡æ¯è§†å›¾å’Œæ”¶è—å¤¹åˆ—è¡¨å¯ä»é€‰é¡¹å¡è§†å›¾å¯¼èˆªã€‚",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Create a Category Row": {
      "zh": "åˆ›å»ºä¸€ä¸ªæ¨ªå‘æ»šåŠ¨æ˜¾ç¤ºçš„ç±»åˆ«ç»„",
      "tips": ""
    },
    "Set the edge insets to zero on both kinds of landmark previews so the content can extend to the edges of the display.": {
      "zh": "å°†ä¸¤ç§åœ°æ ‡é¢„è§ˆçš„è¾¹ç¼˜é—´è·è®¾ç½®ä¸ºé›¶ï¼Œè®©å†…å®¹å¯ä»¥å»¶ä¼¸åˆ°æ˜¾ç¤ºå™¨çš„è¾¹ç¼˜ã€‚",
      "tips": ""
    },
    "Define a new custom view CategoryRow for holding the contents of a row.": {
      "zh": "å®šä¹‰ä¸€ä¸ªæ–°çš„è‡ªå®šä¹‰è§†å›¾ CategoryRow ä»¥æ˜¾ç¤ºè¿™ä¸€è¡Œçš„å†…å®¹ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "æ­¥éª¤ 6",
      "tips": ""
    },
    "Text that you pass as the label for a navigation link renders using the environmentâ€™s accent color, and images may render as template images. You can modify either behavior to best suit your design.": {
      "zh": "ä½œä¸ºå¯¼èˆªé“¾æ¥æ ‡ç­¾çš„æ–‡æœ¬ä¼šä½¿ç”¨ç¯å¢ƒçš„å¼ºè°ƒè‰²è¿›è¡Œæ¸²æŸ“ï¼Œè€Œå›¾åƒå¯èƒ½ä½œä¸ºæ¨¡æ¿å›¾åƒæ¸²æŸ“ã€‚æ‚¨å¯ä»¥æ ¹æ®è®¾è®¡éœ€æ±‚ä¿®æ”¹è¿™ä¸¤ç§å±•ç¤ºæ•ˆæœã€‚",
      "tips": ""
    },
    "Youâ€™ll turn this view into an interactive carousel in a later tutorial. For now, it displays one of the featured landmarks with a scaled and cropped preview image.": {
      "zh": "åœ¨åç»­æ•™ç¨‹ä¸­ï¼Œä½ å°†ä¼šæŠŠæ­¤è§†å›¾å˜æˆä¸€ä¸ªäº¤äº’å¼è½®æ’­ã€‚ç°åœ¨ï¼Œå®ƒä»¥ç¼©æ”¾å’Œè£å‰ªçš„é¢„è§ˆå›¾åƒæ˜¾ç¤ºä¸€ä¸ªç‰¹è‰²åœ°æ ‡ã€‚",
      "tips": ""
    },
    "In Landmark.swift, add a new isFeatured property.": {
      "zh": "åœ¨ Landmark.swift ä¸­ï¼Œæ·»åŠ ä¸€ä¸ªæ–°çš„ isFeatured å±æ€§ã€‚",
      "tips": ""
    },
    "Composing Complex Interfaces": {
      "zh": "",
      "tips": ""
    },
    "Add properties for the category name and the list of items in that category.": {
      "zh": "æ·»åŠ ç±»åˆ«åç§°å’Œé¡¹ç›®åˆ—è¡¨å±æ€§ã€‚",
      "tips": ""
    },
    "Reuse parts of the Landmark view you created in Creating and Combining Views to create familiar previews of a landmark.": {
      "zh": "é‡ç”¨æ‚¨åœ¨â€œåˆ›å»ºå’Œç»„åˆè§†å›¾â€ä¸­åˆ›å»ºçš„Landmarkè§†å›¾çš„éƒ¨åˆ†å†…å®¹ï¼Œä»¥ç”Ÿæˆç†Ÿæ‚‰çš„åœ°æ ‡é¢„è§ˆã€‚",
      "tips": ""
    },
    "Add a state variable for the tab selection, and give it a default value.": {
      "zh": "æ·»åŠ ä¸€ä¸ªç”¨äºè¡¨ç¤ºå½“å‰ Tab çš„çŠ¶æ€å˜é‡ï¼Œå¹¶ä¸ºå…¶è®¾ç½®ä¸€ä¸ªé»˜è®¤å€¼ã€‚",
      "tips": ""
    },
    "You can provide a different way to browse the landmarks by creating a view that sorts landmarks by category, while highlighting a featured landmark at the top of the view.": {
      "zh": "ä½ å¯ä»¥æä¾›ä¸€ç§ä¸åŒçš„æ–¹å¼æ¥æµè§ˆåœ°æ ‡ï¼Œæ–¹æ³•æ˜¯åˆ›å»ºä¸€ä¸ªæŒ‰ç±»åˆ«å¯¹åœ°æ ‡è¿›è¡Œæ’åºçš„è§†å›¾ï¼ŒåŒæ—¶åœ¨è§†å›¾é¡¶éƒ¨çªå‡ºæ˜¾ç¤ºç‰¹è‰²åœ°æ ‡ã€‚",
      "tips": ""
    },
    "Display the name of the category.": {
      "zh": "æ˜¾ç¤ºç±»åˆ«çš„åç§°ã€‚",
      "tips": ""
    },
    "Add a NavigationView to host the different categories.": {
      "zh": "æ·»åŠ ä¸€ä¸ª NavigationView æ¥å¯¼èˆªåˆ°ä¸åŒçš„ç±»åˆ«ã€‚",
      "tips": ""
    },
    "Next, youâ€™ll add a featured landmark to the top of the view. Youâ€™ll need more information from the landmark data to do this.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†åœ¨è§†å›¾é¡¶éƒ¨æ·»åŠ ä¸€ä¸ªç‰¹è‰²åœ°æ ‡ã€‚ä¸ºæ­¤ï¼Œä½ éœ€è¦ä»åœ°æ ‡æ•°æ®ä¸­è·å–æ›´å¤šä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "æ­¥éª¤ 3",
      "tips": ""
    },
    "Create a tab view that wraps the LandmarkList, as well as the new CategoryHome.": {
      "zh": "åˆ›å»ºä¸€ä¸ªåŒ…è£… LandmarkList ä»¥åŠæ–°çš„ CategoryHome çš„åº•éƒ¨æ ‡ç­¾è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "æ­¥éª¤ 4",
      "tips": ""
    },
    "Like for other landmark properties youâ€™ve added, this Boolean already exists in the data â€” you just need to declare a new property.": {
      "zh": "ä¸ä½ æ·»åŠ çš„å…¶ä»–åœ°æ ‡å±æ€§ä¸€æ ·ï¼Œè¿™ä¸ªå¸ƒå°”å€¼å·²ç»å­˜åœ¨äºæ•°æ®ä¸­ï¼Œä½ åªéœ€è¦å£°æ˜ä¸€ä¸ªæ–°å±æ€§ã€‚",
      "tips": ""
    },
    "In the Landmarks app, users can create a profile to express their personality. To give users the ability to change their profile, youâ€™ll add an edit mode and design the preferences screen.": {
      "zh": "åœ¨ Landmarks åº”ç”¨ä¸­ï¼Œç”¨æˆ·å¯ä»¥åˆ›å»ºä¸€ä¸ªä¸ªäººèµ„æ–™ä»¥è¡¨è¾¾è‡ªå·±çš„ä¸ªæ€§ã€‚ä¸ºäº†è®©ç”¨æˆ·èƒ½å¤Ÿæ›´æ”¹ä¸ªäººèµ„æ–™ï¼Œä½ å°†æ·»åŠ ä¸€ä¸ªç¼–è¾‘æ¨¡å¼å¹¶è®¾è®¡åå¥½è®¾ç½®å±å¹•ã€‚",
      "tips": ""
    },
    "Pin the preview so you can see the effect of the next step on the CategoryRow.": {
      "zh": "å›ºå®šé¢„è§ˆï¼Œä»¥ä¾¿æ‚¨å¯ä»¥åœ¨ CategoryRow ä¸Šçœ‹åˆ°ä¸‹ä¸€æ­¥çš„æ•ˆæœã€‚",
      "tips": ""
    },
    "The tag(_:) modifier on each of the views matches one of the possible values that the selection property can take so the TabView can coordinate which view to display when the user makes a selection in the user interface.": {
      "zh": "æ¯ä¸ªè§†å›¾ä¸Šçš„ tag(_:) ä¿®é¥°ç¬¦ ä¸ selection å±æ€§å¯èƒ½å…·æœ‰çš„å€¼ä¹‹ä¸€ç›¸åŒ¹é…ï¼Œè¿™æ · TabView å°±å¯ä»¥æ˜¾ç¤ºç”¨æˆ·åœ¨ç”¨æˆ·ç•Œé¢è¿›è¡Œé€‰æ‹©çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "Display the categories in Landmarks using a List.": {
      "zh": "ä½¿ç”¨ List æ˜¾ç¤º Landmarks ä¸­çš„ç±»åˆ«ã€‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬ 2 èŠ‚",
      "tips": ""
    },
    "In CategoryRow.swift, replace the Text that holds the landmark name with the new CategoryItem view.": {
      "zh": "åœ¨ CategoryRow.swift ä¸­ï¼Œç”¨æ–°çš„ CategoryItem è§†å›¾æ›¿æ¢åŒ…å«åœ°æ ‡åç§°çš„ Textã€‚",
      "tips": ""
    },
    "Add a Category View": {
      "zh": "æ·»åŠ ä¸€ä¸ªç±»åˆ«è§†å›¾",
      "tips": ""
    },
    "Updating the view preview with a larger sampling of data makes it easier to ensure that the scrolling behavior is correct.": {
      "zh": "ä½¿ç”¨å¤šæ•°æ®æ›´æ–°è§†å›¾é¢„è§ˆï¼Œå¯ä»¥æ›´å®¹æ˜“åœ°ç¡®ä¿æ»šåŠ¨è¡Œä¸ºæ­£ç¡®ã€‚",
      "tips": ""
    },
    "Follow the steps to build this project, or download the finished project to explore on your own.": {
      "zh": "æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ„å»ºæ­¤é¡¹ç›®ï¼Œæˆ–è€…ä¸‹è½½å®Œæˆçš„é¡¹ç›®è‡ªè¡Œæ¢ç´¢ã€‚",
      "tips": ""
    },
    "Landmarks displays each category in a row that scrolls horizontally. Add a new view type to represent the row, then display all the landmarks for that category in the new view.": {
      "zh": "åœ°æ ‡åº”ç”¨å°†æ¯ä¸ªç±»åˆ«ä»¥æ°´å¹³æ»šåŠ¨çš„è¡Œå½¢å¼å±•ç¤ºã€‚æ·»åŠ ä¸€ä¸ªæ–°çš„è§†å›¾ç±»å‹æ¥ä»£è¡¨è¿™ä¸€è¡Œï¼Œç„¶ååœ¨æ–°è§†å›¾ä¸­å±•ç¤ºè¯¥ç±»åˆ«ä¸‹çš„æ‰€æœ‰åœ°æ ‡ã€‚",
      "tips": ""
    },
    "Create a Categories group in your projectâ€™s Views group, and create a custom view called CategoryHome to the new group.": {
      "zh": "åœ¨é¡¹ç›®çš„ Views æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ª Categories åˆ†ç»„ï¼Œå¹¶åœ¨æ–°æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ªåä¸º CategoryHome çš„è‡ªå®šä¹‰è§†å›¾ã€‚",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ 3 èŠ‚",
      "tips": ""
    },
    "Start the live preview and try out the new navigation.": {
      "zh": "å¯åŠ¨å®æ—¶é¢„è§ˆå¹¶å°è¯•æ–°çš„å¯¼èˆªã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "æ­¥éª¤ 1",
      "tips": ""
    },
    "Start by reading category data from the landmarkData.json file.": {
      "zh": "é¦–å…ˆä» landmarkData.json æ–‡ä»¶ä¸­è¯»å–åˆ†ç±»æ•°æ®ã€‚",
      "tips": ""
    },
    "Put the categoryâ€™s items in an HStack, and group that with the category name in a VStack.": {
      "zh": "å°†ç±»åˆ«çš„é¡¹ç›®å±•ç¤ºæ”¾åœ¨ä¸€ä¸ª HStack ä¸­ï¼Œå¹¶å°†å…¶ä¸ç±»åˆ«åç§°ä¸€èµ·åŒ…åœ¨ä¸€ä¸ª VStack ä¸­ã€‚",
      "tips": ""
    },
    "Next youâ€™ll modify the appâ€™s main content view to show a tab view that lets the user choose between the category view you just created, and the existing list of landmarks.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†ä¿®æ”¹åº”ç”¨çš„ä¸»å†…å®¹è§†å›¾ï¼Œæ˜¾ç¤ºä¸€ä¸ªåº•éƒ¨æ ‡ç­¾è§†å›¾ï¼Œè®©ç”¨æˆ·åœ¨åˆšåˆšåˆ›å»ºçš„ç±»åˆ«è§†å›¾å’Œç°æœ‰çš„åœ°æ ‡åˆ—è¡¨ä¹‹é—´è¿›è¡Œé€‰æ‹©ã€‚",
      "tips": ""
    },
    "In CategoryRow.swift, wrap the existing CategoryItem with a NavigationLink.": {
      "zh": "åœ¨ CategoryRow.swift ä¸­ï¼Œç”¨ NavigationLink åŒ…è£…ç°æœ‰çš„ CategoryItemã€‚",
      "tips": ""
    },
    "The category view for Landmarks shows a vertically scrolling list of horizontally scrolling landmarks. As you build this view and connect it to your existing views, youâ€™ll explore how composed views can adapt to different device sizes and orientations.": {
      "zh": "åœ¨ Landmarks åº”ç”¨ä¸­ï¼Œåˆ†ç±»è§†å›¾æ˜¾ç¤ºä¸€ä¸ªå‚ç›´æ»šåŠ¨çš„åˆ—è¡¨ï¼Œåˆ—è¡¨ä¸­åŒ…å«æ°´å¹³æ»šåŠ¨çš„åœ°æ ‡ã€‚åœ¨æ„å»ºè¿™ä¸ªè§†å›¾å¹¶å°†å…¶è¿æ¥åˆ°ç°æœ‰è§†å›¾æ—¶ï¼Œä½ å°†æ¢ç©¶å¦‚ä½•ä½¿ç»„åˆè§†å›¾é€‚åº”ä¸åŒçš„è®¾å¤‡å°ºå¯¸å’Œæ–¹å‘ã€‚",
      "tips": ""
    },
    "Give each tab a label.": {
      "zh": "ä¸ºæ¯ä¸ªåº•éƒ¨æ ‡ç­¾æ·»åŠ æ–‡æœ¬å’Œå›¾æ ‡ã€‚",
      "tips": ""
    },
    "In ModelData.swift, add a computed categories dictionary, with category names as keys, and an array of associated landmarks for each key.": {
      "zh": "åœ¨ ModelData.swift ä¸­ï¼Œæ·»åŠ ä¸€ä¸ª categories å­—å…¸ï¼Œä»¥ç±»åˆ«åç§°ä¸ºé”®ï¼Œä»¥æ¯ä¸ªé”®çš„ç›¸å…³åœ°æ ‡æ•°ç»„åšä¸ºå€¼ã€‚",
      "tips": ""
    },
    "Update the body of CategoryHome to pass category information to instances of the row type.": {
      "zh": "æ›´æ–° CategoryHome çš„ bodyï¼Œå°†ç±»åˆ«ä¿¡æ¯ä¼ é€’ç»™æ¯ä¸€è¡Œã€‚",
      "tips": ""
    },
    "In Landmark.swift, add a Category enumeration and a category property to the Landmark structure.": {
      "zh": "åœ¨ Landmark.swift ä¸­ï¼Œä¸º Landmark ç»“æ„æ·»åŠ ä¸€ä¸ª Category æšä¸¾å’Œä¸€ä¸ª category å±æ€§ã€‚",
      "tips": ""
    },
    "Section 4": {
      "zh": "ç¬¬ 4 èŠ‚",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ 1 èŠ‚",
      "tips": ""
    },
    "Add Navigation Between Sections": {
      "zh": "åœ¨ä¸åŒçš„éƒ¨åˆ†æ·»åŠ å¯¼èˆª",
      "tips": ""
    },
    "Unpin the preview, switch to the ContentView and add an enumeration of the tabs to display.": {
      "zh": "å–æ¶ˆå›ºå®šé¢„è§ˆï¼Œåˆ‡æ¢åˆ° ContentView å¹¶æ·»åŠ è¦æ˜¾ç¤ºçš„åº•éƒ¨æ ‡ç­¾æ çš„æšä¸¾ã€‚",
      "tips": ""
    },
    "The category view displays all categories in separate rows arranged in a vertical column for easier browsing. You do this by combining vertical and horizontal stacks, and adding scrolling to the list.": {
      "zh": "åˆ†ç±»è§†å›¾ä»¥å‚ç›´åˆ—è¡¨æ–¹å¼æ˜¾ç¤ºæ‰€æœ‰çš„ç±»åˆ«ï¼Œä»¥ä¾¿äºæµè§ˆã€‚ä½ å¯ä»¥é€šè¿‡ç»“åˆå‚ç›´å’Œæ°´å¹³å †æ ˆï¼Œå¹¶ä¸ºåˆ—è¡¨æ·»åŠ æ»šåŠ¨æ¥å®ç°è¿™ä¸€ç‚¹ã€‚",
      "tips": ""
    },
    "Section 5": {
      "zh": "ç¬¬ 5 èŠ‚",
      "tips": ""
    },
    "Youâ€™ll need access to the categories right now, as well as to other landmark data later.": {
      "zh": "ä½ ç°åœ¨éœ€è¦è®¿é—®ç±»åˆ«ï¼Œä»¥åŠç¨åè®¿é—®å…¶ä»–åœ°æ ‡æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "æ­¥éª¤ 2",
      "tips": ""
    },
    "Create a Category List": {
      "zh": "åˆ›å»ºä¸€ä¸ªç±»åˆ«åˆ—è¡¨",
      "tips": ""
    },
    "Change the navigation appearance of the category items by applying the renderingMode(_:) and foregroundColor(_:) modifiers.": {
      "zh": "é€šè¿‡åº”ç”¨ renderingMode(:) å’Œ foregroundColor(:) ä¿®é¥°ç¬¦æ¥æ›´æ”¹ç±»åˆ«é¡¹ç›®çš„å¯¼èˆªå¤–è§‚ã€‚",
      "tips": ""
    },
    "In ModelData.swift, add a new computed features array, which contains only the landmarks that have isFeatured set to true.": {
      "zh": "åœ¨ ModelData.swift ä¸­ï¼Œæ·»åŠ ä¸€ä¸ªæ–°çš„ features æ•°ç»„ï¼Œå…¶ä¸­ä»…åŒ…å«å°† isFeatured è®¾ç½®ä¸º true çš„åœ°æ ‡ã€‚",
      "tips": ""
    },
    "Give the content some space by specifying a tall frame(width:height:), adding padding, and wrapping the HStack in a scroll view.": {
      "zh": "é€šè¿‡æŒ‡å®šä¸€ä¸ªé«˜åº¦è¾ƒé«˜çš„ frame(width:height:)ï¼Œæ·»åŠ å†…è¾¹è·ï¼Œå¹¶å°† HStack åŒ…è£…åœ¨æ»šåŠ¨è§†å›¾ä¸­ï¼Œä¸ºå†…å®¹ç•™å‡ºä¸€å®šçš„ç©ºé—´ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "æ­¥éª¤7",
      "tips": ""
    },
    "The view showcases one or more featured landmarks at the top.": {
      "zh": "è¯¥è§†å›¾åœ¨é¡¶éƒ¨å±•ç¤ºä¸€ä¸ªæˆ–å¤šä¸ªç‰¹è‰²åœ°æ ‡ã€‚",
      "tips": ""
    },
    "Set the title of the navigation bar to Featured.": {
      "zh": "å°†å¯¼èˆªæ çš„æ ‡é¢˜è®¾ç½®ä¸ºç²¾é€‰ï¼ˆFeaturedï¼‰ã€‚",
      "tips": ""
    },
    "Working with UI Controls": {
      "zh": "",
      "tips": ""
    }
  },
  "swiftui/creating-a-macos-app": {
    "Add a Picker that controls the zoom value through a binding.": {
      "zh": "æ·»åŠ ä¸€ä¸ªç»‘å®šç¼©æ”¾å€¼çš„é€‰æ‹©å™¨ã€‚",
      "tips": ""
    },
    "The changes youâ€™ll make in the next few steps improve the layout for the larger display of a Mac.": {
      "zh": "åœ¨æ¥ä¸‹æ¥çš„å‡ ä¸ªæ­¥éª¤ä¸­ï¼Œä½ å°†è¿›è¡Œçš„æ›´æ”¹å°†ä¼šé’ˆå¯¹ Mac ä¼˜åŒ–ï¼Œåœ¨æ›´å¤§æ˜¾ç¤ºå±ä¸Šå±•ç¤ºç•Œé¢å¸ƒå±€ã€‚",
      "tips": ""
    },
    "Run the macOS app and try out the new menu item.": {
      "zh": "è¿è¡Œ macOS åº”ç”¨ç¨‹åºå¹¶å°è¯•æ–°çš„èœå•é¡¹ã€‚",
      "tips": ""
    },
    "Youâ€™ll define content for the menu next.": {
      "zh": "æ¥ä¸‹æ¥ä½ å°†å®šä¹‰èœå•çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "Adding the second child view automatically converts the list to use the sidebar list style.": {
      "zh": "ç»™ NavigationView æ·»åŠ ç¬¬äºŒä¸ªå­è§†å›¾ä¼šè‡ªåŠ¨å°†åˆ—è¡¨è½¬æ¢ä¸ºä¾§è¾¹æ åˆ—è¡¨æ ·å¼ã€‚",
      "tips": ""
    },
    "Like a View structure, a Commands structure requires a computed body property that uses builder semantics, except with commands instead of views.": {
      "zh": "åƒ View ç»“æ„ä¸€æ ·ï¼ŒCommands ç»“æ„ä¹Ÿéœ€è¦ä¸€ä¸ªä½¿ç”¨æ„å»ºå™¨è¯­ä¹‰çš„è®¡ç®— body å±æ€§ï¼Œåªæ˜¯å®ƒä½¿ç”¨çš„æ˜¯ commands è€Œä¸æ˜¯ viewsã€‚",
      "tips": ""
    },
    "This improves the preview, but also ensures that the list never becomes too small as the user resizes the macOS window.": {
      "zh": "è¿™æ”¹è¿›äº†é¢„è§ˆæ•ˆæœï¼Œä¹Ÿä¿è¯äº†åˆ—è¡¨åœ¨ç”¨æˆ·è°ƒæ•´ macOS çª—å£å¤§å°æ—¶æ°¸è¿œä¸ä¼šå˜å¾—å¤ªå°ã€‚",
      "tips": ""
    },
    "Use a storage key that uniquely identifies the parameter like you would when storing items in UserDefaults, because thatâ€™s the underlying mechanism that SwiftUI relies on.": {
      "zh": "åœ¨å­˜å‚¨é”®ä¸­ä½¿ç”¨ä¸€ä¸ªå”¯ä¸€æ ‡è¯†å‚æ•°çš„å€¼ï¼Œå°±åƒåœ¨ UserDefaults ä¸­å­˜å‚¨é¡¹ç›®ä¸€æ ·ï¼Œå› ä¸ºè¿™æ˜¯ SwiftUI ä¾èµ–çš„åº•å±‚æœºåˆ¶ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "æ­¥éª¤ 6",
      "tips": ""
    },
    "Wrap the landmark name in a VStack and add the park as secondary information.": {
      "zh": "å°†åœ°æ ‡åç§°åŒ…è£…åœ¨ VStack ä¸­ï¼Œå¹¶å°†å…¬å›­æ·»åŠ ä¸ºæ¬¡è¦ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "To ensure that SwiftUI refreshes the map whenever delta changes, youâ€™ll have to alter the way you calculate and apply the region.": {
      "zh": "ä¸ºç¡®ä¿åœ¨ delta æ›´æ”¹æ—¶ SwiftUI åˆ·æ–°åœ°å›¾ï¼Œæ‚¨éœ€è¦æ›´æ”¹è®¡ç®—å’Œåº”ç”¨ region çš„æ–¹å¼ã€‚",
      "tips": ""
    },
    "In the Project navigator, delete the MacLandmarksApp.swift file from the MacLandmarks group. When asked, choose Move to Trash.": {
      "zh": "åœ¨é¡¹ç›®å¯¼èˆªå™¨ä¸­ï¼Œä» MacLandmarks ç»„ä¸­åˆ é™¤ MacLandmarksApp.swift æ–‡ä»¶ã€‚ å½“ç³»ç»Ÿè¯¢é—®æ—¶ï¼Œé€‰æ‹©ç§»è‡³åºŸçº¸ç¯“ã€‚",
      "tips": ""
    },
    "Run the app and try setting the preferences.": {
      "zh": "è¿è¡Œåº”ç”¨ç¨‹åºå¹¶å°è¯•è®¾ç½®åå¥½ã€‚",
      "tips": ""
    },
    "The preview fails because the navigationBarTitleDisplayMode(_:) method isnâ€™t available in macOS.": {
      "zh": "é¢„è§ˆå¤±è´¥æ˜¯å› ä¸º navigationBarTitleDisplayMode(_:) æ–¹æ³•åœ¨ macOS ä¸­ä¸å¯ç”¨ã€‚",
      "tips": ""
    },
    "Run the macOS target and see how the menu operates.": {
      "zh": "è¿è¡Œ macOS ç›®æ ‡å¹¶æŸ¥çœ‹èœå•çš„è¿è¡Œæ–¹å¼ã€‚",
      "tips": ""
    },
    "You wonâ€™t be able to see the toolbar updates until you run the app.": {
      "zh": "åœ¨è¿è¡Œè¯¥åº”ç”¨ç¨‹åºä¹‹å‰ï¼Œå°†çœ‹ä¸åˆ°å·¥å…·æ çš„æ›´æ–°ã€‚",
      "tips": ""
    },
    "You now have three files called LandmarkDetail.swift. Each serves the same purpose in the view hierarchy, but provides an experience tailored to a particular platform.": {
      "zh": "ç°åœ¨æ‚¨æœ‰ä¸‰ä¸ªåä¸º LandmarkDetail.swift çš„æ–‡ä»¶ã€‚å®ƒä»¬åœ¨è§†å›¾å±‚æ¬¡ç»“æ„ä¸­å…·æœ‰ç›¸åŒçš„ä½œç”¨ï¼Œä½†ä»–ä»¬é’ˆå¯¹ç‰¹å®šå¹³å°æä¾›äº†å®šåˆ¶çš„ä½“éªŒã€‚",
      "tips": ""
    },
    "Create a new SwiftUI view called LandmarkSettings that targets only the macOS app.": {
      "zh": "åˆ›é€ ä¸€ä¸ªåä¸º LandmarkSettings çš„æ–° SwiftUI è§†å›¾ï¼Œå®ƒä»…é’ˆå¯¹ macOS å¹³å°ã€‚",
      "tips": ""
    },
    "To make use of commands in an app, you have to apply them to a scene, which youâ€™ll do next.": {
      "zh": "è¦åœ¨åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨å‘½ä»¤ï¼Œä½ éœ€è¦å°†å®ƒä»¬åº”ç”¨äºä¸€ä¸ªåœºæ™¯ï¼Œæ¥ä¸‹æ¥ä½ å°†æ‰§è¡Œè¿™ä¸ªæ“ä½œã€‚",
      "tips": ""
    },
    "Choose the WatchLandmarks target to see a watchOS preview of the list.": {
      "zh": "é€‰æ‹© WatchLandmarks ç›®æ ‡æ¥æŸ¥çœ‹åˆ—è¡¨çš„ watchOS é¢„è§ˆã€‚",
      "tips": ""
    },
    "Move the favorites Toggle into the menu.": {
      "zh": "å°†æ”¶è—åˆ‡æ¢å¼€å…³ç§»åŠ¨åˆ°èœå•ä¸­ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "æ­¥éª¤ 8",
      "tips": ""
    },
    "Replace the region state variable, the setRegion method, and the mapâ€™s onAppear modifier with a computed region property that you pass to the Map initializer as a constant binding.": {
      "zh": "å°† region çŠ¶æ€å˜é‡ã€ setRegion æ–¹æ³•å’Œåœ°å›¾çš„ onAppear ä¿®é¥°ç¬¦æ›¿æ¢ä¸ºè®¡ç®—å¾—å‡ºçš„ region å±æ€§ï¼Œå°†å…¶ä½œä¸ºå¸¸é‡ä¼ é€’ç»™ Map è¿›è¡Œåˆå§‹åŒ–ã€‚",
      "tips": ""
    },
    "Add a FilterCategory enumeration to describe filter states.": {
      "zh": "æ·»åŠ  FilterCategory æšä¸¾æ¥æè¿°è¿‡æ»¤å™¨çŠ¶æ€ã€‚",
      "tips": ""
    },
    "Add an â€œOpen in Mapsâ€ button in a ZStack so that it appears on top of the map in the upper-right corner.": {
      "zh": "åœ¨ ZStack ä¸­æ·»åŠ â€œåœ¨åœ°å›¾ä¸­æ‰“å¼€ï¼ˆOpen in Mapsï¼‰â€æŒ‰é’®ï¼Œä½¿å®ƒæ˜¾ç¤ºåœ¨åœ°å›¾çš„å³ä¸Šè§’ã€‚",
      "tips": ""
    },
    "The detail view displays information about the selected landmark. You created a view like this for the iOS app, but different platforms require different approaches to data presentation.": {
      "zh": "è¯¦ç»†è§†å›¾æ˜¾ç¤ºæœ‰å…³æ‰€é€‰åœ°æ ‡çš„ä¿¡æ¯ã€‚ åœ¨ iOS åº”ç”¨ç¨‹åºä¸­ä½ å·²ç»åˆ›å»ºäº†ä¸€ä¸ªè¿™æ ·çš„è§†å›¾ï¼Œä½†ä¸åŒçš„å¹³å°éœ€è¦ä¸åŒçš„æ•°æ®å‘ˆç°æ–¹æ³•ã€‚",
      "tips": ""
    },
    "The pattern for defining focused values resembles the pattern for defining new Environment values: Use a private key to read and write a custom property on the system-defined FocusedValues structure.": {
      "zh": "å®šä¹‰ focused å€¼çš„æ¨¡å¼ç±»ä¼¼äºå®šä¹‰æ–°çš„ Environment å€¼çš„æ¨¡å¼ï¼šä½¿ç”¨ç§æœ‰é”®åœ¨ç³»ç»Ÿå®šä¹‰çš„ FocusedValues ç»“æ„ä¸Šè¯»å–å’Œå†™å…¥è‡ªå®šä¹‰å±æ€§ã€‚",
      "tips": ""
    },
    "Add a @FocusedBinding property wrapper to track the currently selected landmark.": {
      "zh": "æ·»åŠ  @FocusedBinding å±æ€§åŒ…è£…å™¨æ¥è·Ÿè¸ªå½“å‰é€‰å®šçš„åœ°æ ‡ã€‚",
      "tips": ""
    },
    "Create a new custom view in the MacLandmarks group targeting macOS called LandmarkDetail.": {
      "zh": "åœ¨é’ˆå¯¹ macOS å¹³å°çš„ MacLandmarks æ–‡ä»¶å¤¹ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªåä¸º LandmarkDetail çš„æ–°çš„è‡ªå®šä¹‰è§†å›¾ã€‚",
      "tips": ""
    },
    "Add a new SwiftUI view to the WatchLandmarks Extension folder called LandmarkList.swift that targets only WatchLandmarks Extension, and remove the older fileâ€™s WatchLandmarks Extension target membership.": {
      "zh": "åœ¨ WatchLandmarks Extension æ–‡ä»¶å¤¹ä¸­æ·»åŠ ä¸€ä¸ªä»…é’ˆå¯¹ WatchLandmarks Extension çš„æ–° SwiftUI è§†å›¾ï¼Œå‘½åä¸º LandmarkList.swiftï¼Œå¹¶ç§»é™¤æ—§æ–‡ä»¶çš„ WatchLandmarks Extension ç›®æ ‡å¼•ç”¨ã€‚",
      "tips": ""
    },
    "You typically use a Form to arrange controls in your settings view.": {
      "zh": "ä½ ä¸€èˆ¬å¯ä»¥ä½¿ç”¨ Form åœ¨è®¾ç½®è§†å›¾ä¸­æ’åˆ—æ§ä»¶ã€‚",
      "tips": ""
    },
    "Next, youâ€™ll create a Settings scene that controls the stored zoom value.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œæ‚¨å°†åˆ›å»ºä¸€ä¸ª Settings åœºæ™¯ï¼Œç”¨äºæ§åˆ¶å­˜å‚¨çš„ç¼©æ”¾å€¼ã€‚",
      "tips": ""
    },
    "Update the navigation title to match the state of the filter.": {
      "zh": "æ›´æ–°å¯¼èˆªæ ‡é¢˜æ¥åŒ¹é…è¿‡æ»¤å™¨çš„çŠ¶æ€ã€‚",
      "tips": ""
    },
    "Creating a macOS App": {
      "zh": "",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ 1 èŠ‚",
      "tips": ""
    },
    "Add the focusedValue(_:_:) modifier to the NavigationView, providing a binding the value from the landmarks array.": {
      "zh": "å°† focusedValue(_:_:) ä¿®é¥°ç¬¦æ·»åŠ åˆ° NavigationViewï¼Œä¼ å…¥åœ°æ ‡æ•°ç»„å€¼è¿›è¡Œç»‘å®šã€‚",
      "tips": ""
    },
    "Continue Command-clicking to select all the items in the Model and Resources folders, as well as Asset.xcassets.": {
      "zh": "ç»§ç»­æŒ‰ä½ Command å•å‡»é€‰æ‹© Model å’Œ Resources æ–‡ä»¶å¤¹ä¸­çš„æ‰€æœ‰é¡¹ç›®ï¼Œä»¥åŠ Asset.xcassetsã€‚",
      "tips": ""
    },
    "Add a button to the menu that toggles the selected landmarkâ€™s favorite status, and that has an appearance that changes depending on the currently selected landmark and its state.": {
      "zh": "åœ¨èœå•ä¸­æ·»åŠ ä¸€ä¸ªæŒ‰é’®ï¼Œç”¨äºåˆ‡æ¢æ‰€é€‰åœ°æ ‡çš„æ”¶è—çŠ¶æ€ï¼Œå¹¶ä¸”å®ƒçš„å¤–è§‚ä¼šæ ¹æ®å½“å‰æ‰€é€‰åœ°æ ‡åŠå…¶å½“å‰çš„æ”¶è—çŠ¶æ€è€Œå˜åŒ–ã€‚",
      "tips": ""
    },
    "Copy the iOS detail view contents into the macOS detail view.": {
      "zh": "å°† iOS è¯¦æƒ…è§†å›¾çš„å†…å®¹å¤åˆ¶åˆ° macOS çš„è¯¦æƒ…è§†å›¾ä¸­ã€‚",
      "tips": ""
    },
    "Change the HStack holding the park and state to a VStack with leading alignment, and remove the Spacer.": {
      "zh": "å°†åŒ…å«å…¬å›­å’Œå·ä¿¡æ¯çš„ HStack æ›´æ”¹ä¸ºå¯¹é½æ–¹å¼ä¸º leading çš„ VStackï¼Œå¹¶ç§»é™¤ Spacerã€‚",
      "tips": ""
    },
    "When you let go of the mouse button, the list disappears with no way to get it back. Youâ€™ll add a command to fix this.": {
      "zh": "å½“ä½ æ¾å¼€é¼ æ ‡æŒ‰é’®æ—¶ï¼Œè¯¥åˆ—è¡¨å°†ä¼šæ¶ˆå¤±ä¸”æ— æ³•æ¢å¤ã€‚ ä½ å°†æ·»åŠ ä¸€ä¸ªå‘½ä»¤æ¥ä¿®å¤æ­¤é—®é¢˜ã€‚",
      "tips": ""
    },
    "Delete the navigationBarTitleDisplayMode(_:) modifier and add a frame modifier to the preview so you can see more of the content.": {
      "zh": "åˆ é™¤ navigationBarTitleDisplayMode(_:) ä¿®é¥°ç¬¦å¹¶ä¸ºé¢„è§ˆè®¾ç½®ä¸€ä¸ªè§†å›¾å¤§å°ï¼Œæ–¹ä¾¿ä½ å¯ä»¥çœ‹åˆ°æ›´å¤šå†…å®¹ã€‚",
      "tips": ""
    },
    "This built-in command set includes the command for toggling the sidebar.": {
      "zh": "è¿™ä¸ªå†…ç½®çš„å‘½ä»¤é›†åŒ…æ‹¬ç”¨äºåˆ‡æ¢ä¾§è¾¹æ çš„å‘½ä»¤ã€‚",
      "tips": ""
    },
    "Add a keyboard shortcut for the menu item with the keyboardShortcut(_:modifiers:) modifier.": {
      "zh": "ä½¿ç”¨ keyboardShortcut(_:modifiers:) ä¿®é¥°ç¬¦ä¸ºèœå•ä¸­çš„é€‰é¡¹æ·»åŠ é”®ç›˜å¿«æ·é”®ã€‚",
      "tips": ""
    },
    "SwiftUI automatically shows the keyboard shortcut in the menu.": {
      "zh": "SwiftUI ä¼šè‡ªåŠ¨åœ¨èœå•ä¸­æ˜¾ç¤ºé”®ç›˜å¿«æ·é”®ã€‚",
      "tips": ""
    },
    "Constrain the ScrollView to a maximum width.": {
      "zh": "å°† ScrollView çš„æœ€å¤§å®½åº¦åŠ ä»¥é™åˆ¶ã€‚",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Like LandmarkRow, LandmarkList already works on macOS, but could use improvements. For example, youâ€™ll move the toggle for showing only favorites to a menu in the toolbar, where it can be joined by additional filtering controls.": {
      "zh": "ä¸ LandmarkRow ä¸€æ ·ï¼ŒLandmarkList å·²ç»å¯ä»¥åœ¨ macOS ä¸Šè¿è¡Œï¼Œä½†å¯ä»¥è¿›è¡Œæ”¹è¿›ã€‚ ä¾‹å¦‚ï¼Œä½ å¯ä»¥å°†ä»…æ˜¾ç¤ºæ”¶è—å¤¹çš„å¼€å…³ç§»åŠ¨åˆ°å·¥å…·æ ä¸­çš„èœå•ï¼Œå¯ä»¥åœ¨é‚£é‡ŒåŠ å…¥å…¶ä»–è¿‡æ»¤æ§ä»¶ã€‚",
      "tips": ""
    },
    "This template adds a new macOS app target to the project.": {
      "zh": "æ­¤æ¨¡æ¿å°†æ–°çš„ macOS åº”ç”¨ç¨‹åºç›®æ ‡æ·»åŠ åˆ°é¡¹ç›®ä¸­ã€‚",
      "tips": ""
    },
    "This moves the toggle into the toolbar in a platform-specific way, which has the additional benefit of making it accessible no matter how long the list of landmarks gets, or how far down the user scrolls.": {
      "zh": "è¿™æ ·ä»¥ä¸€ç§å¹³å°ç‰¹å®šçš„æ–¹å¼å°†åˆ‡æ¢æŒ‰é’®ç§»åŠ¨åˆ°å·¥å…·æ ä¸­ï¼Œå¸¦æ¥äº†é¢å¤–çš„å¥½å¤„ï¼Œå³æ— è®ºåœ°æ ‡åˆ—è¡¨æœ‰å¤šé•¿ï¼Œæˆ–è€…ç”¨æˆ·å‘ä¸‹æ»šåŠ¨äº†å¤šè¿œï¼Œéƒ½èƒ½è½»æ¾è®¿é—®å®ƒã€‚",
      "tips": ""
    },
    "The shared LandmarkRow view works in macOS, but itâ€™s worth revisiting to look for improvements given the new visual environment. Because this view is used by all three platforms, you need to be careful that any changes you make work across all of them.": {
      "zh": "å…±äº«çš„ LandmarkRow è§†å›¾åœ¨ macOS ä¸Šå¯ä»¥æ­£å¸¸å·¥ä½œï¼Œä½†è€ƒè™‘åˆ°æ–°çš„è§†è§‰åœºæ™¯ï¼Œæœ‰å¿…è¦é‡æ–°å®¡è§†å®ƒå¯»æ‰¾å€¼å¾—æ”¹è¿›çš„åœ°æ–¹ã€‚ç”±äºè¿™ä¸ªè§†å›¾è¢«ä¸‰ä¸ªå¹³å°éƒ½ä½¿ç”¨åˆ°ï¼Œä½ éœ€è¦ç¡®ä¿æ‰€åšçš„ä»»ä½•æ›´æ”¹éƒ½èƒ½åœ¨æ‰€æœ‰å¹³å°ä¸Šæ­£å¸¸å·¥ä½œã€‚",
      "tips": ""
    },
    "The watchOS app builds again.": {
      "zh": "å†æ¬¡æ„å»º watchOS åº”ç”¨ç¨‹åºã€‚",
      "tips": ""
    },
    "Notice that the map refreshes whenever you change the zoom level.": {
      "zh": "è¯·æ³¨æ„ï¼Œåªè¦æ›´æ”¹ç¼©æ”¾çº§åˆ«ï¼Œåœ°å›¾å°±ä¼šé‡æ–°åˆ·æ–°ã€‚",
      "tips": ""
    },
    "Go back to LandmarkRow and add an #if condition to prevent the secondary text from appearing in a watchOS build.": {
      "zh": "å›åˆ° LandmarkRow ï¼Œæ·»åŠ  #if æ¡ä»¶æ¥é˜²æ­¢äºŒçº§æ–‡æœ¬å‡ºç°åœ¨ watchOS æ„å»ºä¸­ã€‚",
      "tips": ""
    },
    "Open LandmarkList.swift and add a minimum width.": {
      "zh": "æ‰“å¼€ LandmarkList.swift å¹¶æ·»åŠ æœ€å°å®½åº¦ã€‚",
      "tips": ""
    },
    "Add a condition around the commands modifier to omit it for the watchOS app.": {
      "zh": "åœ¨ commands ä¿®é¥°ç¬¦å‘¨å›´æ·»åŠ æ¡ä»¶ï¼Œä»¥æ’é™¤ watchOS åº”ç”¨ç¨‹åºã€‚",
      "tips": ""
    },
    "Youâ€™re reading the value here. Youâ€™ll set it later in the list view, where the user makes the selection.": {
      "zh": "ä½ åœ¨æ­¤å¤„è¯»å–è¯¥å€¼ã€‚ç¨åä½ å°†åœ¨åˆ—è¡¨è§†å›¾ä¸­è®¾ç½®å®ƒï¼Œç”¨æˆ·åœ¨é‚£é‡Œè¿›è¡Œé€‰æ‹©ã€‚",
      "tips": ""
    },
    "You also target iOS because the shared LandmarkList will eventually depend on some of the types you define in this file.": {
      "zh": "ä½ è¿˜éœ€è¦é’ˆå¯¹ iOSï¼Œå› ä¸ºå…±äº«çš„ LandmarkList æœ€ç»ˆå°†ä¾èµ–äºä½ åœ¨æ­¤æ–‡ä»¶ä¸­å®šä¹‰çš„ä¸€äº›ç±»å‹ã€‚",
      "tips": ""
    },
    "When you create an app using the SwiftUI life cycle, the system automatically creates a menu with commonly needed items, like those for closing the front-most window or for quitting the app. SwiftUI lets you add other common commands with built-in behavior, as well as completely custom commands.": {
      "zh": "å½“ä½ ä½¿ç”¨ SwiftUI ç”Ÿå‘½å‘¨æœŸåˆ›å»ºåº”ç”¨ç¨‹åºæ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åˆ›å»ºä¸€ä¸ªåŒ…å«å¸¸ç”¨é€‰é¡¹çš„èœå•ï¼Œæ¯”å¦‚ç”¨äºå…³é—­æœ€å‰é¢çš„çª—å£æˆ–é€€å‡ºåº”ç”¨ç¨‹åºã€‚SwiftUI è¿˜å…è®¸æ‚¨æ·»åŠ å…·æœ‰å†…ç½®è¡Œä¸ºçš„å…¶ä»–å¸¸ç”¨å‘½ä»¤ï¼Œä»¥åŠå®Œå…¨è‡ªå®šä¹‰çš„å‘½ä»¤ã€‚",
      "tips": ""
    },
    "SwiftUI provides both a default main view and its preview provider, just like for an iOS app, enabling you to preview the appâ€™s main window.": {
      "zh": "SwiftUI æä¾›é»˜è®¤ä¸»è§†å›¾åŠå…¶é¢„è§ˆæä¾›ç±»ï¼Œå°±åƒ iOS åº”ç”¨ç¨‹åºä¸€æ ·ï¼Œä½¿ä½ èƒ½å¤Ÿç›´æ¥é¢„è§ˆåº”ç”¨ç¨‹åºçš„ä¸»çª—å£ã€‚",
      "tips": ""
    },
    "The first of these is the shared app definition. The others are views that will work on macOS.": {
      "zh": "å…¶ä¸­ç¬¬ä¸€ä¸ªæ˜¯åº”ç”¨ç¨‹åºçš„å…±äº«å…¥å£ã€‚ å…¶ä»–çš„æ˜¯ä¹Ÿèƒ½å¤Ÿé€‚ç”¨äº macOS çš„è§†å›¾æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "Add a new Swift file called LandmarkCommands.swift and set its targets to include both macOS and iOS.": {
      "zh": "æ·»åŠ ä¸€ä¸ªåä¸º LandmarkCommands.swift çš„ Swift æ–‡ä»¶ï¼Œå¹¶å°†å…¶ç›®æ ‡è®¾ç½®ä¸ºåŒ…æ‹¬ macOS å’Œ iOSã€‚",
      "tips": ""
    },
    "Using the plain style here makes the button look more like the iOS equivalent.": {
      "zh": "åœ¨è¿™é‡Œä½¿ç”¨ plain æ ·å¼ä¼šè®©æŒ‰é’®çœ‹èµ·æ¥æ›´åƒæ˜¯ iOS ä¸Šçš„æŒ‰é’®ã€‚",
      "tips": ""
    },
    "Add a new CommandMenu to your commands called Landmarks.": {
      "zh": "å°†ä¸€ä¸ªåä¸º Landmarks æ–°çš„ CommandMenu æ·»åŠ åˆ°ä½ çš„å‘½ä»¤é€‰é¡¹ä¸­ ã€‚",
      "tips": ""
    },
    "You perform a look-up here to ensure that you are modifying the landmark stored in the model, and not a copy.": {
      "zh": "åœ¨è¿™é‡Œè¿›è¡ŒæŸ¥æ‰¾ä»¥ç¡®ä¿ä½ ä¿®æ”¹çš„æ˜¯å­˜å‚¨åœ¨æ¨¡å‹ä¸­çš„åœ°æ ‡ï¼Œè€Œä¸æ˜¯å…¶å‰¯æœ¬ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "æ­¥éª¤ 3",
      "tips": ""
    },
    "The preview no longer builds because the LandmarkList uses LandmarkDetail, but you havenâ€™t defined a detail view for the macOS app yet. Youâ€™ll take care of that in the next section.": {
      "zh": "é¢„è§ˆä¸å†ç”Ÿæˆï¼Œå› ä¸º LandmarkList ä½¿ç”¨åˆ°äº† LandmarkDetailï¼Œä½†ä½ è¿˜æ²¡æœ‰ä¸º macOS åº”ç”¨ç¨‹åºå®šä¹‰ LandmarkDetailã€‚ ä½ å°†åœ¨ä¸‹ä¸€èŠ‚ä¸­è§£å†³è¿™ä¸ªé—®é¢˜ã€‚",
      "tips": ""
    },
    "The MapView remains blank unless you start the live preview.": {
      "zh": "é™¤éä½ å¼€å§‹å®æ—¶é¢„è§ˆæ¨¡å¼ï¼Œå¦åˆ™ MapView å°†ä¿æŒç©ºç™½ã€‚",
      "tips": ""
    },
    "Update the List View": {
      "zh": "æ›´æ–°åˆ—è¡¨è§†å›¾",
      "tips": ""
    },
    "The changes youâ€™ll make will work for both macOS and iOS, but will be difficult to accommodate on watchOS. Fortunately, in the previous section you already split the list into a separate file for watchOS.": {
      "zh": "ä½ æ‰€åšçš„æ›´æ”¹èƒ½å¤Ÿé€‚ç”¨äº macOS å’Œ iOSï¼Œä½†å¾ˆéš¾é€‚åº” watchOSã€‚ å¹¸è¿çš„æ˜¯ï¼Œåœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œä½ å·²ç»å°†åˆ—è¡¨æ‹†åˆ†æˆäº†ä¸€ä¸ªé’ˆå¯¹ watchOS çš„ç‹¬ç«‹æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬ 2 èŠ‚",
      "tips": ""
    },
    "This improves readability when the user makes the window very wide.": {
      "zh": "å½“è§†å›¾çª—å£éå¸¸å®½çš„æ—¶å€™ï¼Œè¿™æ ·å¯ä»¥æé«˜å¯è¯»æ€§ã€‚",
      "tips": ""
    },
    "Add an @AppStorage property called zoom that takes on the medium zoom level by default.": {
      "zh": "æ·»åŠ ä¸€ä¸ªåä¸º zoom çš„ @AppStorage å±æ€§ï¼Œé»˜è®¤æƒ…å†µä¸‹é‡‡ç”¨ medium ç¼©æ”¾çº§åˆ«ã€‚",
      "tips": ""
    },
    "Return to the MacLandmarks scheme, and in the LandmarkList file that targets iOS and macOS, add a ToolbarItem containing a Menu inside a new toolbar modifier.": {
      "zh": "å›åˆ°åˆ° MacLandmarks schemeï¼Œåœ¨é’ˆå¯¹ iOS å’Œ macOS çš„ LandmarkList æ–‡ä»¶ä¸­ï¼Œåœ¨æ–°çš„ toolbar ä¿®é¥°ç¬¦ä¸­æ·»åŠ ä¸€ä¸ªåŒ…å«èœå•çš„ ToolbarItemã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "æ­¥éª¤ 10",
      "tips": ""
    },
    "Finally, consider how your changes work for iOS.": {
      "zh": "æœ€åï¼Œè€ƒè™‘ä½ çš„æ›´æ”¹æ˜¯å¦å¯ä»¥é€‚ç”¨äº iOSã€‚",
      "tips": ""
    },
    "Section 4": {
      "zh": "ç¬¬ 4 èŠ‚",
      "tips": ""
    },
    "Add a resizable() modifier to the image, and constrain the CircleImage to be a bit smaller.": {
      "zh": "ä¸ºå›¾åƒæ·»åŠ ä¸€ä¸ª resizable() ä¿®é¥°ç¬¦ï¼Œå¹¶å°† CircleImage å¤§å°è®¾ç½®çš„å°ä¸€ç‚¹ã€‚",
      "tips": ""
    },
    "In the previous section, you added a built-in menu command set. In this section, youâ€™ll add a custom command for toggling the favorite status of the currently selected landmark. To know which landmark is currently selected, youâ€™ll use a focused binding.": {
      "zh": "åœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œä½ æ·»åŠ äº†ä¸€ä¸ªå†…ç½®èœå•å‘½ä»¤é›†ã€‚ åœ¨æœ¬èŠ‚ä¸­ï¼Œä½ å°†æ·»åŠ ä¸€ä¸ªè‡ªå®šä¹‰å‘½ä»¤æ¥åˆ‡æ¢å½“å‰æ‰€é€‰åœ°æ ‡çš„æ”¶è—çŠ¶æ€ã€‚ è¦çŸ¥é“å½“å‰é€‰æ‹©äº†å“ªä¸ªåœ°æ ‡ï¼Œä½ å°†ä½¿ç”¨ç„¦ç‚¹ç»‘å®šï¼ˆfocused bindingï¼‰ã€‚",
      "tips": ""
    },
    "Add vertical padding around the contents of the row to give each row a little more breathing room.": {
      "zh": "åœ¨è¡Œå†…å®¹å‘¨å›´æ·»åŠ å‚ç›´å¡«å……ï¼Œä¸ºæ¯è¡Œæä¾›æ›´å¤šçš„ç©ºé—´ï¼Œè®©å®ƒä»¬çœ‹èµ·æ¥æ›´åŠ èˆ’é€‚ã€‚",
      "tips": ""
    },
    "Start by adding a macOS target to the project. Xcode adds a new group and set of starter files for the macOS app, along with the scheme needed to build and run the app. Youâ€™ll then add some existing files to the new target.": {
      "zh": "é¦–å…ˆå‘é¡¹ç›®æ·»åŠ ä¸€ä¸ª macOS ç›®æ ‡ã€‚ Xcode ä¸º macOS åº”ç”¨ç¨‹åºæ·»åŠ äº†ä¸€ä¸ªæ–°çš„æ–‡ä»¶å¤¹ä»¥åŠé…ç½®å¥½äº†å¯åŠ¨æ–‡ä»¶ï¼Œè¿˜æœ‰ç¼–è¯‘å’Œè¿è¡Œè¯¥åº”ç”¨ç¨‹åºæ‰€éœ€çš„æ–¹æ¡ˆã€‚ ç„¶åï¼Œä½ å°†å‘æ–°ç›®æ ‡æ·»åŠ ä¸€äº›ç°æœ‰æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "In LandmarksApp.swift, add the Settings scene to your app, but only for macOS.": {
      "zh": "åœ¨ LandmarksApp.swift ä¸­ï¼Œå°† Settings åœºæ™¯æ·»åŠ åˆ°ä½ çš„åº”ç”¨ç¨‹åºä¸­ï¼Œä½†ä»…é€‚ç”¨äº macOSã€‚",
      "tips": ""
    },
    "In LandmarkCommands, extend the FocusedValues structure with a selectedLandmark value, using a custom key called SelectedLandmarkKey.": {
      "zh": "åœ¨ LandmarkCommands ä¸­ï¼Œä½¿ç”¨åä¸º SelectedLandmarkKey çš„è‡ªå®šä¹‰é”®ï¼Œä½¿ç”¨ selectedLandmark å€¼æ‰©å±• FocusedValues ç»“æ„ã€‚",
      "tips": ""
    },
    "In the Project navigator, Command-click to select the following files: LandmarksApp.swift, LandmarkList.swift, LandmarkRow.swift, CircleImage.swift, MapView.swift, and FavoriteButton.swift.": {
      "zh": "åœ¨é¡¹ç›®å¯¼èˆªæ ä¸­ï¼ŒæŒ‰ä½ Command å•å‡»æ¥é€‰æ‹©ä»¥ä¸‹æ–‡ä»¶ï¼šLandmarksApp.swiftã€LandmarkList.swiftã€LandmarkRow.swiftã€CircleImage.swiftã€MapView.swift å’Œ FavoriteButton.swiftã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "æ­¥éª¤ 7",
      "tips": ""
    },
    "Step 5": {
      "zh": "æ­¥éª¤ 5",
      "tips": ""
    },
    "The changes work well for iOS, so thereâ€™s no need to make any updates for that platform.": {
      "zh": "è¿™äº›æ›´æ”¹é€‚ç”¨äº iOSï¼Œå› æ­¤æ— éœ€é’ˆå¯¹è¯¥å¹³å°è¿›è¡Œä»»ä½•æ›´æ–°ã€‚",
      "tips": ""
    },
    "In the MacLandmarks group, select ContentView.swift, open the Canvas, and click Resume to see the preview.": {
      "zh": "åœ¨ MacLandmarks æ–‡ä»¶å¤¹ä¸­ï¼Œé€‰æ‹© ContentView.swiftï¼Œæ‰“å¼€ Canvasï¼Œç„¶åå•å‡» Resume æŸ¥çœ‹é¢„è§ˆã€‚",
      "tips": ""
    },
    "Add an @AppStorage property that uses the same key as you used in the map view.": {
      "zh": "æ·»åŠ ä¸€ä¸ª @AppStorage å±æ€§ï¼Œè¯¥å±æ€§å’Œä½ åœ¨åœ°å›¾è§†å›¾ä¸­ä½¿ç”¨çš„é”®ç›¸åŒã€‚",
      "tips": ""
    },
    "The minimum row width isnâ€™t appropriate here. Because of this and other changes youâ€™ll make to the list in the next section, the best solution is to create a watch-specific list that omits the width constraint.": {
      "zh": "æœ€å°è¡Œå®½åœ¨è¿™é‡Œæ˜¯ä¸åˆé€‚çš„ã€‚ ç”±äºåœ¨æ¥ä¸‹æ¥çš„éƒ¨åˆ†ä¸­è¿˜éœ€è¦è¿›è¡Œå…¶ä»–æ›´æ”¹ï¼Œæ‰€ä»¥æœ€å¥½çš„è§£å†³æ–¹æ¡ˆæ˜¯åˆ›å»ºä¸€ä¸ªç‰¹å®šäº watch çš„åˆ—è¡¨ï¼Œçœç•¥å®½åº¦ä¸Šçš„çº¦æŸã€‚",
      "tips": ""
    },
    "Update the Row View": {
      "zh": "æ›´æ–°è¡Œè§†å›¾",
      "tips": ""
    },
    "Import SwiftUI and add a LandmarkCommands structure that conforms to the Commands protocol, with a computed body property.": {
      "zh": "å¯¼å…¥ SwiftUI æ¡†æ¶å¹¶æ·»åŠ ä¸€ä¸ªç¬¦åˆ Commands åè®®çš„ LandmarkCommands ç»“æ„ä½“ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªè®¡ç®—å±æ€§ bodyã€‚",
      "tips": ""
    },
    "Open LandmarkRow.swift and add a corner radius to the image for a more refined look.": {
      "zh": "æ‰“å¼€ LandmarkRow.swift å¹¶ä¸ºå›¾åƒæ·»åŠ åœ†è§’åŠå¾„è®©å®ƒçš„å¤–è§‚æ›´åŠ ç²¾è‡´ã€‚",
      "tips": ""
    },
    "Choose the Landmarks build target to see what the list looks like for iOS.": {
      "zh": "é€‰æ‹© Landmarks ç¼–è¯‘ç›®æ ‡æ¥æŸ¥çœ‹ iOS åˆ—è¡¨çš„ç•Œé¢ã€‚",
      "tips": ""
    },
    "For the row, using conditional compilation is appropriate because the differences are small.": {
      "zh": "å¯¹äºè¡Œè§†å›¾æ¥è¯´å¯ä»¥ä½¿ç”¨æ¡ä»¶åˆ¤æ–­æ˜¯å¦éœ€è¦ç¼–è¯‘ï¼Œå› ä¸ºå·®å¼‚å¾ˆå°ã€‚",
      "tips": ""
    },
    "Choose File > New > Target. When the template sheet appears, choose the macOS tab, select the App template, and click Next.": {
      "zh": "é€‰æ‹© File > New > Targetã€‚ å‡ºç°æ¨¡æ¿é€‰æ‹©åˆ—è¡¨æ—¶ï¼Œé€‰æ‹© macOS é€‰é¡¹ï¼Œé€‰æ‹© App æ¨¡ç‰ˆï¼Œç„¶åå•å‡»ä¸‹ä¸€æ­¥ã€‚",
      "tips": ""
    },
    "The tag associates a particular landmark with the given item in the ForEach, which then drives the selection.": {
      "zh": "è¯¥æ ‡ç­¾å°†ç‰¹å®šåœ°æ ‡ä¸ ForEach ä¸­çš„ç»™å®šé¡¹ç›®ç›¸å…³è”ï¼Œæ ‡è¯†åœ°æ ‡æ˜¯å¦é€‰ä¸­ã€‚",
      "tips": ""
    },
    "The menu now contains your new command, but you need to set the selectedLandmark focused binding for it to work.": {
      "zh": "èœå•ç°åœ¨åŒ…å«ä½ çš„æ–°å‘½ä»¤ï¼Œä½†ä½ éœ€è¦è®¾ç½® selectedLandmark ç„¦ç‚¹ç»‘å®šæ‰èƒ½å·¥ä½œã€‚",
      "tips": ""
    },
    "Choose the Landmarks build target, and use the live preview to see that the new filtering works well for iOS as well.": {
      "zh": "é€‰æ‹© Landmarks æ„å»ºç›®æ ‡ï¼Œå¹¶ä½¿ç”¨å®æ—¶é¢„è§ˆæŸ¥çœ‹æ–°è¿‡æ»¤æ˜¯å¦ä¹Ÿé€‚ç”¨äº iOSã€‚",
      "tips": ""
    },
    "Step 11": {
      "zh": "æ­¥éª¤ 11",
      "tips": ""
    },
    "In this section, youâ€™ll add a system-provided command that lets the user toggle the sidebar, to be able to get it back after dragging it closed.": {
      "zh": "åœ¨æœ¬èŠ‚ä¸­ï¼Œä½ å°†æ·»åŠ ä¸€ä¸ªç³»ç»Ÿæä¾›çš„å‘½ä»¤ï¼Œè®©ç”¨æˆ·å¯ä»¥åˆ‡æ¢ä¾§è¾¹æ å±•å¼€å’Œéšè—ï¼Œä»¥ä¾¿åœ¨æ‹–åŠ¨å…³é—­åå¯ä»¥æ¢å¤å®ƒã€‚",
      "tips": ""
    },
    "Drag the AppIcon.appiconset folder from the downloaded projectsâ€™ Resources folder into the MacLandmarkâ€™s Asset catalog.": {
      "zh": "å°† AppIcon.appiconset æ–‡ä»¶å¤¹ä»ä¸‹è½½é¡¹ç›®çš„ Resources æ–‡ä»¶å¤¹æ‹–åˆ° MacLandmark çš„ Asset ç›®å½•ä¸­ã€‚",
      "tips": ""
    },
    "Because the filter has only a few items, you use the inline picker style to make them all appear together.": {
      "zh": "å› ä¸ºè¿‡æ»¤å™¨åªæœ‰å‡ ä¸ªé€‰é¡¹ï¼Œæ‰€ä»¥ä½ ä½¿ç”¨ inline æ ·å¼è®©å®ƒä»¬ä¸€èµ·å‡ºç°ã€‚",
      "tips": ""
    },
    "After creating a version of the Landmarks app for watchOS, itâ€™s time to set your sights on something bigger: bringing Landmarks to the Mac. Youâ€™ll build upon everything youâ€™ve learned so far, to round out the experience of building a SwiftUI app for iOS, watchOS, and macOS.": {
      "zh": "åœ¨ä¸º watchOS åˆ›å»º Landmarks åº”ç”¨ç¨‹åºç‰ˆæœ¬åï¼Œæ˜¯æ—¶å€™å°†ä½ çš„ç›®å…‰æŠ•å‘æ›´å¤§çš„ç›®æ ‡äº†ï¼šå°† Landmarks å¼•å…¥åˆ° Mac ä¸Šã€‚ ä½ å°†ä»¥è¿„ä»Šä¸ºæ­¢æ‰€å­¦çš„ä¸€åˆ‡ä¸ºåŸºç¡€ï¼Œå®Œå–„ä¸º iOSã€watchOS å’Œ macOS æ„å»º SwiftUI åº”ç”¨ç¨‹åºçš„ä½“éªŒã€‚",
      "tips": ""
    },
    "Add a second child view to the NavigationView as a placeholder for the second view in wide layouts.": {
      "zh": "å°†æ–‡æœ¬è§†å›¾æ·»åŠ åˆ° NavigationView çš„æ¨ªå‘å¸ƒå±€ä¸­ï¼Œä½œä¸ºçš„äºŒçº§è§†å›¾çš„å ä½ã€‚",
      "tips": ""
    },
    "Next, youâ€™ll share view, model, and resource files from the iOS app with the macOS target.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†è®©  macOS åº”ç”¨å’Œ iOS åº”ç”¨ç¨‹åºå…±äº«è§†å›¾ã€æ¨¡å‹å’Œèµ„æºæ–‡ä»¶ã€‚",
      "tips": ""
    },
    "Sometimes you can reuse a view across platforms with small adjustments or conditional compilation, but the detail view differs enough for macOS that itâ€™s better to create a dedicated view. Youâ€™ll copy the iOS detail view as a starting point, and then modify it to suit the larger display of macOS.": {
      "zh": "æœ‰æ—¶å€™ï¼Œä½ å¯ä»¥é€šè¿‡è¿›è¡Œå°çš„è°ƒæ•´æˆ–ä½¿ç”¨æ¡ä»¶åˆ¤æ–­æ˜¯å¦å‚ä¸ç¼–è¯‘çš„æ–¹å¼åœ¨ä¸åŒå¹³å°é—´å¤ç”¨è§†å›¾ï¼Œä½†æ˜¯ macOS çš„è¯¦ç»†è§†å›¾å·®åˆ«è¾ƒå¤§ï¼Œå› æ­¤æœ€å¥½åˆ›å»ºä¸€ä¸ªä¸“ç”¨è§†å›¾ã€‚ä½ å°†å¤åˆ¶ iOS è¯¦æƒ…è§†å›¾ä½œä¸ºèµ·ç‚¹ï¼Œç„¶åä¿®æ”¹å®ƒæ¥é€‚åº” macOS æ›´å¤§çš„æ˜¾ç¤ºå±ã€‚",
      "tips": ""
    },
    "Add Preferences with a Settings Scene": {
      "zh": "ä½¿ç”¨è®¾ç½®åœºæ™¯çš„æ–¹å¼æ·»åŠ åå¥½è®¾ç½®",
      "tips": ""
    },
    "Scene modifiers work like view modifiers, except that you apply them to scenes instead of views.": {
      "zh": "åœºæ™¯ä¿®æ”¹å™¨çš„å·¥ä½œæ–¹å¼ç±»ä¼¼äºè§†å›¾ä¿®æ”¹å™¨ï¼Œåªæ˜¯ä½ å°†å®ƒä»¬åº”ç”¨äºåœºæ™¯è€Œä¸æ˜¯è§†å›¾ã€‚",
      "tips": ""
    },
    "Add a Built-in Menu Command": {
      "zh": "æ·»åŠ ä¸€ä¸ªå†…ç½®çš„èœå•æ é€‰é¡¹ã€‚",
      "tips": ""
    },
    "Follow the steps to build this project, or download the finished project to explore on your own.": {
      "zh": "æŒ‰ç…§æ­¥éª¤æ„å»ºæ­¤é¡¹ç›®ï¼Œæˆ–ä¸‹è½½å·²å®Œæˆçš„é¡¹ç›®æ¥è‡ªè¡Œæ¢ç´¢ã€‚",
      "tips": ""
    },
    "Add a SidebarCommands command to the body.": {
      "zh": "åœ¨ body ä¸­æ·»åŠ  SidebarCommands å‘½ä»¤ã€‚",
      "tips": ""
    },
    "Run the macOS app again, and see that you can use the View > Toggle Sidebar menu command to restore the list view.": {
      "zh": "å†æ¬¡è¿è¡Œ macOS åº”ç”¨ç¨‹åºï¼Œå¯ä»¥çœ‹åˆ°ä½ å¯ä»¥ä½¿ç”¨â€œè§†å›¾ï¼ˆViewï¼‰â€>â€œåˆ‡æ¢è¾¹æ ï¼ˆToggle Sidebarï¼‰â€èœå•å‘½ä»¤æ¥æ¢å¤åˆ—è¡¨è§†å›¾ã€‚",
      "tips": ""
    },
    "By setting the scheme to My Mac, you can preview, build, and run the macOS app. As you move through the tutorial, youâ€™ll use the other schemes to keep an eye on how other targets respond to changes in shared files.": {
      "zh": "é€šè¿‡å°†æ–¹æ¡ˆè®¾ç½®ä¸ºâ€œMy Macâ€ï¼Œä½ å¯ä»¥é¢„è§ˆã€ç¼–è¯‘å’Œè¿è¡Œ macOS åº”ç”¨ç¨‹åºã€‚ åœ¨å­¦ä¹ æœ¬æ•™ç¨‹æ—¶ï¼Œä½ ä¹Ÿä¼šä½¿ç”¨å…¶ä»–çš„ç¼–è¯‘æ–¹æ¡ˆæ¥å…³æ³¨å½“å…±äº«æ–‡ä»¶å‘ç”Ÿä¿®æ”¹æ—¶ï¼Œå…¶ä»–ç›®æ ‡æ˜¯å¦‚ä½•å“åº”çš„ã€‚",
      "tips": ""
    },
    "Youâ€™ll replace this in the next step.": {
      "zh": "ä½ å°†åœ¨ä¸‹ä¸€æ­¥ä¸­æ›¿æ¢å®ƒã€‚",
      "tips": ""
    },
    "These items define the appâ€™s data model and resources.": {
      "zh": "è¿™äº›é¡¹ç›®å®šä¹‰äº†åº”ç”¨ç¨‹åºçš„æ•°æ®æ¨¡å‹å’Œèµ„æºã€‚",
      "tips": ""
    },
    "Change the FavoriteButton to use the plain button style.": {
      "zh": "æ›´æ”¹ FavoriteButton çš„æ ·å¼ä¸º plainã€‚",
      "tips": ""
    },
    "Set the scheme to MacLandmarks > My Mac.": {
      "zh": "å°†ç¼–è¯‘æ–¹æ¡ˆè®¾ç½®ä¸º MacLandmarks > My Macï¼Œå³åœ¨æˆ‘çš„ Mac ä¸Šè¿è¡Œåº”ç”¨ç¨‹åºã€‚",
      "tips": ""
    },
    "Update filteredLandmarks to take into account the new filter setting, combined with the category of a given landmark.": {
      "zh": "æ›´æ–° filteredLandmarksï¼Œå°†æ–°çš„è¿‡æ»¤è®¾ç½®ä¸ç»™å®šåœ°æ ‡çš„ç±»åˆ«ç›¸ç»“åˆã€‚",
      "tips": ""
    },
    "Open the LandmarksApp.swift file, and apply LandmarkCommands using the commands(content:) scene modifier.": {
      "zh": "æ‰“å¼€ LandmarksApp.swift æ–‡ä»¶ï¼Œå¹¶ä½¿ç”¨ commands(content:) åœºæ™¯ä¿®é¥°ç¬¦åº”ç”¨ LandmarkCommandsã€‚",
      "tips": ""
    },
    "The content now has the right width, but each row has too much information.": {
      "zh": "å†…å®¹ç°åœ¨æœ‰æ­£ç¡®çš„å®½åº¦äº†ï¼Œä½†æ¯ä¸€è¡Œçš„ä¿¡æ¯å¤ªå¤šäº†ã€‚",
      "tips": ""
    },
    "Section 5": {
      "zh": "ç¬¬ 5 èŠ‚",
      "tips": ""
    },
    "Before modifying the row, set up a preview of the list, because the changes youâ€™ll make are driven by how the row looks in context.": {
      "zh": "åœ¨ä¿®æ”¹è¡Œä¹‹å‰ï¼Œè®¾ç½®å¥½åˆ—è¡¨çš„é¢„è§ˆï¼Œå› ä¸ºä½ æ‰€åšçš„æ›´æ”¹æ˜¯éœ€è¦åœ¨åˆ—è¡¨ä¸­å±•ç¤ºçš„ã€‚",
      "tips": ""
    },
    "Section 6": {
      "zh": "ç¬¬ 6 èŠ‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "æ­¥éª¤ 2",
      "tips": ""
    },
    "Remove the offset from the circle, and instead apply a smaller offset to the entire VStack.": {
      "zh": "å°†åœ†å½¢çš„åç§»é‡ç§»é™¤ï¼Œæ”¹æˆç»™æ•´ä¸ª VStack å¢åŠ ä¸€ä¸ªè¾ƒå°çš„åç§»é‡ã€‚",
      "tips": ""
    },
    "Create a macOS Detail View": {
      "zh": "åˆ›å»º macOS è¯¦ç»†ä¿¡æ¯è§†å›¾",
      "tips": ""
    },
    "Change the longitude and latitude delta used to construct the region property to a value that depends on zoom.": {
      "zh": "å°†ç”¨äºæ„é€  region å±æ€§çš„ç»åº¦å’Œçº¬åº¦å·®å€¼æ›´æ”¹ä¸ºä¸€ä¸ªå–å†³äºç¼©æ”¾çº§åˆ«çš„å€¼ã€‚",
      "tips": ""
    },
    "In the File inspector, add MacLandmarks to the Target Membership for the selected files.": {
      "zh": "åœ¨æ–‡ä»¶æ£€æŸ¥å™¨ä¸­ï¼Œç»™æ‰€é€‰æ‹©çš„æ–‡ä»¶æ·»åŠ  MacLandmarks ç›®æ ‡ï¼Œè®© Mac å·¥ç¨‹èƒ½å¤Ÿå¼•ç”¨è¿™äº›æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "Select the Assets.xcasset file in the MacLandmarks group and delete the empty AppIcon item.": {
      "zh": "é€‰æ‹© MacLandmarks ç»„ä¸­çš„ Assets.xcasset æ–‡ä»¶å¹¶åˆ é™¤ç©ºçš„ AppIcon é¡¹ã€‚",
      "tips": ""
    },
    "Youâ€™ll start by adding a macOS target to your project, and then reusing views and data you created earlier. With a foundation in place, youâ€™ll add some new views tailored to macOS, and modify others to work better across platforms.": {
      "zh": "ä½ å°†é¦–å…ˆå‘ä½ çš„é¡¹ç›®æ·»åŠ ä¸€ä¸ª macOS ç›®æ ‡ï¼Œç„¶åé‡ç”¨ä½ ä¹‹å‰åˆ›å»ºçš„è§†å›¾å’Œæ•°æ®ã€‚ æœ‰äº†é€‚å½“çš„åŸºç¡€ï¼Œä½ å°†æ·»åŠ ä¸€äº›ä¸º macOS é‡èº«å®šåˆ¶çš„æ–°è§†å›¾ï¼Œå¹¶ä¿®æ”¹å…¶ä»–è§†å›¾æ¥æ›´å¥½åœ°è·¨å¹³å°å·¥ä½œã€‚",
      "tips": ""
    },
    "Add a Picker to the menu to set the filter category.": {
      "zh": "åœ¨èœå•ä¸­æ·»åŠ ä¸€ä¸ª Picker æ¥è®¾ç½®è¿‡æ»¤å™¨ç±»åˆ«ã€‚",
      "tips": ""
    },
    "In ContentView in the MacLandmarks group, add LandmarkList as the top level view, with constraints on the frame size.": {
      "zh": "åœ¨ MacLandmarks æ–‡ä»¶å¤¹çš„ ContentView ä¸­ï¼Œæ·»åŠ  LandmarkList ä½œä¸ºé¡¶å±‚è§†å›¾ï¼Œå¹¶é™åˆ¶å®ƒçš„å¸ƒå±€å¤§å°ã€‚",
      "tips": ""
    },
    "Be sure to include MapKit to be able to create the MKMapItem that you send to Maps.": {
      "zh": "è¯·è®°å¾—å¼•ç”¨ MapKit æ¡†æ¶ï¼Œä»¥ä¾¿ä½ èƒ½å¤Ÿåˆ›å»º MKMapItem å¯¹è±¡å‘é€åˆ°åœ°å›¾ Appã€‚",
      "tips": ""
    },
    "In the sheet, enter MacLandmarks as the Product Name. Set the interface to SwiftUI, the life cycle to SwiftUI App, and the language to Swift, and then click Finish.": {
      "zh": "åœ¨å¼¹å‡ºçš„çª—å£ä¸­ï¼Œè¾“å…¥ MacLandmarks ä½œä¸ºäº§å“åç§°ã€‚ ç•Œé¢å¼€å‘æ¡†æ¶è®¾ç½®ä¸º SwiftUIï¼Œç”Ÿå‘½å‘¨æœŸè®¾ç½®ä¸º SwiftUI Appï¼Œè¯­è¨€è®¾ç½®ä¸º Swiftï¼Œç„¶åç‚¹å‡» Finishã€‚",
      "tips": ""
    },
    "With more room available, youâ€™ll add a new control for filtering the list of landmarks by category.": {
      "zh": "æœ‰äº†æ›´å¤šå¯ç”¨ç©ºé—´ï¼Œä½ å°†æ·»åŠ ä¸€ä¸ªæ–°æ§ä»¶ï¼Œæ¥æŒ‰ç±»åˆ«ç­›é€‰åœ°æ ‡åˆ—è¡¨ã€‚",
      "tips": ""
    },
    "Return to the MacLandmarks target, run the macOS app, and drag the separator between the list and detail view all the way to the left.": {
      "zh": "è¿”å› MacLandmarks ç›®æ ‡ï¼Œè¿è¡Œ macOS åº”ç”¨ç¨‹åºï¼Œå¹¶å°†åˆ—è¡¨å’Œè¯¦ç»†è§†å›¾ä¹‹é—´çš„åˆ†éš”ç¬¦ä¸€ç›´æ‹–åˆ°å·¦ä¾§ã€‚",
      "tips": ""
    },
    "The larger display gives you more room for additional features.": {
      "zh": "æ›´å¤§çš„æ˜¾ç¤ºå±ä¹Ÿä¸ºä½ æä¾›æ›´å¤šåŠŸç©ºé—´å±•ç¤ºåŠŸèƒ½ã€‚",
      "tips": ""
    },
    "Section 7": {
      "zh": "ç¬¬ 7 èŠ‚",
      "tips": ""
    },
    "By storing the filter state in the list view, the user can open multiple list view windows, each with its own filter setting, to be able to look at the data in different ways.": {
      "zh": "é€šè¿‡åœ¨åˆ—è¡¨è§†å›¾ä¸­å­˜å‚¨è¿‡æ»¤å™¨çŠ¶æ€ï¼Œç”¨æˆ·å¯ä»¥æ‰“å¼€å¤šä¸ªåˆ—è¡¨è§†å›¾çª—å£ï¼Œæ¯ä¸ªçª—å£éƒ½æœ‰è‡ªå·±çš„è¿‡æ»¤å™¨è®¾ç½®ï¼Œè¿™æ ·èƒ½å¤Ÿä»¥ä¸åŒçš„æ–¹å¼æŸ¥çœ‹æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "æ­¥éª¤ 4",
      "tips": ""
    },
    "Youâ€™ll start by adding a control in the MapView that sets the initial zoom to one of three levels: near, medium, or far.": {
      "zh": "ä½ å°†é¦–å…ˆåœ¨ MapView ä¸­æ·»åŠ ä¸€ä¸ªæ§ä»¶ï¼Œç”¨äºå°†åˆå§‹ç¼©æ”¾è®¾ç½®ä¸ºä¸‰ä¸ªçº§åˆ«ä¹‹ä¸€ï¼šè¿‘ã€ä¸­æˆ–è¿œã€‚",
      "tips": ""
    },
    "Pin the list view preview so that you can see how the row looks in context as you make changes.": {
      "zh": "å›ºå®šåˆ—è¡¨è§†å›¾çš„é¢„è§ˆçª—å£ï¼Œè®©ä½ å¯ä»¥åœ¨è¿›è¡Œæ›´æ”¹æ—¶çœ‹åˆ°è¡Œè§†å›¾åœ¨åˆ—è¡¨ä¸­çš„å¤–è§‚å˜åŒ–ã€‚",
      "tips": ""
    },
    "Initialize the List with a binding to the selected value, and add a tag to the navigation link.": {
      "zh": "ç”¨é€‰å®šå€¼çš„ç»‘å®šåˆå§‹åŒ–åˆ—è¡¨ï¼Œå¹¶åœ¨å¯¼èˆªé“¾æ¥ä¸­æ·»åŠ ä¸€ä¸ªæ ‡ç­¾ã€‚",
      "tips": ""
    },
    "Add a macOS Target to the Project": {
      "zh": "å°† macOS ç›®æ ‡æ·»åŠ åˆ°é¡¹ç›®",
      "tips": ""
    },
    "Step 9": {
      "zh": "æ­¥éª¤ 9",
      "tips": ""
    },
    "Unfortunately, the watchOS app fails to build because Commands has no watchOS availability. Youâ€™ll fix that next.": {
      "zh": "ä¸å¹¸çš„æ˜¯ï¼ŒwatchOS åº”ç”¨ç¨‹åºæ— æ³•æ„å»ºï¼Œå› ä¸º Commands åœ¨ watchOS ä¸Šä¸å¯ç”¨ã€‚æ¥ä¸‹æ¥ä½ å°†è§£å†³è¿™ä¸ªé—®é¢˜ã€‚",
      "tips": ""
    },
    "In LandmarkList.swift, add a state variable for the selected landmark and a computed property that indicates the index of the selected landmark.": {
      "zh": "åœ¨ LandmarkList.swift ä¸­ï¼Œä¸ºæ‰€é€‰åœ°æ ‡æ·»åŠ ä¸€ä¸ªçŠ¶æ€å˜é‡å’Œä¸€ä¸ªè¡¨ç¤ºæ‰€é€‰åœ°æ ‡ç´¢å¼•çš„è®¡ç®—å±æ€§ã€‚",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ 3 èŠ‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "æ­¥éª¤ 1",
      "tips": ""
    },
    "Like with the watchOS app, you donâ€™t need the default app structure because youâ€™ll reuse the one you already have.": {
      "zh": "ä¸ watchOS åº”ç”¨ç¨‹åºä¸€æ ·ï¼Œä½ ä¸éœ€è¦ Xcode ç”Ÿæˆçš„é»˜è®¤çš„ App æ–‡ä»¶ï¼Œå› ä¸ºä½ ä¼šé‡å¤ä½¿ç”¨ä¸»å·¥ç¨‹ä¸­å·²æœ‰çš„ App æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "In MapView.swift, add a Zoom enumeration to characterize the zoom level.": {
      "zh": "åœ¨ MapView.swift ä¸­ï¼Œæ·»åŠ ä¸€ä¸ª Zoom æšä¸¾æ¥è¡¨ç¤ºç¼©æ”¾çº§åˆ«ã€‚",
      "tips": ""
    },
    "Users expect to be able to adjust settings for a macOS app using the standard Preferences menu item. Youâ€™ll add preferences to MacLandmarks by adding a Settings scene. The sceneâ€™s views define the contents of the preferences window, which youâ€™ll use to control the initial zoom level of the MapView. You communicate the value to the map view, and store it persistently, by using the @AppStorage property wrapper.": {
      "zh": "ç”¨æˆ·å¸Œæœ›èƒ½å¤Ÿä½¿ç”¨æ ‡å‡†çš„åå¥½èœå•è°ƒæ•´ macOS åº”ç”¨çš„è®¾ç½®ã€‚ä½ å°†é€šè¿‡æ·»åŠ ä¸€ä¸ª Settings åœºæ™¯æ¥ä¸º MacLandmarks æ·»åŠ åå¥½è®¾ç½®ã€‚åœºæ™¯çš„è§†å›¾å®šä¹‰äº†åå¥½çª—å£çš„å†…å®¹ï¼Œä½ å°†ç”¨å®ƒæ¥æ§åˆ¶ MapView çš„åˆå§‹ç¼©æ”¾çº§åˆ«ã€‚é€šè¿‡ä½¿ç”¨ @AppStorage å±æ€§åŒ…è£…å™¨ï¼Œä½ å¯ä»¥å°†å€¼ä¼ é€’ç»™åœ°å›¾è§†å›¾ï¼Œå¹¶å°†å…¶æŒä¹…åœ°å­˜å‚¨ã€‚",
      "tips": ""
    },
    "This change will be useful in the iOS app.": {
      "zh": "è¿™ä¸ªä¿®æ”¹å°†ä¼šåœ¨ iOS åº”ç”¨ç¨‹åºä¸­ç”Ÿæ•ˆã€‚",
      "tips": ""
    },
    "Add a filter state variable, defaulting to the all case.": {
      "zh": "æ·»åŠ ä¸€ä¸ª filter çŠ¶æ€å˜é‡ï¼Œé»˜è®¤è®¾ç½®ä¸º all åŒ…å«æ‰€æœ‰æƒ…å†µã€‚",
      "tips": ""
    },
    "The updates improve the look in macOS, but you also need to consider the other platforms that use the list. Consider watchOS first.": {
      "zh": "è¿™äº›æ›´æ”¹ä¼˜åŒ–äº† macOS çš„å¤–è§‚ï¼Œä½†ä½ è¿˜éœ€è¦è€ƒè™‘ä½¿ç”¨è¯¥åˆ—è¡¨çš„å…¶ä»–å¹³å°ã€‚é¦–å…ˆè€ƒè™‘ watchOSã€‚",
      "tips": ""
    },
    "Add a macOS app icon set to match those for the other targets.": {
      "zh": "æ·»åŠ ä¸€ä¸ª macOS åº”ç”¨ç¨‹åºå›¾æ ‡é›†åˆï¼Œè®© Mac ä¸Šä¹Ÿèƒ½æ­£ç¡®æ˜¾ç¤º App å›¾æ ‡ã€‚",
      "tips": ""
    },
    "To be able to preview and run the app, be sure your Mac is running macOS Monterey or later.": {
      "zh": "ä¸ºäº†èƒ½å¤Ÿé¢„è§ˆå’Œè¿è¡Œåº”ç”¨ç¨‹åºï¼Œè¯·ç¡®ä¿ä½ çš„ Mac è¿è¡Œçš„æ˜¯ macOS Monterey æˆ–æ›´é«˜ç‰ˆæœ¬ã€‚",
      "tips": ""
    },
    "Match the case strings to the Category enumeration in the Landmark structure so that you can compare them, and include an all case to turn filtering off.": {
      "zh": "å°† FilterCategory æšä¸¾ä¸­çš„çš„å­—ç¬¦ä¸²ä¸ Landmark ç»“æ„ä¸­çš„ Category æšä¸¾ç›¸åŒ¹é…ï¼Œä»¥ä¾¿ä½ å¯ä»¥æ¯”è¾ƒå®ƒä»¬ï¼Œå¹¶åŒ…å«ä¸€ä¸ª all ç±»å‹æ¥å…³é—­è¿‡æ»¤ã€‚",
      "tips": ""
    },
    "Enclose everything below MapView in a VStack, and then place the CircleImage and the rest of the header in an HStack.": {
      "zh": "å°† MapView ä¸‹æ–¹çš„æ‰€æœ‰å†…å®¹éƒ½åŒ…å«åœ¨ VStack ä¸­ï¼Œç„¶åå°† CircleImage å’Œå¤´éƒ¨çš„å…¶ä½™éƒ¨åˆ†æ”¾åœ¨ HStack ä¸­ã€‚",
      "tips": ""
    },
    "Add a Custom Menu Command": {
      "zh": "æ·»åŠ è‡ªå®šä¹‰èœå•å‘½ä»¤",
      "tips": ""
    },
    "Copy the contents of the old LandmarkList into the new one, but without the frame modifier.": {
      "zh": "å°†æ—§ LandmarkList çš„å†…å®¹å¤åˆ¶åˆ°æ–°çš„ LandmarkList ä¸­ï¼Œä½†ä¸å¸¦ frame ä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    }
  },
  "swiftui/creating-a-watchos-app": {
    "Add the Landmarks List": {
      "zh": "æ·»åŠ åœ°æ ‡åˆ—è¡¨",
      "tips": ""
    },
    "This file holds the Watch-specific app definition. Its name depends on the Xcode project name, but itâ€™s always the first item in the WatchLandmarks Extension group. Youâ€™ll reuse the iOS app definition instead, in the next few steps.": {
      "zh": "è¿™ä¸ªæ–‡ä»¶åŒ…å«äº†é’ˆå¯¹ Apple Watch çš„ç‰¹å®šçš„åº”ç”¨å®šä¹‰ï¼Œå®ƒçš„åç§°å–å†³äº Xcode é¡¹ç›®åç§°ï¼Œä½†å®ƒå§‹ç»ˆæ˜¯ WatchLandmarks Extension æ–‡ä»¶å¤¹ä¸­çš„ç¬¬ä¸€é¡¹ã€‚åœ¨æ¥ä¸‹æ¥çš„å‡ ä¸ªæ­¥éª¤ä¸­ï¼Œæ‚¨å°†å¤ç”¨ iOS åº”ç”¨å®šä¹‰ã€‚",
      "tips": ""
    },
    "The first time you run the notification scheme, the system asks for permission to send notifications. Select Allow.": {
      "zh": "ç¬¬ä¸€æ¬¡è¿è¡Œé€šçŸ¥æ–¹æ¡ˆæ—¶ï¼Œç³»ç»Ÿä¼šè¯·æ±‚å‘é€é€šçŸ¥çš„æƒé™ã€‚ é€‰æ‹©å…è®¸ã€‚",
      "tips": ""
    },
    "The LandmarkList that you created for iOS works for your watch app as well, and it automatically navigates to the watch-specific detail view that you just created when compiled for watchOS. Next, youâ€™ll connect the list to the watchâ€™s ContentView, so that it acts as the top level view for the watch app.": {
      "zh": "ä½ ä¸º iOS åˆ›å»ºçš„ LandmarkList ä¹Ÿé€‚ç”¨äºä½ çš„æ‰‹è¡¨åº”ç”¨ç¨‹åºï¼Œå®ƒä¼šè‡ªåŠ¨å¯¼èˆªåˆ°ä½ åˆšåˆšä¸“é—¨ä¸º watchOS æ‰‹è¡¨åˆ›å»ºçš„è¯¦ç»†ä¿¡æ¯è§†å›¾ã€‚ æ¥ä¸‹æ¥ï¼Œä½ ä¼šè®©åˆ—è¡¨å¯¼èˆªåˆ°æ‰‹è¡¨çš„ ContentViewï¼Œè¿™æ ·èƒ½è®©å®ƒå……å½“æ‰‹è¡¨åº”ç”¨ç¨‹åºçš„é¡¶çº§è§†å›¾ã€‚",
      "tips": ""
    },
    "In the Project navigator, Command-click to select the following files: LandmarksApp.swift,LandmarkList.swift, LandmarkRow.swift, CircleImage.swift, MapView.swift.": {
      "zh": "åœ¨é¡¹ç›®å¯¼èˆªå™¨ä¸­ï¼ŒæŒ‰ä½ Command å•å‡»ä»¥é€‰æ‹©ä»¥ä¸‹æ–‡ä»¶ï¼šLandmarksApp.swiftã€LandmarkList.swiftã€LandmarkRow.swiftã€CircleImage.swiftã€MapView.swiftã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "æ­¥éª¤ 6",
      "tips": ""
    },
    "Create the Detail View": {
      "zh": "åˆ›å»ºè¯¦ç»†è§†å›¾",
      "tips": ""
    },
    "The first of these is the shared app definition. The others are views that the app can display on watchOS with no changes.": {
      "zh": "å…¶ä¸­ç¬¬ä¸€ä¸ªæ˜¯å…±äº«åº”ç”¨ç¨‹åºå…¥å£ã€‚ å…¶ä»–æ˜¯åº”ç”¨ç¨‹åºå¯ä»¥åœ¨ watchOS ä¸Šæ˜¾ç¤ºè€Œæ— éœ€æ›´æ”¹çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "As you can see, the information doesnâ€™t quite fit on the watch screen, but you can fix that by placing the VStack within a scroll view.": {
      "zh": "å¦‚ä½ æ‰€è§ï¼Œä¿¡æ¯ä¸å¤ªé€‚åˆåœ¨æ‰‹è¡¨å±å¹•ä¸Šæ˜¾ç¤ºï¼Œä½†ä½ å¯ä»¥é€šè¿‡å°† VStack æ”¾åœ¨æ»šåŠ¨è§†å›¾ä¸­æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚",
      "tips": ""
    },
    "Finally, add a watchOS app icon that matches the iOS app icon you already have.": {
      "zh": "æœ€åï¼Œæ·»åŠ ä¸€ä¸ªä¸ä½ å·²æœ‰çš„ iOS åº”ç”¨ç¨‹åºå›¾æ ‡ç›¸åŒ¹é…çš„ watchOS åº”ç”¨ç¨‹åºå›¾æ ‡ã€‚",
      "tips": ""
    },
    "Add a title to the back button.": {
      "zh": "ç»™åé€€æŒ‰é’®æ·»åŠ æ ‡é¢˜ã€‚",
      "tips": ""
    },
    "Select the WatchLandmarks Extension project and navigate to the projectâ€™s General tab; select the Supports Running Without iOS App Installation checkbox.": {
      "zh": "é€‰æ‹© WatchLandmarks Extension é¡¹ç›®å¹¶ç‚¹å‡»åˆ°é¡¹ç›®çš„ General é¡µé¢ï¼› é€‰ä¸­æ”¯æŒä¸éœ€è¦å®‰è£… iOS App è¿è¡Œï¼ˆSupports Running Without iOS App Installationï¼‰ã€‚",
      "tips": ""
    },
    "The watchOS appâ€™s root view displays the default â€œHello, World!â€ message.": {
      "zh": "watchOS åº”ç”¨ç¨‹åºçš„æ ¹è§†å›¾æ˜¾ç¤ºé»˜è®¤çš„â€œHello, World!â€ ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "æ­¥éª¤ 8",
      "tips": ""
    },
    "Add a new custom view to the WatchLandmarks Extension folder named LandmarkDetail.swift.": {
      "zh": "å°†æ–°çš„è‡ªå®šä¹‰è§†å›¾æ·»åŠ åˆ°åä¸º LandmarkDetail.swift çš„ WatchLandmarks æ‰©å±•æ–‡ä»¶å¤¹ã€‚",
      "tips": ""
    },
    "Finish Command-clicking to add resource files loaded by the model: landmarkData.json, hikeData.json, and Assets.xcassets.": {
      "zh": "æŒ‰ä½ Command å•å‡»ä»¥æ·»åŠ æ¨¡å‹åŠ è½½çš„èµ„æºæ–‡ä»¶ï¼šlandmarkData.jsonã€hikeData.json å’Œ Assets.xcassetsã€‚",
      "tips": ""
    },
    "Create a Custom Notification Interface": {
      "zh": "åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰çš„é€šçŸ¥ç•Œé¢",
      "tips": ""
    },
    "Like LandmarkDetail.swift the content view for the watchOS target has the same name as the one for the iOS target. Keeping names and interfaces the same makes it easy to share files between targets.": {
      "zh": "ä¸ LandmarkDetail.swift ä¸€æ ·ï¼ŒwatchOS ç›®æ ‡çš„å†…å®¹è§†å›¾ä¸ iOS ç›®æ ‡çš„å†…å®¹è§†å›¾å…·æœ‰ç›¸åŒçš„åç§°ã€‚ ä¿æŒåç§°å’Œæ¥å£ç›¸åŒå¯ä»¥è½»æ¾åœ°åœ¨ç›®æ ‡ä¹‹é—´å…±äº«æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "Define the LandmarkIndexKey.": {
      "zh": "å®šä¹‰ LandmarkIndexKeyã€‚",
      "tips": ""
    },
    "These are identical to the properties you added in Handling User Input.": {
      "zh": "è¿™äº›ä¸ä½ åœ¨å¤„ç†ç”¨æˆ·è¾“å…¥æ•™ç¨‹ä¸­æ·»åŠ çš„å±æ€§ç›¸åŒã€‚",
      "tips": ""
    },
    "Change scaleToFill() to scaleToFit() and add padding.": {
      "zh": "å°† scaleToFill() æ›´æ”¹ä¸º scaleToFit() å¹¶æ·»åŠ å¡«å……ã€‚",
      "tips": ""
    },
    "Whenever possible, create an independent watchOS app. Independent watchOS apps donâ€™t require an iOS companion app.": {
      "zh": "å°½å¯èƒ½åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„ watchOS åº”ç”¨ç¨‹åºã€‚ ç‹¬ç«‹çš„ watchOS åº”ç”¨ä¸éœ€è¦ iOS é…å¥—åº”ç”¨ã€‚",
      "tips": ""
    },
    "Creating a macOS App": {
      "zh": "",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ 1 èŠ‚",
      "tips": ""
    },
    "After you grant permission, the Simulator displays a scrollable notification which includes: the appâ€™s icon to help identify the Landmarks app as the sender, the notification view, and buttons for the notificationâ€™s actions.": {
      "zh": "åœ¨ä½ æˆäºˆæƒé™åï¼Œæ¨¡æ‹Ÿå™¨ä¼šæ˜¾ç¤ºä¸€ä¸ªå¯æ»šåŠ¨çš„é€šçŸ¥ï¼Œå…¶ä¸­åŒ…æ‹¬ï¼šåº”ç”¨ç¨‹åºçš„å›¾æ ‡ï¼ˆå¸®åŠ©ç”¨æˆ·è¯†åˆ«æ˜¯ Landmarks åº”ç”¨ç¨‹åºçš„é€šçŸ¥ï¼‰ã€é€šçŸ¥è§†å›¾å’Œé€šçŸ¥æ“ä½œæŒ‰é’®ã€‚",
      "tips": ""
    },
    "This sets the text for the back button to â€œLandmarksâ€.": {
      "zh": "è¿™ä¼šå°†åé€€æŒ‰é’®çš„æ–‡æœ¬è®¾ç½®ä¸ºâ€œLandmarksâ€ã€‚",
      "tips": ""
    },
    "Create previews for the largest (44mm) and smallest (40mm) watch faces.": {
      "zh": "ä¸ºæœ€å¤§ (44mm) å’Œæœ€å° (40mm) è¡¨ç›˜åˆ›å»ºé¢„è§ˆã€‚",
      "tips": ""
    },
    "By testing against the largest and smallest watch faces, you can see how well your app scales to fit on the display. As always, you should test your user interface on all supported device sizes.": {
      "zh": "é€šè¿‡é’ˆå¯¹æœ€å¤§å’Œæœ€å°çš„è¡¨ç›˜è¿›è¡Œæµ‹è¯•ï¼Œä½ å¯ä»¥äº†è§£ä½ çš„åº”ç”¨ç¨‹åºè‡ªé€‚åº”çš„æ•ˆæœã€‚ å’Œä¹‹å‰ä¸€æ ·ï¼Œä½ åº”è¯¥åœ¨æ‰€æœ‰æ”¯æŒçš„è®¾å¤‡å°ºå¯¸ä¸Šæµ‹è¯•ä½ çš„ç”¨æˆ·ç•Œé¢ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "ç¬”è®°",
      "tips": ""
    },
    "When Apple Watch receives a notification, it looks for a scene in your app associated with the notificationâ€™s category.": {
      "zh": "å½“ Apple Watch æ”¶åˆ°é€šçŸ¥æ—¶ï¼Œå®ƒä¼šåœ¨ä½ çš„åº”ç”¨ç¨‹åºä¸­æŸ¥æ‰¾ä¸é€šçŸ¥ç±»åˆ«ç›¸å…³è”çš„åœºæ™¯ã€‚",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "This tutorial gives you a chance to apply much of what youâ€™ve already learned about SwiftUI, and â€” with little effort â€” migrate the Landmarks app to watchOS.": {
      "zh": "æœ¬æ•™ç¨‹è®©ä½ æœ‰æœºä¼šåº”ç”¨å·²ç»å­¦åˆ°çš„å…³äº SwiftUI çš„å¾ˆå¤šçŸ¥è¯†ï¼Œå¹¶ä¸”åªéœ€å¾ˆå°‘çš„åŠªåŠ›ï¼Œå°±å¯ä»¥å°† Landmarks åº”ç”¨è¿ç§»åˆ° watchOSã€‚",
      "tips": ""
    },
    "Configure the test payload to use the LandmarkNear category and to pass along the data expected by the notification controller.": {
      "zh": "é…ç½®é€šçŸ¥çš„æµ‹è¯•è£…ç½®ï¼Œä½¿ç”¨ LandmarkNear ç±»åˆ«å¹¶ä¼ é€’é€šçŸ¥æ§åˆ¶å™¨éœ€è¦çš„æ•°æ®ã€‚",
      "tips": ""
    },
    "In the Project navigator, delete the first item in the WatchLandmarks Extension folder; When asked, choose Move to trash.": {
      "zh": "åœ¨é¡¹ç›®å¯¼èˆªæ ä¸­ï¼Œåˆ é™¤ WatchLandmarks Extension æ–‡ä»¶å¤¹ä¸­çš„ç¬¬ä¸€é¡¹ï¼› å½“è¯¢é—®æ—¶ï¼Œé€‰æ‹©ç§»è‡³åƒåœ¾ç®±ï¼ˆMove To Trashï¼‰ã€‚",
      "tips": ""
    },
    "To create a watchOS app, start by adding a watchOS target to the project. Xcode adds groups and files for the watchOS app to your project, along with the schemes needed to build and run the app.": {
      "zh": "è¦åˆ›å»º watchOS åº”ç”¨ç¨‹åºï¼Œé¦–å…ˆè¦å°† watchOS ç›®æ ‡æ·»åŠ åˆ°é¡¹ç›®ä¸­ã€‚ Xcode å°† watchOS åº”ç”¨ç¨‹åºçš„æ–‡ä»¶å¤¹å’Œæ–‡ä»¶æ·»åŠ åˆ°ä½ çš„é¡¹ç›®ï¼Œä»¥åŠç¼–è¯‘å’Œè¿è¡Œåº”ç”¨ç¨‹åºæ‰€éœ€çš„æ–¹æ¡ˆé…ç½®ã€‚",
      "tips": ""
    },
    "Youâ€™ll start by adding a watchOS target to your project, before copying over the shared data and views you created for the iOS app. With all of the assets in place, youâ€™ll customize the SwiftUI views to display the detail and list views on watchOS.": {
      "zh": "ä½ å°†é¦–å…ˆä¸ºé¡¹ç›®æ·»åŠ ä¸€ä¸ª watchOS ç›®æ ‡ï¼Œç„¶åå¤åˆ¶ä¹‹å‰ä¸º iOS åº”ç”¨åˆ›å»ºçš„å…±äº«æ•°æ®å’Œè§†å›¾ã€‚åœ¨æ‰€æœ‰èµ„æºå°±ç»ªåï¼Œä½ å°†è‡ªå®šä¹‰ SwiftUI è§†å›¾ï¼Œä»¥åœ¨ watchOS ä¸Šæ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯å’Œåˆ—è¡¨è§†å›¾ã€‚",
      "tips": ""
    },
    "This method updates the controllerâ€™s properties. After calling this method, the system invalidates the controllerâ€™s body property, which updates your navigation view. The system then displays the notification on Apple Watch.": {
      "zh": "è¿™ä¸ªæ–¹æ³•æ›´æ–°æ§åˆ¶å™¨çš„å±æ€§ã€‚ è°ƒç”¨æ­¤æ–¹æ³•åï¼Œç³»ç»Ÿä¼šä½¿æ§åˆ¶å™¨çš„ body å±æ€§å¤±æ•ˆï¼Œä»è€Œæ›´æ–°ä½ çš„å¯¼èˆªè§†å›¾ã€‚ ç„¶åç³»ç»Ÿä¼šåœ¨ Apple Watch ä¸Šæ˜¾ç¤ºé€šçŸ¥ã€‚",
      "tips": ""
    },
    "Now that the iOS target resources are in place for working on the watch app, youâ€™ll need to create a watch-specific view for displaying landmark details. To test the detail view, youâ€™ll create custom previews for the largest and smallest watch sizes, and make some changes to the circle view so everything fits on the watch face.": {
      "zh": "ç°åœ¨é’ˆå¯¹ iOS å¹³å°çš„èµ„æºå·²å‡†å¤‡å¥½ç”¨äºæ‰‹è¡¨åº”ç”¨ç¨‹åºï¼Œä½ éœ€è¦åˆ›å»ºä¸€ä¸ªç‰¹å®šç”¨äºæ‰‹è¡¨çš„è§†å›¾æ¥æ˜¾ç¤ºåœ°æ ‡è¯¦ç»†ä¿¡æ¯ã€‚ ä¸ºäº†æµ‹è¯•è¯¦ç»†è§†å›¾ï¼Œæ‚¨å°†ä¸ºæœ€å¤§å’Œæœ€å°æ‰‹è¡¨å°ºå¯¸åˆ›å»ºè‡ªå®šä¹‰é¢„è§ˆï¼Œå¹¶å¯¹åœ†å½¢è§†å›¾è¿›è¡Œä¸€äº›ä¿®æ”¹ï¼Œä»¥ä½¿æ‰€æœ‰å†…å®¹éƒ½é€‚åº”æ‰‹è¡¨è¡¨ç›˜ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "æ­¥éª¤ 3",
      "tips": ""
    },
    "The map appears off screen, but if you enable live preview, you can scroll down to see it.": {
      "zh": "åœ°å›¾æ˜¾ç¤ºåœ¨å±å¹•å¤–ï¼Œä½†å¦‚æœå¯ç”¨å®æ—¶é¢„è§ˆï¼Œåˆ™å¯ä»¥å‘ä¸‹æ»šåŠ¨æ¥æŸ¥çœ‹å®ƒã€‚",
      "tips": ""
    },
    "The scene only makes sense for watchOS, so add the conditional compilation.": {
      "zh": "è¯¥åœºæ™¯ä»…å¯¹ watchOS æœ‰æ„ä¹‰ï¼Œå› æ­¤æ·»åŠ æ¡ä»¶ç¼–è¯‘ã€‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬ 2 èŠ‚",
      "tips": ""
    },
    "This template adds a new watchOS app to your project, setting the iOS app as its companion.": {
      "zh": "è¿™ä¸ªæ¨¡æ¿å°†æ–°çš„ watchOS åº”ç”¨ç¨‹åºæ·»åŠ åˆ°ä½ çš„é¡¹ç›®ï¼Œå°† iOS åº”ç”¨ç¨‹åºè®¾ç½®ä¸ºå®ƒçš„é…å¥—åº”ç”¨ã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "æ­¥éª¤ 10",
      "tips": ""
    },
    "Share Files Between Targets": {
      "zh": "åœ¨ç›®æ ‡ä¹‹é—´å…±äº«æ–‡ä»¶",
      "tips": ""
    },
    "Section 4": {
      "zh": "ç¬¬ 4 èŠ‚",
      "tips": ""
    },
    "Continue Command-clicking to add the following model files: ModelData.swift, Landmark.swift, Hike.swift, Profile.swift.": {
      "zh": "ç»§ç»­æŒ‰ä½ Command å•å‡»æ·»åŠ ä»¥ä¸‹æ¨¡å‹æ–‡ä»¶ï¼šModelData.swiftã€Landmark.swiftã€Hike.swiftã€Profile.swiftã€‚",
      "tips": ""
    },
    "In the File inspector, select the WatchLandmarks Extension checkbox in the Target Membership section.": {
      "zh": "åœ¨æ–‡ä»¶æ£€æŸ¥å™¨ï¼ˆFile inspectorï¼‰ä¸­ï¼Œé€‰ä¸­ç›®æ ‡åˆ—è¡¨ä¸­çš„ WatchLandmarks æ‰©å±•ã€‚",
      "tips": ""
    },
    "Here you reuse the CircleImage view from the iOS project. Because you created a resizable image, the call to scaledToFill() adjusts the circleâ€™s size so that it fills the display.": {
      "zh": "åœ¨è¿™é‡Œï¼Œä½ å¤ç”¨äº† iOS é¡¹ç›®ä¸­çš„ CircleImage è§†å›¾ã€‚ å› ä¸ºä½ åˆ›å»ºäº†ä¸€ä¸ªå¯è°ƒæ•´å¤§å°çš„å›¾åƒï¼Œæ‰€ä»¥è°ƒç”¨ scaledToFill() è°ƒæ•´åœ†çš„å¡«å……æ¨¡å¼ï¼Œä½¿å…¶å……æ»¡è§†å›¾ã€‚",
      "tips": ""
    },
    "Open NotificationView.swift and create a view that displays information about a landmark, title, and message.": {
      "zh": "æ‰“å¼€ NotificationView.swift å¹¶åˆ›å»ºä¸€ä¸ªæ˜¾ç¤ºæœ‰å…³åœ°æ ‡ã€æ ‡é¢˜å’Œæ¶ˆæ¯çš„ä¿¡æ¯çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "æ­¥éª¤ 7",
      "tips": ""
    },
    "Step 5": {
      "zh": "æ­¥éª¤ 5",
      "tips": ""
    },
    "You use this key to extract the landmark index from the notification.": {
      "zh": "ä½¿ç”¨è¿™ä¸ªé”®ä»é€šçŸ¥ä¸­æå–åœ°æ ‡ç´¢å¼•ã€‚",
      "tips": ""
    },
    "Because any notification value can be nil, the preview will display two versions of the notification view. The first just shows the default values when no data is provided, and the second displays the title, message, and location you provide.": {
      "zh": "å› ä¸ºä»»ä½•é€šçŸ¥å€¼éƒ½å¯ä»¥ä¸º nilï¼Œæ‰€ä»¥é¢„è§ˆä¼šæ˜¾ç¤ºä¸¤ä¸ªç‰ˆæœ¬çš„é€šçŸ¥è§†å›¾ã€‚ ç¬¬ä¸€ä¸ªæ˜¯æœªæä¾›æ•°æ®æ—¶æ˜¾ç¤ºé»˜è®¤å€¼ï¼Œç¬¬äºŒä¸ªæ˜¾ç¤ºä½ æä¾›çš„æ ‡é¢˜ã€æ¶ˆæ¯å’Œä½ç½®ã€‚",
      "tips": ""
    },
    "Select ContentView.swift in the WatchLandmarks Extension folder.": {
      "zh": "åœ¨ WatchLandmarks Extension æ–‡ä»¶å¤¹ä¸­é€‰æ‹© ContentView.swiftã€‚",
      "tips": ""
    },
    "Select the Landmarks-Watch (Notification) scheme, and build and run your app.": {
      "zh": "é€‰æ‹© Landmarks-Watch (Notification) æ–¹æ¡ˆï¼Œç¼–è¯‘å¹¶è¿è¡Œä½ çš„åº”ç”¨ç¨‹åºã€‚",
      "tips": ""
    },
    "This scales the circle image to match the displayâ€™s width and ensures the landmark name is visible below the circle image.": {
      "zh": "è¿™ä¼šç¼©æ”¾åœ†å½¢å›¾åƒæ¥é€‚åº”æ˜¾ç¤ºå±çš„å®½åº¦ï¼Œå¹¶ç¡®ä¿åœ°æ ‡åç§°åœ¨åœ†å½¢å›¾åƒä¸‹æ–¹å¯è§ã€‚",
      "tips": ""
    },
    "Drag the AppIcon.appiconset folder from the downloaded projectsâ€™ Resources folder into the WatchLandmarkâ€™s Asset catalog.": {
      "zh": "å°† AppIcon.appiconset æ–‡ä»¶å¤¹ä»ä¸‹è½½é¡¹ç›®çš„ Resources æ–‡ä»¶å¤¹æ‹–åˆ° WatchLandmark çš„ Asset ç›®å½•ä¸­ã€‚",
      "tips": ""
    },
    "After creating a version of the Landmarks app for watchOS, itâ€™s time to set your sights on something bigger: bringing Landmarks to the Mac. Youâ€™ll build upon everything youâ€™ve learned so far, to round out the experience of building a SwiftUI app for iOS, watchOS, and macOS.": {
      "zh": "åœ¨ä¸º watchOS åˆ›å»º Landmarks åº”ç”¨ç¨‹åºç‰ˆæœ¬åï¼Œæ˜¯æ—¶å€™å°†ä½ çš„ç›®å…‰æŠ•å‘æ›´å¤§çš„ç›®æ ‡äº†ï¼šå°† Landmarks å¼•å…¥ Macã€‚ ä½ å°†ä»¥è¿„ä»Šä¸ºæ­¢æ‰€å­¦çš„ä¸€åˆ‡ä¸ºåŸºç¡€ï¼Œå®Œå–„ä¸º iOSã€watchOS å’Œ macOS æ„å»º SwiftUI åº”ç”¨ç¨‹åºçš„ä½“éªŒã€‚",
      "tips": ""
    },
    "This turns on view scrolling, but it creates another problem: the circle image now expands to full size, and it resizes other UI elements to match the image size. Youâ€™ll need to resize the circle image so that just the circle and landmark name appear onscreen.": {
      "zh": "è¿™ä¼šè®©è§†å›¾å¯æ»šåŠ¨ï¼Œä½†ä¼šäº§ç”Ÿå¦ä¸€ä¸ªé—®é¢˜ï¼šåœ†å½¢å›¾åƒç°åœ¨ä¼šæ‰©å±•åˆ°æ•´ä¸ªå±å¹•å¤§å°ï¼Œå¹¶ä¸”ä¼šè°ƒæ•´å…¶ä»– UI å…ƒç´ çš„å¤§å°æ¥åŒ¹é…å›¾åƒå¤§å°ã€‚ ä½ éœ€è¦è°ƒæ•´åœ†åœˆå›¾åƒçš„å¤§å°ï¼Œä»¥ä¾¿åªæœ‰åœ†åœˆå’Œåœ°æ ‡åç§°å‡ºç°åœ¨å±å¹•ä¸Šã€‚",
      "tips": ""
    },
    "Follow the steps to build this project, or download the finished project to explore on your own.": {
      "zh": "æŒ‰ç…§æ­¥éª¤ç¼–è¯‘æ­¤é¡¹ç›®ï¼Œæˆ–ä¸‹è½½å®Œæˆçš„é¡¹ç›®æ¥è‡ªè¡Œæ¢ç´¢ã€‚",
      "tips": ""
    },
    "Be sure to provide the model data as an environment object to the preview. The LandmarksApp already provides this at the app level at run time, just as it does for iOS, but you also have to provide it for any previews that need it.": {
      "zh": "è¯·ç¡®ä¿å°†æ¨¡å‹æ•°æ®ä½œä¸ºç¯å¢ƒå¯¹è±¡æä¾›ç»™é¢„è§ˆã€‚ LandmarksApp å·²åœ¨è¿è¡Œæ—¶åœ¨åº”ç”¨ç¨‹åºçº§åˆ«æä¾›æ­¤åŠŸèƒ½ï¼Œå°±åƒå®ƒåœ¨ iOS å¹³å°æ‰€åšçš„é‚£æ ·ï¼Œä½†æ˜¯ä½ è¿˜æ˜¯å¿…é¡»è¦åœ¨é¢„è§ˆä¸­æä¾›å®ƒï¼Œè®©éœ€è¦çš„å®ƒçš„è§†å›¾èƒ½å¤Ÿæ­£ç¡®é¢„è§ˆã€‚",
      "tips": ""
    },
    "In the preview, create an instance of the model data, and use it to pass a landmark object to the LandmarkDetail structureâ€™s initializer. You also need to set the viewâ€™s environment object.": {
      "zh": "åœ¨é¢„è§ˆä¸­ï¼Œåˆ›å»ºæ¨¡å‹æ•°æ®çš„å®ä¾‹ï¼Œå¹¶ä½¿ç”¨å®ƒå°†åœ°æ ‡å¯¹è±¡ä¼ é€’ç»™ LandmarkDetail ç»“æ„ä½“æ¥åˆå§‹åŒ–ã€‚ ä½ è¿˜éœ€è¦è®¾ç½®è§†å›¾çš„ç¯å¢ƒå¯¹è±¡ã€‚",
      "tips": ""
    },
    "These properties store values about an incoming notification.": {
      "zh": "è¿™äº›å±æ€§å­˜å‚¨æ¶ˆæ¯é€šçŸ¥ç›¸å…³çš„å€¼ã€‚",
      "tips": ""
    },
    "Youâ€™ll replace this in the next step.": {
      "zh": "ä½ å°†åœ¨ä¸‹ä¸€æ­¥ä¸­æ›¿æ¢å®ƒã€‚",
      "tips": ""
    },
    "This method instantiates the notification view that you created earlier.": {
      "zh": "è¿™ä¸ªæ–¹æ³•å®ä¾‹åŒ–ä½ ä¹‹å‰åˆ›å»ºçš„é€šçŸ¥è§†å›¾ã€‚",
      "tips": ""
    },
    "Start the live preview to check out how the app behaves.": {
      "zh": "å¯åŠ¨å®æ—¶é¢„è§ˆæ£€æŸ¥åº”ç”¨ç¨‹åºçš„è¡Œä¸ºã€‚",
      "tips": ""
    },
    "In the sheet, enter WatchLandmarks as the Product Name. Set the Interface to SwiftUI, the Life Cycle to SwiftUI App, and the Language to Swift. Select the Include Notification Scene checkbox, and then click Finish.": {
      "zh": "åœ¨å·¥ä½œè¡¨ä¸­ï¼Œè¾“å…¥ WatchLandmarks ä½œä¸ºäº§å“åç§°ã€‚ å°†ç•Œé¢æ¡†æ¶è®¾ç½®ä¸º SwiftUIï¼Œå°†åº”ç”¨ç”Ÿå‘½å‘¨æœŸè®¾ç½®ä¸º SwiftUI åº”ç”¨ç¨‹åºï¼Œå¹¶å°†è¯­è¨€è®¾ç½®ä¸º Swiftã€‚ é€‰ä¸­åŒ…å«é€šçŸ¥åœºæ™¯ï¼Œç„¶åå•å‡»å®Œæˆã€‚",
      "tips": ""
    },
    "Select the WatchLandmarks scheme.": {
      "zh": "é€‰æ‹© WatchLandmarks æ–¹æ¡ˆã€‚",
      "tips": ""
    },
    "This makes the symbols you selected in the previous steps available to your watchOS app.": {
      "zh": "è¿™å°†ä½¿ä½ åœ¨å‰é¢çš„æ­¥éª¤ä¸­é€‰æ‹©çš„ç¬¦å·å¯ç”¨äºä½ çš„ watchOS åº”ç”¨ç¨‹åºã€‚",
      "tips": ""
    },
    "Open the NotificationController and add the landmark, title, and message properties.": {
      "zh": "æ‰“å¼€ NotificationController å¹¶æ·»åŠ åœ°æ ‡ã€æ ‡é¢˜å’Œæ¶ˆæ¯å±æ€§ã€‚",
      "tips": ""
    },
    "Section 5": {
      "zh": "ç¬¬ 5 èŠ‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "æ­¥éª¤ 2",
      "tips": ""
    },
    "With the watchOS target set, youâ€™ll need to share some resources from the iOS target. Youâ€™ll reuse the Landmark appâ€™s data model, some resource files, as well as any views that both platforms can display without modification.": {
      "zh": "è®¾ç½® watchOS ç›®æ ‡åï¼Œä½ éœ€è¦ä» iOS ç›®æ ‡å…±äº«ä¸€äº›èµ„æºã€‚ ä½ å°†é‡ç”¨ Landmark åº”ç”¨ç¨‹åºçš„æ•°æ®æ¨¡å‹ã€ä¸€äº›èµ„æºæ–‡ä»¶ï¼Œä»¥åŠä»»ä½•ä¸€ä¸ªæ— éœ€ä¿®æ”¹å³å¯åœ¨ä¸¤ä¸ªå¹³å°æ˜¾ç¤ºçš„è§†å›¾ã€‚",
      "tips": ""
    },
    "Add the modelData, landmark, and landmarkIndex properties to to the new LandmarkDetail structure.": {
      "zh": "å°† modelDataã€landmark å’Œ landmarkIndex å±æ€§æ·»åŠ åˆ°æ–°çš„ LandmarkDetail ç»“æ„ä½“ä¸­ã€‚",
      "tips": ""
    },
    "Creating a watchOS App": {
      "zh": "",
      "tips": ""
    },
    "These items define the appâ€™s data model. You wonâ€™t use all aspects of the model, but you need all of the files to successfully compile the app.": {
      "zh": "è¿™äº›é¡¹ç›®å®šä¹‰äº†åº”ç”¨ç¨‹åºçš„æ•°æ®æ¨¡å‹ã€‚ ä½ ä¸ä¼šä½¿ç”¨æ¨¡å‹çš„æ‰€æœ‰æ•°æ®ï¼Œä½†ä½ éœ€è¦æ‰€æœ‰æ–‡ä»¶æ‰èƒ½æˆåŠŸç¼–è¯‘åº”ç”¨ç¨‹åºã€‚",
      "tips": ""
    },
    "Your version of Landmarks for watchOS is almost complete. In this final section, youâ€™ll create a notification interface that displays landmark information whenever you receive a notification indicating that you are close to one of your favorite locations.": {
      "zh": "ä½ çš„ watchOS ç‰ˆæœ¬çš„ Landmarks åº”ç”¨å‡ ä¹å®Œæˆäº†ã€‚åœ¨æœ€åè¿™ä¸€éƒ¨åˆ†ï¼Œä½ å°†åˆ›å»ºä¸€ä¸ªé€šçŸ¥ç•Œé¢ï¼Œæ¯å½“æ”¶åˆ°é€šçŸ¥è¡¨ç¤ºä½ é è¿‘æŸä¸ªå–œæ¬¢çš„åœ°ç‚¹æ—¶ï¼Œå®ƒä¼šæ˜¾ç¤ºåœ°æ ‡ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Wrap the vertical stack in a scroll view.": {
      "zh": "å°†å‚ç›´å †æ ˆåŒ…è£…åœ¨æ»šåŠ¨è§†å›¾ä¸­ã€‚",
      "tips": ""
    },
    "Return a CircleImage view from the body() method.": {
      "zh": "ä» body() æ–¹æ³•è¿”å›ä¸€ä¸ª CircleImage è§†å›¾ã€‚",
      "tips": ""
    },
    "Embed the circle image in a VStack. Display the landmark name and its information below the image.": {
      "zh": "å°†åœ†å½¢å›¾åƒåµŒå…¥åˆ° VStack ä¸­ã€‚ åœ¨å›¾åƒä¸‹æ–¹æ˜¾ç¤ºåœ°æ ‡åç§°åŠå…¶ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Update the body() method to use these properties.": {
      "zh": "æ›´æ–° body() æ–¹æ³•æ¥ä½¿ç”¨è¿™äº›å±æ€§ã€‚",
      "tips": ""
    },
    "The payload file simulates data sent from your server in a remote notification.": {
      "zh": "è´Ÿè½½æ–‡ä»¶æ¨¡æ‹Ÿä»ä½ çš„æœåŠ¡å™¨åœ¨è¿œç¨‹é€šçŸ¥ä¸­å‘é€çš„æ•°æ®ã€‚",
      "tips": ""
    },
    "Select the PushNotificationPayload.apns file, and update the title, body, category, and landmarkIndex properties. Be sure to set category to LandmarkNear. You also delete any keys that are not used in the tutorial, such as the subtitle, WatchKit Simulator Actions, and customKey.": {
      "zh": "é€‰æ‹© PushNotificationPayload.apns æ–‡ä»¶ï¼Œå¹¶æ›´æ–° title ã€ body ã€ category å’Œ landmarkIndex å±æ€§ã€‚è¯·åŠ¡å¿…å°† category è®¾ç½®ä¸º LandmarkNear ã€‚ä½ è¿˜éœ€è¦åˆ é™¤æ•™ç¨‹ä¸­æœªä½¿ç”¨çš„å…¶ä»–çš„é”®ï¼Œä¾‹å¦‚ subtitle ã€ WatchKit Simulator Actions å’Œ customKey ã€‚",
      "tips": ""
    },
    "This lets you build and run your watchOS app.": {
      "zh": "è¿™ä½¿ä½ å¯ä»¥ç¼–è¯‘å’Œè¿è¡Œ watchOS åº”ç”¨ç¨‹åºã€‚",
      "tips": ""
    },
    "Add the MapView after a divider.": {
      "zh": "åœ¨åˆ†éš”ç¬¦ä¹‹åæ·»åŠ  MapViewã€‚",
      "tips": ""
    },
    "Next select all the files, including the appâ€™s entry point, that your watchOS target can share with the existing iOS target.": {
      "zh": "æ¥ä¸‹æ¥é€‰æ‹© watchOS å¹³å°èƒ½å¤Ÿå’Œç°æœ‰ iOS å¹³å°å…±äº«çš„æ‰€æœ‰æ–‡ä»¶ï¼ŒåŒ…æ‹¬åº”ç”¨ç¨‹åºçš„å…¥å£ç‚¹ã€‚",
      "tips": ""
    },
    "Choose File > New > Target. When the template sheet appears, choose the watchOS tab, select the Watch App for iOS App template and click Next.": {
      "zh": "é€‰æ‹©  File > New > Targetã€‚ åœ¨é€‰é¡¹åˆ—è¡¨é€‰æ‹© watchOS é€‰é¡¹ï¼Œé€‰æ‹© Watch App for iOS App æ¨¡æ¿ï¼Œç„¶åå•å‡» Nextã€‚",
      "tips": ""
    },
    "Later, when you create a notification, the system presents your appâ€™s icon to help identify the source of the notification.": {
      "zh": "ç¨åï¼Œå½“ä½ åˆ›å»ºé€šçŸ¥æ—¶ï¼Œç³»ç»Ÿä¼šæ˜¾ç¤ºä½ åº”ç”¨çš„å›¾æ ‡ä»¥å¸®åŠ©ç”¨æˆ·è¯†åˆ«é€šçŸ¥çš„æ¥æºã€‚",
      "tips": ""
    },
    "Modify ContentView so that it displays the List view.": {
      "zh": "ä¿®æ”¹ ContentViewï¼Œä½¿å…¶æ˜¾ç¤ºåˆ—è¡¨è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "æ­¥éª¤ 4",
      "tips": ""
    },
    "Step 9": {
      "zh": "æ­¥éª¤ 9",
      "tips": ""
    },
    "Add a watchOS Target": {
      "zh": "æ·»åŠ  watchOS ç›®æ ‡",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ 3 èŠ‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "æ­¥éª¤ 1",
      "tips": ""
    },
    "Youâ€™re going to want to start with the WatchLandmarks scheme instead, which you choose next.": {
      "zh": "ä½ å°†è¦ä»æ¥ä¸‹æ¥é€‰æ‹©çš„ WatchLandmarks æ–¹æ¡ˆå¼€å§‹ã€‚",
      "tips": ""
    },
    "Update the didReceive(_:) method to parse data from the notification.": {
      "zh": "æ›´æ–° didReceive(_:) æ–¹æ³•æ¥è§£æé€šçŸ¥ä¸­çš„æ•°æ®ã€‚",
      "tips": ""
    },
    "This file is distinguished from the file with the same name in the iOS project by its target membership â€” it applies only to the Watch Extension target.": {
      "zh": "æ­¤æ–‡ä»¶é€šè¿‡é€‰æ‹©å…¶ Watch ç›®æ ‡æ¥å’Œ iOS é¡¹ç›®ä¸­å…·æœ‰ç›¸åŒåç§°çš„æ–‡ä»¶åŒºåˆ†å¼€æ¥ â€”â€” å®ƒä»…ä»…é€‚ç”¨äº Watch Extension ç›®æ ‡ã€‚",
      "tips": ""
    },
    "Select the Assets.xcasset file in the WatchLandmarks folder and delete the empty AppIcon item.": {
      "zh": "é€‰æ‹© WatchLandmarks æ–‡ä»¶å¤¹ä¸­çš„ Assets.xcasset æ–‡ä»¶å¹¶åˆ é™¤ç©ºçš„ AppIcon é¡¹ã€‚",
      "tips": ""
    },
    "Go to LandmarksApp.swift and add a WKNotificationScene using the LandmarkNear category.": {
      "zh": "è½¬åˆ° LandmarksApp.swift å¹¶ä½¿ç”¨ LandmarkNear ç±»åˆ«æ·»åŠ  WKNotificationSceneã€‚",
      "tips": ""
    },
    "The circle image resizes to fill the display. Unfortunately, this causes clipping. To fix the clipping problem, youâ€™ll embed the image in a VStack and make some additional layout changes so that the circle image fits any watch.": {
      "zh": "åœ†å½¢å›¾åƒè°ƒæ•´å¤§å°æ¥å¡«å……è§†å›¾ã€‚ ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¼šå¯¼è‡´å›¾ç‰‡è¢«è£å‰ªã€‚ è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½ éœ€è¦å°†å›¾åƒåµŒå…¥ VStack å¹¶è¿›è¡Œä¸€äº›é¢å¤–çš„å¸ƒå±€æ›´æ”¹ï¼Œä»¥ä¾¿åœ†å½¢å›¾åƒé€‚åˆä»»ä½•æ‰‹è¡¨ã€‚",
      "tips": ""
    },
    "If prompted by Xcode to activate the WatchLandmarks (Complication) scheme, click Cancel.": {
      "zh": "å¦‚æœ Xcode æç¤ºæ¿€æ´» WatchLandmarks (Complication) æ–¹æ¡ˆï¼Œè¯·å•å‡»å–æ¶ˆã€‚",
      "tips": ""
    },
    "This section only covers how to display the notification after you receive it. It doesnâ€™t describe how to set up or send notifications.": {
      "zh": "æœ¬èŠ‚ä»…ä»‹ç»å¦‚ä½•åœ¨æ”¶åˆ°é€šçŸ¥åæ˜¾ç¤ºé€šçŸ¥ã€‚ ä¸ä¼šä»‹ç»å¦‚ä½•è®¾ç½®æˆ–å‘é€é€šçŸ¥ã€‚",
      "tips": ""
    },
    "First, delete the entry point for the watchOS app. You donâ€™t need it because youâ€™ll reuse the entry point defined in LandmarksApp.swift instead.": {
      "zh": "é¦–å…ˆï¼Œåˆ é™¤ watchOS åº”ç”¨ç¨‹åºçš„å…¥å£ã€‚ ä½ ä¸éœ€è¦å®ƒï¼Œå› ä¸ºä½ å°†é‡ç”¨ LandmarksApp.swift ä¸­å®šä¹‰çš„å…¥å£ç‚¹ã€‚",
      "tips": ""
    }
  },
  "swiftui/creating-and-combining-views": {
    "By default, SwiftUI view files declare two structures. The first structure conforms to the View protocol and describes the viewâ€™s content and layout. The second structure declares a preview for that view.": {
      "zh": "é»˜è®¤æƒ…å†µä¸‹ï¼ŒSwiftUI è§†å›¾æ–‡ä»¶å£°æ˜ä¸¤ä¸ªç»“æ„ä½“ã€‚ç¬¬ä¸€ä¸ªç»“æ„ç¬¦åˆ View åè®®ï¼Œæè¿°äº†è§†å›¾çš„å†…å®¹å’Œå¸ƒå±€ã€‚ç¬¬äºŒä¸ªç»“æ„å£°æ˜è¯¥è§†å›¾çš„é¢„è§ˆæ ·å¼ã€‚",
      "tips": ""
    },
    "Create a new Xcode project that uses SwiftUI. Explore the canvas, previews, and the SwiftUI template code.": {
      "zh": "åˆ›å»ºä¸€ä¸ªä½¿ç”¨ SwiftUI æ¡†æ¶çš„æ–° Xcode é¡¹ç›®ã€‚é¦–å…ˆè¯•ç€æ‘¸ç´¢ä¸€ä¸‹ç”»å¸ƒã€é¢„è§ˆéƒ¨åˆ†å’Œ SwiftUI æä¾›çš„æ¨¡æ¿ä»£ç ã€‚",
      "tips": ""
    },
    "By prefixing a state variable with $, you pass a binding, which is like a reference to the underlying value. When the user interacts with the map, the map updates the region value to match the part of the map thatâ€™s currently visible in the user interface.": {
      "zh": "é€šè¿‡åœ¨çŠ¶æ€å˜é‡å‰åŠ ä¸Š $ å‰ç¼€ï¼Œæ‚¨å¯ä»¥ä¼ é€’ä¸€ä¸ªç»‘å®šå€¼ï¼Œå®ƒç±»ä¼¼äºå¯¹åŸå§‹å€¼çš„å¼•ç”¨ã€‚å½“ç”¨æˆ·ä¸åœ°å›¾è¿›è¡Œäº¤äº’æ—¶ï¼Œåœ°å›¾ä¼šæ ¹æ®ç•Œé¢ä¸­çœ‹åˆ°çš„åœ°å›¾åŒºåŸŸæ›´æ–°å®ƒç»‘å®šçš„åœ°åŒºå€¼ã€‚",
      "tips": ""
    },
    "Start by adding an image to the projectâ€™s asset catalog.": {
      "zh": "é¦–å…ˆå°†å›¾åƒæ·»åŠ åˆ°é¡¹ç›®çš„èµ„æºæ–‡ä»¶ç›®å½•ä¸­ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬ 6 æ­¥",
      "tips": ""
    },
    "Replace the text view with the image of Turtle Rock by using the Image(_:) initializer, passing it the name of the image to display.": {
      "zh": "ä½¿ç”¨ Image(_:) åˆå§‹åŒ–æ–¹æ³•å°†æ–‡æœ¬è§†å›¾æ›¿æ¢ä¸º Turtle Rock çš„å›¾åƒè§†å›¾ï¼Œå¹¶å°†è¦æ˜¾ç¤ºçš„å›¾åƒçš„åç§°ä¼ é€’ç»™å®ƒã€‚",
      "tips": ""
    },
    "Instead of adding more code in this file, youâ€™ll create a custom view that applies a mask, border, and drop shadow to the image.": {
      "zh": "ä¸éœ€è¦åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­æ·»åŠ æ›´å¤šçš„ä»£ç äº†ï¼Œä½ å°†åˆ›å»ºä¸€ä¸ªæ–°çš„è‡ªå®šä¹‰è§†å›¾ï¼Œè¿™ä¸ªè§†å›¾åŒ…å«ä¸€ä¸ªå›¾ç‰‡ï¼Œå¹¶ä¸”ä¼šç»™å›¾ç‰‡æ·»åŠ è’™ç‰ˆï¼Œè¾¹æ¡†ä»¥åŠæŠ•å½±ã€‚",
      "tips": ""
    },
    "Add the CircleImage view to the stack.": {
      "zh": "å°† CircleImage è§†å›¾æ·»åŠ åˆ°å †æ ˆã€‚",
      "tips": ""
    },
    "Replace the default Text view with a Map view that takes a binding to the region.": {
      "zh": "å°†é»˜è®¤çš„ Text è§†å›¾æ›¿æ¢æˆå¸¦åœ°åŒºç»‘å®šçš„ Map è§†å›¾ã€‚",
      "tips": ""
    },
    "You use the @State attribute to establish a source of truth for data in your app that you can modify from more than one view. SwiftUI manages the underlying storage and automatically updates views that depend on the value.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ @State å±æ€§ä¸ºä½ çš„åº”ç”¨ç¨‹åºå»ºç«‹çœŸå®çš„æ•°æ®æ¥æºï¼Œéšåå¯ä»¥ä»å¤šä¸ªè§†å›¾ä¸­ä¿®æ”¹è¿™äº›æ•°æ®ã€‚ SwiftUI ç®¡ç†åº•å±‚å­˜å‚¨é€»è¾‘å¹¶ä¸”èƒ½å¤Ÿè‡ªåŠ¨åˆ·æ–°ä¾èµ–è¿™äº›å€¼çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "Download the project files to begin building this project, and follow the steps below.": {
      "zh": "ä¸‹è½½å·¥ç¨‹æ–‡ä»¶æ¥å¼€å§‹æ„å»ºæ­¤é¡¹ç›®ï¼Œå¹¶æŒ‰ç…§ä»¥ä¸‹çš„æ­¥éª¤æ“ä½œã€‚",
      "tips": ""
    },
    "Customize the location to match the desired layout.": {
      "zh": "è°ƒæ•´ä½ç½®æ¥åŒ¹é…æˆ‘ä»¬éœ€è¦çš„å¸ƒå±€ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "ç¬¬ 8 æ­¥",
      "tips": ""
    },
    "Add your custom MapView to the top of the stack. Set the size of the MapView with frame(width:height:).": {
      "zh": "å°†ä½ è‡ªå®šä¹‰çš„ MapView æ·»åŠ åˆ°å †æ ˆçš„é¡¶éƒ¨ã€‚ä½¿ç”¨ frame(width:height:) è®¾ç½® MapView çš„å¤§å°ã€‚",
      "tips": ""
    },
    "When you specify only the height parameter, the view automatically sizes to the width of its content. In this case, MapView expands to fill the available space.": {
      "zh": "å½“ä½ ä»…æŒ‡å®šäº† height å‚æ•°æ—¶ï¼Œè§†å›¾ä¼šæ ¹æ®å†…å®¹çš„å®½åº¦è‡ªé€‚åº”å¤§å°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ MapView ä¼šè‡ªåŠ¨æ‰©å±•å¡«æ»¡èƒ½å¤Ÿå æ®çš„ç©ºé—´ã€‚",
      "tips": ""
    },
    "By default, stacks center their contents along their axis and provide context-appropriate spacing.": {
      "zh": "é»˜è®¤æƒ…å†µä¸‹ï¼Œå‚ç›´å †æ ˆä¼šå°†å†…å®¹å±…ä¸­å¯¹é½ï¼Œå¹¶æ ¹æ®å†…å®¹æä¾›ä¸€ä¸ªåˆé€‚çš„é»˜è®¤é—´è·ã€‚",
      "tips": ""
    },
    "Next, youâ€™ll add a text view to the stack by dragging a Text view from the library.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œå°†é€šè¿‡ä»æ§ä»¶åº“ä¸­æ‹–åŠ¨ Text è§†å›¾çš„æ–¹å¼æ¥å°†æ–‡æœ¬è§†å›¾æ·»åŠ åˆ°å †æ ˆä¸­ã€‚",
      "tips": ""
    },
    "Use SwiftUI Views From Other Frameworks": {
      "zh": "ä½¿ç”¨æ¥è‡ªå…¶ä»–æ¡†æ¶çš„ swiftUI è§†å›¾",
      "tips": ""
    },
    "Create another circle with a gray stroke, and then add it as an overlay to give the image a border.": {
      "zh": "åˆ›å»ºå¦ä¸€ä¸ªå¸¦ç°è‰²æè¾¹çš„åœ†å½¢ï¼Œç„¶åå°†å®ƒä½œä¸ºå›¾ç‰‡çš„è¦†ç›–å±‚ï¼Œè¿™æ ·ç›¸å½“äºç»™å›¾ç‰‡æ·»åŠ è¾¹æ¡†ã€‚",
      "tips": ""
    },
    "Inside the body property, change â€œHello, World!â€ to a greeting for yourself.": {
      "zh": "åœ¨ body å±æ€§ä¸­ï¼Œè¯•ç€ä¿®æ”¹â€œHello, World!â€æ¥ç»™è‡ªå·±ä¸€ä¸ªé—®å€™å§ï¼",
      "tips": ""
    },
    "Combine Views Using Stacks": {
      "zh": "ä½¿ç”¨å †æ ˆç»„åˆè§†å›¾",
      "tips": ""
    },
    "In the canvas, click Resume to display the preview.": {
      "zh": "åœ¨å³è¾¹çš„ç”»å¸ƒä¸­ï¼Œç‚¹å‡» Resume æ¥æ˜¾ç¤ºç¨‹åºçš„é¢„è§ˆæ•ˆæœã€‚",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ 1 èŠ‚",
      "tips": ""
    },
    "Next, add a shadow with a 7 point radius.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œæ·»åŠ ä¸€ä¸ªåŠå¾„ä¸º 7 ç‚¹çš„é˜´å½±ã€‚",
      "tips": ""
    },
    "This time, open the inspector by Command-clicking on the Text declaration in the code editor, and then choose â€œShow SwiftUI Inspectorâ€ from the popover. Click the Color pop-up menu and choose Inherited to change the text color to black again.": {
      "zh": "è¿™ä¸€æ¬¡ï¼Œé€šè¿‡åœ¨ä»£ç ç¼–è¾‘å™¨ä¸­æŒ‰ä½ Command é”®å¹¶å•å‡» Text å£°æ˜æ¥æ‰“å¼€æ£€æŸ¥å™¨ï¼Œç„¶åä»å¼¹å‡ºçª—å£ä¸­é€‰æ‹©â€œShow SwiftUI Inspectorâ€ã€‚ç‚¹å‡»é¢œè‰²å¼¹å‡ºèœå•å¹¶é€‰æ‹©ç»§æ‰¿ï¼ˆInspectorï¼‰ï¼Œè¿™æ ·å°±èƒ½å†æ¬¡å°†æ–‡æœ¬é¢œè‰²æ›´æ”¹ä¸ºé»‘è‰²ã€‚",
      "tips": ""
    },
    "Building Lists and Navigation": {
      "zh": "",
      "tips": ""
    },
    "Enter â€œLandmarksâ€ as the product name, select â€œSwiftUIâ€ for the interface and â€œSwiftâ€ for the language, and click Next. Choose a location to save the Landmarks project on your Mac.": {
      "zh": "è¾“å…¥â€œLandmarksâ€ä½œä¸ºäº§å“åç§°ï¼Œç•Œé¢é€‰æ‹©â€œSwiftUIâ€ï¼Œè¯­è¨€é€‰æ‹©â€œSwiftâ€ï¼Œç‚¹å‡»ä¸‹ä¸€æ­¥ã€‚åœ¨ Mac ä¸Šé€‰æ‹©ä¸€ä¸ªä½ç½®æ¥ä¿å­˜ Landmarks é¡¹ç›®ã€‚",
      "tips": ""
    },
    "In the template selector, select iOS as the platform, select the App template, and then click Next.": {
      "zh": "åœ¨æ¨¡æ¿é€‰æ‹©å™¨ä¸­ï¼Œé€‰æ‹© iOS ä½œä¸ºç¨‹åºè¿è¡Œçš„å¹³å°ï¼Œé€‰æ‹© Appï¼Œç„¶åå•å‡» Nextã€‚",
      "tips": ""
    },
    "Use the inspector to change the text to â€œTurtle Rockâ€, the name of the first landmark youâ€™ll show in your app.": {
      "zh": "ä½¿ç”¨æ£€æŸ¥å™¨å°†æ–‡å­—æ›´æ”¹ä¸ºâ€œTurtle Rockâ€ï¼Œè¿™æ˜¯åœ¨åº”ç”¨ä¸­å°†è¦æ˜¾ç¤ºçš„ç¬¬ä¸€ä¸ªåœ°æ ‡çš„åç§°ã€‚",
      "tips": ""
    },
    "Open Xcode and either click â€œCreate a new Xcode projectâ€ in Xcodeâ€™s startup window, or choose File > New > Project.": {
      "zh": "æ‰“å¼€ Xcodeï¼Œç„¶ååœ¨å¯åŠ¨çª—å£ä¸­ç‚¹å‡» â€œCreate a new Xcode projectâ€ï¼Œæˆ–è€…ç‚¹å‡»çŠ¶æ€æ ä¸­çš„ File > New > Projectã€‚",
      "tips": ""
    },
    "Set up business": {
      "zh": "åˆ›ä¸šï¼Œæ¥æ¥æ¥æ¥æ¥",
      "tips": ""
    },
    "In a moment, youâ€™ll see a map centered on Turtle Rock. You can manipulate the map in live preview to zoom out a bit and see the surrounding area.": {
      "zh": "å¾ˆå¿«ï¼Œä½ ä¼šçœ‹åˆ°ä»¥ Turtle Rock ä¸ºä¸­å¿ƒçš„åœ°å›¾ç•Œé¢ã€‚æ‚¨å¯ä»¥åœ¨å®æ—¶é¢„è§ˆä¸­æ“ä½œåœ°å›¾æ”¾å¤§ç¼©å°æˆ–è€…æŸ¥çœ‹å‘¨å›´åŒºåŸŸã€‚",
      "tips": ""
    },
    "As you change the code in a viewâ€™s body property, the preview updates to reflect your changes.": {
      "zh": "æ¯å½“ä½ ä¿®æ”¹ body å±æ€§é‡Œé¢çš„ä»£ç ï¼Œé¢„è§ˆç•Œé¢å°†ä¼šåŒæ­¥æ›´æ–°ä½ çš„ä¿®æ”¹ã€‚",
      "tips": ""
    },
    "A spacer expands to make its containing view use all of the space of its parent view, instead of having its size defined only by its contents.": {
      "zh": "Spacer ä¼šå°½å¯èƒ½çš„æ’‘å¼€å®ƒåœ¨çˆ¶è§†å›¾é‡Œé¢çš„ç©ºé—´ï¼Œè€Œä¸æ˜¯ç”±çˆ¶è§†å›¾é‡Œé¢çš„å†…å®¹å†³å®šçš„ã€‚",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Your code is always the source of truth for the view. When you use the inspector to change or remove a modifier, Xcode updates your code immediately to match.": {
      "zh": "è§†å›¾çš„ä¿®æ”¹å§‹ç»ˆæ¥æºäºä½ çš„ä»£ç ã€‚å½“ä½¿ç”¨æ£€æŸ¥å™¨æ›´æ”¹æˆ–åˆ é™¤ä¿®é¥°ç¬¦æ—¶ï¼ŒXcode ä¼šç«‹å³æ›´æ–°ä½ çš„æºä»£ç æ¥åŒ¹é…ä½ çš„ä¿®æ”¹ã€‚",
      "tips": ""
    },
    "When you apply a modifier to a layout view like a stack, SwiftUI applies the modifier to all the elements contained in the group.": {
      "zh": "å½“ä½ å°†ä¿®é¥°ç¬¦åº”ç”¨åˆ°å †æ ˆç­‰å¸ƒå±€è§†å›¾æ—¶ï¼ŒSwiftUI ä¼šå°†ä¿®é¥°ç¬¦åº”ç”¨åˆ°å †æ ˆä¸­åŒ…å«çš„æ‰€æœ‰å…ƒç´ ä¸Šã€‚",
      "tips": ""
    },
    "Edit the code by hand to change the padding() modifier to the foregroundColor(.green) modifier; this changes the textâ€™s color to green.": {
      "zh": "æ‰‹åŠ¨ç¼–è¾‘ä»£ç ï¼Œå°† padding() ä¿®é¥°ç¬¦æ”¹ä¸º foregroundColor(.green) ä¿®é¥°ç¬¦ï¼›è¿™ä¸ªæ“ä½œä¼šå°†æ–‡æœ¬çš„é¢œè‰²æ”¹ä¸ºç»¿è‰²ã€‚",
      "tips": ""
    },
    "Add an import statement for MapKit.": {
      "zh": "æ·»åŠ ä¸€è¡Œå¯¼å…¥ MapKit æ¡†æ¶çš„ä»£ç ",
      "tips": ""
    },
    "To preview and interact with views from the canvas in Xcode, and to use all the latest features described throughout the tutorials, ensure your Mac is running macOS Monterey or later.": {
      "zh": "è¦åœ¨ Xcode çš„ç”»å¸ƒä¸­é¢„è§ˆä»¥åŠå’Œè§†å›¾äº¤äº’ï¼Œè¿˜æœ‰ä½¿ç”¨æˆ‘ä»¬è¿™ä¸ªæ•™ç¨‹ä¸­æåˆ°çš„æœ€æ–°åŠŸèƒ½ï¼Œä½ éœ€è¦ä¿è¯ Mac è¿è¡Œçš„æ˜¯ macOS Monterey æˆ–è€…æ›´é«˜çš„ç‰ˆæœ¬ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ 3 æ­¥",
      "tips": ""
    },
    "When previews are in static mode, they only fully render native SwiftUI views. For the Map view, youâ€™ll need to switch to a live preview to see it render.": {
      "zh": "å½“é¢„è§ˆå¤„äºé™æ€æ¨¡å¼æ—¶ï¼Œå®ƒä»¬åªä¼šå‘ˆç°åŸç”Ÿ SwiftUI è§†å›¾ã€‚å¯¹äº Map è§†å›¾ï¼Œä½ éœ€è¦åˆ‡æ¢åˆ°å®æ—¶é¢„è§ˆæ¨¡å¼æ‰èƒ½çœ‹åˆ°å®ƒçš„æ¸²æŸ“æ•ˆæœã€‚",
      "tips": ""
    },
    "Customize the Text View": {
      "zh": "è‡ªå®šä¹‰æ–‡æœ¬è§†å›¾",
      "tips": ""
    },
    "The Circle type is a shape that you can use as a mask, or as a view by giving the circle a stroke or fill.": {
      "zh": "Circle ç±»å‹æ˜¯ä¸€ç§å½¢çŠ¶ï¼Œä½ å¯ä»¥å°†å®ƒç”¨ä½œé®ç½©ï¼Œä¹Ÿå¯ä»¥ç»™åœ†åœˆæ·»åŠ æè¾¹æˆ–å¡«å……æ¥ç”¨ä½œè§†å›¾ã€‚",
      "tips": ""
    },
    "In the Project navigator, select the ContentView.swift file.": {
      "zh": "åœ¨é¡¹ç›®å¯¼èˆªæ ä¸­ï¼Œé€‰æ‹© ContentView.swift æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬ 2 èŠ‚",
      "tips": ""
    },
    "Open the library by clicking the plus button (+) at the top-right of the Xcode window, and then drag a Text view to the place in your code immediately below the â€œTurtle Rockâ€ text view.": {
      "zh": "ç‚¹å‡» Xcode çª—å£å³ä¸Šè§’çš„åŠ å·æŒ‰é’® (+) æ‰“å¼€ç»„ä»¶åº“ï¼Œç„¶åå°† Text è§†å›¾æ‹–åˆ°ä»£ç ä¸­â€œTurtle Rockâ€æ–‡æœ¬è§†å›¾æ­£ä¸‹æ–¹çš„ä½ç½®ã€‚",
      "tips": ""
    },
    "Create a private state variable that holds the region information for the map.": {
      "zh": "åˆ›å»ºä¸€ä¸ªç§æœ‰çŠ¶æ€å˜é‡ï¼Œç”¨äºä¿å­˜åœ°å›¾çš„åŒºåŸŸä¿¡æ¯ã€‚",
      "tips": ""
    },
    "You now have all of the components you need â€” the name and place, a circular image, and a map for the location.": {
      "zh": "ä½ ç°åœ¨å·²ç»å‡†å¤‡å¥½äº†æ‰€æœ‰éœ€è¦çš„è§†å›¾ç»„ä»¶äº†ï¼Œåç§°ã€åœ°ç‚¹ã€ä¸€ä¸ªåœ†å½¢å›¾ç‰‡ï¼Œè¿˜æœ‰åœ°å›¾ã€‚",
      "tips": ""
    },
    "Add a spacer at the bottom of the outer VStack to push the content to the top of the screen.": {
      "zh": "åœ¨å¤–å±‚çš„ VStack åº•éƒ¨æ·»åŠ ä¸€ä¸ª Spacerï¼Œå°†æ•´ä½“å†…å®¹æ¨åˆ°å±å¹•çš„é¡¶éƒ¨ã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "ç¬¬ 10 æ­¥",
      "tips": ""
    },
    "To lay out the views, Landmarks uses stacks to combine and layer the image and text view components. To add a map to the view, youâ€™ll include a standard MapKit component. As you refine the viewâ€™s design, Xcode provides real-time feedback so you can see how those changes translate into code.": {
      "zh": "å¯¹äºç•Œé¢å¸ƒå±€ï¼ŒLandmarks ä½¿ç”¨å †æ ˆçš„æ–¹å¼æ¥ç»„åˆä»¥åŠå¸ƒå±€å›¾åƒå’Œæ–‡æœ¬ç»„ä»¶ã€‚å› ä¸ºç•Œé¢ä¸­æœ‰åœ°å›¾æ¨¡å—ï¼Œæ‰€ä»¥éœ€è¦æ·»åŠ ç³»ç»Ÿçš„ MapKit ç»„ä»¶ã€‚æ¯å½“ä½ é‡æ–°è°ƒæ•´ç•Œé¢çš„è®¾è®¡æ ·å¼æ—¶ï¼ŒXcode ä¼šæä¾›å®æ—¶åé¦ˆï¼Œå› æ­¤ä½ å¯ä»¥çœ‹åˆ°è¿™äº›ä¿®æ”¹æ˜¯å¦‚ä½•è½¬åŒ–æˆä¸ºä»£ç çš„ã€‚",
      "tips": ""
    },
    "Next, youâ€™ll add another text view to the right of the location, this for the parkâ€™s state.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†åœ¨å…¬å›­ä½ç½®æ–‡æœ¬çš„å³è¾¹æ·»åŠ å¦ä¸€ä¸ªæ–‡æœ¬ï¼Œè¿™æ˜¯å…¬å›­æ‰€å±çš„å·ã€‚",
      "tips": ""
    },
    "Section 4": {
      "zh": "ç¬¬ 4 èŠ‚",
      "tips": ""
    },
    "In the preview, Command-click the greeting to bring up the structured editing popover, and choose â€œShow SwiftUI Inspectorâ€.": {
      "zh": "åœ¨é¢„è§ˆç•Œé¢ä¸­ï¼ŒæŒ‰ä½ Command é”®å¹¶ç‚¹å‡»æ–‡å­—ä¼šå¼¹å‡ºä¸€ä¸ªç¼–è¾‘çª—å£ï¼Œç„¶åé€‰æ‹©â€œShow SwiftUI Inspectorâ€ã€‚",
      "tips": ""
    },
    "Next, youâ€™ll customize the text view using the inspector.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†ä½¿ç”¨æ£€æŸ¥å™¨è‡ªå®šä¹‰æ–‡æœ¬è§†å›¾ã€‚",
      "tips": ""
    },
    "When you import SwiftUI and certain other frameworks in the same file, you gain access to SwiftUI-specific functionality provided by that framework.": {
      "zh": "å½“ä½ åœ¨åŒä¸€æ–‡ä»¶ä¸­å¯¼å…¥ SwiftUI å’ŒæŸäº›å…¶ä»–æ¡†æ¶æ—¶ï¼Œä½ å¯ä»¥è®¿é—®è¿™ä¸ªæ¡†æ¶æä¾›ç»™ SwiftUI çš„ç‰¹å®šçš„åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "You can use Xcodeâ€™s structured editing support to embed a view in a container view, open an inspector, or help with other useful changes.": {
      "zh": "æ‚¨å¯ä»¥ä½¿ç”¨ Xcode çš„å¿«é€Ÿç¼–è¾‘åŠŸèƒ½ï¼Œ å®ƒå¯ä»¥åµŒå…¥è§†å›¾åˆ°å½“å‰å®¹å™¨ï¼Œæ‰“å¼€æ£€æŸ¥å™¨æˆ–å¸®åŠ©ä½ è¿›è¡Œå…¶ä»–çš„ä¿®æ”¹ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ 7 æ­¥",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬ 5 æ­¥",
      "tips": ""
    },
    "Add a divider and some additional descriptive text for the landmark.": {
      "zh": "ç»™åœ°æ ‡æ·»åŠ åˆ†éš”çº¿å’Œä¸€äº›å…¶å®ƒçš„æè¿°ã€‚",
      "tips": ""
    },
    "Change the Font modifier to â€œTitleâ€.": {
      "zh": "é€‰æ‹©å­—ä½“ä¿®é¥°ç¬¦ï¼Œä¿®æ”¹ä¸ºâ€œTitleâ€ã€‚",
      "tips": ""
    },
    "Finally, use the padding() modifier method to give the landmarkâ€™s name and details a little more space.": {
      "zh": "æœ€åï¼Œä½¿ç”¨ padding() ä¿®é¥°ç¬¦æ–¹æ³•ç»™åœ°æ ‡çš„åç§°å’Œç»†èŠ‚ä¸€äº›å†…è¾¹è·ã€‚",
      "tips": ""
    },
    "An app that uses the SwiftUI app life cycle has a structure that conforms to the App protocol. The structureâ€™s body property returns one or more scenes, which in turn provide content for display. The @main attribute identifies the appâ€™s entry point.": {
      "zh": "ä½¿ç”¨ SwiftUI æ¡†æ¶çš„åº”ç”¨ç¨‹åºåº”è¯¥å…·æœ‰ä¸€ä¸ªéµå¾ª App åè®®çš„ç»“æ„ä½“ã€‚ç»“æ„ä½“çš„ body å±æ€§è¿”å›ä¸€ä¸ªæˆ–è€…å¤šä¸ªåœºæ™¯ï¼ˆSceneï¼‰ï¼Œè¿™äº›åœºæ™¯æä¾›å†…å®¹ä»¥ä¾›æ˜¾ç¤ºã€‚ @main å±æ€§æ ‡è¯†åº”ç”¨ç¨‹åºçš„å…¥å£ã€‚",
      "tips": ""
    },
    "Set the locationâ€™s font to subheadline.": {
      "zh": "å°†ä½ç½®çš„å­—ä½“è®¾ç½®ä¸º subheadline ã€‚",
      "tips": ""
    },
    "Add a call to clipShape(Circle()) to apply the circular clipping shape to the image.": {
      "zh": "æ·»åŠ  clipShape(Circle()) ï¼Œå°†å›¾ç‰‡è£å‰ªæˆåœ†å½¢ã€‚",
      "tips": ""
    },
    "To layer the image view on top of the map view, give the image an offset of -130 points vertically, and padding of -130 points from the bottom of the view.": {
      "zh": "è¦ä½¿å›¾ç‰‡ç›–åœ¨åœ°å›¾ä¹‹ä¸Šï¼Œä½ éœ€è¦ç»™å›¾åƒæä¾› -130 å•ä½çš„å‚ç›´åç§»ï¼Œä¹Ÿå°±æ˜¯è®©å®ƒå¾€ä¸Šåç§» 130 ä¸ªå•ä½ï¼Œå¹¶ä¸”å°†å®ƒè·ç¦»åº•éƒ¨çš„é—´è·è°ƒæ•´ä¸º -130 å•ä½ã€‚",
      "tips": ""
    },
    "Choose File > New > File, select iOS as the platform, select the â€œSwiftUI Viewâ€ template, and click Next. Name the new file MapView.swift and click Create.": {
      "zh": "é€‰æ‹© File > New > Fileï¼Œé€‰æ‹© iOS ä½œä¸ºå¹³å°ï¼Œé€‰æ‹©â€œSwiftUI Viewâ€æ¨¡æ¿ï¼Œç‚¹å‡» Nextã€‚å°†æ–°æ–‡ä»¶å‘½åä¸º MapView.swift ï¼Œç„¶åç‚¹å‡»â€œåˆ›å»ºâ€ã€‚",
      "tips": ""
    },
    "Tip": {
      "zh": "æç¤º",
      "tips": ""
    },
    "Next, youâ€™ll create a new SwiftUI view for your custom image view.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†åˆ›å»ºä¸€ä¸ªæ–°çš„ SwiftUI è§†å›¾ç”¨æ¥è‡ªå®šä¹‰å›¾ç‰‡ã€‚",
      "tips": ""
    },
    "Embed the VStack that holds the three text views in another VStack.": {
      "zh": "å°†åŒ…å«ä¸‰ä¸ªæ–‡æœ¬è§†å›¾çš„ VStack åµŒå…¥åˆ°å¦ä¸€ä¸ª VStack ä¸­ã€‚",
      "tips": ""
    },
    "This completes the image view.": {
      "zh": "è¿™æ ·å°±å®Œæˆäº†è¿™ä¸ªå›¾ç‰‡è§†å›¾",
      "tips": ""
    },
    "Create a Custom Image View": {
      "zh": "åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰çš„å›¾ç‰‡è§†å›¾",
      "tips": ""
    },
    "This is a new key": {
      "zh": "",
      "tips": ""
    },
    "Replace the Text viewâ€™s placeholder text with â€œJoshua Tree National Parkâ€.": {
      "zh": "å°† Text è§†å›¾çš„é»˜è®¤å ä½æ–‡æœ¬æ›¿æ¢ä¸ºâ€œJoshua Tree National Parkâ€ã€‚",
      "tips": ""
    },
    "In this section, youâ€™ll use a vertical stack to place the title above a horizontal stack that contains details about the park.": {
      "zh": "åœ¨æœ¬èŠ‚ä¸­ï¼Œä½ å°†ä½¿ç”¨å‚ç›´å †æ ˆå°†æ ‡é¢˜æ”¾åœ¨åŒ…å«å…¬å›­ä¿¡æ¯çš„æ°´å¹³å †æ ˆä¸Šæ–¹ã€‚",
      "tips": ""
    },
    "Creating and combining views": {
      "zh": "",
      "tips": ""
    },
    "Next youâ€™ll create a map that centers on a given coordinate. You can use the Map view from MapKit to render the map.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†åˆ›å»ºä¸€ä¸ªä»¥ç»™å®šåæ ‡ä¸ºä¸­å¿ƒçš„åœ°å›¾ã€‚ä½ å¯ä»¥ä½¿ç”¨ MapKit ä¸­çš„åœ°å›¾è§†å›¾æ¥è¿›è¡Œæ¸²æŸ“å±•ç¤ºã€‚",
      "tips": ""
    },
    "When creating a SwiftUI view, you describe its content, layout, and behavior in the viewâ€™s body property; however, the body property only returns a single view. You can combine and embed multiple views in stacks, which group views together horizontally, vertically, or back-to-front.": {
      "zh": "åˆ›å»º SwiftUI è§†å›¾æ—¶ï¼Œä½ ä¼šåœ¨è§†å›¾çš„ body å±æ€§ä¸­æè¿°å…¶å†…å®¹ã€å¸ƒå±€å’Œè¡Œä¸ºã€‚ä½†æ˜¯ï¼Œ body å±æ€§åªèƒ½è¿”å›ä¸€ä¸ªè§†å›¾ã€‚å› æ­¤ä½ å¯ä»¥åœ¨å †æ ˆä¸­ç»„åˆä»¥åŠåµŒå…¥å¤šä¸ªè§†å›¾ï¼Œè¿™äº›è§†å›¾ä»¥æ°´å¹³æ’åˆ—ã€å‚ç›´æ’åˆ—æˆ–å‰åå †å çš„æ–¹å¼ç»„åˆåœ¨ä¸€èµ·ã€‚",
      "tips": ""
    },
    "These adjustments make room for the text by moving the image upwards.": {
      "zh": "å‘ä¸Šè°ƒæ•´å›¾ç‰‡æ¥ä¸ºæ–‡æœ¬è…¾å‡ºç©ºé—´ã€‚",
      "tips": ""
    },
    "In the Project navigator, select LandmarksApp.swift.": {
      "zh": "åœ¨å·¦ä¾§çš„é¡¹ç›®å¯¼èˆªæ ä¸­ï¼Œç‚¹å‡» LandmarksApp.swift æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "The popover shows different attributes that you can customize, depending on the type of view you inspect.": {
      "zh": "å¼¹çª—ä¼šæ ¹æ®ä½ é€‰æ‹©çš„è§†å›¾ç±»å‹å±•ç¤ºä¸åŒçš„å±æ€§ä¾›ä½ è°ƒæ•´ã€‚",
      "tips": ""
    },
    "Find turtlerock@2x.jpg in the project filesâ€™ Resources folder; drag it into the asset catalogâ€™s editor. Xcode creates a new image set for the image.": {
      "zh": "åœ¨é¡¹ç›®æ–‡ä»¶çš„ Resources æ–‡ä»¶å¤¹ä¸­æ‰¾åˆ° turtlerock@2x.jpgï¼Œå°†å®ƒæ‹–åˆ°èµ„æºç›®å½•ä¸­ã€‚ Xcode ä¼šä¸ºå›¾ç‰‡è‡ªåŠ¨åˆ›å»ºä¸€ä¸ªæ–°çš„å›¾åƒé›†åˆã€‚",
      "tips": ""
    },
    "Command-click the text viewâ€™s initializer to show the structured editing popover, and then choose â€œEmbed in VStackâ€.": {
      "zh": "æŒ‰ä½ Command é”®å¹¶ç‚¹å‡»æ–‡æœ¬è§†å›¾çš„åˆå§‹åŒ–æ–¹æ³•ï¼Œç„¶ååœ¨å¼¹çª—ä¸­é€‰æ‹©â€œEmbed in VStackâ€ã€‚",
      "tips": ""
    },
    "With the name and location views all set, the next step is to add an image for the landmark.": {
      "zh": "åç§°å’Œä½ç½®è§†å›¾éƒ½è®¾ç½®å¥½åï¼Œä¸‹ä¸€æ­¥æ˜¯ä¸ºåœ°æ ‡æ·»åŠ å›¾åƒã€‚",
      "tips": ""
    },
    "As you build the Landmarks app, you can use any combination of editors: the source editor, the canvas, or the inspectors. Your code stays updated, regardless of which tool you use.": {
      "zh": "åœ¨æ„å»º Landmarks åº”ç”¨ç¨‹åºæ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨ä»»æ„ç»„åˆçš„ç¼–è¾‘å™¨ï¼šæºä»£ç ç¼–è¾‘å™¨ã€ç”»å¸ƒæˆ–æ£€æŸ¥å™¨ã€‚æ— è®ºä½ ä½¿ç”¨å“ªç§å·¥å…·ä¿®æ”¹ï¼Œä½ çš„ä»£ç éƒ½ä¼šä¿æŒåŒæ­¥åˆ°æœ€æ–°ç‰ˆæœ¬ã€‚",
      "tips": ""
    },
    "You can continue editing the view while showing a Live Preview.": {
      "zh": "ä½ å¯ä»¥åœ¨æ˜¾ç¤ºå®æ—¶é¢„è§ˆçš„åŒæ—¶ç»§ç»­ç¼–è¾‘è§†å›¾ã€‚",
      "tips": ""
    },
    "Section 5": {
      "zh": "ç¬¬ 5 èŠ‚",
      "tips": ""
    },
    "Section 6": {
      "zh": "ç¬¬ 6 èŠ‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬ 2 æ­¥",
      "tips": ""
    },
    "Youâ€™re ready to insert the image and modify its display to match the desired design.": {
      "zh": "ä½ å·²ç»åšå¥½äº†å‡†å¤‡ï¼Œæ¥ä¸‹æ¥å°±æ˜¯æ’å…¥å›¾ç‰‡ï¼Œç„¶åä¿®æ”¹å›¾ç‰‡æˆè®¾è®¡çš„æ•ˆæœã€‚",
      "tips": ""
    },
    "You can customize a viewâ€™s display by changing your code, or by using the inspector to discover whatâ€™s available and to help you write code.": {
      "zh": "ä½ å¯ä»¥å°è¯•è‡ªå·±ä¿®æ”¹ä»£ç è‡ªå®šä¹‰ç•Œé¢å±•ç¤ºï¼Œæˆ–è€…ä½¿ç”¨æ£€æŸ¥å™¨(inspector)æ¥æ¢ç´¢æœ‰å“ªäº›å¯ç”¨çš„å±æ€§ã€‚",
      "tips": ""
    },
    "If the canvas isnâ€™t visible, select Editor > Canvas to show it.": {
      "zh": "å¦‚æœæ²¡æœ‰çœ‹åˆ°ç”»å¸ƒï¼Œç‚¹å‡»çŠ¶æ€æ ä¸­çš„ Editor > Canvas è®©ç”»å¸ƒæ˜¾ç¤ºã€‚",
      "tips": ""
    },
    "Switch the border color to white.": {
      "zh": "å°†è¾¹æ¡†é¢œè‰²åˆ‡æ¢æˆç™½è‰²",
      "tips": ""
    },
    "Edit the VStack initializer to align the views by their leading edges.": {
      "zh": "ç¼–è¾‘ VStack åˆå§‹åŒ–æ–¹æ³•ï¼Œè®©æ–‡æœ¬å±…å·¦å¯¹é½ã€‚",
      "tips": ""
    },
    "In the canvas, Command-click â€œJoshua Tree National Parkâ€, and choose â€œEmbed in HStackâ€.": {
      "zh": "åœ¨ç”»å¸ƒä¸­ï¼ŒæŒ‰ä½ Command é”®å¹¶å•å‡»â€œJoshua Tree National Parkâ€ï¼Œç„¶åé€‰æ‹©â€œEmbed in HStackâ€ã€‚",
      "tips": ""
    },
    "Click Live Preview to switch the preview to live mode. You might need to click Try Again or Resume above your preview.": {
      "zh": "å•å‡»å®æ—¶é¢„è§ˆå°†é¢„è§ˆåˆ‡æ¢ä¸ºå®æ—¶æ¨¡å¼ã€‚å¦‚æœæ²¡èƒ½æˆåŠŸï¼Œä½ å¯ä»¥ç‚¹å‡»é¢„è§ˆä¸Šæ–¹çš„â€œTry Againâ€æˆ–â€œResumeâ€å¤šè¯•å‡ æ¬¡ã€‚",
      "tips": ""
    },
    "To direct the layout to use the full width of the device, separate the park and the state by adding a Spacer to the horizontal stack holding the two text views.": {
      "zh": "è¦è®©ç•Œé¢æŒ‰ç…§æ•´ä¸ªè®¾å¤‡çš„å®½åº¦æ¥å¸ƒå±€ï¼Œä½ å¯ä»¥é€šè¿‡å°† Spacer æ’å…¥åˆ°ä¸¤ä¸ªæ–‡æœ¬çš„ä¸­é—´ï¼Œè¿™æ ·æ°´å¹³æ–¹å‘ä¸Šçš„å¸ƒå±€å°±ä¼šç”¨é—´è·åˆ†éš”å…¬å›­å’Œæ‰€å±çš„å·ã€‚",
      "tips": ""
    },
    "Compose the Detail View": {
      "zh": "å°†è§†å›¾æ•´åˆæˆè¯¦æƒ…ç•Œé¢",
      "tips": ""
    },
    "Beyond the title view you created in the previous section, youâ€™ll add text views to contain details about the landmark, such as the name of the park and state itâ€™s in.": {
      "zh": "é™¤äº†åœ¨ä¸Šä¸€èŠ‚ä¸­åˆ›å»ºçš„æ ‡é¢˜è§†å›¾ä¹‹å¤–ï¼Œä½ è¿˜å°†æ·»åŠ åŒ…å«æœ‰å…³åœ°æ ‡çš„æ–‡æœ¬è§†å›¾ï¼Œä¾‹å¦‚å…¬å›­çš„åç§°å’Œå®ƒæ‰€åœ¨çš„å·ã€‚",
      "tips": ""
    },
    "With the tools youâ€™ve used so far, combine your custom views to create the final design for the landmark detail view.": {
      "zh": "åˆ©ç”¨ä½ å‰é¢ä½¿ç”¨åˆ°çš„å·¥å…·ï¼Œç»„åˆä½ çš„è‡ªå®šä¹‰çš„è§†å›¾ç„¶åæ„å»ºæœ€ç»ˆçš„åœ°æ ‡ç•Œé¢å§ã€‚",
      "tips": ""
    },
    "To get started, youâ€™ll create a new custom view to manage your map.": {
      "zh": "é¦–å…ˆï¼Œæ‚¨å°†åˆ›å»ºä¸€ä¸ªæ–°çš„è‡ªå®šä¹‰è§†å›¾æ¥ç®¡ç†æ‚¨çš„åœ°å›¾ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬ 4 æ­¥",
      "tips": ""
    },
    "To allow the map content to extend to the top edge of the screen, add the ignoresSafeArea(edges: .top) modifier to the map view.": {
      "zh": "ä¸ºäº†è®©åœ°å›¾å†…å®¹èƒ½å¤Ÿæ‰©å±•åˆ°å±å¹•é¡¶éƒ¨çš„è¾¹ç¼˜ï¼Œéœ€è¦å°† ignoresSafeArea(edges: .top) ä¿®é¥°ç¬¦æ·»åŠ åˆ°åœ°å›¾è§†å›¾ã€‚",
      "tips": ""
    },
    "To customize a SwiftUI view, you call methods called modifiers. Modifiers wrap a view to change its display or other properties. Each modifier returns a new view, so itâ€™s common to chain multiple modifiers, stacked vertically.": {
      "zh": "è¦è‡ªå®šä¹‰ SwiftUI è§†å›¾ï¼Œæ‚¨éœ€è¦è°ƒç”¨è¢«ç§°ä¸ºä¿®é¥°ç¬¦ï¼ˆmodifiersï¼‰çš„æ–¹æ³•ã€‚ä¿®é¥°ç¬¦ç”¨æ¥åŒ…è£…ä¸€ä¸ªè§†å›¾ï¼Œå®ƒå¯ä»¥æ›´æ”¹è¿™ä¸ªè§†å›¾çš„æ˜¾ç¤ºæˆ–å…¶ä»–å±æ€§ã€‚æ¯ä¸ªä¿®é¥°ç¬¦éƒ½è¿”å›ä¸€ä¸ªæ–°è§†å›¾ï¼Œå› æ­¤é€šå¸¸éœ€è¦å‚ç›´å †å å¤šä¸ªä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "ç¬¬ 9 æ­¥",
      "tips": ""
    },
    "Click Live Preview to see the rendered map in the composed view.": {
      "zh": "å•å‡»å®æ—¶é¢„è§ˆå¯ä»¥åœ¨ç»„åˆè§†å›¾ä¸­æŸ¥çœ‹æ¸²æŸ“å‡ºæ¥çš„åœ°å›¾ã€‚",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ 3 èŠ‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ 1 æ­¥",
      "tips": ""
    },
    "Notice that Xcode updates your code automatically to reflect the change, removing the foregroundColor(.green) modifier.": {
      "zh": "è¯·æ³¨æ„ï¼Œåœ¨ä½ ä¿®æ”¹ä¹‹å Xcode ä¼šè‡ªåŠ¨æ›´æ–°æ‚¨çš„ä»£ç ï¼Œè¿™é‡Œå®ƒä¼šåˆ é™¤ foregroundColor(.green) ä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    },
    "This applies the system font to the text so that it responds correctly to the userâ€™s preferred font sizes and settings.": {
      "zh": "è¿™æ ·åšä¼šå°†ç³»ç»Ÿçš„å­—ä½“åº”ç”¨åˆ°æ–‡æœ¬ä¸Šï¼Œè®©ä»–å¯ä»¥è·Ÿéšç”¨æˆ·è®¾ç½®çš„å­—ä½“å¤§å°å’Œåå¥½è¿›è¡Œè°ƒæ•´ã€‚",
      "tips": ""
    },
    "This tutorial guides you through building Landmarks â€” an app for discovering and sharing the places you love. Youâ€™ll start by building the view that shows a landmarkâ€™s details.": {
      "zh": "æœ¬æ•™ç¨‹å°†æŒ‡å¯¼ä½ æ„å»º Landmarks â€”â€” ä¸€æ¬¾å‘ç°å’Œåˆ†äº«ä½ å–œæ¬¢çš„åœ°æ–¹çš„åº”ç”¨ç¨‹åºã€‚é¦–å…ˆä½ å°†æ„å»ºä¸€ä¸ªç”¨æ¥æ˜¾ç¤ºåœ°æ ‡è¯¦æƒ…çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "Choose File > New > File to open the template selector again. In the User Interface section, select â€œSwiftUI Viewâ€ and click Next. Name the file CircleImage.swift and click Create.": {
      "zh": "ç‚¹å‡»çŠ¶æ€æ ä¸­çš„ File > New > File å†æ¬¡æ‰“å¼€æ¨¡ç‰ˆé€‰æ‹©çª—å£ã€‚åœ¨ User Interface è¿™ä¸€è¡Œä¸­é€‰æ‹© â€œSwiftUI Viewâ€ ç„¶åç‚¹å‡»ä¸‹ä¸€æ­¥ã€‚å°†æ–‡ä»¶å‘½åä¸ºâ€œCircleImage.swiftâ€ï¼Œç„¶åç‚¹å‡»â€œCreateâ€ã€‚",
      "tips": ""
    },
    "In the Project navigator, select ContentView.swift.": {
      "zh": "åœ¨é¡¹ç›®å¯¼èˆªæ ä¸­ï¼Œé€‰æ‹© ContentView.swift æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "Create a New Project and Explore the Canvas": {
      "zh": "åˆ›å»ºé¡¹ç›®ä»¥åŠè®¤è¯†ç”»å¸ƒ",
      "tips": ""
    },
    "Add a new text view after the location, change the placeholder text to the parkâ€™s state, and then set its font to subheadline.": {
      "zh": "åœ¨å…¬å›­ä½ç½®åé¢æ·»åŠ ä¸€ä¸ªæ–°çš„æ–‡æœ¬è§†å›¾ï¼Œå°†å ä½æ–‡å­—æ›´æ”¹ä¸ºå…¬å›­æ‰€å±çš„å·ï¼Œç„¶åå°†å®ƒçš„å­—ä½“è®¾ç½®ä¸º subheadline ã€‚",
      "tips": ""
    },
    "Finally, move the subheadline font modifier from each Text view to the HStack containing them, and apply the secondary color to the subheadline text.": {
      "zh": "æœ€åï¼Œå°† subheadline å­—ä½“ä¿®é¥°ç¬¦ä»å†…éƒ¨çš„æ–‡æœ¬è§†å›¾ç§»åŠ¨åˆ°åŒ…å«ä»–ä»¬çš„çˆ¶çº§ HStackï¼Œç„¶åå°† secondary é¢œè‰²åº”ç”¨åˆ° HStack ä¸Šã€‚",
      "tips": ""
    }
  },
  "swiftui/drawing-paths-and-shapes": {
    "Drawing Paths and Shapes": {
      "zh": "",
      "tips": ""
    },
    "Users receive a badge whenever they visit a landmark in their list. Of course, for a user to receive a badge, youâ€™ll need to create one. This tutorial takes you through the process of creating a badge by combining paths and shapes, which you then overlay with another shape that represents the location.": {
      "zh": "æ¯å½“ç”¨æˆ·è®¿é—®å…¶åˆ—è¡¨ä¸­çš„åœ°æ ‡æ—¶ï¼Œä»–ä»¬éƒ½ä¼šæ”¶åˆ°ä¸€ä¸ªå¾½ç« ã€‚ å½“ç„¶ï¼Œè¦è®©ç”¨æˆ·æ”¶åˆ°å¾½ç« ï¼Œä½ éœ€è¦åˆ›å»ºä¸€ä¸ªã€‚ æœ¬æ•™ç¨‹å°†å¼•å¯¼ä½ å®Œæˆé€šè¿‡ç»„åˆè·¯å¾„å’Œå½¢çŠ¶åˆ›å»ºå¾½ç« çš„è¿‡ç¨‹ï¼Œç„¶åä½ å°†å…¶ä¸ä»£è¡¨è¯¥ä½ç½®çš„å¦ä¸€ä¸ªå½¢çŠ¶å åŠ ã€‚",
      "tips": ""
    },
    "If you want to create multiple badges for different kinds of landmarks, try experimenting with the overlaid symbol, varying the amount of repetition, or changing the various angles and scales.": {
      "zh": "å¦‚æœä½ æƒ³ä¸ºä¸åŒç±»å‹çš„åœ°æ ‡åˆ›å»ºå¤šä¸ªå¾½ç« ï¼Œè¯·å°è¯•ä½¿ç”¨å åŠ ç¬¦å·è¿›è¡Œè¯•éªŒï¼Œæ”¹å˜é‡å¤æ¬¡æ•°ï¼Œæˆ–æ›´æ”¹å„ç§è§’åº¦å’Œæ¯”ä¾‹ã€‚",
      "tips": ""
    },
    "Follow the steps to build this project, or download the finished project to explore on your own.": {
      "zh": "æŒ‰ç…§æ­¥éª¤æ„å»ºæ­¤é¡¹ç›®ï¼Œæˆ–ä¸‹è½½å®Œæˆçš„é¡¹ç›®ä»¥è‡ªè¡Œæ¢ç´¢ã€‚",
      "tips": ""
    },
    "Create Drawing Data for a Badge View": {
      "zh": "ä¸ºå¾½ç« è§†å›¾åˆ›å»ºç»˜å›¾æ•°æ®",
      "tips": ""
    },
    "To create the badge, youâ€™ll start by defining data that you can use to draw a hexagon shape for the badgeâ€™s background.": {
      "zh": "è¦åˆ›å»ºå¾½ç« ï¼Œä½ éœ€è¦å…ˆå®šä¹‰æ•°æ®ï¼Œç”¨æ¥ç»˜åˆ¶å¾½ç« èƒŒæ™¯çš„å…­è¾¹å½¢å½¢çŠ¶ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "æ­¥éª¤ 1",
      "tips": ""
    },
    "With the Views group selected in the navigation pane, choose File > New > File, select Swift File from the iOS Templates sheet, and click Next.": {
      "zh": "åœ¨å¯¼èˆªçª—æ ¼ä¸­é€‰æ‹© View æ–‡ä»¶å¤¹åï¼Œé€‰æ‹©â€œFileâ€>â€œNewâ€>â€œFileâ€ï¼Œä»â€œiOS Templatesâ€è¡¨ä¸­é€‰æ‹©â€œSwift Fileâ€ï¼Œç„¶åå•å‡»â€œNextâ€ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "æ­¥éª¤ 2",
      "tips": ""
    },
    "Name the new file HexagonParameters.swift.": {
      "zh": "å°†æ–°æ–‡ä»¶å‘½åä¸º HexagonParameters.swiftã€‚",
      "tips": ""
    },
    "Youâ€™ll use this structure to define the shape of a hexagon.": {
      "zh": "ä½ å°†ä½¿ç”¨è¿™ä¸ªç»“æ„ä½“æ¥å®šä¹‰å…­è¾¹å½¢çš„æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "æ­¥éª¤ 3",
      "tips": ""
    },
    "Inside the new file, create a structure called HexagonParameters.": {
      "zh": "åœ¨æ–°æ–‡ä»¶ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªåä¸º HexagonParameters çš„ç»“æ„ä½“ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "æ­¥éª¤ 4",
      "tips": ""
    },
    "Define a Segment structure to hold the three points that represent one side of the hexagon; import CoreGraphics so you can use CGPoint.": {
      "zh": "å®šä¹‰ä¸€ä¸ª Segment ç»“æ„æ¥ä¿å­˜ä»£è¡¨å…­è¾¹å½¢ä¸€ä¾§çš„ä¸‰ä¸ªç‚¹ï¼› å¯¼å…¥ CoreGraphicsï¼Œä»¥ä¾¿ä½ å¯ä»¥ä½¿ç”¨ CGPointã€‚",
      "tips": ""
    },
    "Each side starts where the previous ends, moves in a straight line to the first point, and then moves over a BÃ©zier curve at the corner to the second point. The third point controls the shape of the curve.": {
      "zh": "æ¯æ¡è¾¹éƒ½ä»å‰ä¸€æ¡è¾¹ç»“æŸçš„ç‚¹å¼€å§‹ï¼Œæ²¿ç›´çº¿ç§»åŠ¨åˆ°ç¬¬ä¸€ä¸ªç‚¹ï¼Œç„¶åé€šè¿‡æ‹è§’å¤„çš„è´å¡å°”æ›²çº¿ç§»åŠ¨åˆ°ç¬¬äºŒä¸ªç‚¹ã€‚ ç¬¬ä¸‰ç‚¹æ§åˆ¶æ›²çº¿çš„å½¢çŠ¶ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "æ­¥éª¤ 5",
      "tips": ""
    },
    "Create an array to hold segments.": {
      "zh": "åˆ›å»ºä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨ Segmentã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "æ­¥éª¤ 6",
      "tips": ""
    },
    "Add data for the six segments, one for each side of the hexagon.": {
      "zh": "ä¸ºå…­ä¸ªéƒ¨åˆ†åˆ†åˆ«æ·»åŠ æ•°æ®ï¼Œæ¯ä¸ªéƒ¨åˆ†å¯¹åº”å…­è¾¹å½¢çš„ä¸€æ¡è¾¹ã€‚",
      "tips": ""
    },
    "The values are stored as a fraction of a unit square having its origin in the upper left, with positive x to the right and positive y down. Later, youâ€™ll use these fractions to find the actual points of a hexagon with a given size.": {
      "zh": "è¿™äº›æ•°å€¼ä»¥ä¸€ä¸ªæ­£æ–¹å½¢ä¸ºåŸºå‡†åæ ‡ï¼ŒæŒ‰ç…§æ¯”ä¾‹è®¾ç½®ï¼Œæ­£ x å‘å³ï¼Œæ­£ y å‘ä¸‹ã€‚ å¾…ä¼šä½ å°†ä½¿ç”¨è¿™äº›æ¯”ä¾‹æ•°å€¼æ¥æŸ¥æ‰¾å…·æœ‰ç»™å®šå¤§å°çš„å…­è¾¹å½¢çš„å®é™…ç‚¹ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "æ­¥éª¤ 7",
      "tips": ""
    },
    "Add an adjustment value that lets you tune the shape of the hexagon.": {
      "zh": "æ·»åŠ ä¸€ä¸ªè°ƒæ•´å€¼ï¼Œä½¿ä½ å¯ä»¥è°ƒæ•´å…­è¾¹å½¢çš„å½¢çŠ¶ã€‚",
      "tips": ""
    },
    "Draw the Badge Background": {
      "zh": "ç»˜åˆ¶å¾½ç« èƒŒæ™¯",
      "tips": ""
    },
    "Use the graphics APIs in SwiftUI to draw a custom badge shape.": {
      "zh": "ä½¿ç”¨ SwiftUI ä¸­çš„å›¾å½¢ API ç»˜åˆ¶è‡ªå®šä¹‰å¾½ç« å½¢çŠ¶ã€‚",
      "tips": ""
    },
    "Create another new file with File > New > File, this time selecting SwiftUI View from the iOS Templates sheet. Click Next and then name the file BadgeBackground.swift.": {
      "zh": "ä½¿ç”¨ File > New > File åˆ›å»ºå¦ä¸€ä¸ªæ–°æ–‡ä»¶ï¼Œè¿™æ¬¡ä» iOS æ¨¡æ¿ä¸­é€‰æ‹© SwiftUI è§†å›¾ã€‚ å•å‡»ä¸‹ä¸€æ­¥ï¼Œç„¶åå°†æ–‡ä»¶å‘½åä¸º BadgeBackground.swiftã€‚",
      "tips": ""
    },
    "In BadgeBackground.swift, add a Path shape to the badge and apply the fill() modifier to turn the shape into a view.": {
      "zh": "åœ¨ BadgeBackground.swift ä¸­ï¼Œå°† Path å½¢çŠ¶æ·»åŠ åˆ°å¾½ç« å¹¶ä½¿ç”¨ fill() ä¿®é¥°ç¬¦å°†å½¢çŠ¶å˜æˆè§†å›¾ã€‚",
      "tips": ""
    },
    "You use paths to combine lines, curves, and other drawing primitives to form more complex shapes like the badgeâ€™s hexagonal background.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ Path æ¥ç»„åˆç›´çº¿ã€æ›²çº¿å’Œå…¶ä»–ç»˜å›¾åŸºç¡€å…ƒç´ ï¼Œæ¥ç»„åˆæˆæ›´å¤æ‚çš„å½¢çŠ¶ï¼Œä¾‹å¦‚å¾½ç« çš„å…­è¾¹å½¢èƒŒæ™¯ã€‚",
      "tips": ""
    },
    "Add a starting point to the path, assuming a container with size 100 x 100 px.": {
      "zh": "å‡è®¾å®¹å™¨å¤§å°ä¸º 100 x 100 åƒç´ ï¼Œå°†èµ·ç‚¹æ·»åŠ åˆ° Pathã€‚",
      "tips": ""
    },
    "The move(to:) method moves the drawing cursor within the bounds of a shape as though an imaginary pen or pencil is hovering over the area, waiting to start drawing.": {
      "zh": "move(to:) æ–¹æ³•å°±åƒä¸€æ”¯æƒ³è¦å¼€å§‹ç»˜ç”»çš„è™šæ‹Ÿç¬”æˆ–é“…ç¬”æ‚¬æµ®åœ¨å½¢çŠ¶åŒºåŸŸå†…ï¼Œå¯ä»¥åœ¨åŒºåŸŸå†…ç§»åŠ¨ç»˜ç”»å…‰æ ‡ã€‚",
      "tips": ""
    },
    "Draw the lines for each point of the shape data to create a rough hexagonal shape.": {
      "zh": "ç»™å½¢çŠ¶æ•°æ®çš„æ¯ä¸ªç‚¹è¿çº¿æ¥åˆ›å»ºä¸€ä¸ªå¤§è‡´çš„å…­è¾¹å½¢ã€‚",
      "tips": ""
    },
    "The addLine(to:) method takes a single point and draws it. Successive calls to addLine(to:) begin a line at the previous point and continue to the new point.": {
      "zh": "addLine(to:) æ–¹æ³•æ¥å—ä¸€ä¸ªç‚¹å¹¶ç»˜åˆ¶å®ƒã€‚è¿ç»­è°ƒç”¨  addLine(to:) çš„ä»å‰ä¸€ä¸ªç‚¹è¿çº¿åˆ°ä¸‹ä¸€ä¸ªç‚¹ï¼Œæœ€ç»ˆå½¢æˆä¸€ä¸ªå½¢çŠ¶ã€‚",
      "tips": ""
    },
    "Donâ€™t worry if your hexagon looks a little unusual; thatâ€™s because youâ€™re ignoring the curved part of each segment at the shapeâ€™s corners. Youâ€™ll account for that next.": {
      "zh": "å¦‚æœä½ çš„å…­è¾¹å½¢çœ‹èµ·æ¥æœ‰ç‚¹ä¸å¤ªå¯¹åŠ²ï¼Œåˆ«æ‹…å¿ƒï¼› é‚£æ˜¯å› ä¸ºä½ å¿½ç•¥äº†çº¿æ®µè¾¹è§’å¤„çš„å¼¯æ›²éƒ¨åˆ†ã€‚ æ¥ä¸‹æ¥ä½ ä¼šè€ƒè™‘åˆ°è¿™ä¸€ç‚¹ã€‚",
      "tips": ""
    },
    "Use the addQuadCurve(to:control:) method to draw the BÃ©zier curves for the badgeâ€™s corners.": {
      "zh": "ä½¿ç”¨ addQuadCurve(to:control:) æ–¹æ³•ç»˜åˆ¶å¾½ç« æ‹è§’å¤„çš„è´å¡å°”æ›²çº¿ã€‚",
      "tips": ""
    },
    "Wrap the path in a GeometryReader so the badge can use the size of its containing view, which defines the size instead of hard-coding the value (100).": {
      "zh": "å°† Path åŒ…è£…åœ¨ GeometryReader ä¸­ï¼Œè®©å¾½ç« å¯ä»¥è·å–åˆ°çˆ¶è§†å›¾çš„å¤§å°ï¼Œè¿™æ ·å°±ä¸ç”¨ä½¿ç”¨å†™æ­» 100 æ¥è®¾ç½®å¤§å°ã€‚",
      "tips": ""
    },
    "Using the smallest of the geometryâ€™s two dimensions preserves the aspect ratio of the badge when its containing view isnâ€™t square.": {
      "zh": "å½“å¾½ç« çš„çˆ¶è§†å›¾ä¸æ˜¯æ­£æ–¹å½¢æ—¶ï¼Œä½¿ç”¨ geometry çš„ä¸¤ä¸ªç»´åº¦ä¸­æœ€å°çš„ä¸€ä¸ªå¯ä»¥ä¿ç•™å¾½ç« çš„é•¿å®½æ¯”ã€‚",
      "tips": ""
    },
    "Scale the shape on the x-axis using xScale, and then add xOffset to recenter the shape within its geometry.": {
      "zh": "ä½¿ç”¨ xScale åœ¨ x è½´ä¸Šç¼©æ”¾å½¢çŠ¶ï¼Œç„¶åæ·»åŠ  xOffset è®©å›¾å½¢é‡æ–°å±…ä¸­ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "æ­¥éª¤ 8",
      "tips": ""
    },
    "Replace the solid black background with a gradient to match the design.": {
      "zh": "æŒ‰ç…§è®¾è®¡æ•ˆæœï¼Œç”¨æ¸å˜æ›¿æ¢çº¯é»‘è‰²èƒŒæ™¯ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "æ­¥éª¤ 9",
      "tips": ""
    },
    "Apply the aspectRatio(_:contentMode:) modifier to the gradient fill.": {
      "zh": "å°† aspectRatio(_:contentMode:) ä¿®é¥°ç¬¦åº”ç”¨åˆ°æ¸å˜è§†å›¾ä¸Šã€‚",
      "tips": ""
    },
    "By preserving a 1:1 aspect ratio, the badge maintains its position at the center of the view, even if its ancestor views arenâ€™t square.": {
      "zh": "ä¿æŒ 1:1 çš„é•¿å®½æ¯”ï¼Œå¾½ç« èƒ½å¤Ÿå§‹ç»ˆæ˜¾ç¤ºåœ¨è§†å›¾çš„ä¸­å¿ƒä½ç½®ï¼Œå³ä½¿å…¶çˆ¶çº§è§†å›¾å¹¶éæ­£æ–¹å½¢ã€‚",
      "tips": ""
    },
    "Draw the Badge Symbol": {
      "zh": "ç»˜åˆ¶å¾½ç« å›¾æ ‡",
      "tips": ""
    },
    "The Landmarks badge has a custom insignia in its center thatâ€™s based on the mountain that appears in the Landmarks app icon.": {
      "zh": "åœ°æ ‡åº”ç”¨çš„å¾½ç« åœ¨å…¶ä¸­å¿ƒæ‹¥æœ‰ä¸€ä¸ªå®šåˆ¶çš„å›¾æ¡ˆï¼Œå…¶çµæ„Ÿæ¥æºäºåœ°æ ‡åº”ç”¨å›¾æ ‡ä¸­å‡ºç°çš„å±±å³°ã€‚",
      "tips": ""
    },
    "The mountain symbol consists of two shapes: one that represents a snowcap at the peak, and the other that represents vegetation along the approach. Youâ€™ll draw them using two partially triangular shapes that are set apart by a small gap.": {
      "zh": "è¿™ä¸ªå±±å³°å›¾æ ‡ç”±ä¸¤ä¸ªå½¢çŠ¶ç»„æˆï¼šä¸€ä¸ªä»£è¡¨å±±é¡¶çš„é›ªå¸½ï¼Œå¦ä¸€ä¸ªä»£è¡¨æ²¿é€”çš„æ¤è¢«ã€‚ä½ å°†ç»˜åˆ¶ä¸¤ä¸ªç•¥å¸¦ä¸‰è§’å½¢çŠ¶çš„å›¾æ¡ˆæ¥å®Œæˆå®ƒä»¬ï¼Œè¿™ä¸¤ä¸ªå½¢çŠ¶ä¹‹é—´æœ‰ä¸€ä¸ªå°é—´éš™ã€‚",
      "tips": ""
    },
    "First youâ€™ll give your app an icon, to establish a look for the badge.": {
      "zh": "é¦–å…ˆï¼Œä½ å°†ä¸ºä½ çš„åº”ç”¨ç¨‹åºæä¾›ä¸€ä¸ªå›¾æ ‡ï¼Œåšä¸º App çš„ Logoã€‚",
      "tips": ""
    },
    "Delete the empty AppIcon item from your projectâ€™s Asset Catalog, and then drag the AppIcon.appiconset folder from the downloaded projectsâ€™ Resources folder into the Asset catalog.": {
      "zh": "ä»é¡¹ç›®çš„ Asset Catalog ä¸­åˆ é™¤ç©ºçš„ AppIconï¼Œç„¶åå°† AppIcon.appiconset æ–‡ä»¶å¤¹ä»ä¸‹è½½çš„é¡¹ç›®çš„ Resources æ–‡ä»¶å¤¹ç›´æ¥æ‹–åˆ° Asset ç›®å½•ä¸­ã€‚",
      "tips": ""
    },
    "Xcode recognizes the folder as containing all the size variations of an app icon and creates a corresponding item in the catalog.": {
      "zh": "Xcode ä¼šè¯†åˆ«è¯¥æ–‡ä»¶å¤¹åŒ…å«åº”ç”¨ç¨‹åºå›¾æ ‡çš„æ‰€æœ‰ä¸åŒå°ºå¯¸ï¼Œå¹¶ä¸”åœ¨ç›®å½•ä¸­åˆ›å»ºå¯¹åº”çš„é¡¹ã€‚",
      "tips": ""
    },
    "Next, youâ€™ll build the matching badge symbol.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†æ„å»ºå¯¹åº”çš„å¾½ç« å›¾æ ‡ã€‚",
      "tips": ""
    },
    "Create a new custom view called BadgeSymbol for the mountain shape thatâ€™s stamped in a rotated pattern in the badge design.": {
      "zh": "åˆ›å»ºä¸€ä¸ªåä¸ºBadgeSymbolçš„æ–°è‡ªå®šä¹‰è§†å›¾ï¼Œä»¥æ—‹è½¬å›¾æ¡ˆå‘ˆç°å±±çš„å½¢çŠ¶ã€‚",
      "tips": ""
    },
    "Draw the top portion of the symbol using the path APIs.": {
      "zh": "ä½¿ç”¨ Path API ç»˜åˆ¶å›¾æ ‡çš„é¡¶éƒ¨ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®éªŒ",
      "tips": ""
    },
    "Adjust the numeric multipliers associated with the spacing, topWidth, and topHeight constants to see how they influence the overall shape.": {
      "zh": "è°ƒæ•´ä¸ spacingã€topWidth å’Œ totopHeight å¸¸é‡å…³è”çš„æ•°å€¼çš„ä¹˜æ•°ï¼Œè§‚å¯Ÿå®ƒä»¬å¦‚ä½•å½±å“æ•´ä½“å½¢çŠ¶ã€‚",
      "tips": ""
    },
    "Draw the bottom portion of the symbol.": {
      "zh": "ç»˜åˆ¶ç¬¦å·çš„åº•éƒ¨ã€‚",
      "tips": ""
    },
    "Use the move(to:) modifier to insert a gap between multiple shapes in the same path.": {
      "zh": "ä½¿ç”¨ move(to:) ä¿®é¥°ç¬¦åœ¨åŒä¸€è·¯å¾„ä¸­çš„å¤šä¸ªå½¢çŠ¶ä¹‹é—´æ’å…¥é—´éš™ã€‚",
      "tips": ""
    },
    "Fill the symbol with the purple color from the design.": {
      "zh": "ç”¨ç´«è‰²æ¥å¡«å……å›¾æ ‡é¢œè‰²ã€‚",
      "tips": ""
    },
    "Create a new RotatedBadgeSymbol view to encapsulate the concept of a rotated symbol.": {
      "zh": "åˆ›å»ºä¸€ä¸ªæ–°çš„ RotatedBadgeSymbol è§†å›¾æ¥å°è£…æ—‹è½¬å›¾æ ‡ã€‚",
      "tips": ""
    },
    "Adjust the angle in the preview to test the effect of the rotation.": {
      "zh": "åœ¨é¢„è§ˆä¸­è°ƒæ•´è§’åº¦ï¼Œæµ‹è¯•æ—‹è½¬æ•ˆæœã€‚",
      "tips": ""
    },
    "Combine the Badge Foreground and Background": {
      "zh": "åˆå¹¶å¾½ç« å†…å®¹å’ŒèƒŒæ™¯",
      "tips": ""
    },
    "The badge design calls for the mountain shape to be rotated and repeated multiple times on top of the badge background.": {
      "zh": "å¾½ç« è®¾è®¡è¦æ±‚å±±å½¢å›¾æ¡ˆåœ¨å¾½ç« èƒŒæ™¯ä¸Šæ—‹è½¬å¹¶é‡å¤å¤šæ¬¡ã€‚",
      "tips": ""
    },
    "Define a new type for rotation and leverage the ForEach view to apply the same adjustments to multiple copies of the mountain shape.": {
      "zh": "å®šä¹‰ä¸€ä¸ªæ–°çš„æ—‹è½¬ç±»å‹ï¼Œå¹¶åˆ©ç”¨ ForEach å°†ç›¸åŒçš„è°ƒæ•´åº”ç”¨äºå¤šä¸ªå±±å½¢çš„å‰¯æœ¬ã€‚",
      "tips": ""
    },
    "Create a new SwiftUI view called Badge.": {
      "zh": "åˆ›å»ºä¸€ä¸ªåä¸º Badge çš„æ–° SwiftUI è§†å›¾ã€‚",
      "tips": ""
    },
    "Place BadgeBackground in the body of Badge.": {
      "zh": "å°† BadgeBackground æ”¾åœ¨ Badge çš„ä¸»ä½“ä¸­ã€‚",
      "tips": ""
    },
    "Lay the badgeâ€™s symbol over the badge background by placing it in a ZStack.": {
      "zh": "å°†å¾½ç« å›¾æ¡ˆæ”¾ç½®åœ¨ ZStack ä¸­ï¼Œå°†å…¶ç½®äºå¾½ç« èƒŒæ™¯ä¹‹ä¸Šã€‚",
      "tips": ""
    },
    "As it appears now, the badge symbol is too large compared to the intended design and relative size of the background.": {
      "zh": "æ ¹æ®ç›®å‰çš„å±•ç¤ºæ•ˆæœï¼Œä¸é¢„æœŸè®¾è®¡åŠèƒŒæ™¯ç›¸å¯¹å°ºå¯¸ç›¸æ¯”ï¼Œå¾½ç« å›¾æ ‡è¿‡å¤§ã€‚",
      "tips": ""
    },
    "Correct the size of the badge symbol by reading the surrounding geometry and scaling the symbol.": {
      "zh": "é€šè¿‡è¯»å–å¸ƒå±€çš„ geometry å¹¶ç¼©æ”¾å›¾æ¡ˆæ¥æ›´æ­£å¾½ç« å›¾æ¡ˆçš„å¤§å°ã€‚",
      "tips": ""
    },
    "Add a ForEach view to rotate and display copies of the badge symbol.": {
      "zh": "æ·»åŠ  ForEach è§†å›¾æ¥æ—‹è½¬å’Œæ˜¾ç¤ºå¾½ç« å›¾æ¡ˆçš„å‰¯æœ¬ã€‚",
      "tips": ""
    },
    "A full, 360Â° rotation split into eight segments creates a sun-like pattern by repeating the mountain symbol.": {
      "zh": "ä¸€ä¸ªå®Œæ•´çš„ 360Â° æ—‹è½¬åˆ†ä¸ºå…«ä¸ªéƒ¨åˆ†ï¼Œé€šè¿‡é‡å¤å±±å³°å›¾æ¡ˆåˆ›å»ºä¸€ä¸ªç±»ä¼¼å¤ªé˜³çš„å›¾æ¡ˆã€‚",
      "tips": ""
    },
    "To keep the project organized, before moving on to the next tutorial, collect all of the new files that you added in this tutorial into a Badges group.": {
      "zh": "ä¸ºäº†ä½¿é¡¹ç›®ç»“æ„æ¸…æ™°ï¼Œåœ¨ç»§ç»­ä¸‹ä¸€ä¸ªæ•™ç¨‹ä¹‹å‰ï¼Œå°†ä½ åœ¨æœ¬æ•™ç¨‹ä¸­æ·»åŠ çš„æ‰€æœ‰æ–°æ–‡ä»¶ç§»åŠ¨åˆ° Badges æ–‡ä»¶å¤¹ä¸­ã€‚",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Animating Views and Transitions": {
      "zh": "",
      "tips": ""
    },
    "When using SwiftUI, you can individually animate changes to views, or to a viewâ€™s state, no matter where the effects are. SwiftUI handles all the complexity of these combined, overlapping, and interruptible animations for you.": {
      "zh": "ä½¿ç”¨ SwiftUI æ—¶ï¼Œä½ å¯ä»¥å•ç‹¬ä¸ºè§†å›¾æˆ–è§†å›¾çŠ¶æ€çš„æ›´æ”¹è®¾ç½®åŠ¨ç”»ï¼Œæ— è®ºæ•ˆæœåœ¨å“ªé‡Œã€‚ SwiftUI ä¸ºä½ å¤„ç†è¿™äº›ç»„åˆã€é‡å å’Œå¯ä¸­æ–­åŠ¨ç”»çš„æ‰€æœ‰å¤æ‚æ€§ã€‚",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ 1 èŠ‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬ 2 èŠ‚",
      "tips": ""
    },
    "Section 4": {
      "zh": "ç¬¬ 4 èŠ‚",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ 3 èŠ‚",
      "tips": ""
    }
  },
  "swiftui/handling-user-input": {
    "Use an Observable Object for Storage": {
      "zh": "ä½¿ç”¨å¯è§‚å¯Ÿå¯¹è±¡æ¥å­˜å‚¨",
      "tips": ""
    },
    "You can customize the list view so that it shows all of the landmarks, or just the userâ€™s favorites. To do this, youâ€™ll need to add a bit of state to the LandmarkList type.": {
      "zh": "ä½ å¯ä»¥è‡ªå®šä¹‰åˆ—è¡¨è§†å›¾ï¼Œä½¿å…¶æ˜¾ç¤ºæ‰€æœ‰åœ°æ ‡ï¼Œæˆ–ä»…æ˜¾ç¤ºç”¨æˆ·æ”¶è—çš„åœ°æ ‡ã€‚ è¦å®ç°è¿™ç§æ•ˆæœï¼Œä½ éœ€è¦å‘ LandmarkList ç±»å‹æ·»åŠ ä¸€äº›çŠ¶æ€ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "æ­¥éª¤ 6",
      "tips": ""
    },
    "Use the filtered version of the list of landmarks in the List.": {
      "zh": "å°†åˆ—è¡¨ä¿®æ”¹ä¸ºä½¿ç”¨è¿‡æ»¤ä¹‹åçš„æ•°æ®ã€‚",
      "tips": ""
    },
    "Use modelData.landmarks as the data when filtering landmarks.": {
      "zh": "ç­›é€‰åœ°æ ‡æ—¶ä½¿ç”¨ modelData.landmarks ä½œä¸ºæ•°æ®ã€‚",
      "tips": ""
    },
    "You use the $ prefix to access a binding to a state variable, or one of its properties.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ $ å‰ç¼€æ¥ç»‘å®šçŠ¶æ€å˜é‡æˆ–å®ƒçš„æŸä¸ªå±æ€§ã€‚",
      "tips": ""
    },
    "Change the initial value of showFavoritesOnly to true to see how the list reacts.": {
      "zh": "å°† showFavoritesOnly çš„åˆå§‹å€¼æ›´æ”¹ä¸º true æŸ¥çœ‹åˆ—è¡¨çš„å˜åŒ–ã€‚",
      "tips": ""
    },
    "Because system images are vector based, you can change their color with the foregroundColor(_:) modifier.": {
      "zh": "å› ä¸ºç³»ç»Ÿå›¾åƒæ˜¯åŸºäºçŸ¢é‡çš„ï¼Œæ‰€ä»¥ä½ å¯ä»¥ä½¿ç”¨ foregroundColor(_:) ä¿®é¥°ç¬¦æ›´æ”¹å®ƒä»¬çš„é¢œè‰²ã€‚",
      "tips": ""
    },
    "To give the user control over the listâ€™s filter, you need to add a control that can alter the value of showFavoritesOnly. You do this by passing a binding to a toggle control.": {
      "zh": "è¦è®©ç”¨æˆ·æ§åˆ¶åˆ—è¡¨çš„è¿‡æ»¤ï¼Œä½ éœ€è¦æ·»åŠ ä¸€ä¸ªæ§ä»¶ç”¨æ¥æ›´æ”¹ showFavoritesOnly å€¼ã€‚ ä½ å¯ä»¥å°†è¿™ä¸ªå€¼ç»‘å®šåˆ°ä¸€ä¸ªå¼€å…³ä¸Šã€‚",
      "tips": ""
    },
    "Because you use a binding, changes made inside this view propagate back to the data source.": {
      "zh": "å› ä¸ºä½¿ç”¨ @Binding å±æ€§ï¼Œæ‰€ä»¥åœ¨æ­¤è§†å›¾å†…æ‰€åšçš„æ›´æ”¹ä¼šä¼ æ’­å›æ•°æ®æºã€‚",
      "tips": ""
    },
    "\u0001Step 7": {
      "zh": "æ­¥éª¤ 7",
      "tips": ""
    },
    "Users receive a badge whenever they visit a landmark in their list. Of course, for a user to receive a badge, youâ€™ll need to create one. This tutorial takes you through the process of creating a badge by combining paths and shapes, which you then overlay with another shape that represents the location.": {
      "zh": "æ¯å½“ç”¨æˆ·è®¿é—®å…¶åˆ—è¡¨ä¸­çš„åœ°æ ‡æ—¶ï¼Œä»–ä»¬éƒ½ä¼šæ”¶åˆ°ä¸€ä¸ªå¾½ç« ã€‚ å½“ç„¶ï¼Œè¦è®©ç”¨æˆ·æ”¶åˆ°å¾½ç« ï¼Œä½ éœ€è¦åˆ›å»ºä¸€ä¸ªã€‚ æœ¬æ•™ç¨‹å°†å¼•å¯¼ä½ å®Œæˆé€šè¿‡ç»„åˆè·¯å¾„å’Œå½¢çŠ¶åˆ›å»ºå¾½ç« çš„è¿‡ç¨‹ï¼Œç„¶åä½ å°†å…¶ä¸ä»£è¡¨è¯¥ä½ç½®çš„å¦ä¸€ä¸ªå½¢çŠ¶å åŠ ã€‚",
      "tips": ""
    },
    "\u0001Step 6": {
      "zh": "æ­¥éª¤ 6",
      "tips": ""
    },
    "Add a @State property called showFavoritesOnly with its initial value set to false.": {
      "zh": "æ·»åŠ ä¸€ä¸ªåä¸º showFavoritesOnly çš„ @State å±æ€§ï¼Œåˆå§‹å€¼è®¾ç½®ä¸º falseã€‚",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ 1 èŠ‚",
      "tips": ""
    },
    "Update the LandmarkRow preview to work with the ModelData object.": {
      "zh": "æ›´æ–° LandmarkRow çš„é¢„è§ˆä»¥ä½¿ç”¨ ModelData å¯¹è±¡ã€‚",
      "tips": ""
    },
    "The Landmarks app can now switch between a filtered and unfiltered view of the landmarks, but the list of favorite landmarks is still hard coded. To allow the user to add and remove favorites, you need to add a favorite button to the landmark detail view.": {
      "zh": "Landmarks åº”ç”¨ç¨‹åºç°åœ¨å¯ä»¥åœ¨è¿‡æ»¤å’Œæœªè¿‡æ»¤çš„åœ°æ ‡è§†å›¾ä¹‹é—´åˆ‡æ¢ï¼Œä½†æ”¶è—çš„åœ°æ ‡åˆ—è¡¨ä»ç„¶æ˜¯å†™æ­»çš„ã€‚ è¦å…è®¸ç”¨æˆ·è‡ªå·±æ·»åŠ å’Œåˆ é™¤æ”¶è—å¤¹ï¼Œä½ éœ€è¦åœ¨åœ°æ ‡è¯¦ç»†è§†å›¾ä¸­æ·»åŠ æ”¶è—å¤¹æŒ‰é’®ã€‚",
      "tips": ""
    },
    "Switch back to LandmarkList.swift and turn on the live preview to verify that everything is working properly.": {
      "zh": "åˆ‡æ¢å› LandmarkList.swift å¹¶æ‰“å¼€å®æ—¶é¢„è§ˆï¼ŒéªŒè¯ä¸€åˆ‡æ˜¯å¦æ­£å¸¸ã€‚",
      "tips": ""
    },
    "In LandmarkList.swift, add an @EnvironmentObject property declaration to the view, and an environmentObject(_:) modifier to the preview.": {
      "zh": "åœ¨ LandmarkList.swift ä¸­ï¼Œå‘è§†å›¾æ·»åŠ ä¸€ä¸ª @EnvironmentObject å±æ€§å£°æ˜ï¼Œå¹¶å‘é¢„è§ˆæ·»åŠ ä¸€ä¸ª environmentObject(_:) ä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Switch back to LandmarkList.swift, and turn on the live preview.": {
      "zh": "åˆ‡æ¢å› LandmarkList.swiftï¼Œå¹¶æ‰“å¼€å®æ—¶é¢„è§ˆã€‚",
      "tips": ""
    },
    "Create a new view called FavoriteButton.swift.": {
      "zh": "åˆ›å»ºä¸€ä¸ªåä¸º FavoriteButton.swift çš„æ–°è§†å›¾ã€‚",
      "tips": ""
    },
    "When you make changes to your viewâ€™s structure, like adding or modifying a property, you need to manually refresh the canvas.": {
      "zh": "å½“ä½ æ›´æ”¹è§†å›¾çš„ç»“æ„æ—¶ï¼Œä¾‹å¦‚æ·»åŠ æˆ–ä¿®æ”¹å±æ€§ï¼Œä½ éœ€è¦æ‰‹åŠ¨åˆ·æ–°ç”»å¸ƒã€‚",
      "tips": ""
    },
    "Embed the landmarkâ€™s name in an HStack with a new FavoriteButton; provide a binding to the isFavorite property with the dollar sign ($).": {
      "zh": "å°†æ–°çš„æ”¶è—æŒ‰é’®ä»¥åŠåœ°æ ‡çš„åç§°åµŒå…¥åˆ° HStack ä¸­ï¼› ä½¿ç”¨ç¬¦å· $ å¯¹ isFavorite å±æ€§è¿›è¡Œç»‘å®šã€‚",
      "tips": ""
    },
    "In the Landmarks app, a user can flag their favorite places, and filter the list to show just their favorites. To create this feature, youâ€™ll start by adding a switch to the list so users can focus on just their favorites, and then youâ€™ll add a star-shaped button that a user taps to flag a landmark as a favorite.": {
      "zh": "åœ¨ Landmarks åº”ç”¨ç¨‹åºä¸­ï¼Œç”¨æˆ·å¯ä»¥æ ‡è®°ä»–ä»¬æœ€å–œæ¬¢çš„åœ°æ–¹å¹¶ä¸”å¯¹åˆ—è¡¨è¿›è¡Œè¿‡æ»¤ä»…æ˜¾ç¤ºä»–ä»¬çš„æ”¶è—ã€‚ è¦åˆ›å»ºæ­¤åŠŸèƒ½ï¼Œä½ é¦–å…ˆè¦åœ¨åˆ—è¡¨ä¸­æ·»åŠ ä¸€ä¸ªå¼€å…³ï¼Œç”¨æˆ·å¯ä»¥åˆ‡æ¢å¼€å…³å±•ç¤ºä»–çš„æ”¶è—å¤¹ï¼Œç„¶åä½ å°†æ·»åŠ ä¸€ä¸ªæ˜Ÿå½¢æŒ‰é’®ï¼Œç”¨æˆ·ç‚¹å‡»è¯¥æŒ‰é’®å¯å°†åœ°æ ‡æ ‡è®°ä¸ºæ”¶è—ã€‚",
      "tips": ""
    },
    "In SwiftUI blocks, you use if statements to conditionally include views.": {
      "zh": "åœ¨ SwiftUI å—ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨ if è¯­å¥åˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºè§†å›¾ã€‚",
      "tips": ""
    },
    "Youâ€™ll first create a reusable FavoriteButton.": {
      "zh": "ä½ å°†é¦–å…ˆåˆ›å»ºä¸€ä¸ªå¯é‡ç”¨çš„ FavoriteButtonã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "æ­¥éª¤ 3",
      "tips": ""
    },
    "Begin by enhancing the list to show users their favorites at a glance. Add a property to the Landmark structure to read the initial state of a landmark as a favorite, and then add a star to each LandmarkRow that shows a favorite landmark.": {
      "zh": "é¦–å…ˆä¼˜åŒ–åˆ—è¡¨ï¼Œè®©ç”¨æˆ·ä¸€ç›®äº†ç„¶åœ°çœ‹åˆ°ä»–ä»¬å–œæ¬¢çš„åœ°æ ‡ã€‚ å‘ Landmark ç»“æ„æ·»åŠ ä¸€ä¸ªå±æ€§è¡¨ç¤ºæ˜¯å¦æ”¶è—ï¼Œç„¶åå‘æ¯ä¸ªå·²æ”¶è—çš„ LandmarkRow æ·»åŠ ä¸€ä¸ªæ˜Ÿæ˜Ÿå›¾æ ‡ã€‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬ 2 èŠ‚",
      "tips": ""
    },
    "Filter the List View": {
      "zh": "è¿‡æ»¤åˆ—è¡¨è§†å›¾",
      "tips": ""
    },
    "A binding acts as a reference to a mutable state. When a user taps the toggle from off to on, and off again, the control uses the binding to update the viewâ€™s state accordingly.": {
      "zh": "binding å…³é”®è¯ç›¸å½“äºå¯¹å¯å˜çŠ¶æ€çš„å¼•ç”¨ã€‚ å½“ç”¨æˆ·ç‚¹å‡»å¼€å…³ä»å…³é—­åˆ°æ‰“å¼€ï¼Œç„¶åå†æ¬¡å…³é—­æ—¶ï¼Œä½¿ç”¨ç»‘å®šèƒ½ç›¸åº”åœ°æ›´æ–°è§†å›¾çš„çŠ¶æ€ã€‚",
      "tips": ""
    },
    "The star is present whenever a landmarkâ€™s isFavorite property is true. Youâ€™ll see how to modify that property later in this tutorial.": {
      "zh": "æ¯å½“åœ°æ ‡çš„ isFavorite å±æ€§ä¸º trueï¼Œæ˜Ÿæ˜Ÿå›¾æ ‡å°±ä¼šæ˜¾ç¤ºã€‚ ä½ å°†åœ¨æœ¬æ•™ç¨‹åé¢çœ‹åˆ°å¦‚ä½•ä¿®æ”¹è¯¥å±æ€§ã€‚",
      "tips": ""
    },
    "An observable object needs to publish any changes to its data, so that its subscribers can pick up the change.": {
      "zh": "å¯è§‚å¯Ÿå¯¹è±¡å¯¹å…¶æ•°æ®çš„ä»»ä½•æ›´æ”¹éƒ½éœ€è¦å‘å¸ƒå‡ºå»ï¼Œä»¥ä¾¿è®¢é˜…è€…å¯ä»¥æ”¶åˆ°æ›´æ”¹çš„æ¶ˆæ¯ã€‚",
      "tips": ""
    },
    "A preview fails if any subview requires a model object in the environment, but the view you are previewing doesnâ€™t have the environmentObject(_:) modifier.": {
      "zh": "å¦‚æœæœ‰ä»»ä½•å­è§†å›¾éœ€è¦ç¯å¢ƒä¸­çš„å¯¹è±¡ï¼Œè€Œä½ æ­£åœ¨é¢„è§ˆçš„è§†å›¾æ²¡æœ‰ä¼ å…¥ environmentObject(_:) ä¿®é¥°ç¬¦ï¼Œåˆ™ä¼šé¢„è§ˆå¤±è´¥ã€‚",
      "tips": ""
    },
    "As you navigate from the list to the detail and tap the button, those changes persist when you return to the list. Because both views access the same model object in the environment, the two views maintain consistency.": {
      "zh": "å½“ä½ ä»åˆ—è¡¨å¯¼èˆªåˆ°è¯¦ç»†ä¿¡æ¯å¹¶ç‚¹å‡»æ”¶è—æŒ‰é’®æ—¶ï¼Œè¿™äº›æ›´æ”¹åœ¨ä½ è¿”å›åˆ—è¡¨æ—¶ä»ç„¶å­˜åœ¨ã€‚ å› ä¸ºä¸¤ä¸ªè§†å›¾è®¿é—®ç¯å¢ƒä¸­çš„åŒä¸€ä¸ªæ¨¡å‹å¯¹è±¡ï¼Œæ‰€ä»¥ä¸¤ä¸ªè§†å›¾ä¿æŒä¸€è‡´ã€‚",
      "tips": ""
    },
    "Section 4": {
      "zh": "ç¬¬ 4 èŠ‚",
      "tips": ""
    },
    "After the spacer, add a star image inside an if statement to test whether the current landmark is a favorite.": {
      "zh": "åœ¨ spacer ä¹‹åï¼Œåœ¨ if è¯­å¥ä¸­æ·»åŠ ä¸€ä¸ªæ˜Ÿæ˜Ÿå›¾åƒæ¥æ ‡è¯†å½“å‰åœ°æ ‡æ˜¯å¦æ˜¯æ”¶è—ã€‚",
      "tips": ""
    },
    "The landmarkData.json file has a key with this name for each landmark. Because Landmark conforms to Codable, you can read the value associated with the key by creating a new property with the same name as the key.": {
      "zh": "landmarkData.json æ–‡ä»¶ä¸­çš„æ¯ä¸ªåœ°æ ‡å¯¹è±¡éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ isFavorite é”®ã€‚ å› ä¸º Landmark ç¬¦åˆ Codableï¼Œä½ å¯ä»¥é€šè¿‡åˆ›å»ºä¸ json ä¸­åŒåçš„å±æ€§æ¥è¯»å–ä¸é”®å…³è”çš„å€¼ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "æ­¥éª¤ 7",
      "tips": ""
    },
    "Step 5": {
      "zh": "æ­¥éª¤ 5",
      "tips": ""
    },
    "State is a value, or a set of values, that can change over time, and that affects a viewâ€™s behavior, content, or layout. You use a property with the @State attribute to add state to a view.": {
      "zh": "çŠ¶æ€æ˜¯ä¸€ä¸ªå€¼æˆ–ä¸€ç»„å€¼ï¼Œå¯ä»¥éšæ—¶é—´å˜åŒ–ï¼Œå¹¶å½±å“è§†å›¾çš„è¡Œä¸ºã€å†…å®¹æˆ–å¸ƒå±€ã€‚ ä½ å¯ä»¥ä½¿ç”¨å¸¦æœ‰ @State ç‰¹æ€§çš„å±æ€§æ¥å°†çŠ¶æ€æ·»åŠ åˆ°è§†å›¾ã€‚",
      "tips": ""
    },
    "Open the starting point Xcode project or the project you finished in the previous tutorial, and select Landmark.swift in the Project navigator.": {
      "zh": "æ‰“å¼€åˆå§‹ Xcode é¡¹ç›®æˆ–è€…ä½ åœ¨ä¸Šä¸ªæ•™ç¨‹ä¸­å®Œæˆçš„é¡¹ç›®ï¼Œç„¶ååœ¨é¡¹ç›®å¯¼èˆªå™¨ä¸­é€‰æ‹© Landmark.swiftã€‚",
      "tips": ""
    },
    "Update the ContentView preview to add the model object to the environment, which makes the object available to any subview.": {
      "zh": "æ›´æ–° ContentView é¢„è§ˆï¼Œå°†æ¨¡å‹å¯¹è±¡æ·»åŠ åˆ°ç¯å¢ƒä¸­ï¼Œè¿™ä½¿å¾—è¯¥å¯¹è±¡å¯ç”¨äºä»»ä½•å­è§†å›¾ã€‚",
      "tips": ""
    },
    "An observable object is a custom object for your data that can be bound to a view from storage in SwiftUIâ€™s environment. SwiftUI watches for any changes to observable objects that could affect a view, and displays the correct version of the view after a change.": {
      "zh": "å¯¹äºä½ çš„æ•°æ®æ¥è¯´ï¼Œå¯è§‚å¯Ÿå¯¹è±¡æ˜¯å¯è‡ªå®šä¹‰çš„ï¼Œå®ƒå¯ä»¥ç»‘å®šåˆ° SwiftUI ç¯å¢ƒä¸­å­˜å‚¨çš„è§†å›¾ã€‚ SwiftUI ä¼šç›‘å¬å¯èƒ½å½±å“è§†å›¾çš„å¯è§‚å¯Ÿå¯¹è±¡çš„ä»»ä½•ä¿®æ”¹ï¼Œå¹¶åœ¨å¯è§‚å¯Ÿå¯¹è±¡å‘ç”Ÿæ›´æ”¹ååˆ·æ–°è§†å›¾ï¼Œä¿è¯æ˜¾ç¤ºæ•°æ®æ­£ç¡®ã€‚",
      "tips": ""
    },
    "Declare a new model type that conforms to the ObservableObject protocol from the Combine framework.": {
      "zh": "åˆ›å»ºä¸€ä¸ªæ–°çš„æ¨¡å‹ç±»å‹ï¼Œä½¿å®ƒéµå¾ª Combine æ¡†æ¶ä¸­çš„ ObservableObject åè®®ã€‚",
      "tips": ""
    },
    "Download the starter project and follow along with this tutorial, or open the finished project and explore the code on your own.": {
      "zh": "ä¸‹è½½åˆå§‹é¡¹ç›®å¹¶æŒ‰ç…§æœ¬æ•™ç¨‹è¿›è¡Œæ“ä½œï¼Œæˆ–è€…æ‰“å¼€å®Œæˆçš„é¡¹ç›®è‡ªå·±æ¢ç´¢ä»£ç ã€‚",
      "tips": ""
    },
    "Create a Favorite Button for Each Landmark": {
      "zh": "ä¸ºæ¯ä¸ªåœ°æ ‡åˆ›å»ºä¸€ä¸ªæ”¶è—æŒ‰é’®",
      "tips": ""
    },
    "Next, youâ€™ll add the FavoriteButton to the detail view, binding the buttonâ€™s isSet property to the isFavorite property of a given landmark.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œå°† FavoriteButton æ·»åŠ åˆ°è¯¦æƒ…è§†å›¾ï¼Œå°†æŒ‰é’®çš„ isSet å±æ€§ç»‘å®šç»™å®šåœ°æ ‡çš„ isFavorite å±æ€§ã€‚",
      "tips": ""
    },
    "Because you use state properties to hold information thatâ€™s specific to a view and its subviews, you always create state as private.": {
      "zh": "å› ä¸ºä½ ä½¿ç”¨ @State å±æ€§æ¥ä¿å­˜é’ˆå¯¹äºç‰¹å®šè§†å›¾åŠå…¶å­è§†å›¾çš„çŠ¶æ€ï¼Œæ‰€ä»¥ä½ éœ€è¦å°†å±æ€§è®¾ç½®ä¸ºç§æœ‰çš„ã€‚",
      "tips": ""
    },
    "To support this, you also need access to the environmentâ€™s model data.": {
      "zh": "ä¸ºæ­¤ï¼Œä½ è¿˜éœ€è¦è®¿é—®ç¯å¢ƒä¸­çš„æ¨¡å‹æ•°æ®ã€‚",
      "tips": ""
    },
    "Add a Control to Toggle the State": {
      "zh": "æ·»åŠ æ§åˆ¶æ˜¾ç¤ºçŠ¶æ€çš„æ§ä»¶",
      "tips": ""
    },
    "\u0001Step 5": {
      "zh": "æ­¥éª¤ 5",
      "tips": ""
    },
    "Use the live preview and try out this new functionality by tapping the toggle.": {
      "zh": "ä½¿ç”¨å®æ—¶é¢„è§ˆå¹¶é€šè¿‡ç‚¹å‡»åˆ‡æ¢å¼€å…³æ¥å°è¯•è¿™ä¸ªæ–°åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "\u0001Step 4": {
      "zh": "æ­¥éª¤ 4",
      "tips": ""
    },
    "Add an isSet binding that indicates the buttonâ€™s current state, and provide a constant value for the preview.": {
      "zh": "æ·»åŠ ä¸€ä¸ª isSet å±æ€§è¡¨ç¤ºæŒ‰é’®å½“å‰çš„çŠ¶æ€ï¼Œå¹¶ä¸ºé¢„è§ˆè§†å›¾æä¾›ä¸€ä¸ªå¸¸é‡ã€‚",
      "tips": ""
    },
    "Add the @Published attribute to the landmarks array.": {
      "zh": "å°† @Published å±æ€§æ·»åŠ åˆ° landmarks æ•°ç»„ã€‚",
      "tips": ""
    },
    "Select LandmarkRow.swift in the Project navigator.": {
      "zh": "åœ¨é¡¹ç›®æ–‡ä»¶ç›®å½•ä¸­é€‰æ‹© LandmarkRow.swiftã€‚",
      "tips": ""
    },
    "Create a nested ForEach group to transform the landmarks into rows.": {
      "zh": "åˆ›å»ºä¸€ä¸ªåµŒå¥—çš„ ForEach å°†åœ°æ ‡æ•°æ®è½¬æ¢ä¸ºè¡Œè§†å›¾ã€‚",
      "tips": ""
    },
    "Compute a filtered version of the landmarks list by checking the showFavoritesOnly property and each landmark.isFavorite value.": {
      "zh": "æ£€æŸ¥ showFavoritesOnly å±æ€§å’Œæ¯ä¸ª landmark.isFavorite å€¼æ¥å†³å®šåœ°æ ‡åˆ—è¡¨çš„è¿‡æ»¤æ–¹æ¡ˆã€‚",
      "tips": ""
    },
    "Switch to LandmarkDetail.swift, and compute the index of the input landmark by comparing it with the model data.": {
      "zh": "åˆ‡æ¢åˆ° LandmarkDetail.swiftï¼Œé€šè¿‡å°†ä¼ å…¥çš„ landmark ä¸ modelData è¿›è¡Œæ¯”è¾ƒæ¥è®¡ç®—åœ°æ ‡çš„ç´¢å¼•ã€‚",
      "tips": ""
    },
    "Before moving on, return the default value of showsFavoritesOnly to false.": {
      "zh": "åœ¨ç»§ç»­ä¹‹å‰ï¼Œå°† showsFavoritesOnly çš„é»˜è®¤å€¼è®¾ç½®ä¸º falseã€‚",
      "tips": ""
    },
    "Select LandmarkList.swift in the Project navigator and revert the preview to show only a single version of the list.": {
      "zh": "åœ¨é¡¹ç›®æ–‡ä»¶ç›®å½•ä¸­é€‰æ‹© LandmarkList.swift å¹¶å°†é¢„è§ˆæ¢å¤ä¸ºä»…æ˜¾ç¤ºå•ä¸ªåˆ—è¡¨çš„ç‰ˆæœ¬ã€‚",
      "tips": ""
    },
    "Click Resume to refresh the canvas.": {
      "zh": "å•å‡» Resume åˆ·æ–°ç”»å¸ƒã€‚",
      "tips": ""
    },
    "Add a Toggle view as the first child of the List view, passing a binding to showFavoritesOnly.": {
      "zh": "æ·»åŠ ä¸€ä¸ªå¼€å…³ä½œä¸ºåˆ—è¡¨è§†å›¾çš„ç¬¬ä¸€ä¸ªå­è§†å›¾ï¼Œå°† showFavoritesOnly å€¼ç»‘å®šåˆ°å¼€å…³ã€‚",
      "tips": ""
    },
    "Now that youâ€™ve created the ModelData object, you need to update your views to adopt it as the data store for your app.": {
      "zh": "ç°åœ¨ä½ å·²ç»åˆ›å»ºäº† ModelData å¯¹è±¡ï¼Œä½ å°†ä½¿ç”¨å®ƒæ›´æ–°æ‚¨çš„è§†å›¾ï¼Œå®ƒå°†ä½œä¸ºä½ åº”ç”¨çš„æ•°æ®å­˜å‚¨ã€‚",
      "tips": ""
    },
    "In the projectâ€™s navigation pane, select ModelData.swift.": {
      "zh": "åœ¨é¡¹ç›®çš„æ–‡ä»¶åˆ—è¡¨ä¸­ï¼Œé€‰æ‹© ModelData.swiftã€‚",
      "tips": ""
    },
    "Section 5": {
      "zh": "ç¬¬ 5 èŠ‚",
      "tips": ""
    },
    "Section 6": {
      "zh": "ç¬¬ 6 èŠ‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "æ­¥éª¤ 2",
      "tips": ""
    },
    "Move the landmarks array into the model.": {
      "zh": "å°† landmarks æ•°ç»„ç§»åŠ¨åˆ°æ¨¡å‹ä¸­ã€‚",
      "tips": ""
    },
    "SwiftUI subscribes to your observable object, and updates any views that need refreshing when the data changes.": {
      "zh": "SwiftUI ä¼šè®¢é˜…ä½ çš„å¯è§‚å¯Ÿå¯¹è±¡ï¼Œå¹¶åœ¨æ•°æ®æ›´æ”¹æ—¶æ›´æ–°ä»»ä½•éœ€è¦åˆ·æ–°çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "To prepare for the user to control which particular landmarks are favorites, youâ€™ll first store the landmark data in an observable object.": {
      "zh": "ä¸ºäº†è®©ç”¨æˆ·èƒ½å¤Ÿä¿®æ”¹å–œæ¬¢çš„ç‰¹å®šåœ°æ ‡æ•°æ®ï¼Œé¦–å…ˆè¦å°†åœ°æ ‡æ•°æ®å­˜å‚¨åœ¨ä¸€ä¸ªå¯è§‚å¯Ÿå¯¹è±¡ä¸­ã€‚",
      "tips": ""
    },
    "Mark the Userâ€™s Favorite Landmarks": {
      "zh": "æ ‡è®°ç”¨æˆ·æœ€å–œæ¬¢çš„åœ°æ ‡",
      "tips": ""
    },
    "Adopt the Model Object in Your Views": {
      "zh": "åœ¨ä½ çš„è§†å›¾ä¸­ä½¿ç”¨æ¨¡å‹å¯¹è±¡",
      "tips": ""
    },
    "Drawing Paths and Shapes": {
      "zh": "",
      "tips": ""
    },
    "Update the LandmarksApp to create a model instance and supply it to ContentView using the environmentObject(_:) modifier.": {
      "zh": "æ›´æ–° LandmarksApp åˆ›å»º modelDarta å®ä¾‹å¹¶ä½¿ç”¨ environmentObject(_:) ä¿®é¥°ç¬¦å°†å…¶æä¾›ç»™ ContentViewã€‚",
      "tips": ""
    },
    "As your project grows, itâ€™s a good idea to add hierarchy. Before moving on, create a few more groups.": {
      "zh": "éšç€é¡¹ç›®çš„å¢é•¿ï¼Œæˆ‘ä»¬æœ‰å¿…è¦ç»™æ–‡ä»¶è¿›è¡Œç»“æ„åŒ–ç®¡ç†ã€‚ åœ¨ç»§ç»­ä¹‹å‰ï¼Œå†åˆ›å»ºå‡ ä¸ªæ–‡ä»¶å¤¹ã€‚",
      "tips": ""
    },
    "Collect the general purpose CircleImage.swift, MapView.swift, and FavoriteButton.swift, into a Helpers group, and the landmark views into a Landmarks group.": {
      "zh": "å°† CircleImage.swiftã€MapView.swift å’Œ FavoriteButton.swift æ”¾åˆ°ä¸€ä¸ª Helpers æ–‡ä»¶å¤¹ä¸­ï¼Œå¹¶å°†åœ°æ ‡è§†å›¾æ”¾åˆ°ä¸€ä¸ª Landmarks æ–‡ä»¶å¤¹ä¸­ã€‚",
      "tips": ""
    },
    "The title string that you provide for the buttonâ€™s label doesnâ€™t appear in the UI when you use the iconOnly label style, but VoiceOver uses it to improve accessibility.": {
      "zh": "å½“ä½ ä½¿ç”¨ iconOnly æ ‡ç­¾æ ·å¼æ—¶ï¼Œä½ ä¸ºæŒ‰é’®æ ‡ç­¾æä¾›çš„æ ‡é¢˜å­—ç¬¦ä¸²ä¸ä¼šå‡ºç°åœ¨ UI ä¸­ï¼Œä½† VoiceOver å¯ä»¥ä½¿ç”¨å®ƒæ¥æé«˜å¯è®¿é—®æ€§ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "æ­¥éª¤ 4",
      "tips": ""
    },
    "Add an isFavorite property to the Landmark structure.": {
      "zh": "å°† isFavorite å±æ€§æ·»åŠ åˆ° Landmark ç»“æ„ä½“ä¸­ã€‚",
      "tips": ""
    },
    "To combine static and dynamic views in a list, or to combine two or more different groups of dynamic views, use the ForEach type instead of passing your collection of data to List.": {
      "zh": "è¦åœ¨åˆ—è¡¨ä¸­ç»„åˆé™æ€å’ŒåŠ¨æ€è§†å›¾ï¼Œæˆ–è€…ç»„åˆä¸¤ä¸ªæˆ–å¤šä¸ªä¸åŒçš„åŠ¨æ€è§†å›¾ç»„ï¼Œè¯·ä½¿ç”¨ ForEach ç±»å‹ï¼Œè€Œä¸æ˜¯å°†æ•°æ®é›†åˆä¼ é€’ç»™ Listã€‚",
      "tips": ""
    },
    "Use landmarkIndex with the modelData object to ensure that the button updates the isFavorite property of the landmark stored in your model object.": {
      "zh": "å°† landmarkIndex ä¸ modelData å¯¹è±¡ä¸€èµ·ä½¿ç”¨ï¼Œä¿è¯æŒ‰é’®æ›´æ–° modelData çš„åœ°æ ‡æ•°ç»„å…¶ä¸­çš„ä¸€ä¸ªåœ°æ ‡çš„ isFavorite å±æ€§ã€‚",
      "tips": ""
    },
    "The modelData property gets its value automatically, as long as the environmentObject(_:) modifier has been applied to a parent.": {
      "zh": "åªè¦ environmentObject(_:) ä¿®é¥°ç¬¦åœ¨çˆ¶çº§åº”ç”¨ï¼Œå­çº§çš„ modelData å±æ€§å°±ä¼šè‡ªåŠ¨è·å–å…¶å€¼ã€‚",
      "tips": ""
    },
    "Update the LandmarkDetail view to work with the ModelData object in the environment.": {
      "zh": "æ›´æ–° LandmarkDetail è§†å›¾çš„é¢„è§ˆä»¥ä½¿ç”¨ç¯å¢ƒä¸­çš„ ModelData å¯¹è±¡ã€‚",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ 3 èŠ‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "æ­¥éª¤ 1",
      "tips": ""
    },
    "Use the @StateObject attribute to initialize a model object for a given property only once during the life time of the app. This is true when you use the attribute in an app instance, as shown here, as well as when you use it in a view.": {
      "zh": "ä½¿ç”¨ @StateObject ä¿®é¥°æŒ‡å®šå±æ€§ï¼Œåœ¨åº”ç”¨ç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸå†…ä»…ä¼šåˆå§‹åŒ–ä¸€æ¬¡æ¨¡å‹å¯¹è±¡ã€‚ å½“ä½ åœ¨ App å®ä¾‹ä¸­ä½¿ç”¨è¯¥å±æ€§æ—¶ï¼ˆå¦‚æ­¤å¤„æ‰€ç¤ºï¼‰ä»¥åŠåœ¨å­è§†å›¾ä¸­ä½¿ç”¨å®ƒæ—¶éƒ½æ˜¯å¦‚æ­¤ã€‚",
      "tips": ""
    },
    "Next, youâ€™ll update the app instance to put the model object in the environment when you run the app in the simulator or on a device.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œå½“ä½ åœ¨æ¨¡æ‹Ÿå™¨æˆ–è®¾å¤‡ä¸Šè¿è¡Œåº”ç”¨ç¨‹åºæ—¶ï¼Œä½ å°†æ›´æ–° App æ–‡ä»¶å°†æ¨¡å‹å¯¹è±¡æ”¾å…¥ç¯å¢ƒä¸­ã€‚",
      "tips": ""
    },
    "Handling User Input": {
      "zh": "",
      "tips": ""
    },
    "Create a Button with an action that toggles the isSet state, and that changes its appearance based on the state.": {
      "zh": "åˆ›å»ºä¸€ä¸ªæŒ‰é’®ç”¨æ¥åˆ‡æ¢ isSet çš„çŠ¶æ€ï¼Œå¹¶ä¸”æ ¹æ®çŠ¶æ€æ”¹å˜å¤–è§‚ã€‚",
      "tips": ""
    }
  },
  "swiftui/interfacing-with-uikit": {
    "To prepare for adding a custom UIPageControl, you need a way to track the current page from within PageView.": {
      "zh": "è¦å‡†å¤‡æ·»åŠ è‡ªå®šä¹‰ UIPageControlï¼Œä½ éœ€è¦ä¸€ç§ä» PageView ä¸­è·Ÿè¸ªå½“å‰é¡µé¢çš„æ–¹æ³•ã€‚",
      "tips": ""
    },
    "Next, youâ€™ll create a custom view to present your UIViewControllerRepresentable view.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰è§†å›¾æ¥å‘ˆç°ä½ çš„ UIViewControllerRepresentable è§†å›¾ã€‚",
      "tips": ""
    },
    "Because SwiftUI calls this method whenever a page switching animation completes, you can find the index of the current view controller and update the binding.": {
      "zh": "å› ä¸º SwiftUI ä¼šåœ¨é¡µé¢åˆ‡æ¢åŠ¨ç”»å®Œæˆæ—¶è°ƒç”¨æ­¤æ–¹æ³•ï¼Œæ‰€ä»¥ä½ å¯ä»¥æ‰¾åˆ°å½“å‰è§†å›¾æ§åˆ¶å™¨çš„ç´¢å¼•å¹¶æ›´æ–°ç»‘å®šå€¼ã€‚",
      "tips": ""
    },
    "Update the preview provider to pass the required array of views, and the preview starts working.": {
      "zh": "æ›´æ–°é¢„è§ˆæä¾›ç±»å¹¶ä¼ é€’æ‰€éœ€çš„è§†å›¾æ•°ç»„ï¼Œç„¶åé¢„è§ˆå°†ä¼šå¼€å§‹å·¥ä½œã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "æ­¥éª¤ 6",
      "tips": ""
    },
    "Observe that when you swipe from page to page, the value doesnâ€™t change.": {
      "zh": "è¯·æ³¨æ„ï¼Œå½“ä½ ä»ä¸€é¡µæ»‘åŠ¨åˆ°å¦ä¸€é¡µæ—¶ï¼Œå®ƒçš„å€¼ä¸ä¼šæ”¹å˜ã€‚",
      "tips": ""
    },
    "Add an updateUIViewController(_:context:) method that calls setViewControllers(_:direction:animated:) to provide a view controller for display.": {
      "zh": "æ·»åŠ ä¸€ä¸ªè°ƒç”¨äº† setViewControllers(_:direction:animated:) çš„ updateUIViewController(_:context:) æ–¹æ³•æ¥æä¾›ç”¨äºæ˜¾ç¤ºçš„è§†å›¾æ§åˆ¶å™¨ã€‚",
      "tips": ""
    },
    "UIViewRepresentable and UIViewControllerRepresentable types have the same life cycle, with methods that correspond to their underlying UIKit types.": {
      "zh": "UIViewRepresentable å’Œ UIViewControllerRepresentable ç±»å‹å…·æœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸï¼Œå®ƒä»¬å…·æœ‰ä¸å…¶åº•å±‚ UIKit ç±»å‹ç›¸å¯¹åº”çš„æ–¹æ³•ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "æ­¥éª¤ 8",
      "tips": ""
    },
    "With the binding connected in both directions, the text view updates to show the correct page number after each swipe.": {
      "zh": "é€šè¿‡åŒå‘è¿æ¥çš„ç»‘å®šï¼Œåœ¨æ¯æ¬¡æ»‘åŠ¨åæ–‡æœ¬è§†å›¾ä¼šæ›´æ–°æ˜¾ç¤ºæ­£ç¡®çš„é¡µç ã€‚",
      "tips": ""
    },
    "The preview fails because Xcode canâ€™t infer a type for Page.": {
      "zh": "é¢„è§ˆå¤±è´¥ï¼Œå› ä¸º Xcode æ— æ³•æ¨æ–­ Page çš„ç±»å‹ã€‚",
      "tips": ""
    },
    "Add a makeUIViewController(context:) method that creates a UIPageViewController with the desired configuration.": {
      "zh": "æ·»åŠ ä¸€ä¸ª makeUIViewController(context:) æ–¹æ³•æ¥åˆ›å»ºå¸¦æœ‰æˆ‘ä»¬éœ€è¦é…ç½®çš„ UIPageViewControllerã€‚",
      "tips": ""
    },
    "Interfacing with UIKit": {
      "zh": "",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ 1 èŠ‚",
      "tips": ""
    },
    "A landmarkâ€™s feature image, if it exists, has different dimensions than the regular image.": {
      "zh": "åœ°æ ‡çš„ç‰¹å¾å›¾åƒï¼ˆå¦‚æœå­˜åœ¨ï¼‰ä¸å¸¸è§„å›¾åƒå…·æœ‰ä¸åŒçš„å°ºå¯¸ã€‚",
      "tips": ""
    },
    "Create a View to Represent a UIPageViewController": {
      "zh": "åˆ›å»ºä¸€ä¸ªè§†å›¾æ¥è¡¨ç¤º UIPageViewController",
      "tips": ""
    },
    "Create the View Controllerâ€™s Data Source": {
      "zh": "åˆ›å»ºè§†å›¾æ§åˆ¶å™¨çš„æ•°æ®æº",
      "tips": ""
    },
    "Replace the text box with the page control, switching from a VStack to a ZStack for layout.": {
      "zh": "å°†æ–‡æœ¬æ¡†æ›¿æ¢ä¸º PageControlï¼Œå°†å¸ƒå±€ä» VStack åˆ‡æ¢åˆ° ZStackã€‚",
      "tips": ""
    },
    "Create a nested Coordinator type in PageControl, and add a makeCoordinator() method to create and return a new coordinator.": {
      "zh": "åœ¨ PageControl ä¸­åˆ›å»ºä¸€ä¸ªåµŒå¥—çš„ Coordinator ç±»å‹ï¼Œå¹¶æ·»åŠ ä¸€ä¸ª makeCoordinator() æ–¹æ³•æ¥åˆ›å»ºå¹¶è¿”å›ä¸€ä¸ªæ–°çš„åè°ƒå™¨ã€‚",
      "tips": ""
    },
    "You can use this coordinator to implement common Cocoa patterns, such as delegates, data sources, and responding to user events via target-action.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨è¿™ä¸ªåè°ƒå™¨æ¥å®ç°å¸¸è§çš„ Cocoa æ¨¡å¼ï¼Œæ¯”å¦‚å§”æ‰˜ï¼Œæ•°æ®æºä»¥åŠé€šè¿‡ç›®æ ‡ - åŠ¨ä½œå“åº”ç”¨æˆ·äº‹ä»¶ã€‚",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "This tutorial gives you a chance to apply much of what youâ€™ve already learned about SwiftUI, and â€” with little effort â€” migrate the Landmarks app to watchOS.": {
      "zh": "æœ¬æ•™ç¨‹è®©ä½ æœ‰æœºä¼šåº”ç”¨ä½ å·²äº†è§£çš„æœ‰å…³ SwiftUI çš„å¤§éƒ¨åˆ†çŸ¥è¯†ï¼Œå¹¶ä¸”åªéœ€å¾ˆå°‘çš„åŠªåŠ›å³å¯å°† Landmarks åº”ç”¨ç¨‹åºè¿ç§»åˆ° watchOSã€‚",
      "tips": ""
    },
    "This tutorial shows you how to convert the featured landmark from the home screen to wrap instances of UIPageViewController and UIPageControl. Youâ€™ll use UIPageViewController to display a carousel of SwiftUI views, and use state variables and bindings to coordinate data updates throughout the user interface.": {
      "zh": "æœ¬æ•™ç¨‹å‘ä½ å±•ç¤ºå¦‚ä½•å°†ä¸»å±å¹•ä¸Šçš„ç‰¹è‰²åœ°æ ‡è½¬æ¢æˆä¸ºåŒ…è£… UIPageViewController å’Œ UIPageControl çš„å®ä¾‹ã€‚ ä½ å°†ä½¿ç”¨ UIPageViewController æ¥æ˜¾ç¤º SwiftUI è§†å›¾çš„è½®æ’­ï¼Œå¹¶ä½¿ç”¨çŠ¶æ€å˜é‡å’Œç»‘å®šæ¥åè°ƒæ•´ä¸ªç”¨æˆ·ç•Œé¢çš„æ•°æ®æ›´æ–°ã€‚",
      "tips": ""
    },
    "Finally, in CategoryHome, replace the placeholder feature image with the new page view.": {
      "zh": "æœ€åï¼Œåœ¨ CategoryHome ä¸­ï¼Œå°†å ä½å›¾ç‰‡æ›¿æ¢ä¸ºæ–°çš„ PageViewã€‚",
      "tips": ""
    },
    "Overlay text information about the landmark on the image.": {
      "zh": "åœ¨å›¾åƒä¸Šå åŠ æœ‰å…³åœ°æ ‡çš„æ–‡æœ¬ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Test that the value flows through the binding to the PageViewController by changing its initial value.": {
      "zh": "é€šè¿‡æ›´æ”¹å…¶åˆå§‹å€¼æ¥æµ‹è¯•è¯¥å€¼æ˜¯å¦é€šè¿‡ç»‘å®šæµå‘ PageViewControllerã€‚",
      "tips": ""
    },
    "Before you continue, prepare a feature card for use as a page.": {
      "zh": "åœ¨ç»§ç»­ä¹‹å‰ï¼Œè¯·å‡†å¤‡ä¸€å¼ åŠŸèƒ½å¡ç‰‡è§†å›¾ä»¥ç”¨ä½œé¡µé¢ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "æ­¥éª¤ 3",
      "tips": ""
    },
    "Add the coordinator as the target for the valueChanged event, specifying the updateCurrentPage(sender:) method as the action to perform.": {
      "zh": "æ·»åŠ åè°ƒå™¨ä½œä¸º valueChanged äº‹ä»¶çš„ç›®æ ‡ï¼ŒæŒ‡å®š updateCurrentPage(sender:) æ–¹æ³•ä½œä¸ºè¦æ‰§è¡Œçš„æ“ä½œã€‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬ 2 èŠ‚",
      "tips": ""
    },
    "Add a button to PageView that makes the page view controller jump to the second view.": {
      "zh": "å‘ PageView æ·»åŠ ä¸€ä¸ªæŒ‰é’®ï¼Œä½¿é¡µé¢è§†å›¾æ§åˆ¶å™¨è·³è½¬åˆ°ç¬¬äºŒä¸ªè§†å›¾ã€‚",
      "tips": ""
    },
    "Initialize an array of controllers in the coordinator using the pages array of views.": {
      "zh": "ä½¿ç”¨ pages è§†å›¾æ•°ç»„åˆå§‹åŒ–åè°ƒå™¨ä¸­çš„æ§åˆ¶å™¨æ•°ç»„ã€‚",
      "tips": ""
    },
    "To do this, youâ€™ll declare a @State property in PageView, and pass a binding to this property down to the PageViewController view. The PageViewController updates the binding to match the visible page.": {
      "zh": "ä¸ºäº†åšåˆ°è¿™ç§æ•ˆæœï¼Œä½ éœ€è¦åœ¨ PageView ä¸­å£°æ˜ä¸€ä¸ª @State å±æ€§ï¼Œå¹¶å°†å¯¹è¯¥å±æ€§çš„ç»‘å®šå‘ä¸‹ä¼ é€’åˆ° PageViewController è§†å›¾ã€‚ PageViewController æ›´æ–°ç»‘å®šçš„å€¼æ¥åŒ¹é…å¯è§é¡µé¢ã€‚",
      "tips": ""
    },
    "SwiftUI manages your UIViewControllerRepresentable typeâ€™s coordinator, and provides it as part of the context when calling the methods you created above.": {
      "zh": "SwiftUI ç®¡ç†ä½ çš„ UIViewControllerRepresentable ç±»å‹çš„åè°ƒå™¨ï¼Œå¹¶åœ¨è°ƒç”¨ä½ åœ¨ä¸Šé¢åˆ›å»ºçš„æ–¹æ³•æ—¶å°†å…¶ä½œä¸ºä¸Šä¸‹æ–‡çš„ä¸€éƒ¨åˆ†æä¾›ã€‚",
      "tips": ""
    },
    "Section 4": {
      "zh": "ç¬¬ 4 èŠ‚",
      "tips": ""
    },
    "Create a PageView group in your projectâ€™s Views folder, and add a new Swift file named PageViewController.swift; Declare the PageViewController type as conforming to UIViewControllerRepresentable.": {
      "zh": "åœ¨é¡¹ç›®çš„ Views æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ª PageView æ–‡ä»¶å¤¹ï¼Œå¹¶æ·»åŠ ä¸€ä¸ªåä¸º PageViewController.swift çš„æ–° Swift æ–‡ä»¶ï¼› å°† PageViewController ç±»å‹å£°æ˜ä¸ºç¬¦åˆ UIViewControllerRepresentable åè®®ã€‚",
      "tips": ""
    },
    "Now try out all the different interactions â€” PageView shows how UIKit and SwiftUI views and controllers can work together.": {
      "zh": "ç°åœ¨å°è¯•ä¸€ä¸‹æ‰€æœ‰ä¸åŒçš„äº¤äº’æ•ˆæœâ€”â€”PageView å±•ç¤ºäº† UIKit å’Œ SwiftUI è§†å›¾å’Œæ§åˆ¶å™¨å¦‚ä½•ååŒå·¥ä½œã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "æ­¥éª¤ 7",
      "tips": ""
    },
    "Step 5": {
      "zh": "æ­¥éª¤ 5",
      "tips": ""
    },
    "SwiftUI works seamlessly with the existing UI frameworks on all Apple platforms. For example, you can place UIKit views and view controllers inside SwiftUI views, and vice versa.": {
      "zh": "SwiftUI å¯ä»¥ä¸æ‰€æœ‰ Apple å¹³å°ä¸Šçš„ç°æœ‰ UI æ¡†æ¶æ— ç¼åä½œã€‚ ä¾‹å¦‚ï¼Œä½ å¯ä»¥å°† UIKit è§†å›¾å’Œè§†å›¾æ§åˆ¶å™¨æ”¾ç½®åœ¨ SwiftUI è§†å›¾ä¸­ï¼Œåä¹‹äº¦ç„¶ã€‚",
      "tips": ""
    },
    "These two methods establish the relationships between view controllers, so that you can swipe back and forth between them.": {
      "zh": "è¿™ä¸¤ç§æ–¹æ³•å»ºç«‹è§†å›¾æ§åˆ¶å™¨ä¹‹é—´çš„å…³ç³»ï¼Œè®©ä½ å¯ä»¥åœ¨å®ƒä»¬ä¹‹é—´æ¥å›æ»‘åŠ¨ã€‚",
      "tips": ""
    },
    "The page view controller stores an array of Page instances, which must be a type of View. These are the pages you use to scroll between landmarks.": {
      "zh": "é¡µé¢è§†å›¾æ§åˆ¶å™¨å­˜å‚¨ä¸€ä¸ª Page å®ä¾‹æ•°ç»„ï¼Œå®ƒå¿…é¡»æ˜¯ View ç±»å‹ã€‚ è¿™äº›æ˜¯ä½ ç”¨æ¥åœ¨æ»šåŠ¨åˆ‡æ¢åœ°æ ‡çš„é¡µé¢ã€‚",
      "tips": ""
    },
    "Tip": {
      "zh": "æç¤º",
      "tips": ""
    },
    "Add a Custom Page Control": {
      "zh": "æ·»åŠ è‡ªå®šä¹‰é¡µé¢æ§ä»¶",
      "tips": ""
    },
    "Add another method to PageViewController to make the coordinator.": {
      "zh": "å‘ PageViewController æ·»åŠ å¦ä¸€ä¸ªæ–¹æ³•æ¥åˆ›å»ºåè°ƒå™¨ã€‚",
      "tips": ""
    },
    "Because UIControl subclasses like UIPageControl use the target-action pattern instead of delegation, this Coordinator implements an @objc method to update the current page binding.": {
      "zh": "å› ä¸ºåƒ UIPageControl è¿™æ ·çš„ UIControl å­ç±»ä½¿ç”¨ç›®æ ‡-åŠ¨ä½œæ¨¡å¼è€Œä¸æ˜¯ä»£ç†æ¨¡å¼ï¼Œæ‰€ä»¥è¿™ä¸ª Coordinator å®ç°äº†ä¸€ä¸ª@objc æ–¹æ³•æ¥æ›´æ–°å½“å‰é¡µé¢ç»‘å®šã€‚",
      "tips": ""
    },
    "Create a new SwiftUI view file, named PageControl.swift. Update the PageControl type to conform to the UIViewRepresentable protocol.": {
      "zh": "åˆ›å»ºä¸€ä¸ªæ–°çš„ SwiftUI è§†å›¾æ–‡ä»¶ï¼Œå‘½åä¸º PageControl.swiftã€‚ æ›´æ–° PageControl ç±»ä½¿å®ƒéµå¾ª UIViewRepresentable åè®®ã€‚",
      "tips": ""
    },
    "Youâ€™re ready to add a custom UIPageControl to your view, wrapped in SwiftUI UIViewRepresentable view.": {
      "zh": "ä½ å·²å‡†å¤‡å¥½å°†è‡ªå®šä¹‰ UIPageControl æ·»åŠ åˆ°ä½ çš„è§†å›¾ï¼ŒåŒ…è£…åœ¨ SwiftUI UIViewRepresentable è§†å›¾ä¸­ã€‚",
      "tips": ""
    },
    "Add a text view with the currentPage property, so that you can keep an eye on the @State propertyâ€™s value.": {
      "zh": "æ·»åŠ å…·æœ‰ currentPage å±æ€§çš„æ–‡æœ¬è§†å›¾ï¼Œä»¥ä¾¿ä½ å¯ä»¥è§‚å¯Ÿ @State å±æ€§çš„å€¼ã€‚",
      "tips": ""
    },
    "In addition to declaring the @Binding property, you also update the call to setViewControllers(_:direction:animated:), passing the value of the currentPage binding.": {
      "zh": "é™¤äº†å£°æ˜ @Binding å±æ€§ä¹‹å¤–ï¼Œä½ è¿˜å°†æ›´æ–°å¯¹ setViewControllers(_:direction:animated:) çš„è°ƒç”¨ï¼Œä¼ é€’äº† currentPage çš„å€¼è¿›è¡Œç»‘å®šã€‚",
      "tips": ""
    },
    "Follow the steps to build this project, or download the finished project to explore on your own.": {
      "zh": "æŒ‰ç…§æ­¥éª¤æ„å»ºæ­¤é¡¹ç›®ï¼Œæˆ–ä¸‹è½½å·²å®Œæˆçš„é¡¹ç›®æ¥è‡ªè¡Œæ¢ç´¢ã€‚",
      "tips": ""
    },
    "SwiftUI calls this method a single time when itâ€™s ready to display the view, and then manages the view controllerâ€™s life cycle.": {
      "zh": "SwiftUI åœ¨å‡†å¤‡å¥½æ˜¾ç¤ºè§†å›¾æ—¶ä¼šè°ƒç”¨æ­¤æ–¹æ³•ä¸€æ¬¡ï¼Œç„¶åç®¡ç†è§†å›¾æ§åˆ¶å™¨çš„ç”Ÿå‘½å‘¨æœŸã€‚",
      "tips": ""
    },
    "Return to PageView, turn on live previews, and test out the swipe interactions.": {
      "zh": "è¿”å› PageViewï¼Œæ‰“å¼€å®æ—¶é¢„è§ˆï¼Œå¹¶æµ‹è¯•æ»‘åŠ¨äº¤äº’ã€‚",
      "tips": ""
    },
    "Remember to use the $ syntax to create a binding to a value that is stored as state.": {
      "zh": "è¯·è®°ä½ä½¿ç”¨ $ è¯­æ³•è®¾ç½®å¸¦ @State å±æ€§çš„å€¼ã€‚",
      "tips": ""
    },
    "For now, you create the UIHostingController that hosts the page SwiftUI view on every update. Later, youâ€™ll make this more efficient by initializing the controller only once for the life of the page view controller.": {
      "zh": "ç°åœ¨ï¼Œä½ åœ¨æ¯æ¬¡æ›´æ–°æ—¶éƒ½åˆ›å»ºæ‰˜ç®¡ SwiftUI è§†å›¾çš„ UIHostingControllerã€‚ç¨åï¼Œå°†é€šè¿‡ä»…åœ¨é¡µé¢è§†å›¾æ§åˆ¶å™¨çš„ç”Ÿå‘½å‘¨æœŸå†…åˆå§‹åŒ–ä¸€æ¬¡æ§åˆ¶å™¨æ¥æé«˜æ•ˆç‡ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "æ­¥éª¤ 2",
      "tips": ""
    },
    "In a few short steps, youâ€™ve done a lot â€” the PageViewController uses a UIPageViewController to show content from a SwiftUI view. Now itâ€™s time to enable swiping interactions to move from page to page.": {
      "zh": "åœ¨å‡ ä¸ªç®€çŸ­çš„æ­¥éª¤ä¸­ï¼Œä½ å·²ç»å®Œæˆäº†å¾ˆå¤šå·¥ä½œ â€”â€” PageViewController ä½¿ç”¨ UIPageViewController æ¥æ˜¾ç¤ºæ¥è‡ª SwiftUI è§†å›¾çš„å†…å®¹ã€‚ ç°åœ¨æ˜¯æ—¶å€™å¯ç”¨æ»‘åŠ¨äº¤äº’ä»¥ä»ä¸€ä¸ªé¡µé¢ç§»åŠ¨åˆ°å¦ä¸€ä¸ªé¡µé¢äº†ã€‚",
      "tips": ""
    },
    "Creating a watchOS App": {
      "zh": "",
      "tips": ""
    },
    "Assign the coordinator as the delegate for the UIPageViewController, in addition to the data source.": {
      "zh": "é™¤äº†æ•°æ®æºä¹‹å¤–ï¼Œè¿˜å°†åè°ƒå™¨æŒ‡å®šä¸º UIPageViewController çš„å§”æ‰˜ã€‚",
      "tips": ""
    },
    "To represent UIKit views and view controllers in SwiftUI, you create types that conform to the UIViewRepresentable and UIViewControllerRepresentable protocols. Your custom types create and configure the UIKit types that they represent, while SwiftUI manages their life cycle and updates them when needed.": {
      "zh": "è¦åœ¨ SwiftUI ä¸­å±•ç¤º UIKit è§†å›¾å’Œè§†å›¾æ§åˆ¶å™¨ï¼Œä½ å¯ä»¥åˆ›å»ºç¬¦åˆ UIViewRepresentable å’Œ UIViewControllerRepresentable åè®®çš„ç±»ã€‚ ç„¶åç”¨ä½ è‡ªå®šä¹‰çš„ç±»åˆ›å»ºå’Œé…ç½®å®ƒä»¬æ‰€è¡¨ç¤ºçš„ UIKit ç±»å‹ï¼Œè€Œ SwiftUI ç®¡ç†å®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸå¹¶åœ¨éœ€è¦æ—¶æ›´æ–°å®ƒä»¬ã€‚",
      "tips": ""
    },
    "Next, add the two requirements for the UIViewControllerRepresentable protocol.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œæ·»åŠ  UIViewControllerRepresentable åè®®çš„ä¸¤ä¸ªè¦æ±‚ã€‚",
      "tips": ""
    },
    "Because youâ€™re passing the page count and the binding to the current page, the page control is already showing the correct values.": {
      "zh": "å› ä¸ºä½ å·²ç»å°†é¡µæ•°å’Œå½“å‰å®šä½ä¼ é€’åˆ°å½“å‰é¡µé¢ï¼Œæ‰€ä»¥é¡µé¢æ§ä»¶å·²ç»æ˜¾ç¤ºäº†æ­£ç¡®çš„å€¼ã€‚",
      "tips": ""
    },
    "Track the Page in a SwiftUI Viewâ€™s State": {
      "zh": "åœ¨ SwiftUI è§†å›¾çš„çŠ¶æ€ä¸­è·Ÿè¸ªé¡µé¢å˜åŒ–",
      "tips": ""
    },
    "A SwiftUI view that represents a UIKit view controller can define a Coordinator type that SwiftUI manages and provides as part of the representable viewâ€™s context.": {
      "zh": "è¡¨ç¤º UIKit è§†å›¾æ§åˆ¶å™¨çš„ SwiftUI è§†å›¾å¯ä»¥å®šä¹‰ä¸€ä¸ª Coordinator ç±»å‹ï¼Œè¿™ä¸ªè§†å›¾ç”± SwiftUI ç®¡ç†å¹¶ä½œä¸ºå¯å‘ˆç°è§†å›¾ä¸Šä¸‹æ–‡çš„ä¸€éƒ¨åˆ†",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®éªŒ",
      "tips": ""
    },
    "In PageViewController.swift, conform the coordinator to UIPageViewControllerDelegate, and add the pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted completed: Bool) method.": {
      "zh": "åœ¨ PageViewController.swift ä¸­ï¼Œä½¿åè°ƒå™¨ç¬¦åˆ UIPageViewControllerDelegate åè®®ï¼Œå¹¶æ·»åŠ  pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted completed: Bool) æ–¹æ³•ã€‚",
      "tips": ""
    },
    "Add the coordinator as the data source of the UIPageViewController.": {
      "zh": "æ·»åŠ åè°ƒå™¨ä½œä¸º UIPageViewController çš„æ•°æ®æºã€‚",
      "tips": ""
    },
    "Declare the @State variable in PageView, and pass a binding to the property when creating the child PageViewController.": {
      "zh": "åœ¨ PageView ä¸­å£°æ˜ @State å˜é‡ï¼Œå¹¶åœ¨åˆ›å»ºå­ PageViewController æ—¶å°†è¯¥å±æ€§ä¼ è¿›å»ã€‚",
      "tips": ""
    },
    "Start by adding a currentPage binding as a property of PageViewController.": {
      "zh": "é¦–å…ˆä¸º PageViewController æ·»åŠ ä¸€ä¸ª currentPage ç»‘å®šå±æ€§ã€‚",
      "tips": ""
    },
    "SwiftUI calls this makeCoordinator() method before makeUIViewController(context:), so that you have access to the coordinator object when configuring your view controller.": {
      "zh": "SwiftUI åœ¨ makeUIViewController(context:) ä¹‹å‰è°ƒç”¨æ­¤ makeCoordinator() æ–¹æ³•ï¼Œè¿™æ ·åœ¨é…ç½®è§†å›¾æ§åˆ¶å™¨æ—¶å°±å¯ä»¥è®¿é—®åè°ƒå™¨å¯¹è±¡ã€‚",
      "tips": ""
    },
    "Create a new SwiftUI view file, named PageView.swift, and update the PageView type to declare PageViewController as a child view.": {
      "zh": "åˆ›å»ºä¸€ä¸ªæ–°çš„ SwiftUI è§†å›¾æ–‡ä»¶ï¼Œå‘½åä¸º PageView.swiftï¼Œå¹¶æ›´æ–° PageView ç±»ï¼Œå°† PageViewController å£°æ˜ä¸ºå­è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "æ­¥éª¤ 4",
      "tips": ""
    },
    "Declare a nested Coordinator class inside PageViewController.": {
      "zh": "åœ¨ PageViewController ä¸­å£°æ˜ä¸€ä¸ªåµŒå¥—çš„ Coordinator ç±»ã€‚",
      "tips": ""
    },
    "Add UIPageViewControllerDataSource conformance to the Coordinator type, and implement the two required methods.": {
      "zh": "å°† UIPageViewControllerDataSource åè®®æ·»åŠ åˆ° Coordinator ç±»ï¼Œå¹¶å®ç°ä¸¤ä¸ªå¿…éœ€çš„æ–¹æ³•ã€‚",
      "tips": ""
    },
    "Next, make the page control interactive so users can tap one side or the other to move between pages.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œä½¿é¡µé¢æ§ä»¶èƒ½å¤Ÿè¿›è¡Œäº¤äº’ï¼Œä»¥ä¾¿ç”¨æˆ·å¯ä»¥ç‚¹å‡»ä¸€ä¾§æˆ–å¦ä¸€ä¾§ä»¥åœ¨é¡µé¢ä¹‹é—´ç§»åŠ¨ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "æ­¥éª¤ 9",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ 3 èŠ‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "æ­¥éª¤ 1",
      "tips": ""
    },
    "Add a computed property to the Landmark structure that returns the feature image, if it exists.": {
      "zh": "å°†è®¡ç®—å±æ€§æ·»åŠ åˆ° Landmark ç»“æ„ä½“ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ï¼Œè¿™ä¸ªå±æ€§è¿”å›åœ°æ ‡çš„ç‰¹å¾å›¾åƒ ã€‚",
      "tips": ""
    },
    "Important": {
      "zh": "é‡è¦çš„",
      "tips": ""
    },
    "The coordinator is a good place to store these controllers, because the system initializes them only once, and before you need them to update the view controller.": {
      "zh": "åè°ƒå™¨æ˜¯å­˜å‚¨è¿™äº›æ§åˆ¶å™¨çš„å¥½åœ°æ–¹ï¼Œå› ä¸ºç³»ç»Ÿåªåˆå§‹åŒ–å®ƒä»¬ä¸€æ¬¡ï¼Œå¹¶ä¸”æ˜¯åœ¨ä½ éœ€è¦å®ƒä»¬æ›´æ–°è§†å›¾æ§åˆ¶å™¨ä¹‹å‰ã€‚",
      "tips": ""
    },
    "Drag the images in the downloaded project filesâ€™ Resources directory into your appâ€™s Asset catalog.": {
      "zh": "å°†ä¸‹è½½çš„é¡¹ç›®æ–‡ä»¶çš„ Resources ç›®å½•ä¸­çš„å›¾åƒæ‹–åˆ°åº”ç”¨ç¨‹åºçš„ Asset ç›®å½•ä¸­ã€‚",
      "tips": ""
    },
    "Add a new SwiftUI view file, named FeatureCard.swift that displays the landmarkâ€™s feature image.": {
      "zh": "æ·»åŠ ä¸€ä¸ªåä¸º FeatureCard.swift çš„æ–° SwiftUI è§†å›¾æ–‡ä»¶ï¼Œç”¨äºæ˜¾ç¤ºåœ°æ ‡çš„ç‰¹å¾å›¾åƒã€‚",
      "tips": ""
    }
  },
  "swiftui/working-with-ui-controls": {
    "Note": {
      "zh": "ç¬”è®°",
      "tips": ""
    },
    "SwiftUI works seamlessly with the existing UI frameworks on all Apple platforms. For example, you can place UIKit views and view controllers inside SwiftUI views, and vice versa.": {
      "zh": "SwiftUI å¯ä¸æ‰€æœ‰ Apple å¹³å°ä¸Šçš„ç°æœ‰ UI æ¡†æ¶æ— ç¼åä½œã€‚ ä¾‹å¦‚ï¼Œä½ å¯ä»¥å°† UIKit è§†å›¾å’Œè§†å›¾æ§åˆ¶å™¨æ”¾ç½®åœ¨ SwiftUI è§†å›¾ä¸­ï¼Œåä¹‹äº¦ç„¶ã€‚",
      "tips": ""
    },
    "SwiftUI provides storage in the environment for values you can access using the @Environment property wrapper. Access the editMode value to read or write the edit scope.": {
      "zh": "SwiftUI åœ¨ç¯å¢ƒä¸­æä¾›äº†å­˜å‚¨ï¼Œä½ å¯ä»¥ä½¿ç”¨ @Environment å±æ€§åŒ…è£…å™¨è®¿é—®è¿™äº›å€¼ã€‚è®¿é—® editMode å€¼ä»¥è¯»å–æˆ–å†™å…¥ç¼–è¾‘èŒƒå›´ã€‚",
      "tips": ""
    },
    "The first control in the view is a TextField, which controls and updates a string binding â€” in this case, the userâ€™s chosen display name. You provide a label and a binding to a string when creating a text field.": {
      "zh": "è§†å›¾ä¸­çš„ç¬¬ä¸€ä¸ªæ§ä»¶æ˜¯ TextFieldï¼Œå®ƒæ§åˆ¶å’Œæ›´æ–°å­—ç¬¦ä¸²ç»‘å®šâ€”â€”åœ¨æœ¬ä¾‹ä¸­ï¼Œæ˜¯ç”¨æˆ·é€‰æ‹©çš„æ˜¾ç¤ºåç§°ã€‚ ä½ åœ¨åˆ›å»ºæ–‡æœ¬å­—æ®µæ—¶æä¾›æ ‡ç­¾å’Œå­—ç¬¦ä¸²ç»‘å®šã€‚",
      "tips": ""
    },
    "Add an Edit Mode": {
      "zh": "æ·»åŠ ç¼–è¾‘æ¨¡å¼",
      "tips": ""
    },
    "Step 5": {
      "zh": "æ­¥éª¤ 5",
      "tips": ""
    },
    "Delay Edit Propagation": {
      "zh": "ç¼–è¾‘æ•°æ®å»¶è¿Ÿä¿å­˜åŒæ­¥",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Update ProfileSummary to add several badges with varying hues and reasons for earning the badge.": {
      "zh": "æ›´æ–° ProfileSummary æ·»åŠ å‡ ä¸ªå…·æœ‰ä¸åŒè‰²è°ƒå’Œæˆå°±æè¿°çš„å¾½ç« ã€‚",
      "tips": ""
    },
    "Update the conditional content in ProfileHost to include the profile editor and pass along the profile binding.": {
      "zh": "æ›´æ–° ProfileHost ä¸­çš„æ¡ä»¶å†…å®¹ï¼ŒåŒ…æ‹¬ä¸ªäººèµ„æ–™ç¼–è¾‘å™¨ï¼Œå¹¶ä¼ é€’ä¸ªäººèµ„æ–™è¿›è¡Œç»‘å®šã€‚",
      "tips": ""
    },
    "Update the ModelData class to include an instance of the user profile that persists even after the user dismisses the profile view.": {
      "zh": "æ›´æ–° ModelData ç±»ï¼Œç±»åŒ…å«ä¸€ä¸ªç”¨æˆ·ä¸ªäººèµ„æ–™çš„å®ä¾‹ï¼Œè¯¥å®ä¾‹åœ¨ç”¨æˆ·å…³é—­ä¸ªäººèµ„æ–™è§†å›¾åä»ç„¶å­˜åœ¨ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "æ­¥éª¤ 6",
      "tips": ""
    },
    "The EditButton controls the same editMode environment value that you accessed in the previous step.": {
      "zh": "EditButton æ§åˆ¶ä½ åœ¨ä¸Šä¸€æ­¥ä¸­è®¿é—®çš„ editMode å€¼ã€‚",
      "tips": ""
    },
    "Add an Environment view property that keys off of the environmentâ€™s \\.editMode.": {
      "zh": "æ·»åŠ ä¸€ä¸ª Environment è§†å›¾å±æ€§ï¼Œè¯¥å±æ€§åŸºäºç¯å¢ƒçš„ .editModeã€‚",
      "tips": ""
    },
    "For consistency with the profile summary, youâ€™ll add the profile details in the same order in the editor.": {
      "zh": "ä¸ºäº†ä¸ä¸ªäººèµ„æ–™ç®€ä»‹ä¿æŒä¸€è‡´ï¼Œä½ å°†åœ¨ç¼–è¾‘å™¨ä¸­ä»¥ç›¸åŒçš„é¡ºåºæ·»åŠ ä¸ªäººèµ„æ–™è¯¦ç»†ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "The profile summary takes a Profile value rather than a binding to the profile because the parent view, ProfileHost, manages the state for this view.": {
      "zh": "ä¸ªäººèµ„æ–™æ‘˜è¦æ¥æ”¶ä¸€ä¸ª Profile å€¼ï¼Œè€Œä¸æ˜¯ä¸ä¸ªäººèµ„æ–™ç»‘å®šï¼Œå› ä¸ºç”±çˆ¶è§†å›¾ ProfileHost è´Ÿè´£ç®¡ç†è¿™ä¸ªè§†å›¾çš„çŠ¶æ€ã€‚",
      "tips": ""
    },
    "Read the userâ€™s profile data from the environment to pass control of the data to the profile host.": {
      "zh": "ä»ç¯å¢ƒä¸­è¯»å–ç”¨æˆ·çš„åå¥½è®¾ç½®æ•°æ®ï¼Œå°†æ•°æ®çš„æ§åˆ¶æƒä¼ é€’ç»™åå¥½è®¾ç½®é¡µé¢ã€‚",
      "tips": ""
    },
    "Apply the onAppear(perform:) and onDisappear(perform:) modifiers to populate the editor with the correct profile data and update the persistent profile when the user taps the Done button.": {
      "zh": "åº”ç”¨ onAppear(perform:) å’Œ onDisappear(perform:) ä¿®é¥°ç¬¦ï¼Œä»¥åœ¨ç¼–è¾‘å™¨ä¸­å¡«å……æ­£ç¡®çš„ä¸ªäººèµ„æ–™æ•°æ®ï¼Œå¹¶åœ¨ç”¨æˆ·ç‚¹å‡»â€œå®Œæˆâ€æŒ‰é’®æ—¶æ›´æ–°æœ¬åœ°åŒ–çš„ä¸ªäººèµ„æ–™ã€‚",
      "tips": ""
    },
    "Update ProfileHost to display the new summary view.": {
      "zh": "æ›´æ–° ProfileHost æ˜¾ç¤ºæ–°çš„æ‘˜è¦è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "æ­¥éª¤ 8",
      "tips": ""
    },
    "The user profile editor consists primarily of different controls that change individual details in the profile. Some items in the profile, like the badges, arenâ€™t user-editable, so they donâ€™t appear in the editor.": {
      "zh": "ç”¨æˆ·ä¸ªäººèµ„æ–™ç¼–è¾‘å™¨ä¸»è¦ç”±ä¸åŒçš„æ§ä»¶ç»„æˆï¼Œè¿™äº›æ§ä»¶å¯ä»¥æ›´æ”¹ä¸ªäººèµ„æ–™ä¸­çš„å„ä¸ªè¯¦ç»†ä¿¡æ¯ã€‚ä¸ªäººèµ„æ–™ä¸­çš„ä¸€äº›é¡¹ç›®ï¼Œå¦‚å¾½ç« ï¼Œä¸å¯ä¾›ç”¨æˆ·ç¼–è¾‘ï¼Œå› æ­¤å®ƒä»¬ä¸ä¼šå‡ºç°åœ¨ç¼–è¾‘å™¨ä¸­ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "æ­¥éª¤ 3",
      "tips": ""
    },
    "Step 4": {
      "zh": "æ­¥éª¤ 4",
      "tips": ""
    },
    "In the Landmarks app, users can create a profile to express their personality. To give users the ability to change their profile, youâ€™ll add an edit mode and design the preferences screen.": {
      "zh": "åœ¨ Landmarks åº”ç”¨ç¨‹åºä¸­ï¼Œç”¨æˆ·å¯ä»¥åˆ›å»ºä¸ªäººèµ„æ–™æ¥è¡¨è¾¾è‡ªå·±çš„ä¸ªæ€§ã€‚ ä¸ºäº†è®©ç”¨æˆ·èƒ½å¤Ÿæ›´æ”¹ä»–ä»¬çš„ä¸ªäººèµ„æ–™ï¼Œä½ éœ€è¦æ·»åŠ ä¸€ä¸ªç¼–è¾‘æ¨¡å¼å¹¶è®¾è®¡åå¥½è®¾ç½®é¡µé¢ã€‚",
      "tips": ""
    },
    "You can see the effect of entering edit mode by running the live preview and tapping the edit button. For now, the Edit mode view is just a static text field.": {
      "zh": "ä½ å¯ä»¥é€šè¿‡è¿è¡Œå®æ—¶é¢„è§ˆå¹¶ç‚¹å‡»ç¼–è¾‘æŒ‰é’®æ¥æŸ¥çœ‹è¿›å…¥ç¼–è¾‘æ¨¡å¼çš„æ•ˆæœã€‚ ç›®å‰ï¼Œç¼–è¾‘æ¨¡å¼è§†å›¾åªæ˜¯ä¸€ä¸ªé™æ€æ–‡æœ¬å­—æ®µã€‚",
      "tips": ""
    },
    "Create another view in the Profiles group named ProfileSummary that takes a Profile instance and displays some basic user information.": {
      "zh": "åœ¨ Profiles åˆ†ç»„ä¸­åˆ›å»ºå¦ä¸€ä¸ªåä¸º ProfileSummary çš„è§†å›¾ï¼Œè¯¥è§†å›¾æ¥æ”¶ä¸€ä¸ª Profile å®ä¾‹å¹¶æ˜¾ç¤ºä¸€äº›åŸºæœ¬çš„ç”¨æˆ·ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Start by defining a user profile in a new Swift file named Profile.swift that you add to your projectâ€™s Model group.": {
      "zh": "é¦–å…ˆåœ¨ä¸€ä¸ªåä¸º Profile.swift çš„æ–° Swift æ–‡ä»¶ä¸­å®šä¹‰ä¸€ä¸ªç”¨æˆ·é…ç½®æ–‡ä»¶ï¼Œå°†å®ƒæ·»åŠ åˆ°é¡¹ç›®çš„ Models ç›®å½•ä¸­ã€‚",
      "tips": ""
    },
    "Add the listStyle modifier to pick a list style that better suits the content.": {
      "zh": "æ·»åŠ  listStyle ä¿®é¥°ç¬¦ä»¥é€‰æ‹©æ›´é€‚åˆå†…å®¹çš„åˆ—è¡¨æ ·å¼ã€‚",
      "tips": ""
    },
    "Add a cancel button to ProfileHost.": {
      "zh": "å‘ ProfileHost æ·»åŠ å–æ¶ˆæŒ‰é’®ã€‚",
      "tips": ""
    },
    "Define the Profile Editor": {
      "zh": "å®šä¹‰ä¸ªäººä¿¡æ¯ç¼–è¾‘å™¨",
      "tips": ""
    },
    "Finally, add a DatePicker below the season selector to make the landmark visitation goal date modifiable.": {
      "zh": "æœ€åï¼Œåœ¨å­£èŠ‚é€‰æ‹©å™¨ä¸‹æ–¹æ·»åŠ ä¸€ä¸ª DatePickerï¼Œä½¿åœ°æ ‡å‚è§‚æ—¥æœŸå¯ä¿®æ”¹ã€‚",
      "tips": ""
    },
    "In CategoryHome.swift, add a user profile button to the navigation bar using the toolbar modifier, and present the ProfileHost view when the user taps it.": {
      "zh": "åœ¨ CategoryHome.swift ä¸­ï¼Œä½¿ç”¨ toorbar ä¿®é¥°ç¬¦å°†ç”¨æˆ·åå¥½è®¾ç½®æŒ‰é’®æ·»åŠ åˆ°å¯¼èˆªæ ï¼Œå¹¶åœ¨ç”¨æˆ·ç‚¹å‡»å®ƒæ—¶æ˜¾ç¤º ProfileHost è§†å›¾ã€‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬ 2 èŠ‚",
      "tips": ""
    },
    "Follow the steps to build this project, or download the finished project to explore on your own.": {
      "zh": "æŒ‰ç…§æ­¥éª¤æ„å»ºæ­¤é¡¹ç›®ï¼Œæˆ–ä¸‹è½½å·²å®Œæˆçš„é¡¹ç›®ä»¥è‡ªè¡Œæ¢ç´¢ã€‚",
      "tips": ""
    },
    "Toggles are controls that are either on or off, so theyâ€™re a good fit for Boolean values like a yes or no preference.": {
      "zh": "Toggles æ˜¯å¼€å…³æ§ä»¶ï¼Œå› æ­¤å®ƒä»¬éå¸¸é€‚åˆå¸ƒå°”å€¼ï¼Œä¾‹å¦‚æ˜¯å¦æ‰“å¼€åå¥½ã€‚",
      "tips": ""
    },
    "The badgeâ€™s drawing logic produces a result that depends on the size of the frame in which it renders. To ensure the desired appearance, render in a frame of 300 x 300 points. To get the desired size for the final graphic, then scale the rendered result and place it in a comparably smaller frame.": {
      "zh": "å¾½ç« çš„ç»˜åˆ¶é€»è¾‘äº§ç”Ÿçš„ç»“æœå–å†³äºå®ƒå‘ˆç°çš„å¸ƒå±€æ¡†çš„å¤§å°ã€‚ ä¸ºç¡®ä¿ç†æƒ³çš„å¤–è§‚æ•ˆæœï¼Œè¯·åœ¨300 x 300ç‚¹çš„å¸ƒå±€æ¡†ä¸­è¿›è¡Œæ¸²æŸ“ã€‚ç„¶åï¼Œç¼©æ”¾æ¸²æŸ“ç»“æœå¹¶å°†å…¶æ”¾ç½®åœ¨ä¸€ä¸ªç›¸å¯¹è¾ƒå°çš„æ¡†æ¶ä¸­ï¼Œä»¥è·å¾—æœ€ç»ˆå›¾å½¢çš„æœŸæœ›å°ºå¯¸ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "æ­¥éª¤ 9",
      "tips": ""
    },
    "The Landmarks app locally stores some configuration details and preferences. Before the user edits their details, theyâ€™re displayed in a summary view that doesnâ€™t have any editing controls.": {
      "zh": "Landmarks åº”ç”¨ç¨‹åºåœ¨æœ¬åœ°å­˜å‚¨äº†ä¸€äº›é…ç½®ç»†èŠ‚å’Œåå¥½è®¾ç½®ã€‚åœ¨ç”¨æˆ·ç¼–è¾‘ä¸ªäººä¿¡æ¯ä¹‹å‰ï¼Œè¿™äº›ä¿¡æ¯å°†æ˜¾ç¤ºåœ¨ä¸€ä¸ªæ²¡æœ‰ç¼–è¾‘æ§ä»¶çš„æ‘˜è¦è§†å›¾ä¸­ã€‚",
      "tips": ""
    },
    "Create an Edit button that toggles the environmentâ€™s editMode value on and off.": {
      "zh": "åˆ›å»ºä¸€ä¸ªç¼–è¾‘æŒ‰é’®ï¼Œç”¨äºæ‰“å¼€å’Œå…³é—­ç¯å¢ƒçš„ editMode å€¼ã€‚",
      "tips": ""
    },
    "Add a conditional view that displays either the static profile or the view for Edit mode.": {
      "zh": "æ·»åŠ æ˜¾ç¤ºé™æ€é…ç½®æ–‡ä»¶æˆ–ç¼–è¾‘æ¨¡å¼è§†å›¾çš„æ¡ä»¶è§†å›¾ã€‚",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ 3 èŠ‚",
      "tips": ""
    },
    "Otherwise, the old values appear the next time edit mode activates.": {
      "zh": "ä¸è¿™æ ·åšçš„è¯ï¼Œæ—§çš„å€¼ä¼šåœ¨ä¸‹æ¬¡è¿›å…¥ç¼–è¾‘æ¨¡å¼æ—¶å‡ºç°ã€‚",
      "tips": ""
    },
    "The badge is just a graphic, so the text in HikeBadge along with the accessibilityLabel(_:) modifier make the meaning of the badge clearer to other users.": {
      "zh": "å¾½ç« åªæ˜¯ä¸€ä¸ªå›¾å½¢ï¼Œå› æ­¤ HikeBadge ä¸­çš„æ–‡æœ¬ä»¥åŠ accessibilityLabel(_:) ä¿®é¥°ç¬¦èƒ½å¤Ÿä½¿å…¶ä»–ç”¨æˆ·æ›´æ¸…æ¥šå¾½ç« çš„å«ä¹‰ã€‚",
      "tips": ""
    },
    "The ProfileHost view will host both a static, summary view of profile information and an edit mode.": {
      "zh": "ProfileHost è§†å›¾å°†åŒæ—¶æ‰¿è½½ä¸ªäººèµ„æ–™ä¿¡æ¯çš„é™æ€æ‘˜è¦è§†å›¾å’Œç¼–è¾‘æ¨¡å¼ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "æ­¥éª¤ 1",
      "tips": ""
    },
    "Interfacing with UIKit": {
      "zh": "",
      "tips": ""
    },
    "Next, create a new group named Profiles under the Views group, and then add a view named ProfileHost to that group with a text view that displays the username of a stored profile.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œåœ¨ Views ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªåä¸º Profiles çš„æ–°æ–‡ä»¶å¤¹ï¼Œç„¶åå‘è¯¥æ–‡ä»¶å¤¹æ·»åŠ ä¸€ä¸ªåä¸º ProfileHost çš„è§†å›¾ï¼Œè¯¥è§†å›¾åŒ…å«ä¸€ä¸ªæ–‡æœ¬è§†å›¾ï¼Œç”¨äºæ˜¾ç¤ºå­˜å‚¨çš„ä¸ªäººèµ„æ–™ä¸­çš„ç”¨æˆ·åã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "æ­¥éª¤ 10",
      "tips": ""
    },
    "Users need to toggle between viewing or editing their profile details. Youâ€™ll add an edit mode by adding an EditButton to the existing ProfileHost, and then creating a view with controls for editing individual values.": {
      "zh": "ç”¨æˆ·éœ€è¦åœ¨æŸ¥çœ‹æˆ–ç¼–è¾‘ä¸ªäººèµ„æ–™è¯¦ç»†ä¿¡æ¯ä¹‹é—´åˆ‡æ¢ã€‚ä½ å°†é€šè¿‡å‘ç°æœ‰çš„ ProfileHost æ·»åŠ  EditButton æ¥æ·»åŠ ç¼–è¾‘æ¨¡å¼ï¼Œç„¶ååˆ›å»ºä¸€ä¸ªå¸¦æœ‰ç”¨äºç¼–è¾‘å„ä¸ªå€¼çš„æ§ä»¶çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "Display a User Profile": {
      "zh": "å±•ç¤ºç”¨æˆ·ä¸ªäººèµ„æ–™",
      "tips": ""
    },
    "Unlike the Done button that EditButton provides, the Cancel button doesnâ€™t apply the edits to the real profile data in its closure.": {
      "zh": "ä¸ EditButton æä¾›çš„ Done æŒ‰é’®ä¸åŒï¼ŒCancel æŒ‰é’®ä¸ä¼šåœ¨å…¶é—­åŒ…ä¸­å°†ç¼–è¾‘åº”ç”¨åˆ°åŸå§‹çš„åå¥½æ•°æ®ä¸­ã€‚",
      "tips": ""
    },
    "Place a Picker control and its label in a VStack to make the landmark photos have a selectable preferred season.": {
      "zh": "å°†ä¸€ä¸ª Picker æ§ä»¶åŠå…¶æ ‡ç­¾æ”¾ç½®åœ¨ä¸€ä¸ª VStack ä¸­ï¼Œä½¿åœ°æ ‡ç…§ç‰‡å…·æœ‰å¯é€‰æ‹©çš„é¦–é€‰å­£èŠ‚ã€‚",
      "tips": ""
    },
    "Finish off the profile summary by including a HikeView from Animating Views and Transitions.": {
      "zh": "é€šè¿‡åŒ…å«ä¸€ä¸ªä» Animating Views and Transitions æ•™ç¨‹çš„ HikeView æ¥å®Œæˆåå¥½è®¾ç½®æ‘˜è¦ã€‚",
      "tips": ""
    },
    "Section 4": {
      "zh": "ç¬¬ 4 èŠ‚",
      "tips": ""
    },
    "Create a new view named ProfileEditor and include a binding to the draft copy of the userâ€™s profile.": {
      "zh": "åˆ›å»ºä¸€ä¸ªåä¸º ProfileEditor çš„æ–°è§†å›¾ï¼Œå¹¶åŒ…å«å¯¹ç”¨æˆ·é…ç½®æ–‡ä»¶ç¼–è¾‘è‰ç¨¿å‰¯æœ¬çš„ç»‘å®šã€‚",
      "tips": ""
    },
    "Add a toggle that corresponds with the userâ€™s preference for receiving notifications about landmark-related events.": {
      "zh": "æ·»åŠ ä¸€ä¸ªå¼€å…³ï¼Œå¯¹åº”ç”¨æˆ·æ¥æ”¶ä¸åœ°æ ‡ç›¸å…³äº‹ä»¶é€šçŸ¥çš„åå¥½ã€‚",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ 1 èŠ‚",
      "tips": ""
    },
    "Create a new view named HikeBadge in the Hikes folder that composes the Badge from Drawing Paths and Shapes along with some descriptive text about the hike.": {
      "zh": "åœ¨ Hikes æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ªåä¸º HikeBadge çš„æ–°è§†å›¾ï¼Œè¯¥è§†å›¾ç”± Drawing Paths and Shapes æ•™ç¨‹ä¸­çš„ Badge ä»¥åŠä¸€äº›å…³äºè¿œè¶³çš„æè¿°æ€§æ–‡æœ¬ç»„æˆã€‚",
      "tips": ""
    },
    "To use the hike data, you also need to add a model data environment object.": {
      "zh": "è¦ä½¿ç”¨è¿œè¶³æ•°æ®ï¼Œä½ è¿˜éœ€è¦æ·»åŠ ä¸€ä¸ªç¯å¢ƒä¸­çš„æ¨¡å‹æ•°æ®å¯¹è±¡ã€‚",
      "tips": ""
    },
    "To make it so edits donâ€™t take effect until after the user exits edit mode, you use the draft copy of their profile during editing, then assign the draft copy to the real copy only when the user confirms an edit.": {
      "zh": "ä¸ºäº†è®©ç¼–è¾‘åœ¨ç”¨æˆ·é€€å‡ºç¼–è¾‘æ¨¡å¼åæ‰ç”Ÿæ•ˆï¼Œä½ å¯ä»¥åœ¨ç¼–è¾‘è¿‡ç¨‹ä¸­ä½¿ç”¨ç”¨æˆ·ä¸ªäººèµ„æ–™çš„è‰ç¨¿å‰¯æœ¬ï¼Œç„¶ååœ¨ç”¨æˆ·ç¡®è®¤ç¼–è¾‘æ—¶å°†è‰ç¨¿å‰¯æœ¬è®¾ç½®ç»™åŸå§‹æ•°æ®ã€‚",
      "tips": ""
    },
    "To avoid updating the global app state before confirming any edits â€” such as while the user enters their name â€” the editing view operates on a copy of itself.": {
      "zh": "ä¸ºäº†é¿å…åœ¨ç¡®è®¤ä»»ä½•ç¼–è¾‘ä¹‹å‰æ›´æ–°å…¨å±€åº”ç”¨çŠ¶æ€ï¼ˆä¾‹å¦‚ï¼Œåœ¨ç”¨æˆ·è¾“å…¥å§“åæ—¶ï¼‰ï¼Œç¼–è¾‘è§†å›¾å°†åœ¨å®ƒè‡ªèº«çš„å‰¯æœ¬ä¸Šä¿®æ”¹ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "æ­¥éª¤ 2",
      "tips": ""
    },
    "Now the edit profile view displays when you tap Edit.": {
      "zh": "ç°åœ¨ï¼Œå½“ä½ ç‚¹å‡»ç¼–è¾‘æ—¶ï¼Œä¼šæ˜¾ç¤ºç¼–è¾‘é…ç½®æ–‡ä»¶è§†å›¾ã€‚",
      "tips": ""
    },
    "Even though this view doesnâ€™t use a property with the @EnvironmentObject attribute, ProfileSummary, a child of this view, does. So without the modifier, the preview fails.": {
      "zh": "å³ä½¿æ­¤è§†å›¾ä¸ä½¿ç”¨å…·æœ‰ @EnvironmentObject çš„å±æ€§ï¼Œä½† ProfileSummaryï¼ˆè¿™ä¸ªè§†å›¾çš„å­è§†å›¾ï¼‰éœ€è¦ä½¿ç”¨ã€‚å› æ­¤ï¼Œå¦‚æœæ²¡æœ‰è¿™ä¸ªä¿®é¥°ç¬¦ï¼Œé¢„è§ˆå°†æ— æ³•è¿›è¡Œã€‚",
      "tips": ""
    },
    "Switch to the live preview and try tapping the profile button to examine the profile summary.": {
      "zh": "åˆ‡æ¢åˆ°å®æ—¶é¢„è§ˆï¼Œå°è¯•ç‚¹å‡»ä¸ªäººèµ„æ–™æŒ‰é’®ä»¥æŸ¥çœ‹ä¸ªäººèµ„æ–™æ‘˜è¦ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "æ­¥éª¤ 7",
      "tips": ""
    },
    "Working with UI Controls": {
      "zh": "",
      "tips": ""
    },
    "Select ProfileHost and add the model data as an environment object to the preview.": {
      "zh": "é€‰æ‹© ProfileHost å¹¶å°†æ¨¡å‹æ•°æ®ä½œä¸ºç¯å¢ƒå¯¹è±¡æ·»åŠ åˆ°é¢„è§ˆä¸­ã€‚",
      "tips": ""
    },
    "Youâ€™ll work with a variety of common user interface controls for data entry, and update the Landmarks model types whenever the user saves their changes.": {
      "zh": "ä½ å°†ä½¿ç”¨å„ç§å¸¸è§çš„ç”¨æˆ·ç•Œé¢æ§ä»¶è¿›è¡Œæ•°æ®è¾“å…¥ï¼Œå¹¶åœ¨ç”¨æˆ·ä¿å­˜æ›´æ”¹æ—¶æ›´æ–°åœ°æ ‡æ¨¡å‹ç±»å‹ã€‚",
      "tips": ""
    }
  },
  "swiftui-concepts/adjusting-the-space-between-views": {
    "Adjusting the space between views": {
      "zh": "è°ƒæ•´è§†å›¾ä¹‹é—´çš„é—´è·",
      "tips": ""
    },
    "Specify the alignment and spacing of your content.": {
      "zh": "æŒ‡å®šä½ å†…å®¹çš„å¯¹é½å’Œé—´è·ã€‚",
      "tips": ""
    },
    "As you define the views that display information, you can adjust the layout by declaring where any extra space should go. Depending on how you want your layout to adapt, you may choose different tools. Some of the tools for managing the space between views are themselves views, like Spacer. There are also view modifiers that affect the space adjacent to a view, like padding(_:_:). In some cases, you affect a layout by providing a non-default value as a parameter of a view or modifier.": {
      "zh": "å½“å®šä¹‰è§†å›¾æ¥æ˜¾ç¤ºä¿¡æ¯æ—¶ï¼Œä½ å¯ä»¥é€šè¿‡å£°æ˜é¢å¤–çš„é—´è·æ¥è°ƒæ•´å¸ƒå±€ã€‚æ ¹æ®å¸Œæœ›å¸ƒå±€å¦‚ä½•è‡ªé€‚åº”ï¼Œä½ å¯ä»¥é€‰æ‹©ä¸åŒçš„å·¥å…·ã€‚ ä¸€äº›ç”¨äºç®¡ç†è§†å›¾ä¹‹é—´é—´è·çš„å·¥å…·æœ¬èº«å°±æ˜¯è§†å›¾ï¼Œä¾‹å¦‚ Spacerã€‚è¿˜æœ‰ä¸€äº›è§†å›¾ä¿®é¥°ç¬¦å¯ä»¥å½±å“ç›¸é‚»è§†å›¾çš„é—´è·ï¼Œä¾‹å¦‚ padding(::)ã€‚ åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¯ä»¥é€šè¿‡ä¸ºè§†å›¾æˆ–ä¿®é¥°ç¬¦çš„å‚æ•°æä¾›éé»˜è®¤å€¼æ¥å½±å“å¸ƒå±€ã€‚",
      "tips": ""
    },
    "Define your content": {
      "zh": "å®šä¹‰ä½ çš„å†…å®¹",
      "tips": ""
    },
    "To show some different strategies for changing the spacing between views, this example uses a sequence of train cars. Each train has three views â€” a front, middle, and rear section â€” and uses the train car symbols from SF Symbols. These examples use an HStack to show horizontal spacing. The same principles apply on the vertical axis and to other stack and grid views in SwiftUI.": {
      "zh": "ä¸ºäº†å±•ç¤ºæ”¹å˜è§†å›¾ä¹‹é—´é—´è·çš„ä¸åŒæ–¹å¼ï¼Œè¿™ä¸ªä¾‹å­ä½¿ç”¨äº†ä¸€ç³»åˆ—çš„ç«è½¦è½¦å¢ã€‚æ¯ä¸ªç«è½¦æœ‰ä¸‰ä¸ªè§†å›¾ï¼ˆå‰éƒ¨ã€ä¸­éƒ¨å’Œåéƒ¨ï¼‰ï¼Œæ¯ä¸ªè§†å›¾éƒ½ä½¿ç”¨äº† SF Symbols ä¸­çš„ç«è½¦è½¦å¢ç¬¦å·ã€‚ è¿™äº›ä¾‹å­ä½¿ç”¨ä¸€ä¸ª HStack æ¥æ§åˆ¶æ°´å¹³é—´è·ã€‚ç›¸åŒçš„åŸåˆ™ä¹Ÿé€‚ç”¨äºå‚ç›´æ–¹å‘ä»¥åŠ SwiftUI ä¸­çš„å…¶ä»– Stack å’Œç½‘æ ¼è§†å›¾ã€‚",
      "tips": ""
    },
    "Many of these container views include some negative space by default, so set up your content and a PreviewProvider first to see how the defaults look before you customize the spacing.": {
      "zh": "è®¸å¤šè¿™äº›å®¹å™¨è§†å›¾éƒ½åŒ…å«ä¸€äº›é»˜è®¤å€¼æ˜¯è´Ÿæ•°çš„é—´è·ï¼Œå› æ­¤åœ¨è‡ªå®šä¹‰é—´è·ä¹‹å‰ï¼Œé¦–å…ˆè®¾ç½®ä½ çš„å†…å®¹ï¼Œå¹¶ä¸”åˆ›å»ºä¸€ä¸ªå®ç°äº† PreviewProvider åè®®çš„å®ä¾‹æ¥æŸ¥çœ‹é»˜è®¤æ ·å¼æ˜¯ä»€ä¹ˆæ ·çš„ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "This custom view defines an Image view that displays an SF Symbol of a train car, with a pink background to show the extent of the view.": {
      "zh": "è¿™ä¸ªè‡ªå®šä¹‰è§†å›¾å®šä¹‰äº†ä¸€ä¸ª Image è§†å›¾ï¼Œç”¨äºæ˜¾ç¤ºä¸€ä¸ªè¡¨ç¤ºç«è½¦è½¦å¢çš„ SF Symbolï¼Œå¹¶ä½¿ç”¨ç²‰è‰²èƒŒæ™¯æ¥æ˜¾ç¤ºè§†å›¾çš„èŒƒå›´ã€‚",
      "tips": ""
    },
    "You can define your own custom views so that you can have similar views in multiple places without having to specify the same modifiers and parameters in each place.": {
      "zh": "ä½ å¯ä»¥è‡ªå·±å®šä¹‰ä¸€ä¸ªè§†å›¾ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨å¤šä¸ªåœ°æ–¹å¤ç”¨ç›¸åŒçš„è§†å›¾ï¼Œè€Œæ— éœ€åœ¨æ¯ä¸ªåœ°æ–¹éƒ½é‡å¤æŒ‡å®šç›¸åŒçš„ä¿®é¥°ç¬¦å’Œå‚æ•°ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®è·µ",
      "tips": ""
    },
    "Try changing the color of the background(_:ignoresSafeAreaEdges:) to another color, and see the color of the background change on all the train cars.": {
      "zh": "å°è¯•å°†ä¼ å…¥ background(_:ignoresSafeAreaEdges:) çš„èƒŒæ™¯é¢œè‰²æ›´æ”¹ä¸ºå…¶ä»–é¢œè‰²ï¼Œå¹¶è§‚å¯Ÿæ‰€æœ‰ç«è½¦è½¦å¢èƒŒæ™¯é¢œè‰²å‘ç”Ÿçš„å˜åŒ–ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "Hereâ€™s an example of that custom TrainCar view in use. This view declaration only specifies which part of the train it represents. The TrainCar structure defines the Image view with the corresponding symbol and adds a background.": {
      "zh": "è¿™é‡Œå±•ç¤ºäº†ä¸€ä¸ªä½¿ç”¨è‡ªå®šä¹‰ TrainCar è§†å›¾çš„ç¤ºä¾‹ã€‚è¿™ä¸ªè§†å›¾çš„å£°æ˜ä»…éœ€æŒ‡å®šå®ƒè¡¨ç¤ºç«è½¦çš„å“ªä¸ªéƒ¨åˆ†ã€‚å‰©ä¸‹çš„å°±ç”± TrainCar ç»“æ„æ¥å®šä¹‰ç›¸åº”ç¬¦å·çš„ Image è§†å›¾ï¼Œå¹¶æ·»åŠ äº†ä¸€ä¸ªèƒŒæ™¯ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "This HStack contains three TrainCar views - front, middle, and rear - to form a train. The code doesnâ€™t add any custom space or padding to the HStack or the TrainCar views, but thereâ€™s still a little space between the frames of the train cars.": {
      "zh": "è¿™ä¸ª HStack åŒ…å«äº†ç»„æˆç«è½¦å‰ä¸­åä¸‰ä¸ªéƒ¨åˆ†çš„ TrainCar è§†å›¾ã€‚ä»£ç æ²¡æœ‰ç»™ HStack æˆ– TrainCar è§†å›¾æ·»åŠ ä»»ä½•è‡ªå®šä¹‰çš„é—´è·æˆ–å¡«å……ï¼Œä½†ç«è½¦è½¦å¢ä¹‹é—´ä»ç„¶æœ‰ä¸€äº›é—´è·ã€‚",
      "tips": ""
    },
    "An HStack, like many of SwiftUIâ€™s built-in collection views, puts some spacing between its subviews by default.": {
      "zh": "HStack å°±åƒ SwiftUI ä¸­è®¸å¤šå†…ç½®çš„é›†åˆè§†å›¾ä¸€æ ·ï¼Œé»˜è®¤æƒ…å†µä¸‹ä¼šåœ¨å…¶å­è§†å›¾ä¹‹é—´æ·»åŠ ä¸€äº›é—´è·ã€‚",
      "tips": ""
    },
    "Customize a container's spacing": {
      "zh": "è‡ªå®šä¹‰å®¹å™¨çš„é—´è·",
      "tips": ""
    },
    "The default spacing of an HStack isnâ€™t right for all layouts. You can specify a constant spacing between a stackâ€™s subviews, spacing that scales with Dynamic Type, or no spacing at all.": {
      "zh": "HStack çš„é»˜è®¤é—´è·å¹¶ä¸é€‚ç”¨äºæ‰€æœ‰å¸ƒå±€ã€‚ä½ å¯ä»¥æŒ‡å®šä¸€ä¸ªå¸¸é‡ä½œä¸ºå­è§†å›¾é—´çš„é—´è·ï¼Œä½¿å…¶éšåŠ¨æ€ç±»å‹è¿›è¡Œç¼©æ”¾ï¼Œæˆ–è€…å®Œå…¨æ²¡æœ‰é—´è·ã€‚",
      "tips": ""
    },
    "The spacing parameter of an HStack customizes the spacing between its views. This value of 20 puts 20 points of space between the front and middle TrainCar views and 20 points of space between the middle and rear TrainCar views, instead of the default spacing.": {
      "zh": "HStack çš„ spacing å‚æ•°å¯ä»¥è‡ªå®šä¹‰è§†å›¾é—´çš„é—´è·ã€‚è¿™é‡Œç”¨ 20 å–ä»£äº†é»˜è®¤çš„é—´è·ï¼Œåœ¨å‰éƒ¨å’Œä¸­éƒ¨ï¼Œä»¥åŠä¸­éƒ¨å’Œåéƒ¨çš„ TrainCar è§†å›¾ä¹‹é—´å¢åŠ äº† 20 ä¸ªç‚¹çš„é—´è·ã€‚",
      "tips": ""
    },
    "Because these train cars are SF symbols, their size changes when the current dynamicTypeSize changes. This trainâ€™s spacing adjusts proportionally. In this HStack, the value for the spacing parameter is the trainCarSpace property of the ScaledSpacing view.": {
      "zh": "å› ä¸ºè¿™äº›ç«è½¦è½¦å¢æ˜¯ SF ç¬¦å·ï¼Œæ‰€ä»¥å®ƒä»¬çš„å¤§å°ä¼šéšç€å½“å‰ dynamicTypeSize çš„å˜åŒ–è€Œæ”¹å˜ã€‚è¿™åˆ—ç«è½¦è½¦å¢ä¹‹é—´çš„é—´è·ä¹Ÿåº”è¯¥æŒ‰æ¯”ä¾‹è°ƒæ•´ã€‚ åœ¨è¿™ä¸ª HStack ä¸­ï¼Œspacing å‚æ•°çš„å€¼æ˜¯ç”± ScaledSpacing ä¿®é¥°çš„ trainCarSpace å±æ€§æ¥è¡¨ç¤ºã€‚",
      "tips": ""
    },
    "Adjust the Dynamic Type slider in the Canvas Device Settings to see how the train cars and spacing in the preview change.": {
      "zh": "è°ƒæ•´ç”»å¸ƒè®¾å¤‡è®¾ç½®ä¸­çš„ Dynamic Type æ»‘å—ï¼Œè§‚å¯Ÿé¢„è§ˆä¸­ç«è½¦è½¦å¢å’Œé—´è·çš„å˜åŒ–ã€‚",
      "tips": ""
    },
    "The ScaledMetric property wrapper configures the trainCarSpace property to change in proportion to the current body font size.": {
      "zh": "ä½¿ç”¨ ScaledMetric å±æ€§åŒ…è£…å™¨ï¼Œå¯ä»¥è®© trainCarSpace å±æ€§æŒ‰å½“å‰ body å­—ä½“å¤§å°æˆæ¯”ä¾‹åœ°å˜åŒ–ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "Using the value of 0 for the spacing parameter here removes all of the space between the views. In this HStack, the train cars are right next to each other.": {
      "zh": "åœ¨è¿™é‡Œï¼Œå°† spacing å‚æ•°è®¾ç½®ä¸º 0ï¼Œä¼šåˆ é™¤è§†å›¾ä¹‹é—´çš„æ‰€æœ‰é—´è·ï¼Œåœ¨è¿™ä¸ª HStack ä¸­ï¼Œç«è½¦è½¦å¢å½¼æ­¤ç´§å¯†ç›¸è¿ï¼Œæ²¡æœ‰ä»»ä½•é—´è·ã€‚",
      "tips": ""
    },
    "Add padding around subviews": {
      "zh": "åœ¨å­è§†å›¾å‘¨å›´æ·»åŠ å¡«å……",
      "tips": ""
    },
    "You can add padding to the outer edges of a view to put some space between that view and any neighboring views, or to the edge of a window or scene.": {
      "zh": "ä½ å¯ä»¥åœ¨è§†å›¾çš„å¤–éƒ¨è¾¹ç¼˜æ·»åŠ å¡«å……ï¼Œè®©è¯¥è§†å›¾å’Œä»»ä½•ç›¸é‚»è§†å›¾ä¹‹é—´ç•™å‡ºä¸€äº›ç©ºé—´ï¼Œæˆ–è€…ä¸ windows æˆ– scene çš„è¾¹ç¼˜ä¿æŒè·ç¦»ã€‚",
      "tips": ""
    },
    "padding(_:_:) without any parameters puts space around all four edges. The size of the default padding varies, depending on attributes of the view and the environment where the view appears.": {
      "zh": "ä¸å¸¦ä»»ä½•å‚æ•°çš„ padding(_:_:) ä¼šç»™å‘¨å›´å››ä¸ªè¾¹ç¼˜éƒ½æ·»åŠ ç©ºé—´ã€‚é»˜è®¤å¡«å……çš„å¤§å°ä¼šæ ¹æ®è§†å›¾çš„å±æ€§å’Œå…¶å‡ºç°çš„ç¯å¢ƒè€Œå˜åŒ–ã€‚",
      "tips": ""
    },
    "This example pads the leading edge of a train car, but not the other edges, by specifying a set that contains only leading.": {
      "zh": "è¿™é‡Œé€šè¿‡æŒ‡å®šä¸€ä¸ªåªåŒ…å« leading çš„é›†åˆæ¥åªå¡«å……ç«è½¦è½¦å¢çš„ leading è¾¹ç¼˜ã€‚",
      "tips": ""
    },
    "This example defines a specific amount of padding in the length parameter.": {
      "zh": "è¿™ä¸ªä¾‹å­ç»™ length å‚æ•°æŒ‡å®šäº†ä¸€ä¸ªå¡«å……çš„æ•°å€¼ã€‚",
      "tips": ""
    },
    "You can also use a ScaledMetric to adjust the spacing in response to font changes.": {
      "zh": "ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ ScaledMetric åŒ…è£…å™¨æ¥æ ¹æ®å­—ä½“å˜åŒ–è°ƒæ•´é—´è·ã€‚",
      "tips": ""
    },
    "The effect of the padding modifier depends on which view it modifies.": {
      "zh": "padding ä¿®é¥°ç¬¦çš„æ•ˆæœå–å†³äºå®ƒä¿®æ”¹çš„æ˜¯å“ªä¸ªè§†å›¾ã€‚",
      "tips": ""
    },
    "Applying the padding(_:_:) modifier to the stack that contains the TrainCar views puts padding around the edges of the stack instead of between the train cars.": {
      "zh": "å°† padding(::) ä¿®é¥°ç¬¦åº”ç”¨äºåŒ…å« TrainCar è§†å›¾çš„ stack ä¸Šæ—¶ï¼Œä¸ä¼šåœ¨ç«è½¦è½¦å¢ä¸Šæ·»åŠ å¡«å……ï¼Œè€Œæ˜¯ä¼šåœ¨å…¶å‘¨å›´è¾¹ç¼˜æ·»åŠ å¡«å……ã€‚",
      "tips": ""
    },
    "Add a view to create space": {
      "zh": "æ·»åŠ ä¸€ä¸ªç”¨æ¥ä½œä¸ºé—´è·çš„è§†å›¾",
      "tips": ""
    },
    "Besides modifying a content view to create space, you can also create space by adding an invisible view that modifies your layout without displaying any content.": {
      "zh": "é™¤äº†ä¿®æ”¹å†…å®¹è§†å›¾æœ¬èº«æ¥åˆ›å»ºé—´è·å¤–ï¼Œä½ è¿˜å¯ä»¥é€šè¿‡æ·»åŠ ä¸€ä¸ªä»€ä¹ˆéƒ½ä¸æ˜¾ç¤ºçš„ä¸å¯è§è§†å›¾æ¥ä¿®æ”¹å¸ƒå±€ä»¥è¾¾åˆ°åˆ›å»ºé—´è·çš„ç›®çš„ã€‚",
      "tips": ""
    },
    "This Spacer() between views pushes the content views as far apart as possible.": {
      "zh": "è¿™ä¸ª Spacer() ä¼šåœ¨è§†å›¾ä¹‹é—´å°†å®ƒä»¬å°½å¯èƒ½åœ°æ¨å¼€ã€‚",
      "tips": ""
    },
    "You can specify a minimum width for each Spacer, or let it squish all the way to zero if the adjacent content needs all the space.": {
      "zh": "ä½ å¯ä»¥ä¸ºæ¯ä¸ª Spacer æŒ‡å®šæœ€å°å®½åº¦ï¼Œæˆ–è€…å¦‚æœç›¸é‚»çš„å†…å®¹éœ€è¦æ‰€æœ‰çš„ç©ºé—´ï¼Œé‚£ä¹ˆå¯ä»¥å°†å…¶å˜æˆé›¶ã€‚",
      "tips": ""
    },
    "Change to a landscape orientation in the Canvas Device Settings or choose a different size device for previews to see how the width of the device changes the layout.": {
      "zh": "åœ¨ç”»å¸ƒè®¾å¤‡è®¾ç½®ä¸­æ›´æ”¹ä¸ºæ¨ªå±ï¼Œæˆ–é€‰æ‹©ä¸åŒå°ºå¯¸çš„è®¾å¤‡è¿›è¡Œé¢„è§ˆï¼Œä»¥æŸ¥çœ‹è®¾å¤‡å®½åº¦å¦‚ä½•æ”¹å˜å¸ƒå±€ã€‚",
      "tips": ""
    },
    "This layout specifies an amount of space that depends on the size of a view by using the opacity modifier to create an invisible version of that view to take up the correct amount of space.": {
      "zh": "è¿™ä¸ªå¸ƒå±€é€šè¿‡ä½¿ç”¨ opacity ä¿®é¥°ç¬¦åˆ›å»ºä¸€ä¸ªä¸å¯è§çš„è§†å›¾ï¼Œä»¥å æ®æ°å½“çš„ç©ºé—´ï¼Œè¯¥ç©ºé—´é‡å–å†³äºè§†å›¾çš„å¤§å°ã€‚",
      "tips": ""
    },
    "A ZStack adapts to the size of its largest view, so the invisible view in this stack creates a visual appearance like padding around the middle train car.": {
      "zh": "ZStack ä¼šæ ¹æ®æœ€å¤§å­è§†å›¾çš„å¤§å°è¿›è¡Œè°ƒæ•´ï¼Œå› æ­¤åœ¨è¿™ä¸ª stack ä¸­è¢«éšè—çš„è§†å›¾ä¼šåˆ›å»ºä¸€ç§ç±»ä¼¼åœ¨ä¸­éƒ¨ç«è½¦è½¦å¢å‘¨å›´å¡«å……çš„è§†è§‰æ•ˆæœã€‚",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ä¸€èŠ‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬äºŒèŠ‚",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ä¸‰èŠ‚",
      "tips": ""
    },
    "Section 4": {
      "zh": "ç¬¬å››èŠ‚",
      "tips": ""
    }
  },
  "swiftui-concepts/choosing-the-right-way-to-hide-a-view": {
    "Choosing the right way to hide a view": {
      "zh": "é€‰æ‹©æ­£ç¡®çš„æ–¹å¼æ¥éšè—ä¸€ä¸ªè§†å›¾",
      "tips": ""
    },
    "Control whether a view exists, and how that affects the overall layout.": {
      "zh": "æ§åˆ¶è§†å›¾æ˜¯å¦å­˜åœ¨ä»¥åŠå®ƒå¯¹æ•´ä½“å¸ƒå±€çš„å½±å“ã€‚",
      "tips": ""
    },
    "If your design has views that arenâ€™t always relevant, you have a choice about how their absence affects the overall layout. You can lay out all the other content as if the view doesnâ€™t exist, then update the position of the other content when the view becomes visible. Or, you can reserve space for the view regardless of whether itâ€™s visible, so that when it becomes visible, none of the other content needs to move to accommodate it.": {
      "zh": "å¦‚æœä½ çš„è®¾è®¡ä¸­æœ‰ä¸€äº›è§†å›¾å¹¶ä¸æ€»æ˜¯ç›¸å…³çš„ï¼Œé‚£ä½ å¯ä»¥é€‰æ‹©å¦‚ä½•å¤„ç†å®ƒä»¬çš„å­˜åœ¨ä¸å¦å¯¹äºæ•´ä½“å¸ƒå±€çš„å½±å“ã€‚ å¦‚æœè¯¥è§†å›¾ä¸å­˜åœ¨ï¼Œä½ å°±åœ¨å½“å®ƒä¸å­˜åœ¨çš„æƒ…å†µä¸‹å¸ƒå±€å…¶ä»–å†…å®¹ï¼Œç„¶ååœ¨è¯¥è§†å›¾å˜ä¸ºå¯è§æ—¶æ›´æ–°å…¶ä»–å†…å®¹çš„ä½ç½®ä»¥é€‚åº”æ–°çš„å¸ƒå±€ã€‚ æˆ–è€…æ— è®ºä¸€ä¸ªè§†å›¾æ˜¯å¦å¯è§ï¼Œä½ éƒ½é¢„ç•™ç©ºé—´ç»™å®ƒï¼Œè¿™æ ·å½“å®ƒå˜ä¸ºå¯è§æ—¶ï¼Œå…¶ä»–å†…å®¹å°±æ— éœ€ä½ç½®ç§»åŠ¨ä»¥é€‚åº”å®ƒã€‚",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "è¦å®è·µè¿™æ®µä»£ç çš„è¯ï¼Œè¯·ä¸‹è½½é¡¹ç›®æ–‡ä»¶å¹¶åœ¨ Xcode ä¸­æ‰“å¼€ç¤ºä¾‹ã€‚",
      "tips": ""
    },
    "Conditionally removing a view": {
      "zh": "æœ‰æ¡ä»¶åœ°ç§»é™¤ä¸€ä¸ªè§†å›¾",
      "tips": ""
    },
    "Your design might have a login screen that doesnâ€™t show an error message the first time it appears, but adds an error message after someone mistypes their password. The user name and password fields shouldnâ€™t shift position depending on whether the error message is visible. Use an opacity(_:) modifier with a value of 0 so that the layout accounts for the error message whether or not itâ€™s visible. You can also use this strategy for removing a view that doesnâ€™t affect other viewsâ€™ placement, like a view inside an overlay(alignment:content:) modifier.": {
      "zh": "ä½ çš„è®¾è®¡ä¸­å¯èƒ½åŒ…å«ä¸€ä¸ªç™»å½•ç•Œé¢ï¼Œåœ¨é¦–æ¬¡å‡ºç°æ—¶ä¸ä¼šæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ï¼Œä½†åœ¨ç”¨æˆ·è¾“é”™å¯†ç åä¼šæ˜¾ç¤ºä¸€ä¸ªé”™è¯¯ä¿¡æ¯ã€‚ç”¨æˆ·åå’Œå¯†ç è¾“å…¥æ¡†ä¸åº”è¯¥æ ¹æ®é”™è¯¯ä¿¡æ¯æ˜¯å¦å¯è§è€Œæ”¹å˜å…¶ä½ç½®ã€‚ ä½ å¯ä»¥ä½¿ç”¨ opacity(_:) ä¿®é¥°ç¬¦ï¼Œå¹¶å°†å…¶å€¼è®¾ç½®ä¸º 0ï¼Œè¿™æ ·æ— è®ºé”™è¯¯ä¿¡æ¯æ˜¯å¦å¯è§ï¼Œç³»ç»Ÿéƒ½ä¼šè€ƒè™‘åˆ°å®ƒçš„å­˜åœ¨è€Œè¿›è¡Œå¸ƒå±€ã€‚ ä½ è¿˜å¯ä»¥åœ¨ä¸å½±å“å…¶ä»–è§†å›¾ä½ç½®çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨è¿™ç§ç­–ç•¥æ¥ç§»é™¤ä¸€ä¸ªè§†å›¾ï¼Œæ¯”å¦‚åœ¨ overlay(alignment:content:) ä¿®é¥°ç¬¦ä¸­çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "Or, you might have an order Form that displays a second set of address fields if a person chooses not to use the same address for their shipping and billing addresses. For content like address fields that people might need to scroll past, use an if statement to only make room for the content when itâ€™s visible, and shift other content as it appears and disappears.": {
      "zh": "æˆ–è€…ä½ å¯èƒ½æœ‰ä¸€ä¸ªè¡¨ç¤ºè®¢å•çš„ Form è§†å›¾ï¼Œå¦‚æœä¸€ä¸ªäººé€‰æ‹©æ”¶è´§å’Œè´¦å•åœ°å€ä¸ç›¸åŒï¼Œå°±ä¼šéœ€è¦æ˜¾ç¤ºç¬¬äºŒå¥—è¾“å…¥åœ°å€çš„æ§ä»¶ã€‚ å¯¹äºåƒåœ°å€å­—æ®µè¿™æ ·çš„å†…å®¹ï¼Œäººä»¬å¯èƒ½éœ€è¦æ»šåŠ¨æµè§ˆï¼Œæ‰€ä»¥ä½ å¯ä»¥ä½¿ç”¨ if è¯­å¥æ¥ä»…åœ¨å®ƒä»¬å¯è§æ—¶ä¸ºå…¶é¢„ç•™ç©ºé—´ï¼Œå¹¶åœ¨å®ƒä»¬å‡ºç°å’Œæ¶ˆå¤±æ—¶è°ƒæ•´å…¶ä»–å†…å®¹çš„ä½ç½®ã€‚",
      "tips": ""
    },
    "If you need to reserve space in a layout based on the measurement of a view, but never want to show that view, you can use the hidden() modifier.": {
      "zh": "å¦‚æœä½ éœ€è¦åœ¨å¸ƒå±€ä¸­åŸºäºä¸€ä¸ªè§†å›¾çš„å°ºå¯¸æ¥ä¿ç•™å…¶ç©ºé—´ï¼Œä½†åˆä¸æƒ³æ˜¾ç¤ºè¯¥è§†å›¾ï¼Œä½ å¯ä»¥ä½¿ç”¨ hidden() ä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    },
    "VoiceOver and gesture recognizers also ignore a view that you remove in any of these ways.": {
      "zh": "VoiceOver å’Œæ‰‹åŠ¿è¯†åˆ«å™¨ä¹Ÿä¼šå¿½ç•¥ç”¨ä»¥ä¸Šä»»ä½•ä¸€ç§æ–¹å¼ç§»é™¤çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "To show the differences between these approaches, this example uses a sequence of train cars. Each train has three views â€” a front, middle, and rear section â€” and uses the train car symbols from SF Symbols. For a long train, the front, middle, and rear car all appear. For a shorter train, the middle car doesnâ€™t appear. The code that defines each train uses a different technique to omit the middle car.": {
      "zh": "ä¸ºäº†å±•ç¤ºè¿™äº›æ–¹æ³•ä¹‹é—´çš„åŒºåˆ«ï¼Œä»¥ä¸‹ç¤ºä¾‹ä½¿ç”¨äº†ä¸€ç³»åˆ—ç«è½¦è½¦å¢ç¬¦å·ã€‚æ¯ä¸ªç«è½¦æœ‰ä¸‰ä¸ªè§†å›¾ï¼šå‰éƒ¨ã€ä¸­éƒ¨å’Œåéƒ¨ï¼Œå¹¶éƒ½ä½¿ç”¨äº† SF Symbols ä¸­çš„ç¬¦å·ã€‚ å¯¹äºä¸€ä¸ªå®Œæ•´çš„ç«è½¦ï¼Œå‰éƒ¨ã€ä¸­éƒ¨å’Œåéƒ¨çš„è½¦å¢éƒ½ä¼šæ˜¾ç¤ºã€‚å¯¹äºçŸ­ç«è½¦ï¼Œä¸­éƒ¨è½¦å¢ä¸ä¼šæ˜¾ç¤ºã€‚æ¯ä¸ªä¾‹å­éƒ½ä½¿ç”¨äº†ä¸åŒçš„æŠ€æœ¯æ¥éšè—ä¸­éƒ¨è½¦å¢ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "In these examples, the longerTrain property tracks whether to show or hide the middle train car.": {
      "zh": "åœ¨ä¾‹å­ä¸­ï¼ŒlongerTrain å±æ€§ç”¨æ¥è¡¨ç¤ºæ˜¯å¦éšè—ä¸­é—´çš„ç«è½¦è½¦å¢ç¬¦å·ã€‚",
      "tips": ""
    },
    "In a full app, the data determining whether to hide a view might be a Binding, or an Environment value.": {
      "zh": "åœ¨ä¸€ä¸ªå®é™…çš„ app ä¸­ï¼Œå†³å®šæ˜¯å¦éšè—è§†å›¾çš„æ•°æ®å¯èƒ½æ˜¯ä¸€ä¸ª Binding æˆ– Environment å€¼ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "The first train uses if, a conditional clause, to control the middle car. When longerTrain is true, the middle car is part of the train. When longerTrain is false, the middle car doesnâ€™t exist, and the other cars are closer together.": {
      "zh": "ç¬¬ä¸€ä¸ªä¾‹å­ä½¿ç”¨ if è¯­å¥æ¥æ§åˆ¶ä¸­é—´çš„è½¦å¢ç¬¦å·æ˜¯å¦æ˜¾ç¤ºã€‚å½“ longerTrain ä¸º true æ—¶ï¼Œä¸­é—´çš„è½¦å¢ç¬¦å·ä¼šæ˜¾ç¤ºæˆç«è½¦çš„ä¸€éƒ¨åˆ†ã€‚è€Œå½“ longerTrain ä¸º false æ—¶ï¼Œè¿™ä¸ªç¬¦å·ä¸å­˜åœ¨ï¼Œå…¶ä»–ç¬¦å·åˆ™ä¼šäº’ç›¸æ¥è¿‘ã€‚",
      "tips": ""
    },
    "You can also use an else clause the same way. The contents of the else clause only exist when the condition is false.": {
      "zh": "æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨ else å­å¥è¾¾åˆ°ç›¸åŒçš„ç›®çš„ã€‚else å­å¥ä¸­çš„å†…å®¹åªåœ¨æ¡ä»¶ä¸ºå‡æ—¶ä¼šæ‰§è¡Œã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "The second train uses the opacity(_:) modifier to control the visibility of the middle car. When longerTrain is true, the middle car is part of the train, and it looks just like the previous conditional example. But when longerTrain is false, the middle car still takes up space in this train.": {
      "zh": "ç¬¬äºŒä¸ªä¾‹å­åˆ™ä½¿ç”¨ opacity(_:) ä¿®é¥°ç¬¦æ¥æ§åˆ¶ä¸­é—´çš„è½¦å¢ç¬¦å·æ˜¯å¦å¯è§ã€‚å½“ longerTrain ä¸º true æ—¶ï¼Œä¸­é—´è½¦å¢ç¬¦å·æ˜¯ç«è½¦çš„ä¸€éƒ¨åˆ†ï¼Œæ˜¾ç¤ºæ•ˆæœå’Œä¹‹å‰çš„ä¾‹å­ç›¸åŒã€‚ ä½†å½“ longerTrain ä¸º false æ—¶ï¼Œè¿™ä¸ªç¬¦å·ä»ç„¶å æ®ä¸­é—´çš„ç©ºé—´ï¼Œä½†æ˜¯å˜ä¸ºä¸å¯è§ã€‚",
      "tips": ""
    },
    "Use an opacity modifier when you donâ€™t want other content to shift around as the view appears or disappears.": {
      "zh": "å½“ä½ ä¸å¸Œæœ›ä¸€ä¸ªè§†å›¾çš„å‡ºç°æˆ–æ¶ˆå¤±ä¼šè®©å…¶ä»–å†…å®¹å‘ç”Ÿä½ç½®å˜åŒ–æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ opacity ä¿®é¥°ç¬¦ã€‚",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ä¸€èŠ‚",
      "tips": ""
    }
  },
  "swiftui-concepts/creating-a-custom-input-control-that-binds-to-a-value": {
    "Creating a custom input control that binds to a value": {
      "zh": "åˆ›å»ºä¸€ä¸ªä¸ç‰¹å®šå€¼ç»‘å®šçš„è¾“å…¥æ§ä»¶",
      "tips": ""
    },
    "Provide interactions that are unique to your app with custom controls that bind to a value.": {
      "zh": "é€šè¿‡ä½¿ç”¨ä¸ç‰¹å®šå€¼ç»‘å®šçš„è‡ªå®šä¹‰æ§ä»¶ä¸ºä½ çš„åº”ç”¨æä¾›ç‹¬ä¸€æ— äºŒçš„äº¤äº’ä½“éªŒã€‚",
      "tips": ""
    },
    "SwiftUI provides input controls like Slider, TextField, and many others that bind to a value and can change the value as a personâ€™s interacts with the control. But every app is different. You may find that you need a custom control that provides behavior unique to your app.": {
      "zh": "SwiftUI æä¾›äº†ä¸€äº›ä¸ç‰¹å®šå€¼ç»‘å®šçš„è¾“å…¥æ§åˆ¶ç»„ä»¶ï¼Œä¾‹å¦‚æ»‘åŠ¨æ¡ï¼Œæ–‡æœ¬è¾“å…¥æ¡†ç­‰ã€‚è¿™äº›ç»„ä»¶çš„å€¼ä¼šéšç€ç”¨æˆ·ä¸å…¶äº¤äº’è€Œæ”¹å˜ã€‚ä½†æ˜¯æ¯ä¸ªåº”ç”¨éƒ½æ˜¯ç‹¬ä¸€æ— äºŒçš„ã€‚ä½ å¯èƒ½ä¼šå‘ç°ï¼Œä½ éœ€è¦ä¸€ä¸ªè‡ªå®šä¹‰æ§ä»¶æ¥æä¾›ä½ çš„åº”ç”¨æ‰€ç‰¹æœ‰çš„äº¤äº’è¡Œä¸ºã€‚",
      "tips": ""
    },
    "SwiftUI provides the building blocks you need to create a custom input control for your app. This tutorial walks through an example of one such control, a rating control. The sample app uses this control to let people rate recipes from 1 to 5 stars.": {
      "zh": "SwiftUI æä¾›äº†ä½ ä¸ºä½ çš„åº”ç”¨åˆ›å»ºè‡ªå®šä¹‰è¾“å…¥æ§ä»¶æ‰€éœ€è¦çš„æ„å»ºç»„ä»¶ã€‚æœ¬æ•™ç¨‹å°†ä»‹ç»è¿™æ ·æ§ä»¶çš„ä¸€ä¸ªä¾‹å­ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªè¯„çº§æ§ä»¶ã€‚è¯¥æ¡ˆä¾‹åº”ç”¨é€šè¿‡è¿™ä¸ªæ§ä»¶è®©ç”¨æˆ·ç»™èœè°±ä» 1 åˆ° 5 æ˜Ÿè¯„åˆ†",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "å¦‚æœè¦äº²è‡ªå°è¯•ä»£ç ï¼Œè¯·ä¸‹è½½é¡¹ç›®æ–‡ä»¶ï¼Œå¹¶åœ¨Xcodeä¸­æ‰“å¼€æ¡ˆä¾‹ã€‚",
      "tips": ""
    },
    "Design a custom control": {
      "zh": "è®¾è®¡ä¸€ä¸ªè‡ªå®šä¹‰æ§ä»¶",
      "tips": ""
    },
    "Before implementing a custom control, ask yourself what data does the control need, what does it do with that data, and how it does it represent that data visually within the app. The sample app, for instance, needs an Int property that represents the rating of a recipe. The control needs to be able to change the value of this property. And because the control shows the rating of a recipe, it needs to display a set of stars that reflects the rating value; for instance, the control displays five stars when the rating value is 5.": {
      "zh": "åœ¨å®ç°ä¸€ä¸ªè‡ªå®šä¹‰æ§ä»¶ä¹‹å‰ï¼Œè¯·é—®é—®è‡ªå·±è¿™ä¸ªæ§ä»¶éœ€è¦ä»€ä¹ˆæ•°æ®ï¼Œå®ƒç”¨è¿™äº›æ•°æ®åšä»€ä¹ˆï¼Œä»¥åŠå®ƒå¦‚ä½•åœ¨åº”ç”¨ä¸­ç›´è§‚åœ°å±•ç°è¿™äº›æ•°æ®ã€‚ä¾‹å¦‚ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œéœ€è¦ä¸€ä¸ª Int å±æ€§æ¥è¡¨ç¤ºä¸€ä¸ªèœè°±çš„ç­‰çº§ã€‚æ‰€ä»¥æ§ä»¶éœ€è¦èƒ½å¤Ÿæ”¹å˜è¿™ä¸ªå±æ€§çš„å€¼ã€‚å¹¶ä¸”å› ä¸ºè¯¥æ§ä»¶æ˜¾ç¤ºäº†é£Ÿè°±çš„è¯„çº§ï¼Œæ‰€ä»¥å®ƒéœ€è¦å±•ç¤ºä¸€ç»„æ˜Ÿæ˜Ÿç”¨äºååº”è¯„çº§ï¼›ä¾‹å¦‚ï¼Œå½“è¯„çº§ä¸º 5 æ—¶ï¼Œè¯¥æ§ä»¶æ˜¾ç¤ºäº”é¢—æ˜Ÿã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "The sample defines the custom control as a structure named StarRating.": {
      "zh": "è¿™ä¸ªæ¡ˆä¾‹å°†è‡ªå®šä¹‰æ§ä»¶å®šä¹‰ä¸ºä¸€ä¸ªå«åš StarRating çš„ç»“æ„ä½“ã€‚",
      "tips": ""
    },
    "This structure conforms to the View protocol because the control appears as part of the appâ€™s user interface.": {
      "zh": "è¿™ä¸ªç»“æ„ä½“ç¬¦åˆ View åè®®ï¼Œå› ä¸ºè¿™ä¸ªæ§ä»¶å°†ä½œä¸ºåº”ç”¨ç”¨æˆ·ç•Œé¢çš„ä¸€éƒ¨åˆ†å‡ºç°ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "The structure defines a Binding variable named rating, which stores the rating of a recipe.": {
      "zh": "è¿™ä¸ªç»“æ„ä½“å®šä¹‰äº†ä¸€ä¸ªåä¸º rating çš„ Binding å˜é‡ï¼Œç”¨æ¥å­˜å‚¨å¯¹é…æ–¹çš„è¯„çº§ã€‚",
      "tips": ""
    },
    "By defining rating as a binding variable, StarRating can read and write the value even though another view is responsible for creating the value.": {
      "zh": "é€šè¿‡å°† ratting å®šä¹‰ä¸ºä¸€ä¸ªç»‘å®šå˜é‡ï¼ŒStarRating å¯ä»¥è¯»å–å’Œå†™å…¥è¯¥å€¼ï¼Œå³ä½¿è¿™ä¸ªå€¼æ˜¯ç”±å¦ä¸€ä¸ªè§†å›¾è´Ÿè´£åˆ›å»ºçš„ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "The private constant maxRating stores the highest rating possible that a person can give a recipe.": {
      "zh": "ç§æœ‰å¸¸é‡ maxRating å­˜å‚¨é‡ç”¨æˆ·å¯ä»¥ç»™é…æ–¹çš„æœ€é«˜è¯„åˆ†ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨é‡Š",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "The HStack displays the rating stars in a horizontal line.": {
      "zh": "HStack ä»¥æ°´å¹³çš„æ–¹å¼æ˜¾ç¤ºæ˜Ÿçº§ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "Inside the HStack, the control uses a ForEach structure to display the number of stars indicated by the maxRating constant.": {
      "zh": "åœ¨ HStackä¸­ï¼Œä½¿ç”¨äº†ä¸€ä¸ª ForEach ç»“æ„æ¥æ˜¾ç¤ºæ˜Ÿæ˜Ÿï¼Œæ˜Ÿæ˜Ÿçš„æ•°é‡ä¸å¸¸é‡ maxRating ä¸€æ ·ã€‚",
      "tips": ""
    },
    "ForEach iterates through a collection of data defined as a range of Int instances, 1 to 5.": {
      "zh": "ForEach éå†äº†ä¸€ä¸ªç”±ä»ä¸€åˆ°äº” Int å®ä¾‹ç»„æˆçš„æ•°æ®é›†åˆã€‚",
      "tips": ""
    },
    "Important": {
      "zh": "é‡è¦æç¤º",
      "tips": ""
    },
    "The id parameter is of type ID, which is Hashable. The ForEach structure uses this parameter to identify the data, that is, the integer values 1 through 5. The parameter value is the identity key path \\.self, which specifies an Int instance for each integer. Because Int is hashable, using this key path satisfies the requirements of the ForEach initializer method init(_:id:content:). And because the data is an increasing range of integers that will never have duplicate values, itâ€™s okay to use each integer value as its identifier.": {
      "zh": "id å‚æ•°çš„ç±»å‹æ˜¯ IDï¼Œå®ƒç¬¦åˆ Hashable åè®®ã€‚ForEach ç»“æ„ä½¿ç”¨è¿™ä¸ªå‚æ•°æ¥è¯†åˆ«æ•°æ®ï¼Œä¹Ÿå°±æ˜¯ä»1åˆ°5çš„æ•´æ•°å€¼ã€‚è¿™ä¸ªå‚æ•°å€¼æ˜¯ä¸€ä¸ªç”¨äºæ ‡è¯†çš„ Key-Path è¡¨è¾¾å¼ \\.selfï¼Œå®ƒä¸ºæ¯ä¸ªéå†çš„æ•´æ•°æŒ‡å®šäº†ä¸€ä¸ª Int å®ä¾‹ã€‚å› ä¸º In tæ˜¯ Hashable çš„ï¼Œä½¿ç”¨è¿™ä¸ª Key-Path è¡¨è¾¾å¼æ»¡è¶³äº† ForEach åˆå§‹åŒ–æ–¹æ³• init(_:id:content:) çš„è¦æ±‚ã€‚è€Œä¸”å› ä¸º ForEach éå†çš„æ•°æ®æœ‰æ°¸è¿œä¸ä¼šé‡å¤ï¼Œä¸”æŒç»­å¢é•¿ï¼Œæ‰€ä»¥ä½¿ç”¨æ¯ä¸ªæ•°æ®çš„æ•´æ•°å€¼ä½œä¸ºå®ƒçš„æ ‡è¯†ç¬¦æ˜¯å¯è¡Œçš„ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ä¸ƒæ­¥",
      "tips": ""
    },
    "The control displays a star using an instance of Image.": {
      "zh": "è¿™ä¸ªæ§ä»¶é€šè¿‡ä¸€ä¸ª Image çš„å®ä¾‹æ¥å±•ç¤ºæ˜Ÿæ˜Ÿå›¾ç‰‡ã€‚",
      "tips": ""
    },
    "The sample displays an image of a star using the initializer method init(systemName:). This method creates an image view that displays a system symbol image. Symbol images like star come from SF Symbols, a library of iconography that you can use in your app.": {
      "zh": "è¯¥ä¾‹å­ä½¿ç”¨åˆå§‹åŒ–æ–¹æ³• init(systemName:) æ˜¾ç¤ºä¸€ä¸ªæ˜Ÿæ˜Ÿå›¾åƒã€‚è¿™ä¸ªæ–¹æ³•åˆ›å»ºäº†ä¸€ä¸ªå›¾åƒè§†å›¾ï¼Œæ˜¾ç¤ºä¸€ä¸ªç³»ç»Ÿå›¾åƒç¬¦å·ã€‚åƒæ˜Ÿæ˜Ÿè¿™æ ·çš„ç¬¦å·å›¾åƒæ¥è‡ª SF Symbolsï¼Œè¿™æ˜¯ä¸€ä¸ªä½ å¯ä»¥åœ¨ä½ çš„åº”ç”¨ä¸­éšæ„ä½¿ç”¨çš„å›¾æ ‡åº“ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®è·µ",
      "tips": ""
    },
    "Change the symbol from a star to another symbol such as circle.": {
      "zh": "å°è¯•å°†ç¬¦å·ä»æ˜Ÿæ˜Ÿæ”¹ä¸ºå…¶ä»–ç¬¦å·ï¼Œå¦‚åœ†åœˆã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "ç¬¬å…«æ­¥",
      "tips": ""
    },
    "The control displays a filled star when the integer value is less than or equal to the rating value and an empty star when the integer value is greater than rating, so the control applies the symbolVariant(_:) modifier to the Image instance.": {
      "zh": "å½“ value æ•°å€¼å°äºæˆ–ç­‰äº ratting å€¼æ—¶ï¼Œæ§ä»¶ä¼šæ˜¾ç¤ºä¸€ä¸ªå¡«å……çš„æ˜Ÿæ˜Ÿï¼Œå½“ value å€¼å¤§äº ratting å€¼æ—¶ï¼Œä¼šæ˜¾ç¤ºä¸€ä¸ªç©ºçš„æ˜Ÿæ˜Ÿï¼Œæ‰€ä»¥æ§ä»¶å¯¹ Image å®ä¾‹åº”ç”¨äº† symbolVariant(_:) ä¿®æ”¹å™¨æ¥ä¿®æ”¹å›¾ç‰‡çš„å¡«å……çŠ¶æ€ã€‚",
      "tips": ""
    },
    "To determine which SymbolVariants to apply, fill or none, the control uses a ternary conditional operator. This operator takes three parts, which takes the form of question ? answer1 : answer2. For more information, see Ternary Conditional Operator.": {
      "zh": "ä¸ºäº†ç¡®å®šåº”ç”¨å“ªç§ SymbolVariantsï¼Œä¹Ÿå°±æ˜¯å¡«å……è¿˜æ˜¯ä¸å¡«å……ï¼Œè¯¥æ§ä»¶ä½¿ç”¨äº†ä¸€ä¸ªä¸‰å…ƒè¿ç®—ç¬¦ã€‚è¿™ä¸ªè¿ç®—ç¬¦æœ‰ä¸‰ä¸ªéƒ¨åˆ†ï¼Œå…¶å½¢å¼ä¸º question ? answer1 : answer2ã€‚æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ä¸‰å…ƒæ¡ä»¶è¿ç®—ç¬¦ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "ç¬¬ä¹æ­¥",
      "tips": ""
    },
    "The control set the color of the stars using the foregroundColor(_:) view modifier.": {
      "zh": "è¯¥æ§ä»¶ä½¿ç”¨ foregroundColor(_:) è§†å›¾ä¿®æ”¹å™¨æ¥è®¾ç½®æ˜Ÿæ˜Ÿçš„é¢œè‰²ã€‚",
      "tips": ""
    },
    "Make the control interactive": {
      "zh": "è®©æ§ä»¶å…·æœ‰äº¤äº’æ€§",
      "tips": ""
    },
    "StarRating is able to display a set of stars to indicate the rating of a recipe. For instance, if the recipeâ€™s rating is 4, the control displays four filled stars, followed by one empty star. To make StarRating interactive, it uses the onTapGesture(count:perform:) action.": {
      "zh": "StarRating èƒ½å¤Ÿæ˜¾ç¤ºä¸€ç»„æ˜Ÿæ˜Ÿæ¥è¡¨ç¤ºå¯¹ä¸€ä¸ªé£Ÿè°±çš„è¯„çº§ã€‚ä¾‹å¦‚ï¼Œå¦‚æœèœè°±çš„ç­‰çº§æ˜¯4ï¼Œè¯¥æ§ä»¶å°±ä¼šæ˜¾ç¤ºå››é¢—å¡«å……çš„æ˜Ÿå’Œä¸€é¢—ç©ºæ˜Ÿã€‚ä¸ºäº†ä½¿ StarRating å…·æœ‰äº¤äº’æ€§ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† onTapGesture(count:perform:) åŠ¨ä½œã€‚",
      "tips": ""
    },
    "To make it possible for a person to interact with the rating control, StarRating adds the onTapGesture(count:perform:) action to each Image instance created in the ForEach loop.": {
      "zh": "ä¸ºäº†ä½¿ç”¨æˆ·äºè¯„åˆ†ç©ºé—´äº¤äº’æˆä¸ºå¯èƒ½ï¼ŒStarRating ç»™æ¯ä¸ªåœ¨ ForEach å¾ªç¯ä¸­åˆ›å»ºçš„ Image å®ä¾‹æ·»åŠ äº† onTapGesture(count:perform:) åŠ¨ä½œã€‚",
      "tips": ""
    },
    "The tap gesture performs the action defined in the closure when a person clicks or taps a star Image instance. The star indicates the rating that StarRating assigns to the recipe. For example, if a person taps the fourth star, the recipeâ€™s rating is set to 4. Tap the fourth star again and StarRating resets the recipeâ€™s rating to 0 or no stars.": {
      "zh": "å½“ä¸€ä¸ªäººç‚¹å‡»ä¸€ä¸ªæ˜Ÿæ˜Ÿ Image å®ä¾‹æ—¶ï¼Œå°±ä¼šæ‰§è¡Œåœ¨ onTapGesture çš„é—­åŒ…ä¸­å®šä¹‰çš„åŠ¨ä½œã€‚æ˜Ÿæ˜Ÿè¡¨ç¤ºäº†ç”¨æˆ·é€šè¿‡ StarRating åˆ†é…ç»™èœè°±çš„è¯„çº§ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªäººç‚¹äº†ç¬¬å››é¢—æ˜Ÿï¼Œèœè°±çš„è¯„çº§å°±ä¼šè¢«è®¾ç½®ä¸º 4ã€‚å†ç‚¹ç¬¬å››é¢—æ˜Ÿï¼ŒStarRating å°±ä¼šå°†èœè°±çš„è¯„çº§é‡ç½®ä¸º 0 çº§ã€‚",
      "tips": ""
    },
    "When the integer value isnâ€™t equal to the rating value, the closure sets rating to the integer value, which indicates the new rating that the person assigns to the recipe.": {
      "zh": "å½“ value ä¸ç­‰äº rating æ—¶ï¼Œé—­åŒ…å°† rating è®¾ç½®ä¸º value çš„å€¼ï¼Œè¿™è¡¨ç¤ºç”¨æˆ·ç»™èœè°±è®¾ç½®äº†ä¸€ä¸ªæ–°è¯„çº§ã€‚",
      "tips": ""
    },
    "By setting rating to the integer value, StarRating updates its appearance to show filled stars up to the number identified by value, followed by empty stars up to the number identified by maxRating.": {
      "zh": "é€šè¿‡è®¾ç½® rating çš„å€¼ï¼ŒStarRating æ›´æ–°äº†å®ƒçš„å¤–è§‚ï¼Œä»¥æ˜¾ç¤º value æ‰€ç¡®å®šçš„å¡«å……æ˜Ÿæ˜Ÿæ•°ï¼Œå’Œ value å’Œ maxRating æ‰€ç¡®å®šçš„ç©ºæ˜Ÿæ˜Ÿæ•°ã€‚",
      "tips": ""
    },
    "When the integer value is equal to the rating value, the closure resets the recipeâ€™s rating to no stars by setting rating to 0.": {
      "zh": "å½“ value ç­‰äº rating çš„å€¼æ—¶ï¼Œé—­åŒ…é€šè¿‡å°† rating è®¾ç½®ä¸º 0ï¼Œä»¥å°†è¯„çº§è®¾ç½®ä¸ºæ— æ˜Ÿã€‚",
      "tips": ""
    },
    "StarRating displays five empty stars to indicate that the recipe has no rating.": {
      "zh": "StarRating å°†ä¼šæ˜¾ç¤ºäº”ä¸ªç©ºæ˜Ÿï¼Œè¡¨ç¤ºè¯¥é£Ÿè°±æ²¡æœ‰è¯„çº§ã€‚",
      "tips": ""
    },
    "Display the custom control in other views": {
      "zh": "åœ¨å…¶ä»–è§†å›¾å±•ç¤ºæˆ‘ä»¬çš„è‡ªå®šä¹‰æ§ä»¶",
      "tips": ""
    },
    "StarRating is ready to go. It has the data it needs, it can apply changes to that data, and it can visually represent the current state of the data in the appâ€™s user interface. The next step is to make use of the custom input control.": {
      "zh": "StarRating æ§ä»¶å·²ç»å‡†å¤‡å¥½äº†ã€‚å®ƒæœ‰å®ƒæ‰€éœ€è¦çš„æ•°æ®ï¼Œå¯ä»¥å±•ç¤ºè¿™äº›æ•°æ®çš„å˜åŒ–ï¼Œå¹¶ä¸”å®ƒå¯ä»¥åœ¨åº”ç”¨çš„ç”¨æˆ·ç•Œé¢ä¸Šç›´è§‚åœ°è¡¨ç¤ºæ•°æ®çš„å½“å‰çŠ¶æ€ã€‚é‚£ä¹ˆä¸‹ä¸€æ­¥å°±æ˜¯åˆ©ç”¨æˆ‘ä»¬çš„è‡ªå®šä¹‰è¾“å…¥æ§ä»¶ã€‚",
      "tips": ""
    },
    "In the sample app, StarRating appears under the recipe title that appears in the recipe detail view.": {
      "zh": "åœ¨ç¤ºä¾‹åº”ç”¨ä¸­ï¼ŒStarRating ä¼šå‡ºç°åœ¨é£Ÿè°±è¯¦ç»†è§†å›¾ä¸­çš„æ ‡é¢˜ä¸‹ã€‚",
      "tips": ""
    },
    "The structure RegularTitleView is a view that displays the title and subtitle of a recipe along with its rating.": {
      "zh": "ç»“æ„ä½“ RegularTitleView æ˜¯ä¸€ä¸ªæ˜¾ç¤ºèœè°±çš„æ ‡é¢˜å’Œå‰¯æ ‡é¢˜ä»¥åŠå…¶è¯„çº§çš„è§†å›¾ã€‚",
      "tips": ""
    },
    "RegularTitleView defines a binding variable that stores a recipe received from another view.": {
      "zh": "RegularTitleView å®šä¹‰äº†ä¸€ä¸ªç»‘å®šå˜é‡ï¼Œç”¨æ¥å­˜å‚¨ä»å¦ä¸€ä¸ªè§†å›¾æ¥æ”¶çš„é…æ–¹ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "This binding allows the view to read and write data to an instance of Recipe. However, the view isnâ€™t the owner of the recipe. Another view in the sample is responsible for creating and owning the Recipe instance.": {
      "zh": "è¿™ç§ç»‘å®šå…è®¸è§†å›¾è¯»å–å’Œå†™å…¥æ•°æ® Recipe å®ä¾‹ã€‚ç„¶è€Œï¼Œè¯¥è§†å›¾å¹¶ä¸æ˜¯è¯¥ Recipe å®ä¾‹çš„æ‰€æœ‰è€…ã€‚æ¡ˆä¾‹ä¸­çš„å¦ä¸€ä¸ªè§†å›¾è´Ÿè´£åˆ›å»ºå¹¶ä¸”æ‹¥æœ‰ Recipe å®ä¾‹ã€‚",
      "tips": ""
    },
    "The view shares a binding to the recipeâ€™s rating property with the custom control StarRating, which allows the control to read and write to that property.": {
      "zh": "è§†å›¾ä¸è‡ªå®šä¹‰æ§ä»¶ StarRating å…±äº«å¯¹é…æ–¹è¯„çº§å±æ€§çš„ç»‘å®šï¼Œè¿™ä½¿æ§ä»¶å¯ä»¥è¯»å–å’Œå†™å…¥è¯¥å±æ€§ã€‚",
      "tips": ""
    },
    "As a person interacts with the StarRating control, SwiftUI redraws the view to reflect the selected rating.": {
      "zh": "å½“ä¸€ä¸ªäººä¸ StarRating æ§ä»¶äº’åŠ¨æ—¶ï¼ŒSwiftUI ä¼šé‡æ–°ç»˜åˆ¶è§†å›¾ä»¥åæ˜ æ‰€é€‰çš„è¯„çº§ã€‚",
      "tips": ""
    },
    "The dollar sign ($) prefix on the variable name recipe indicates that the call is passing a binding to StarRating.": {
      "zh": "å˜é‡åç§° recipe ä¸Šçš„ç¾å…ƒç¬¦å·ï¼ˆ$ï¼‰å‰ç¼€è¡¨æ˜ï¼Œè¯¥è°ƒç”¨æ­£åœ¨å‘ StarRating ä¼ é€’ä¸€ä¸ªç»‘å®šå€¼ã€‚",
      "tips": ""
    },
    "Defining the source of truth using a custom binding": {
      "zh": "ä½¿ç”¨è‡ªå®šä¹‰ç»‘å®šæ¥å®šä¹‰äº‹å®æ¥æº",
      "tips": ""
    },
    "Provide an alternative to a state variable by using a custom binding.": {
      "zh": "é€šè¿‡ä½¿ç”¨è‡ªå®šä¹‰ç»‘å®šæä¾›ä¸€ä¸ªçŠ¶æ€å˜é‡çš„æ›¿ä»£æ–¹æ¡ˆã€‚",
      "tips": ""
    },
    "Change the color of the stars by replacing accentColor with a different color, such as yellow.": {
      "zh": "å°è¯•ç”¨ä¸åŒçš„é¢œè‰²ï¼ˆå¦‚é»„è‰²ï¼‰æ›¿æ¢ accentColor æ¥æ”¹å˜æ˜Ÿæ˜Ÿçš„é¢œè‰²ã€‚",
      "tips": ""
    },
    "Every SwiftUI view must implement body to provide the contents of the view.": {
      "zh": "æ¯ä¸ª SwiftUI è§†å›¾éƒ½å¿…é¡»å®ç° body å±æ€§ä»¥æä¾›è§†å›¾å†…å®¹ã€‚",
      "tips": ""
    },
    "Like all other SwiftUI views, StarRating implements the required computed property body.": {
      "zh": "åƒæ‰€æœ‰å…¶ä»– SwiftUI è§†å›¾ä¸€æ ·ï¼ŒStarRating å®ç°äº†æ‰€éœ€çš„è®¡ç®—å±æ€§ bodyã€‚",
      "tips": ""
    }
  },
  "swiftui-concepts/defining-the-source-of-truth-using-a-custom-binding": {
    "Defining the source of truth using a custom binding": {
      "zh": "é€šè¿‡è‡ªå®šä¹‰ç»‘å®šå®šä¹‰æ•°æ®æº",
      "tips": ""
    },
    "Provide an alternative to a state variable by using a custom binding.": {
      "zh": "é€šè¿‡ä½¿ç”¨è‡ªå®šä¹‰ç»‘å®šæä¾›çŠ¶æ€å˜é‡çš„æ›¿ä»£æ–¹æ¡ˆã€‚",
      "tips": ""
    },
    "The most common way to define a source of truth that binds to other views in your app is to declare a state variable using the State property wrapper. However, there may be those rare occasions when the source of truth is dynamic and canâ€™t be defined using the @State attribute. For instance, this sample app needs to retrieve a recipe as the source of truth using the recipeâ€™s id. The app accomplishes this by creating a computed property that returns a custom binding.": {
      "zh": "å®šä¹‰ä¸åº”ç”¨ä¸­å…¶ä»–è§†å›¾ç»‘å®šçš„æ•°æ®æºçš„æœ€å¸¸è§æ–¹å¼æ˜¯ä½¿ç”¨ State å±æ€§åŒ…è£…å™¨å£°æ˜ä¸€ä¸ªçŠ¶æ€å˜é‡ã€‚ç„¶è€Œï¼Œåœ¨ä¸€äº›ç½•è§çš„æƒ…å†µä¸‹ï¼Œæ•°æ®æºæ˜¯åŠ¨æ€çš„ï¼Œä¸èƒ½ç”¨ @State åŒ…è£…å™¨æ¥å®šä¹‰ã€‚ä¾‹å¦‚ï¼Œè¿™ä¸ªç¤ºä¾‹åº”ç”¨éœ€è¦ä½¿ç”¨é…æ–¹çš„ id æ¥æ£€ç´¢ä¸€ä¸ªé…æ–¹ä½œä¸ºæ•°æ®æºã€‚è¯¥åº”ç”¨é€šè¿‡åˆ›å»ºä¸€ä¸ªè¿”å›è‡ªå®šä¹‰ç»‘å®šçš„è®¡ç®—å±æ€§æ¥å®ç°è¿™ä¸€ç›®çš„ã€‚",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "å¦‚æœè¦äº²è‡ªå°è¯•ä»£ç ï¼Œè¯·ä¸‹è½½é¡¹ç›®æ–‡ä»¶ï¼Œå¹¶åœ¨Xcodeä¸­æ‰“å¼€æ¡ˆä¾‹ã€‚",
      "tips": ""
    },
    "Specifying the source of truth": {
      "zh": "æŒ‡å®šæ•°æ®æº",
      "tips": ""
    },
    "This sample app displays the details of a recipe in the custom view DetailView. The view only knows the recipe id, but not the recipe, so it uses the id to retrieve the recipe from the recipe box (a data store that contains all the recipes). Because the view needs to retrieve the recipe, it uses a custom binding as the source of truth of the recipe instead of declaring a state variable for the recipe.": {
      "zh": "è¿™ä¸ªç¤ºä¾‹åº”ç”¨å°†åœ¨è‡ªå®šä¹‰è§†å›¾ DetailView æ˜¾ç¤ºé£Ÿè°±è¯¦æƒ…ã€‚ç”±äºè§†å›¾åªçŸ¥é“èœè°±çš„ IDï¼Œä½†ä¸çŸ¥é“èœè°±æœ¬èº«çš„å†…å®¹ï¼Œæ‰€ä»¥å®ƒéœ€è¦ä½¿ç”¨ ID ä»èœè°±ç›’ï¼ˆä¸€ä¸ªåŒ…å«æ‰€æœ‰èœè°±çš„æ•°æ®å­˜å‚¨ï¼‰ä¸­æ£€ç´¢èœè°±ã€‚å› ä¸ºè§†å›¾éœ€è¦æ£€ç´¢èœè°±ï¼Œæ‰€ä»¥å®ƒä½¿ç”¨è‡ªå®šä¹‰ç»‘å®šä½œä¸ºé…æ–¹çš„æ•°æ®æºï¼Œè€Œä¸æ˜¯ç›´æ¥ç»™èœè°±å£°æ˜çŠ¶æ€å˜é‡ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨é‡Š",
      "tips": ""
    },
    "Using a custom binding is a useful feature of SwiftUI, but isnâ€™t always the best option. Limit its use to use cases where using a state variable or object isnâ€™t possible. In most cases, define the source of truth as either a State variable (for state local to the view) or StateObject (for shared data models) to let SwiftUI manage the value or object for you.": {
      "zh": "SwiftUI ä¸­çš„è‡ªå®šä¹‰ç»‘å®šæ˜¯ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„åŠŸèƒ½ï¼Œä½†æ˜¯å®ƒå¹¶ä¸æ°¸è¿œæ˜¯æœ€å¥½çš„é€‰æ‹©ã€‚è¯·ä»…åœ¨æ— æ³•ä½¿ç”¨çŠ¶æ€å˜é‡å’ŒçŠ¶æ€å¯¹è±¡çš„æ—¶å€™ä½¿ç”¨å®ƒã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä½¿ç”¨ State å˜é‡ï¼ˆå½“è¿™ä¸ªçŠ¶æ€ä»…ç”¨äºå½“å‰è§†å›¾ï¼‰æˆ– StateObjectï¼ˆç”¨äºè¢«å¤šä¸ªè§†å›¾å…±äº«çš„æ•°æ®æ¨¡å‹ï¼‰è®© SwiftUI ç®¡ç†ä½ çš„å€¼å’ŒçŠ¶æ€ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "To get the recipe value in the DetailView, this sample implements the computed property recipe instead of declaring a state variable.": {
      "zh": "ä¸ºäº†åœ¨ DetailView ä¸­è·å¾—èœè°±çš„å…·ä½“å†…å®¹ï¼Œ è¿™ä¸ªæ¡ˆä¾‹å°† recipe è®¾ç½®ä¸ºè®¡ç®—å±æ€§è€Œä¸æ˜¯çŠ¶æ€å˜é‡ã€‚",
      "tips": ""
    },
    "The computed recipe property doesnâ€™t return a Recipe. Instead, it returns a custom Binding of type Recipe. This allows the view to share the recipe as a source of truth with other views.": {
      "zh": "è®¡ç®—å±æ€§çš„ recipe å¹¶ä¸ä¼šè¿”å›ä¸€ä¸ª Recipeã€‚ç›¸åï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ªç»‘å®šç±»å‹ä¸º Recipe çš„è‡ªå®šä¹‰ Bindingã€‚è¿™å°†å…è®¸è§†å›¾å°†èœè°±è§†ä¸ºæ•°æ®æºå¹¶ä¸å…¶ä»–è§†å›¾å…±äº«ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "A Binding provides read and write access to a value. To provide this access to the recipe value, the computed recipe property uses the init(get:set:) initializer method to create a binding.": {
      "zh": "Binding èƒ½ä½¿ä¸€ä¸ªå€¼å˜å¾—å¯è¯»å’Œè¯¾å†™ã€‚ä¸ºäº†ä½¿èœè°±å€¼å¯è¯»å¯å†™ï¼Œè®¡ç®—å±æ€§ recipe ä½¿ç”¨äº† init(get:set:) åˆå§‹åŒ–å™¨æ¥åˆ›å»ºä¸€ä¸ªç»‘å®šã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "The bindingâ€™s get closure uses recipeId to retrieve a recipe from the data store recipeBox.": {
      "zh": "ç»‘å®šçš„ get é—­åŒ…ä½¿ç”¨ recipeId æ¥ä»æ•°æ®åº“ recipeBox ä¸­è·å–ä¸€ä¸ªé…æ–¹ã€‚",
      "tips": ""
    },
    "If the recipe no longer exists or canâ€™t be found, the closure returns an empty recipe.": {
      "zh": "å¦‚æœé…æ–¹ä¸å†å­˜åœ¨æˆ–æ— æ³•æ‰¾åˆ°ï¼Œé—­åŒ…ä¼šè¿”å›ä¸€ä¸ªç©ºçš„é…æ–¹ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "In the set closure, the binding updates the recipe box with the new recipe value, updatedRecipe.": {
      "zh": "åœ¨ set é—­åŒ…ä¸­ï¼Œç»‘å®šç”¨æ–°çš„é…æ–¹å€¼ updateRecipe æ¥æ›´æ–°èœè°±ç›’ã€‚",
      "tips": ""
    },
    "This update happens any time data changes in the bindingâ€™s recipe value; for instance, after a person changes the rating of the recipe.": {
      "zh": "å½“ç»‘å®šçš„èœè°±å€¼å‘ç”Ÿä»»ä½•å˜åŒ–çš„æ—¶å€™ï¼Œè¿™ä¸ªæ›´æ–°å°±ä¼šå‘ç”Ÿã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå½“ç”¨æˆ·æ”¹å˜äº†èœè°±è¯„åˆ†ï¼Œé‚£ä¹ˆå°±ä¼šæ›´æ–°èœè°±ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "DetailView passes recipe to the RecipeDetailView view as a binding value, which allows the detail view to read and write to the recipe value.": {
      "zh": "DetailView å°†é…æ–¹ä½œä¸ºä¸€ä¸ªç»‘å®šå€¼ä¼ é€’ç»™ RecipeDetailView è§†å›¾ï¼Œè¿™ä½¿å¾—è¿™ä¸ªè¯¦æƒ…è§†å›¾å¯ä»¥è¯»å–å’Œå†™å…¥é…æ–¹å€¼ã€‚",
      "tips": ""
    },
    "Important": {
      "zh": "é‡è¦æç¤º",
      "tips": ""
    },
    "Because the computed property recipe returns a Binding, it isnâ€™t necessary to include the dollar sign ($) prefix thatâ€™s required when passing a state variable as a binding. For state variables â€” variables defined with a State property wrapper â€” the dollar sign ($) prefix tells SwiftUI to pass the projectedValue, which is a Binding.": {
      "zh": "å› ä¸ºè®¡ç®—çš„å±æ€§ recipe ä¼šè¿”å›ä¸€ä¸ªç»‘å®šï¼Œæ‰€ä»¥æ²¡æœ‰å¿…è¦ä½¿ç”¨åœ¨ä¼ é€’çŠ¶æ€å˜é‡ä½œä¸ºç»‘å®šæ—¶å¿…é¡»çš„ç¾å…ƒç¬¦å·ï¼ˆ$ï¼‰å‰ç¼€ã€‚å¯¹äºçŠ¶æ€å˜é‡--ç”¨çŠ¶æ€å±æ€§åŒ…è£…å™¨å®šä¹‰çš„å˜é‡--ç¾å…ƒç¬¦å·ï¼ˆ$ï¼‰å‰ç¼€å‘Šè¯‰ SwiftUI ä¼ é€’ projectedValueï¼Œå…¶æœ¬è´¨æ˜¯ä¸€ä¸ª Bindingã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "The navigationTitle(_:) modifier accepts a string value not a binding to a string value, so the view passes the recipe bindingâ€™s wrappedValue.": {
      "zh": "navigationTitle(_:) ä¿®æ”¹å™¨æ¥å—çš„æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²å€¼ï¼Œè€Œä¸æ˜¯å¯¹ä¸€ä¸ªå­—ç¬¦ä¸²å€¼çš„ç»‘å®šï¼Œæ‰€ä»¥è§†å›¾ä¼šä¼ é€’ recipe ç»‘å®šçš„ wrappedValue å€¼ã€‚",
      "tips": ""
    },
    "A wrappedValue is the underlying value referenced by the binding. Since the computed recipe property returns a binding, its wrapped value is the actual recipe value. So recipe.wrappedValue.title gets the wrappedValue of the recipe binding, then it passes the title property of the recipe value to navigationTitle(_:).": {
      "zh": "wrappedValue æ˜¯ç»‘å®šæ‰€å¼•ç”¨çš„å€¼ã€‚ç”±äºè®¡ç®—çš„é…æ–¹å±æ€§è¿”å›ä¸€ä¸ªç»‘å®šï¼Œå®ƒçš„åŒ…è£…å€¼ï¼ˆä¹Ÿå°±æ˜¯æ‰€å¼•ç”¨çš„å€¼ï¼‰å°±æ˜¯å®é™…çš„é…æ–¹å€¼ã€‚æ‰€ä»¥ recipe.wrappedValue.title å¾—åˆ°äº† recipe ç»‘å®šçš„ wrappedValueï¼Œç„¶åå®ƒå°†é…æ–¹çš„æ ‡é¢˜ä¼ é€’ç»™ navigationTitle(_:)ã€‚",
      "tips": ""
    }
  },
  "swiftui-concepts/driving-changes-in-your-ui-with-state-and-bindings": {
    "Driving changes in your UI with state and bindings": {
      "zh": "é€šè¿‡çŠ¶æ€å’Œç»‘å®šæ¥æ”¹å˜ä½ çš„ UI",
      "tips": ""
    },
    "Indicate data dependencies in a view using state, and share those dependencies with other views using bindings.": {
      "zh": "é€šè¿‡çŠ¶æ€åœ¨è§†å›¾ä¸­æ¥æŒ‡ç¤ºæ•°æ®ä¾èµ–å…³ç³»ï¼Œå¹¶é€šè¿‡ç»‘å®šå°†è¿™äº›ä¾èµ–å…³ç³»ä¸å…¶ä»–è§†å›¾å…±äº«ã€‚",
      "tips": ""
    },
    "The user interface of a SwiftUI app is a composition of views that form a view hierarchy. Each view has a dependency on some data. As that data changes, either due to external events or because of actions taken by a person using the app, SwiftUI automatically updates the view to reflect those changes.": {
      "zh": "SwiftUIåº”ç”¨çš„ç”¨æˆ·ç•Œé¢æ˜¯ä¸€ç»„è§†å›¾çš„ç»„åˆï¼Œè¿™äº›è§†å›¾æ„æˆäº†è§†å›¾çš„å±‚æ¬¡æœºæ„ã€‚æ¯ä¸ªè§†å›¾éƒ½ä¾èµ–äºæŸäº›æ•°æ®ã€‚å½“æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶ï¼Œæ— è®ºæ˜¯ç”±äºå¤–éƒ¨äº‹ä»¶è¿˜æ˜¯ç”±äºç”¨æˆ·åœ¨ä½¿ç”¨åº”ç”¨ç¨‹åºæ‰€è¿›è¡Œçš„æ“ä½œï¼ŒSwiftUI éƒ½ä¼šè‡ªåŠ¨æ›´æ–°è§†å›¾ä»¥åæ˜ è¿™äº›å˜åŒ–ã€‚",
      "tips": ""
    },
    "This sample shows examples of using State variables to indicate data dependencies, and sharing data with other views using the Binding property wrapper.": {
      "zh": "è¿™ä¸ªæ¡ˆä¾‹å±•ç¤ºäº†ä¸€ä¸ªä½¿ç”¨Stateå˜é‡æ¥æŒ‡ç¤ºæ•°æ®çš„ä¾èµ–æ€§ï¼Œä»¥åŠä½¿ç”¨ Binding å±æ€§åŒ…è£…å™¨ä¸å…¶ä»–è§†å›¾å…±äº«æ•°æ®çš„ä¾‹å­ã€‚",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "å¦‚æœè¦äº²è‡ªå°è¯•ä»£ç ï¼Œè¯·ä¸‹è½½é¡¹ç›®æ–‡ä»¶ï¼Œå¹¶åœ¨ Xcode ä¸­æ‰“å¼€æ¡ˆä¾‹ã€‚",
      "tips": ""
    },
    "Separate properties and imperative code from the view": {
      "zh": "ä»è§†å›¾ä¸­åˆ†ç¦»å±æ€§å’ŒæŒ‡ä»¤ä»£ç ",
      "tips": ""
    },
    "When a view needs to manage more than a single piece of state data, it can be helpful to manage that data in a separate view-specific structure. This approach helps make the declarative interface code of a view more readable by moving properties and imperative code outside of the view. It also helps make unit testing state changes easier to implement.": {
      "zh": "å½“ä¸€ä¸ªè§†å›¾éœ€è¦ç®¡ç†ä¸æ­¢ä¸€å—çŠ¶æ€æ•°æ®æ—¶ï¼Œåœ¨ä¸€ä¸ªè§†å›¾ä¸“ç”¨çš„ç»“æ„ä¸­ç®¡ç†è¿™äº›æ•°æ®ä¼šå¾ˆæœ‰å¸®åŠ©ã€‚é€šè¿‡å°†å±æ€§å’ŒæŒ‡ä»¤ä»£ç ç§»åˆ°è§†å›¾ä¹‹å¤–ï¼Œæœ‰åŠ©äºä½¿è§†å›¾çš„å£°æ˜å¼ç•Œé¢ä»£ç æ›´æ˜“é˜…è¯»ã€‚æ­¤å¤–ï¼Œè¿˜æ›´å®¹æ˜“å®ç°å…³äºçŠ¶æ€æ”¹å˜çš„å•å…ƒæµ‹è¯•ä»£ç ã€‚",
      "tips": ""
    },
    "This sample app displays a collection of cooking recipes. A person using the app can view the details of a recipe and add new ones. To add a recipe, the sample presents the custom view RecipeEditor, which needs three pieces of state data: a recipe, a flag indicating whether to save the changes, and a flag indicating whether to present the RecipeEditor view.": {
      "zh": "è¿™ä¸ªæ¡ˆä¾‹åº”ç”¨å±•ç¤ºäº†ä¸€ä¸ªé£Ÿè°±çš„é›†åˆã€‚ä½¿ç”¨è¿™ä¸ªåº”ç”¨çš„äººå¯ä»¥æŸ¥çœ‹é£Ÿè°±çš„è¯¦ç»†è¯´æ˜å¹¶æ·»åŠ æ–°çš„é£Ÿè°±ã€‚ä¸ºäº†èƒ½ä½¿ç”¨æˆ·æ·»åŠ ä¸€ä¸ªé£Ÿè°±ï¼Œè¯¥æ¡ˆä¾‹æ˜¾ç¤ºäº†ä¸€ä¸ªè‡ªå®šä¹‰è§†å›¾ RecipeEditorï¼Œå®ƒéœ€è¦ä¸‰å—çŠ¶æ€æ•°æ®ï¼šä¸€ä¸ªæ˜¯é£Ÿè°±ï¼Œä¸€ä¸ªç”¨æ¥è¡¨ç¤ºæ˜¯å¦ä¿å­˜æ›´æ”¹çš„æ ‡å¿—ï¼Œä»¥åŠä¸€ä¸ªè¡¨ç¤ºæ˜¯å¦å±•ç¤º RecipeEditor è§†å›¾çš„æ ‡å¿—ã€‚",
      "tips": ""
    },
    "The sample app separates its state data and imperative code from RecipeEditor by defining a structure, RecipeEditorConfig.": {
      "zh": "è¿™ä¸ªæ¡ˆä¾‹åº”ç”¨é€šè¿‡å®šä¹‰ä¸€ä¸ªç»“æ„ï¼ŒRecipeEditorConfigï¼Œå°†çŠ¶æ€æ•°æ®å’ŒæŒ‡ä»¤ä»£ç ä¸RecipeEditoråˆ†å¼€ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "The structure RecipeEditorConfig stores the state data that the RecipeEditor view needs.": {
      "zh": "ç»“æ„ RecipeEditorConfig å­˜å‚¨äº† RecipeEditor è§†å›¾éœ€è¦çš„çŠ¶æ€æ•°æ®ã€‚",
      "tips": ""
    },
    "To trigger state changes that happen in the RecipeEditor view, RecipeEditorConfig provides mutating functions that update the data to reflect a new state.": {
      "zh": "ä¸ºäº†è§¦å‘å‘ç”Ÿåœ¨ RecipeEditor è§†å›¾ä¸­çš„çŠ¶æ€å˜åŒ–ï¼ŒRecipeEditorConfig æä¾›äº†ä¸€äº›å¯å˜æ–¹æ³•ï¼Œç”¨æ¥æ›´æ–°æ•°æ®ä»¥åæ˜ æ–°çš„çŠ¶æ€ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "The method presentAddRecipe(sidebarItem:) changes the state of the view to indicate that its editing a new recipe.": {
      "zh": "æ–¹æ³• presentAddRecipe(sidebarItem:) ç”¨æ¥æ”¹å˜è§†å›¾çš„çŠ¶æ€ï¼Œè¡¨æ˜æ­£åœ¨ç¼–è¾‘ä¸€ä¸ªæ–°çš„é£Ÿè°±ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨é‡Š",
      "tips": ""
    },
    "The app calls this method when a person taps the Add Recipe button.": {
      "zh": "å½“ç”¨æˆ·ç‚¹å‡»â€œAdd Recipeâ€æŒ‰é’®æ—¶ï¼Œåº”ç”¨ä¼šè°ƒç”¨è¿™ä¸ªæ–¹æ³•ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "This method creates an empty recipe as the recipe to edit.": {
      "zh": "è¯¥æ–¹æ³•åˆ›å»ºäº†ä¸€ä¸ªç©ºçš„é…æ–¹ä½œä¸ºè¦ç¼–è¾‘çš„é…æ–¹ã€‚",
      "tips": ""
    },
    "The static method emptyRecipe() creates a new instance of Recipe, setting its properties to the default values of a new recipe.": {
      "zh": "é™æ€æ–¹æ³• emptyRecipe() ç”¨äºåˆ›å»ºä¸€ä¸ªæ–°çš„é…æ–¹å®ä¾‹ï¼Œå¹¶å°†å…¶å±æ€§è®¾ç½®ä¸ºæ–°é…æ–¹çš„é»˜è®¤å€¼ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "In addition to the default values that emptyRecipes() sets, presentAddRecipe(sidebarItem:) sets the recipeâ€™s isFavorite and collections properties based on the selected sidebar item.": {
      "zh": "é™¤äº† emptyRecipes() è®¾ç½®çš„é»˜è®¤å€¼å¤–ï¼ŒpresentAddRecipe(sidebarItem:) è¿˜ä¼šæ ¹æ®é€‰å®šçš„è¾¹æ é¡¹è®¾ç½®é£Ÿè°±çš„ isFavorite å’Œ collections å±æ€§ã€‚",
      "tips": ""
    },
    "By setting the isFavorite and collections properties, the new recipe automatically appears in the appropriate list of recipes after saving the recipe.": {
      "zh": "é€šè¿‡è®¾ç½® isFavorite å’Œ collections å±æ€§ï¼Œæ–°é…æ–¹åœ¨ä¿å­˜åä¼šè‡ªåŠ¨å‡ºç°åœ¨ç›¸åº”çš„é…æ–¹åˆ—è¡¨ä¸­ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "presentAddRecipe(sidebarItem:) sets the shouldSaveChanges flag to false because the person using the app hasnâ€™t indicated that they want to save the changes yet.": {
      "zh": "presentAddRecipe(sidebarItem:) ä¼šå°† shouldSaveChanges æ ‡å¿—è®¾ç½®ä¸º falseï¼Œå› ä¸ºä½¿ç”¨è¯¥åº”ç”¨çš„äººè¿˜æ²¡æœ‰è¡¨ç¤ºä»–ä»¬æƒ³ä¿å­˜è¿™äº›å˜åŒ–ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "This method sets the isPresented flag to true to tell SwiftUI to display the editor view.": {
      "zh": "æ­¤æ–¹æ³•å°† isPresented æ ‡å¿—è®¾ç½®ä¸º trueï¼Œä»¥å‘Šè¯‰SwiftUIæ˜¾ç¤ºç¼–è¾‘å™¨è§†å›¾ã€‚",
      "tips": ""
    },
    "Keeping reading to learn how the recipe editor appears based on the isPresented value.": {
      "zh": "ç»§ç»­é˜…è¯»ä»¥äº†è§£å¦‚ä½•é€šè¿‡æ”¹å˜ isPresented çš„å€¼æ˜¾ç¤ºé…æ–¹ç¼–è¾‘å™¨ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ä¸ƒæ­¥",
      "tips": ""
    },
    "The method presentEditRecipe(_:) is similar to presentAddRecipe(sidebarItem:), but for editing an existing recipe.": {
      "zh": "presentEditRecipe(_:) æ–¹æ³•ä¸ presentAddRecipe(sidebarItem:) ç±»ä¼¼ï¼Œä½†ç”¨äºç¼–è¾‘ç°æœ‰é…æ–¹ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "ç¬¬å…«æ­¥",
      "tips": ""
    },
    "Instead of creating an empty recipe like presentAddRecipe(sidebarItem:) does, presentEditRecipe(_:) receives the recipe to edit as a parameter and sets recipe to the incoming recipe.": {
      "zh": "presentEditRecipe(_:) ä¸æ˜¯åƒæ˜¯ presentAddRecipe(sidebarItem:) é‚£æ ·åˆ›å»ºä¸€ä¸ªç©ºé…æ–¹ï¼Œè€Œæ˜¯æ¥æ”¶è¦ç¼–è¾‘çš„é…æ–¹ä½œä¸ºå‚æ•°ï¼Œå¹¶å°† recipe è®¾ç½®ä¸ºè¿™ä¸ªè¢«ä¼ å…¥çš„é…æ–¹ã€‚",
      "tips": ""
    },
    "The RecipeEditorConfig supports two other mutating methods that trigger state changes in the editor while also separating imperative code from declarative interface code: done() and cancel().": {
      "zh": "RecipeEditorConfig æ”¯æŒå¦å¤–ä¸¤ä¸ªè§¦å‘ç¼–è¾‘å™¨çŠ¶æ€å˜åŒ–çš„å¯å˜æ–¹æ³•ï¼ŒåŒæ—¶ä¹Ÿå°†æŒ‡ä»¤æ€§ä»£ç ä¸å£°æ˜æ€§ç•Œé¢ä»£ç åˆ†å¼€ï¼šdone() å’Œ cancel()ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "ç¬¬ä¹æ­¥",
      "tips": ""
    },
    "The done() method indicates that the editor should save changes made to the recipe, and dismiss the RecipeEditor view.": {
      "zh": "done() æ–¹æ³•è¡¨ç¤ºç¼–è¾‘å™¨åº”è¯¥ä¿å­˜å¯¹é…æ–¹æ‰€åšçš„ä¿®æ”¹ï¼Œå¹¶é€€å‡º RecipeEditor è§†å›¾ã€‚",
      "tips": ""
    },
    "The method sets shouldSaveChanges to true to indicate that the app should save changes made to the recipe. It also sets isPresented to false, which tells SwiftUI to dismiss the editor view.": {
      "zh": "è¯¥æ–¹æ³•å°† shouldSaveChanges è®¾ç½®ä¸º trueï¼Œè¡¨ç¤ºåº”ç”¨åº”è¯¥ä¿å­˜å¯¹é…æ–¹çš„ä¿®æ”¹ã€‚å®ƒè¿˜å°† isPresented è®¾ç½®ä¸º falseï¼Œå‘Šè¯‰SwiftUIå–æ¶ˆæ˜¾ç¤ºç¼–è¾‘å™¨è§†å›¾ã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "ç¬¬åæ­¥",
      "tips": ""
    },
    "The cancel() method is similar to done(), but it sets shouldSaveChanges to false, telling the app to disregard the changes made to the recipe.": {
      "zh": "cancel() æ–¹æ³•ä¸ done() æ–¹æ³•ç±»ä¼¼ï¼Œä½†å®ƒå°† shouldSaveChanges è®¾ç½®ä¸º falseï¼Œå‘Šè¯‰åº”ç”¨æ— è§†å¯¹é…æ–¹çš„ä¿®æ”¹ã€‚",
      "tips": ""
    },
    "The method also sets isPresented to false, which tells SwiftUI to dismiss the editor view.": {
      "zh": "è¿™ä¸ªæ–¹æ³•è¿˜å°† isPresented è®¾ç½®ä¸º falseï¼Œè¿™å‘Šè¯‰SwiftUIå–æ¶ˆæ˜¾ç¤ºç¼–è¾‘å™¨è§†å›¾ã€‚",
      "tips": ""
    },
    "Bind the view to its state data": {
      "zh": "å°†è§†å›¾ä¸å®ƒçš„çŠ¶æ€æ•°æ®ç»‘å®š",
      "tips": ""
    },
    "With a structure in place that contains the data that the recipe editor needs, and methods that change the state of the editor, look at the RecipeEditor view to see how it uses RecipeEditorConfig.": {
      "zh": "æœ‰äº†ä¸€ä¸ªåŒ…å«é…æ–¹ç¼–è¾‘å™¨æ‰€éœ€æ•°æ®çš„ç»“æ„ï¼Œä»¥åŠä¸€äº›æ”¹å˜ç¼–è¾‘å™¨çŠ¶æ€çš„æ–¹æ³•ï¼Œæ˜¯æ—¶å€™çœ‹çœ‹ RecipeEditor è§†å›¾æ˜¯å¦‚ä½•ä½¿ç”¨ RecipeEditorConfig çš„ã€‚",
      "tips": ""
    },
    "RecipeEditor is a structure that conforms to the View protocol.": {
      "zh": "RecipeEditor æ˜¯ä¸€ä¸ªç¬¦åˆ View åè®®çš„ç»“æ„ã€‚",
      "tips": ""
    },
    "The structure declares the binding variable config of type RecipeEditorConfig, which contains the state data that the view uses to determine its appearance.": {
      "zh": "è¯¥ç»“æ„å£°æ˜äº†ä¸€ä¸ª RecipeEditorConfig ç±»å‹çš„ç»‘å®šå˜é‡ configï¼Œå®ƒåŒ…å«äº†è§†å›¾ç”¨æ¥å†³å®šå¤–è§‚çš„çŠ¶æ€æ•°æ®ã€‚",
      "tips": ""
    },
    "Important": {
      "zh": "é‡è¦æç¤º",
      "tips": ""
    },
    "The Binding property wrapper provides a two-way, read-write binding to data that the view needs. However, RecipeEditor doesnâ€™t own the data. Instead, another view creates and owns the instance of RecipeEditorConfig that RecipeEditor binds to and uses.": {
      "zh": "Binding å±æ€§åŒ…è£…å™¨ä¸ºè§†å›¾æ‰€éœ€çš„æ•°æ®æä¾›äº†åŒå‘çš„ã€å¯è¯»å†™çš„ç»‘å®šã€‚ç„¶è€Œï¼ŒRecipeEditor å¹¶ä¸æ‹¥æœ‰è¿™äº›æ•°æ®ã€‚ç›¸åï¼Œå¦ä¸€ä¸ªè§†å›¾åˆ›å»ºå¹¶æ‹¥æœ‰ RecipeEditorConfig çš„å®ä¾‹ï¼ŒRecipeEditor ä»…ä»…åªæ˜¯ä¸ä¹‹ç»‘å®šå¹¶ä½¿ç”¨å…¶æ•°æ®ã€‚",
      "tips": ""
    },
    "RecipeEditor contains RecipeEditorForm, which displays the input fields needed to edit recipe data.": {
      "zh": "RecipeEditor åŒ…å« RecipeEditorFormï¼Œå®ƒæ˜¾ç¤ºäº†ç¼–è¾‘é…æ–¹æ•°æ®æ‰€éœ€çš„è¾“å…¥æ¡†ã€‚",
      "tips": ""
    },
    "RecipeEditor passes the binding variable config to RecipeEditorForm. It passes the variable as a binding, indicated by prefixing the variable name config with the $ symbol. Because RecipeEditorForm receives config as a binding, the form can read and write data to config.": {
      "zh": "RecipeEditor æŠŠç»‘å®šå˜é‡ config ä¼ é€’ç»™äº† RecipeEditorFormã€‚é€šè¿‡åœ¨å˜é‡å config å‰åŠ ä¸Š $ ç¬¦å·ï¼Œå®ƒæŠŠè¿™ä¸ªå˜é‡ä½œä¸ºä¸€ä¸ªç»‘å®šå˜é‡æ¥ä¼ é€’ã€‚å› ä¸º RecipeEditorForm æ¥æ”¶ config ä½œä¸ºä¸€ä¸ªç»‘å®šå˜é‡ï¼Œæ‰€ä»¥ RecipeEditorForm å¯ä»¥å‘ config è¯»å†™æ•°æ®ã€‚",
      "tips": ""
    },
    "The editor displays a Cancel button in its toolbar.": {
      "zh": "ç¼–è¾‘å™¨åœ¨å…¶å·¥å…·æ ä¸Šæ˜¾ç¤ºä¸€ä¸ªå–æ¶ˆæŒ‰é’®ã€‚",
      "tips": ""
    },
    "When a person taps the Cancel button, its action calls the mutating method cancel() defined in RecipeEditorConfig, which sets shouldSaveChanges to false and isPresented to false.": {
      "zh": "å½“ä¸€ä¸ªäººç‚¹å‡»å–æ¶ˆæŒ‰é’®æ—¶ï¼Œå®ƒä¼šè°ƒç”¨ RecipeEditorConfig ä¸­å®šä¹‰çš„å¯å˜æ–¹æ³• cancel()ï¼Œå®ƒå°† shouldSaveChanges è®¾ç½®ä¸º falseï¼ŒisPresented è®¾ç½®ä¸º falseã€‚",
      "tips": ""
    },
    "The editor also displays a Save button that, when a person taps it, calls the mutating done() method, which sets shouldSaveChanges to true and isPresented to false, telling the app to save any changes made to the recipe and dismiss the editor view.": {
      "zh": "ç¼–è¾‘å™¨è¿˜æ˜¾ç¤ºä¸€ä¸ªä¿å­˜æŒ‰é’®ï¼Œå½“äººä»¬ç‚¹å‡»è¯¥æŒ‰é’®æ—¶ï¼Œä¼šè°ƒç”¨å¯å˜æ–¹æ³• doed()ï¼Œè¯¥æ–¹æ³•å°† shouldSaveChanges è®¾ç½®ä¸º trueï¼Œå°† isPresented è®¾ç½®ä¸º falseï¼Œå‘Šè¯‰åº”ç”¨ä¿å­˜å¯¹é…æ–¹æ‰€åšçš„ä»»ä½•ä¿®æ”¹ï¼Œå¹¶é€€å‡ºç¼–è¾‘å™¨è§†å›¾ã€‚",
      "tips": ""
    },
    "Settings shouldSaveChanges and isPresented in the cancel() and done() methods make the view code easier to read because each buttonâ€™s action only needs one line of code. The button actions couldâ€™ve explicitly set config.saveConfig and config.isPresented, but keeping imperative code in an action to a minimum helps make the declarative interface code of the view more readable and easier to maintain.": {
      "zh": "åœ¨ cancel() å’Œ done() æ–¹æ³•ä¸­è®¾ç½® shouldSaveChanges å’Œ isPresented å¯ä»¥ä½¿è§†å›¾ä»£ç æ›´å®¹æ˜“é˜…è¯»ï¼Œå› ä¸ºæ¯ä¸ªæŒ‰é’®çš„åŠ¨ä½œåªéœ€è¦ä¸€è¡Œä»£ç ã€‚æŒ‰é’®åŠ¨ä½œä¹Ÿå¯ä»¥æ˜ç¡®åœ°è®¾ç½® config.saveConfig å’Œ config.isPresented çš„å€¼ï¼Œä½†å°†æŒ‰é’®åŠ¨ä½œä¸­çš„æŒ‡ä»¤æ€§ä»£ç ä¿æŒåœ¨æœ€ä½é™åº¦ï¼Œæœ‰åŠ©äºä½¿è§†å›¾çš„å£°æ˜æ€§ç•Œé¢ä»£ç æ›´æ˜“è¯»ï¼Œæ›´å®¹æ˜“ç»´æŠ¤ã€‚",
      "tips": ""
    },
    "Create a state variable in another view": {
      "zh": "åœ¨å¦ä¸€ä¸ªè§†å›¾ä¸­åˆ›å»ºä¸€ä¸ªçŠ¶æ€å˜é‡",
      "tips": ""
    },
    "The RecipeEditor view has a binding to an instance of RecipeEditorConfig. The editor can read and write the data but it doesnâ€™t own the recipe data. Instead, the view ContentListView creates and owns the data, and SwiftUI manages that data for the lifespan of the content list view.": {
      "zh": "RecipeEditor è§†å›¾æ‹¥æœ‰ä¸€ä¸ªå¯¹ RecipeEditorConfig å®ä¾‹çš„ç»‘å®šã€‚ç¼–è¾‘å™¨å¯ä»¥è¯»å–å’Œå†™å…¥æ•°æ®ï¼Œä½†å®ƒå¹¶ä¸æ‹¥æœ‰é…æ–¹æ•°æ®ã€‚ç›¸åï¼Œè§†å›¾ ContentListView åˆ›å»ºå¹¶æ‹¥æœ‰è¿™äº›æ•°æ®ï¼ŒSwiftUIåœ¨ ContentListView çš„ç”Ÿå‘½å‘¨æœŸå†…ç®¡ç†è¿™äº›æ•°æ®ã€‚",
      "tips": ""
    },
    "ContentListView is a custom view that conforms to the View protocol and displays a list of recipes.": {
      "zh": "ContentListView æ˜¯ä¸€ä¸ªç¬¦åˆ View åè®®çš„è‡ªå®šä¹‰è§†å›¾ï¼Œå®ƒæ˜¾ç¤ºäº†ä¸€ä¸ªé£Ÿè°±åˆ—è¡¨ã€‚",
      "tips": ""
    },
    "ContentListView is also responsible for displaying the recipe editor when a person wants to add a recipe, making this view the ideal place to create an instance of RecipeEditorConfig.": {
      "zh": "ContentListView è¿˜è´Ÿè´£åœ¨äººä»¬æƒ³è¦æ·»åŠ é£Ÿè°±æ—¶æ˜¾ç¤ºé£Ÿè°±ç¼–è¾‘å™¨ï¼Œè¿™ä½¿å¾—è¯¥è§†å›¾æˆä¸ºåˆ›å»º RecipeEditorConfig å®ä¾‹çš„ç†æƒ³åœºæ‰€ã€‚",
      "tips": ""
    },
    "The view defines the private state variable recipeEditorConfig, of type RecipeEditorConfig.": {
      "zh": "è¯¥è§†å›¾å®šä¹‰äº†ä¸€ä¸ªç§æœ‰çŠ¶æ€å˜é‡ recipeEditorConfigï¼Œç±»å‹ä¸º RecipeEditorConfigã€‚",
      "tips": ""
    },
    "This view also displays an Add Recipe button in its toolbar.": {
      "zh": "è¯¥è§†å›¾è¿˜åœ¨å…¶å·¥å…·æ ä¸Šæ˜¾ç¤ºäº†ä¸€ä¸ªæ·»åŠ é…æ–¹æŒ‰é’®ã€‚",
      "tips": ""
    },
    "The Add Recipe button appears as a button with a plus sign as its label.": {
      "zh": "æ·»åŠ é…æ–¹æŒ‰é’®å°†æ˜¾ç¤ºä¸ºä¸€ä¸ªå¸¦åŠ å·æ ‡è¯†çš„æŒ‰é’®ã€‚",
      "tips": ""
    },
    "When a person taps the Add Recipe button, the buttonâ€™s action calls the mutating method presentAddRecipe(sidebarItem:), which changes the data contained in recipeEditorConfig.": {
      "zh": "å½“ä¸€ä¸ªäººç‚¹å‡»æ·»åŠ é…æ–¹æŒ‰é’®æ—¶ï¼Œè¯¥æŒ‰é’®çš„åŠ¨ä½œä¼šè°ƒç”¨å¯å˜æ–¹æ³• presentAddRecipe(sidebarItem:) ï¼Œä»è€Œæ”¹å˜ recipeEditorConfig ä¸­åŒ…å«çš„æ•°æ®ã€‚",
      "tips": ""
    },
    "Recall that presentAddRecipe(sidebarItem:) creates an empty recipe and sets its isFavorite and collections property values based on the selected sidebar item. The method also sets shouldSaveChanges to false and isPresented to true. Keeping this imperative code outside of the view helps make the declarative code of the view easier to understand and maintain.": {
      "zh": "å›æƒ³ä¸€ä¸‹ presentAddRecipe(sidebarItem:)ï¼Œå®ƒåˆ›å»ºäº†ä¸€ä¸ªç©ºçš„é…æ–¹ï¼Œå¹¶æ ¹æ®é€‰å®šçš„ä¾§è¾¹æ é¡¹ç›®è®¾ç½® isFavorite å’Œ collection å±æ€§çš„å€¼ã€‚è¯¥æ–¹æ³•è¿˜å°† shouldSaveChanges è®¾ç½®ä¸º falseï¼ŒisPresented è®¾ç½®ä¸º trueã€‚å°†è¿™äº›å‘½ä»¤å¼ä»£ç æ”¾ç½®åœ¨è§†å›¾ä¹‹å¤–æœ‰åŠ©äºä½¿è§†å›¾çš„å£°æ˜å¼ç•Œé¢ä»£ç æ›´å®¹æ˜“ç†è§£å’Œç»´æŠ¤ã€‚",
      "tips": ""
    },
    "After calling presentAddRecipe(sidebarItem:), isPresented is true, which tells SwiftUI to display a sheet that contains the recipe editor.": {
      "zh": "è°ƒç”¨ presentAddRecipe(sidebarItem:) åï¼ŒisPresented å°†è®¾ç½®ä¸º trueï¼Œè¿™ä¼šè®©SwiftUIæ˜¾ç¤ºä¸€ä¸ªåŒ…å«é£Ÿè°±ç¼–è¾‘å™¨çš„é¡µé¢ã€‚",
      "tips": ""
    },
    "The Boolean value recipeEditorConfig.isPresented determines whether to present the sheet that contains the RecipeEditor view. When the value changes from false to true, the sheet presents a modal view containing RecipeEditor. When the value changes from true to false, the sheet dismisses the modal view.": {
      "zh": "å¸ƒå°”å€¼ recipeEditorConfig.isPresented å†³å®šäº†æ˜¯å¦å‘ˆç°åŒ…å« RecipeEditor è§†å›¾çš„å¼¹çª—ã€‚å½“å€¼ä» false å˜ä¸º true æ—¶ï¼Œé•¿å¼¹çª—ä¼šå‘ˆç°ä¸€ä¸ªåŒ…å« RecipeEditor çš„è§†å›¾ã€‚å½“è¯¥å€¼ä» true å˜ä¸º false æ—¶ï¼Œé•¿å¼¹çª—å°±ä¼šå–æ¶ˆè¯¥è§†å›¾ã€‚",
      "tips": ""
    },
    "The modifier sheet(isPresented:onDismiss:content:) receives a binding as indicated by the dollar sign ($) prefix. This binding lets the sheet read and write to the property. For instance, when a person dismisses the sheet by swiping it downward, the sheet sets recipeEditorConfig.isPresented to false. This change causes SwiftUI to reinitialize and rebuild the view. And because isPresented is now false, the sheet no longer appears.": {
      "zh": "ä¿®é¥°å™¨ sheet(isPresented:onDismiss:content:) æ¥æ”¶ä¸€ä¸ªç”±ç¾å…ƒç¬¦å·ï¼ˆ$ï¼‰å‰ç¼€è¡¨ç¤ºçš„ç»‘å®šã€‚è¿™ä¸ªç»‘å®šè®©é•¿å¼¹çª—å¯ä»¥è¯»å–å’Œå†™å…¥å…¶ä¸­çš„å±æ€§ã€‚ä¾‹å¦‚ï¼Œå½“ä¸€ä¸ªäººå‘ä¸‹è½»æ‰«é•¿å¼¹çª—æ—¶ï¼Œé•¿å¼¹çª—ä¼šå°† recipeEditorConfig.isPresented è®¾ç½®ä¸º falseã€‚è¿™ä¸€å˜åŒ–å¯¼è‡´SwiftUIé‡æ–°åˆå§‹åŒ–å¹¶é‡å»ºè§†å›¾ã€‚ç”±äº isPresented ç°åœ¨æ˜¯ falseï¼Œé•¿å¼¹çª—ä¸å†å‡ºç°ã€‚",
      "tips": ""
    },
    "The sheet contains RecipeEditor, a custom view that displays a form containing input fields that let a person change the data of a recipe.": {
      "zh": "è¯¥é•¿å¼¹çª—åŒ…å« RecipeEditorï¼Œè¿™æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰è§†å›¾ï¼Œæ˜¾ç¤ºäº†ä¸€ä¸ªåŒ…å«ä¸€äº›ç”¨äºè®©äººæ”¹å˜é£Ÿè°±æ•°æ®çš„è¾“å…¥æ¡†çš„è¡¨å•ã€‚",
      "tips": ""
    },
    "RecipeEditor receives a binding to recipeEditorConfig â€” as indicated by the dollar sign ($) prefix â€” which makes it possible for the editor to retrieve and make changes to data contained in recipeEditorConfig. This includes changing recipe data and triggering state changes.": {
      "zh": "RecipeEditor æ”¶åˆ°äº†ä¸€ä¸ªä¸ recipeEditorConfig çš„ç»‘å®š -- å¦‚ç¾å…ƒç¬¦å·ï¼ˆ$ï¼‰å‰ç¼€æ‰€ç¤º -- è¿™ä½¿å¾—ç¼–è¾‘å™¨å¯ä»¥è·å–å’Œæ”¹å˜ recipeEditorConfig ä¸­åŒ…å«çš„æ•°æ®ã€‚è¿™åŒ…æ‹¬æ”¹å˜é…æ–¹æ•°æ®å’Œè§¦å‘çŠ¶æ€å˜åŒ–ã€‚",
      "tips": ""
    },
    "When the value of isPresented changes from true to false, the sheet calls its onDismiss action, which calls the didDismissEditor method.": {
      "zh": "å½“ isPresented çš„å€¼ä» true å˜ä¸º false æ—¶ï¼Œé•¿å¼¹çª—å°±ä¼šè°ƒç”¨å®ƒçš„ onDismiss åŠ¨ä½œï¼Œå³è°ƒç”¨ didDismissEditor æ–¹æ³•ã€‚",
      "tips": ""
    },
    "The sheet also calls onDismiss when isPresented changes from true to false in the cancel() and done() methods that RecipeEditorConfig defines. The sheet is able to detect the value change because it has a binding to the recipeEditorConfig.isPresented property.": {
      "zh": "å½“ isPresented åœ¨ RecipeEditorConfig å®šä¹‰çš„ cancel() å’Œ done() æ–¹æ³•ä¸­ä» true å˜ä¸º false æ—¶ï¼Œé•¿å¼¹çª—ä¹Ÿä¼šè°ƒç”¨ onDismissã€‚é•¿å¼¹çª—èƒ½å¤Ÿæ£€æµ‹åˆ°è¿™ä¸ªå€¼çš„å˜åŒ–ï¼Œå› ä¸ºå®ƒä¸ recipeEditorConfig.isPresented å±æ€§æœ‰ä¸€ä¸ªç»‘å®šã€‚",
      "tips": ""
    },
    "This view implements the didDismissEditor method, which saves the changes a person makes to the recipe if recipeEditorConfig.shouldSaveChanges is true; otherwise, the method disregards the changes.": {
      "zh": "è¿™ä¸ªè§†å›¾å®ç°äº† didDismissEditor æ–¹æ³•ï¼Œå¦‚æœr ecipeEditorConfig.shouldSaveChanges ä¸º trueï¼Œè¯¥æ–¹æ³•å°†ä¿å­˜ä¸€ä¸ªäººå¯¹é…æ–¹æ‰€åšçš„ä¿®æ”¹ï¼›å¦åˆ™ï¼Œè¯¥æ–¹æ³•å°†ä¸è€ƒè™‘è¿™äº›ä¿®æ”¹ã€‚",
      "tips": ""
    },
    "RecipeEditorConfig concerns itself with RecipeEditor and only that view, which is why ContentListView implements the didDismissEditor method instead of RecipeEditorConfig. This approach keeps the areas of concern separate.": {
      "zh": "RecipeEditorConfig ä¸ RecipeEditor æœ‰å…³ï¼Œå¹¶ä¸”ä»…ä¸è¯¥è§†å›¾æœ‰å…³ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆ ContentListView å®ç°äº† didDismissEditor æ–¹æ³•ï¼Œè€Œä¸æ˜¯ RecipeEditorConfigã€‚è¿™ç§æ–¹å¼ä½¿å…³æ³¨çš„é¢†åŸŸåˆ†å¼€ã€‚",
      "tips": ""
    },
    "Creating a custom input control that binds to a value": {
      "zh": "åˆ›å»ºä¸€ä¸ªä¸å€¼ç»‘å®šçš„è‡ªå®šä¹‰è¾“å…¥æ§ä»¶",
      "tips": ""
    },
    "Provide interactions that are unique to your app with custom controls that bind to a value.": {
      "zh": "é€šè¿‡ç»‘å®šåˆ°ä¸€ä¸ªå€¼çš„è‡ªå®šä¹‰æ§ä»¶ï¼Œæä¾›ä½ åº”ç”¨æ‰€ç‰¹æœ‰çš„äº¤äº’æ–¹å¼ã€‚",
      "tips": ""
    },
    "The recipeEditorConfig declaration includes the attribute for the State property wrapper, which tells SwiftUI to create and manage the instance of RecipeEditorConfig. Each time view state changes, that is, data that recipeEditorConfig contains changes, SwiftUI reinitializes the view, reconnects the RecipeEditorConfig instance to the view, and rebuilds the view defined in the computed body property, which reflects the current state of the data. For more information, see Model data.": {
      "zh": "recipeEditorConfig å£°æ˜åŒ…æ‹¬Stateå±æ€§åŒ…è£…å™¨ï¼Œå®ƒè®©SwiftUIåˆ›å»ºå¹¶ç®¡ç† RecipeEditorConfig çš„å®ä¾‹ã€‚æ¯æ¬¡è§†å›¾çŠ¶æ€å‘ç”Ÿå˜åŒ–ï¼Œå³ recipeEditorConfig åŒ…å«çš„æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶ï¼ŒSwiftUIéƒ½ä¼šé‡æ–°åˆå§‹åŒ–è§†å›¾ï¼Œå°† RecipeEditorConfig å®ä¾‹é‡æ–°è¿æ¥åˆ°è§†å›¾ï¼Œå¹¶é‡æ–°æ„å»ºè®¡ç®—å±æ€§ä¸­å®šä¹‰çš„è§†å›¾ï¼Œä½¿å…¶åæ˜ æ•°æ®å½“å‰çš„çŠ¶æ€ã€‚æƒ³è¦äº†è§£æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è€ƒæ¨¡å‹æ•°æ®ã€‚",
      "tips": ""
    },
    "When presentAddRecipe(sidebarItem:) changes the data in recipeEditorConfig, SwiftUI reinitializes the ContentListView instance and reconnects recipeEditorConfig to the instance that itâ€™s managing. SwiftUI then rebuilds the view from its computed body property so that the view reflects the current state of the data.": {
      "zh": "å½“ presentAddRecipe(sidebarItem:) æ›´æ”¹ recipeEditorConfig ä¸­çš„æ•°æ®æ—¶ï¼ŒSwiftUI ä¼šé‡æ–°åˆå§‹åŒ– ContentListView å®ä¾‹ï¼Œå¹¶å°† recipeEditorConfig é‡æ–°è¿æ¥åˆ°å®ƒæ‰€ç®¡ç†çš„å®ä¾‹ã€‚ç„¶åï¼ŒSwiftUIä»å…¶è®¡ç®—å±æ€§ body ä¸­é‡å»ºè§†å›¾ï¼Œä»¥ä½¿è§†å›¾åæ˜ æ•°æ®çš„å½“å‰çŠ¶æ€ã€‚",
      "tips": ""
    }
  },
  "swiftui-concepts/exploring-the-structure-of-a-swiftui-app": {
    "Exploring the structure of a SwiftUI app": {
      "zh": "æ¢ç´¢ SwiftUI app çš„ç»“æ„",
      "tips": ""
    },
    "Walk through code that explores the structure of a SwiftUI app.": {
      "zh": "è·Ÿç€ä»£ç é€æ­¥æ¢ç´¢ SwiftUI app çš„ç»“æ„",
      "tips": ""
    },
    "SwiftUI is a declarative framework that helps you compose the user interface of your app. The principle building blocks that form the structure of a SwiftUI app are the App, Scene, and View protocols. This sample introduces you to these protocols by walking through lines of code, and explaining whatâ€™s happening and why.": {
      "zh": "SwiftUI æ˜¯ä¸€ä¸ªå£°æ˜å¼æ¡†æ¶ï¼Œå¯å¸®åŠ©æ‚¨æ„å»ºåº”ç”¨ç¨‹åºçš„ç”¨æˆ·ç•Œé¢ã€‚æ„æˆ SwiftUI åº”ç”¨ç¨‹åºç»“æ„çš„ä¸»è¦éƒ¨åˆ†æ˜¯ Appã€Scene å’Œ View protocolï¼ˆåè®®ï¼‰ã€‚æœ¬ç¤ºä¾‹é€šè¿‡é€è¡Œä»£ç å»ä»‹ç»è¿™äº›åè®®ï¼Œä»¥åŠè§£é‡Šæ­£åœ¨å‘ç”Ÿçš„äº‹æƒ…ä»¥åŠåŸå› ã€‚",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "è‹¥è¦å°è¯•ä»£ç ï¼Œä¸‹è½½é¡¹ç›®æ–‡ä»¶å¹¶åœ¨ Xcode ä¸­æ‰“å¼€ç¤ºä¾‹ã€‚",
      "tips": ""
    },
    "App structure": {
      "zh": "App ç»“æ„ä½“",
      "tips": ""
    },
    "An app structure describes the content and behavior of your app, and each SwiftUI app has one and only one main app structure. This sample defines its app structure in the MyApp.swift file. Letâ€™s take a look at the contents of that file.": {
      "zh": "App ç»“æ„æè¿°äº† App å†…çš„å†…å®¹å’Œæ‚¨ App çš„å„ç§è¡Œä¸ºï¼Œæ¯ä¸ª SwiftUI App æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªä¸» App ç»“æ„ã€‚è¿™ä¸ªç¤ºä¾‹åœ¨ MyApp.swift æ–‡ä»¶ä¸­å®šä¹‰äº†å®ƒçš„ App ç»“æ„ã€‚è®©æˆ‘ä»¬çœ‹ä¸€çœ‹è¿™ä¸ªæ–‡ä»¶é‡Œçš„å†…å®¹ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ 1 æ­¥",
      "tips": ""
    },
    "To access the symbols and features of SwiftUI, the app uses an import declaration to import the SwiftUI framework.": {
      "zh": "ä¸ºäº†ä½¿ç”¨ SwiftUI çš„ç¬¦å·å’ŒåŠŸèƒ½ï¼ŒApp ä½¿ç”¨ import å£°æ˜æ¥å¯¼å…¥ SwiftUI æ¡†æ¶ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨é‡Š",
      "tips": ""
    },
    "For more information, see Import Declaration in The Swift Programming Language.": {
      "zh": "æ›´å¤šçš„ç›¸å…³ä¿¡æ¯ï¼Œè¯·å‚é˜… The Swift Programming Language ä¸­çš„ Import Declaration éƒ¨åˆ†ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬ 2 æ­¥",
      "tips": ""
    },
    "To indicate the entry point of the SwiftUI app, the sample applies the @main attribute to the app structure.": {
      "zh": "ä¸ºäº†æ ‡ç¤º SwiftUI app çš„å…¥å£ç‚¹ï¼Œç¤ºä¾‹é¡¹ç›®å°† @main å±æ€§åº”ç”¨äº app ç»“æ„ä½“ã€‚",
      "tips": ""
    },
    "The entry point is responsible for the start up of the app.": {
      "zh": "å…¥å£ç‚¹è´Ÿè´£ app çš„å¯åŠ¨ã€‚",
      "tips": ""
    },
    "Important": {
      "zh": "é‡è¦æç¤º",
      "tips": ""
    },
    "A SwiftUI app contains one and only one entry point. Attempting to apply @main to more than one structure in the app results in a compiler error.": {
      "zh": "ä¸€ä¸ª SwiftUI app åŒ…å«ä¸€ä¸ªä¸”ä»…åŒ…å«ä¸€ä¸ªå…¥å£ç‚¹ã€‚å°è¯•å°† @main åœ¨ app å†…åº”ç”¨åˆ°å¤šäºä¸€ä¸ªç»“æ„ä½“çš„ä½ç½®ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ 3 æ­¥",
      "tips": ""
    },
    "The MyApp structure conforms to the App protocol, and provides the content of the app and its behavior.": {
      "zh": "MyApp ç»“æ„ä½“éµå¾ª App åè®®ï¼Œå¹¶æä¾›äº† App çš„å†…å®¹å’Œè¿™ä¸ª App çš„è¡Œä¸ºã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬ 4 æ­¥",
      "tips": ""
    },
    "The structure implements the computed property body, which is a requirement of the App protocol.": {
      "zh": "è¯¥ç»“æ„ä½“å†…å®ç°äº†è®¡ç®—å±æ€§ bodyï¼Œè¿™æ˜¯ä¸ºäº†éµå¾ª App åè®®ã€‚",
      "tips": ""
    },
    "This property returns the contents of your app described as a Scene. A scene contains the view hierarchy that defines the appâ€™s user interface. SwiftUI provides different types of scenes including WindowGroup, Window, DocumentGroup, and Settings.": {
      "zh": "è¿™ä¸ªå±æ€§è¿”å›äº†ä¸€ä¸ªè¢«ç§°ä¸º Sceneï¼ˆåœºæ™¯ï¼‰çš„ä¸œè¥¿ï¼Œä»–æè¿°äº† app å†…çš„å†…å®¹ã€‚ä¸€ä¸ª sceneï¼ˆåœºæ™¯ï¼‰åŒ…å«äº†è§†å›¾å±‚æ¬¡ç»“æ„ï¼Œå®šä¹‰äº† app çš„ç”¨æˆ·ç•Œé¢ã€‚SwiftUI æä¾›äº†ä¸åŒçš„ sceneï¼ˆåœºæ™¯ï¼‰ï¼ŒåŒ…æ‹¬ WindowGroupï¼ˆçª—å£ç»„ï¼‰ï¼ŒWindowï¼ˆçª—å£ï¼‰ï¼ŒDocumentGroupï¼ˆæ–‡æ¡£ç»„ï¼‰ å’Œ Settingsï¼ˆè®¾ç½®ï¼‰ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬ 5 æ­¥",
      "tips": ""
    },
    "This sample uses a WindowGroup scene to represent the main window that the app displays.": {
      "zh": "è¿™ä¸ªç¤ºä¾‹ä½¿ç”¨äº†ä¸€ä¸ª WindowGroupï¼ˆçª—å£ç»„ï¼‰åœºæ™¯æ¥å±•ç¤ºåº”ç”¨æ˜¾ç¤ºçš„ä¸»çª—å£ã€‚",
      "tips": ""
    },
    "SwiftUI provides platform-specific behaviors for WindowGroup. For instance, in macOS and iPadOS, a person can open more than one window from the group. And in macOS, a person can combine multiple instances of the window group into a set of tabs.": {
      "zh": "SwiftUI çš„ WindowGroup ä¸ºä¸åŒçš„å¹³å°æä¾›äº†ä¸åŒçš„è¡¨ç°æ–¹å¼ã€‚ä¾‹å¦‚ï¼Œåœ¨ macOS å’Œ iPadOS ä¸­ï¼Œä¸€ä¸ªç”¨æˆ·å¯ä»¥ä» groupï¼ˆç»„ï¼‰å†…æ‰“å¼€å¤šä¸ª windowï¼ˆçª—å£ï¼‰ã€‚å¹¶ä¸”åœ¨ macOS ä¸Šï¼Œå¯ä»¥å°†å¤šä¸ªçª—å£ groupï¼ˆç»„ï¼‰çš„å®ä½“æ”¾åˆ°ä¸€ä¸ªå¤šæ ‡ç­¾é¡µé›†åˆä¸­ã€‚",
      "tips": ""
    },
    "Tip": {
      "zh": "æç¤º",
      "tips": ""
    },
    "If youâ€™re creating a document-based app such as a word processor or text editor, you can use the DocumentGroup scene to open, save, and edit documents. For more information, see Building a Document-Based App with SwiftUI.": {
      "zh": "å¦‚æœä½ è¦åˆ›å»ºä¸€ä¸ªåŸºäºæ–‡æ¡£çš„ appï¼Œä¾‹å¦‚æ–‡å­—å¤„ç†å™¨æˆ–æ–‡æœ¬ç¼–è¾‘å™¨ï¼Œä½ å¯ä»¥ä½¿ç”¨ DocumentGroupï¼ˆæ–‡æ¡£ç»„ï¼‰sceneï¼ˆåœºæ™¯ï¼‰æ¥æ‰“å¼€ï¼Œä¿å­˜ï¼Œç¼–è¾‘æ–‡æ¡£ã€‚æ›´å¤šçš„ç›¸å…³ä¿¡æ¯ï¼Œè¯·å‚é˜…æ–‡ç«  - Building a Document-Based App with SwiftUIï¼ˆåˆ©ç”¨ SwiftUI åˆ›å»ºä¸€ä¸ªåŸºäºæ–‡æ¡£çš„ Appï¼‰ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬ 6 æ­¥",
      "tips": ""
    },
    "The scene contains ContentView, a custom view that creates a view hierarchy that consists of an image and text.": {
      "zh": "sceneï¼ˆåœºæ™¯ï¼‰åŒ…å« ContentViewï¼ˆå†…å®¹è§†å›¾ï¼‰ï¼Œä»–æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰ viewï¼ˆè§†å›¾ï¼‰ï¼Œç”¨äºåˆ›å»ºä¸€ä¸ªåŒ…å«å›¾åƒå’Œæ–‡æœ¬çš„è§†å›¾å±‚æ¬¡ç»“æ„ã€‚",
      "tips": ""
    },
    "Keep reading to learn how ContentView composes the view hierarchy.": {
      "zh": "ç»§ç»­é˜…è¯»ä»¥äº†è§£ ContentViewï¼ˆå†…å®¹è§†å›¾ï¼‰æ˜¯å¦‚ä½•å»ºç«‹ view hierachyï¼ˆè§†å›¾æ ‘ï¼‰çš„ã€‚",
      "tips": ""
    },
    "Content view": {
      "zh": "å†…å®¹è§†å›¾",
      "tips": ""
    },
    "In SwiftUI, a scene contains the view hierarchy that an app displays as its user interface. A view hierarchy defines the layout of views relative to other views. In this sample, a WindowGroup scene contains the view hierarchy that ContentView composes using other views.": {
      "zh": "SwiftUI ä¸­ï¼Œä¸€ä¸ª sceneï¼ˆåœºæ™¯ï¼‰å†…åŒ…å«äº† app æ‰€æ˜¾ç¤º UI çš„è§†å›¾å±‚æ¬¡ç»“æ„ã€‚è§†å›¾çš„å±‚æ¬¡ç»“æ„å®šä¹‰äº†è¯¥è§†å›¾ç›¸å¯¹äºå…¶ä»–è§†å›¾çš„å¸ƒå±€ã€‚åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œä¸€ä¸ª WindowGroupï¼ˆçª—å£ç»„ï¼‰sceneï¼ˆåœºæ™¯ï¼‰åŒ…å«äº†è§†å›¾çš„å±‚æ¬¡ç»“æ„ï¼Œå³ ContentViewï¼ˆå†…å®¹è§†å›¾ï¼‰é€šè¿‡ç»„åˆå…¶ä»–è§†å›¾è€Œæˆã€‚",
      "tips": ""
    },
    "The source code begins by importing the SwiftUI framework.": {
      "zh": "æºä»£ç ä»å¯¼å…¥ SwiftUI æ¡†æ¶å¼€å§‹ã€‚",
      "tips": ""
    },
    "Without the import declaration, ContentView wouldnâ€™t have access to symbols in SwiftUI.": {
      "zh": "å¦‚æœæ²¡æœ‰ import å¯¼å…¥å£°æ˜ï¼ŒContentView å°†æ— æ³•è®¿é—® SwiftUI ä¸­çš„ç›¸å…³å†…å®¹ã€‚",
      "tips": ""
    },
    "ContentView is a structure that conforms to the View protocol.": {
      "zh": "ContentView æ˜¯éµå¾ª View protocolï¼ˆåè®®ï¼‰çš„ structï¼ˆç»“æ„ä½“ï¼‰ã€‚",
      "tips": ""
    },
    "A view defines one or more visual elements that appear somewhere on a screen. A view is typically made up of other views, creating a view hierarchy.": {
      "zh": "viewï¼ˆè§†å›¾ï¼‰å®šä¹‰äº†ä¸€ä¸ªæˆ–å¤šä¸ªå‡ºç°åœ¨å±å¹•ä¸Šçš„å¯è§å…ƒç´ ã€‚viewï¼ˆè§†å›¾ï¼‰é€šå¸¸ç”±å…¶ä»–è§†å›¾æ„æˆï¼Œæœ€ç»ˆå½¢æˆ view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰ã€‚",
      "tips": ""
    },
    "Implementing body is a common pattern that you see throughout your SwiftUI code; for instance, when a structure conforms to protocols such as App, Scene, and View.": {
      "zh": "åœ¨ç¼–å†™ SwiftUI ä»£ç çš„è¿‡ç¨‹ä¸­ï¼Œåœ¨ç»“æ„ä½“ä¸­å®ç° bodyï¼ˆä¸»ä½“ï¼‰å±æ€§ï¼Œæ˜¯ä¸€ç§éå¸¸å¸¸è§çš„æ¨¡å¼ï¼›ä¾‹å¦‚ï¼Œå½“ç»“æ„ä½“éµå¾ª Appï¼ŒSceneï¼ŒView åè®®æ—¶ï¼Œå†…éƒ¨éƒ½è¦å®ç° bodyï¼ˆä¸»ä½“ï¼‰å±æ€§ã€‚",
      "tips": ""
    },
    "ContentView contains the SwiftUI-provided view VStack, which arranges subviews vertically.": {
      "zh": "ContentViewï¼ˆå†…å®¹è§†å›¾ï¼‰å†…åŒ…å«äº† SwiftUI æä¾›çš„è§†å›¾ VStackï¼ˆå‚ç›´å †æ ˆï¼‰ï¼Œç”¨äºå‚ç›´æ•´ç†å­è§†å›¾ã€‚",
      "tips": ""
    },
    "A VStack simultaneously renders any on- or off-screen views it contains. Using VStack is ideal when you have a small number of subviews. However, if your app needs to display many more subviews, consider using LazyVStack, which only renders the views when the app needs to display them onscreen.": {
      "zh": "VStackï¼ˆå‚ç›´å †æ ˆï¼‰åŒæ—¶æ¸²æŸ“å®ƒæ‰€åŒ…å«çš„ä»»æ„å±å¹•ä¸Šæˆ–å±å¹•å¤–çš„è§†å›¾ã€‚å½“ä½ æœ‰å°‘é‡çš„å­è§†å›¾æ—¶ï¼Œç”¨ VStackï¼ˆå‚ç›´å †æ ˆï¼‰æ˜¯æœ€åˆé€‚çš„ã€‚ç„¶è€Œï¼Œå¦‚æœä½ çš„ app éœ€è¦å±•ç¤ºæ›´å¤šçš„å­è§†å›¾ï¼Œè€ƒè™‘ä½¿ç”¨ LazyVStackï¼ˆæƒ°æ€§å‚ç›´å †æ ˆï¼‰ï¼Œä»–åªåœ¨ app éœ€è¦åœ¨å±å¹•ä¸Šå±•ç¤ºå¯¹åº”è§†å›¾æ—¶æ‰è¿›è¡Œæ¸²æŸ“ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®è·µ",
      "tips": ""
    },
    "Replace VStack with either HStack or LazyHStack to arrange subviews horizontally.": {
      "zh": "å°† VStackï¼ˆå‚ç›´å †æ ˆï¼‰æ›¿æ¢æˆ HStackï¼ˆæ°´å¹³å †æ ˆï¼‰æˆ– LazyHStackï¼ˆæƒ°æ€§æ°´å¹³å †æ ˆï¼‰ï¼Œä»¥æ°´å¹³æ•´ç†å­è§†å›¾ã€‚",
      "tips": ""
    },
    "The first subview in VStack is Image, a view that displays an image.": {
      "zh": "VStackï¼ˆæ°´å¹³å †æ ˆï¼‰å†…ç¬¬ä¸€ä¸ªå­è§†å›¾æ˜¯ Imageï¼ˆå›¾åƒï¼‰ï¼Œè¿™ä¸ªè§†å›¾ç”¨äºå±•ç¤ºå›¾ç‰‡ã€‚",
      "tips": ""
    },
    "The sample displays an image of a globe using the initializer method init(systemName:). This method creates an image view that displays a system symbol image. Symbol images like globe come from SF Symbols, a library of icons that you can use in your app.": {
      "zh": "ç¤ºä¾‹ä¸­ä½¿ç”¨åˆå§‹åŒ–æ–¹æ³• init(systemName:) å±•ç¤ºäº†ä¸€ä¸ªåœ°çƒå›¾ç‰‡ã€‚è¿™ä¸ªæ–¹æ³•åˆ›å»ºäº†ä¸€ä¸ªå±•ç¤ºç³»ç»Ÿç¬¦å·çš„å›¾åƒè§†å›¾ã€‚å¦‚å±•ç¤ºä¸­çš„åœ°çƒï¼Œä»¥åŠå…¶ä»–çš„ç¬¦å·å›¾ç‰‡éƒ½æ¥è‡ª SF Symbolsï¼Œè¿™æ˜¯ä¸€ä¸ªåŒ…å«ä¸°å¯Œ iconï¼ˆå›¾æ ‡ï¼‰çš„åº“ï¼Œä½ éƒ½å¯ä»¥åœ¨ä½ çš„ app å†…ä½¿ç”¨ã€‚",
      "tips": ""
    },
    "ContentView applies the view modifier imageScale(_:) to the image view to scale the image within the view to the relative size Image.Scale.large.": {
      "zh": "ContentViewï¼ˆå†…å®¹è§†å›¾ï¼‰å†…æ·»åŠ äº† imageScale(_:)ï¼ˆå¯è°ƒæ•´å›¾ç‰‡ç¼©æ”¾ï¼‰è§†å›¾ä¿®é¥°ç¬¦ï¼Œå¯ä»¥å°†å›¾ç‰‡ç¼©æ”¾åˆ°ç›¸å¯¹å¤§å°çš„å°ºå¯¸ï¼Œå¦‚ Image.Scale.largeã€‚",
      "tips": ""
    },
    "Change Image.Scale.large to another scale size. For a list of sizes, see Image.Scale.": {
      "zh": "å°† Image.Scale.large æ›¿æ¢æˆå¦å¤–çš„ç¼©æ”¾å°ºå¯¸ã€‚æœ‰å…³å°ºå¯¸åˆ—è¡¨ï¼Œè¯·å‚é˜… Image.Scaleã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ 7 æ­¥",
      "tips": ""
    },
    "The foregroundColor(_:) modifier adds color to the image view.": {
      "zh": "foregroundColor(_:) ä¿®é¥°ç¬¦èƒ½ç»™ image viewï¼ˆå›¾åƒè§†å›¾ï¼‰æ·»åŠ é¢œè‰²ã€‚",
      "tips": ""
    },
    "In this sample, ContentView applies the semantic color accentColor, which reflects the accent color of the system or app. To learn more about color representations, see Color.": {
      "zh": "åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼ŒContentViewï¼ˆå†…å®¹è§†å›¾ï¼‰åº”ç”¨äº†è¯­ä¹‰é¢œè‰²ï¼šaccentColorï¼ˆå¼ºè°ƒè‰²ï¼‰ï¼Œå®ƒåæ˜ äº†ç³»ç»Ÿæˆ– app çš„å¼ºè°ƒè‰²ã€‚è¦äº†è§£æœ‰å…³é¢œè‰²çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… Color",
      "tips": ""
    },
    "Step 8": {
      "zh": "ç¬¬ 8 æ­¥",
      "tips": ""
    },
    "The second subview of VStack is Text, a view that displays one or more lines of read-only text.": {
      "zh": "VStackï¼ˆå‚ç›´å †æ ˆï¼‰çš„ç¬¬äºŒä¸ªå­è§†å›¾æ˜¯ Textï¼ˆæ–‡æœ¬ï¼‰ï¼Œè¯¥è§†å›¾èƒ½å¤Ÿå±•ç¤ºä¸€è¡Œæˆ–å¤šè¡Œåªè¯»æ–‡æœ¬ã€‚",
      "tips": ""
    },
    "Replace â€œHello, world!â€ with â€œHello, your name!â€ or other text.": {
      "zh": "å°† \"Hello, world\" æ›¿æ¢æˆ \"Hello, your name!\" æˆ–å…¶ä»–æ–‡æœ¬ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "ç¬¬ 9 æ­¥",
      "tips": ""
    },
    "ContentView applies the padding(_:_:) modifier to the VStack, adding a platform-specific default amount of padding â€” that is, space â€” to the edges of the VStack view.": {
      "zh": "ContentViewï¼ˆæ–‡æœ¬è§†å›¾ï¼‰å°† padding(_:_:)ï¼ˆå¡«å……ï¼‰ä¿®é¥°ç¬¦åº”ç”¨äº VStackï¼ˆå‚ç›´å †æ ˆï¼‰ï¼Œä¸º VStack è§†å›¾çš„è¾¹ç¼˜æ·»åŠ äº†é’ˆå¯¹ä¸åŒå¹³å°è¿›è¡Œè°ƒæ•´çš„é»˜è®¤çš„ paddingï¼ˆå¡«å……ï¼‰ï¼Œä¹Ÿå¯ä»¥ç†è§£æˆä¸º VStack è§†å›¾çš„è¾¹ç¼˜æ·»åŠ äº†ç©ºé—´ã€‚",
      "tips": ""
    },
    "You can specify which edges and amount of padding to apply by providing edges and length parameter values; for example, padding([.bottom, .trailing], 20). Change the padding edges and amount or comment the line of code to see what effect it has on the view.": {
      "zh": "ä½ å¯ä»¥é€šè¿‡æä¾› edgesï¼ˆè¾¹ç¼˜ï¼‰å’Œ lengthï¼ˆé•¿åº¦ï¼‰æ¥æŒ‡å®šè¦åº”ç”¨åˆ°çš„ç‰¹å®šè¾¹ç¼˜å’Œå…¶ç‰¹å®šçš„å¡«å……é‡ï¼›ä¾‹å¦‚ï¼Œpadding([.bottom, .trailing], 20)ã€‚å°è¯•æ›´æ”¹è¾¹ç¼˜å’Œé•¿åº¦æˆ–æ³¨é‡Šæ‰ä»£ç ï¼Œçœ‹çœ‹å®ƒå¯¹è§†å›¾çš„å½±å“ã€‚",
      "tips": ""
    },
    "Step 10": {
      "zh": "ç¬¬ 10 æ­¥",
      "tips": ""
    },
    "When you run the sample app, it displays the scene that contains the view hierarchy described in ContentView.": {
      "zh": "å½“ä½ è¿è¡Œç¤ºä¾‹ Appï¼Œä»–ä¼šå±•ç¤º sceneï¼ˆåœºæ™¯ï¼‰ï¼Œè¯¥åœºæ™¯åŒ…å« ContentView é‡Œæ‰€æè¿°çš„ view hierachyï¼ˆè§†å›¾æ ‘ï¼‰",
      "tips": ""
    },
    "Build and run the sample using Xcode. Then play around with code by following the suggested experiments mentioned in the previous steps.": {
      "zh": "ä½¿ç”¨ Xcode ç¼–è¯‘å¹¶è¿è¡Œç¤ºä¾‹ã€‚ç„¶åæŒ‰ç…§å‰é¢æ­¥éª¤ä¸­æåˆ°çš„å»ºè®®çš„å®è·µå†…å®¹ï¼Œå°è¯•ç¼–å†™ä¸€ä¸‹ä»£ç ã€‚",
      "tips": ""
    },
    "Specifying the view hierarchy of an app using a scene": {
      "zh": "ä½¿ç”¨ sceneï¼ˆåœºæ™¯ï¼‰æŒ‡å®š app çš„ view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰",
      "tips": ""
    },
    "A scene contains the view hierarchy of your app.": {
      "zh": "sceneï¼ˆåœºæ™¯ï¼‰å†…åŒ…å« app çš„ view hierachyï¼ˆè§†å›¾æ ‘ï¼‰ã€‚",
      "tips": ""
    },
    "ContentView implements the computed property body, just like the â€˜MyAppâ€™ structure does in the previous section.": {
      "zh": "ContentViewï¼ˆå†…å®¹è§†å›¾ï¼‰å†…å®ç°äº† computed propertyï¼ˆè®¡ç®—å±æ€§ï¼‰bodyï¼Œå°±åƒå‰é¢ç« èŠ‚é‡Œ MyApp ä¸­çš„ç»“æ„ä½“ä¸€æ ·ã€‚",
      "tips": ""
    },
    "Change the foreground color to another semantic color such as primary or a standard color like teal.": {
      "zh": "å°†å‰æ™¯è‰²æ›´æ”¹ä¸ºå…¶ä»– semantic colorï¼ˆè¯­ä¹‰é¢œè‰²ï¼‰ï¼Œä¾‹å¦‚ primaryï¼ˆåŸºç¡€è‰²ï¼‰æˆ– tealï¼ˆè“ç»¿è‰²ï¼‰",
      "tips": ""
    }
  },
  "swiftui-concepts/layering-content": {
    "Layering content": {
      "zh": "å†…å®¹åˆ†å±‚",
      "tips": ""
    },
    "Define views in an overlay or background to adapt their layout to the primary content.": {
      "zh": "å¯ä»¥åœ¨ overlay æˆ– background ä¸­å®šä¹‰è§†å›¾ï¼Œä»¥ä½¿å®ƒä»¬çš„å¸ƒå±€é€‚åº”ä¸»è¦å†…å®¹ã€‚",
      "tips": ""
    },
    "Designs that layer content often specify that some content stays within the bounds of other content, or maintains a specific margin around that content. You can define these relationships between views with overlay and background modifiers. For example, if your design includes a graphic that provides contrast behind some text, you can define a layout so that the graphic adapts its size and position as the text updates. You can wrap text to fit within the width of another view by defining the text in a background or overlay of that other view.": {
      "zh": "è®¾è®¡ä¸­å†…å®¹åˆ†å±‚çš„æƒ…å†µé€šå¸¸éœ€è¦æŒ‡å®šæŸäº›å†…å®¹ä¿æŒåœ¨å…¶ä»–å†…å®¹çš„è¾¹ç•Œå†…ï¼Œæˆ–è€…åœ¨å…¶å‘¨å›´ä¿æŒä¸€ä¸ªç‰¹å®šçš„è¾¹è·ã€‚ä½ å¯ä»¥ä½¿ç”¨ overlay å’Œ background ä¿®é¥°ç¬¦å®šä¹‰è§†å›¾ä¹‹é—´çš„è¿™äº›å…³ç³»ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœä½ çš„è®¾è®¡ä¸­åŒ…å«ä¸€ä¸ªç”¨æ¥åœ¨æŸäº›æ–‡æœ¬åé¢æä¾›å¯¹æ¯”åº¦çš„å›¾å½¢ï¼Œé‚£ä¹ˆå¯ä»¥å®šä¹‰ä¸€ä¸ªå¸ƒå±€ï¼Œä½¿å¾—è¯¥å›¾å½¢éšç€æ–‡æœ¬çš„æ›´æ–°è€Œè‡ªé€‚åº”å…¶å¤§å°å’Œä½ç½®ã€‚ ä½ å¯ä»¥é€šè¿‡å°†æ–‡æœ¬å®šä¹‰åœ¨å¦ä¸€ä¸ªè§†å›¾çš„ background æˆ– overlay ä¸­ï¼Œä½¿å…¶é€‚åº”è¯¥è§†å›¾çš„å®½åº¦è¿›è¡Œæ¢è¡Œã€‚",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "è¦å®è·µè¿™æ®µä»£ç çš„è¯ï¼Œè¯·ä¸‹è½½é¡¹ç›®æ–‡ä»¶å¹¶åœ¨ Xcode ä¸­æ‰“å¼€ç¤ºä¾‹ã€‚",
      "tips": ""
    },
    "Define an overlay": {
      "zh": "å®šä¹‰ä¸€ä¸ª overlay",
      "tips": ""
    },
    "When you arrange content on the z-axis, you can use a ZStack or an overlay or background modifier, like overlay(alignment:content:) or background(_:in:fillStyle:), respectively. A ZStack sizes each view based on the available space, without consideration for the other views in the stack. To specify that the size of some content depends on the size of other content, define this secondary content inside one of the overlay or background modifiers.": {
      "zh": "å½“ä½ åœ¨zè½´ä¸Šæ’åˆ—å†…å®¹æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ ZStackã€overlay ä¿®é¥°ç¬¦ï¼ˆä¾‹å¦‚ overlay(alignment:content:)ï¼‰æˆ– background ä¿®é¥°ç¬¦ ï¼ˆä¾‹å¦‚ background(_:in:fillStyle:)ï¼‰ã€‚ å¯¹äºå †æ ˆä¸­çš„æ¯ä¸ªè§†å›¾ï¼ŒZStack æ˜¯æ ¹æ®å¯ç”¨ç©ºé—´è°ƒæ•´å…¶å¤§å°ï¼Œè€Œä¸ä¼šè€ƒè™‘å®ƒä¸å…¶ä»–è§†å›¾çš„å…³ç³»ã€‚ å¦‚æœè¦æŒ‡å®šæŸäº›å†…å®¹çš„å¤§å°æ˜¯è¦å–å†³äºå…¶ä»–å†…å®¹å¤§å°çš„è¯ï¼Œå¯ä»¥å°†è¿™äº›æ¬¡è¦å†…å®¹å®šä¹‰åœ¨ overlay æˆ– background ä¿®é¥°ç¬¦ä¸­ã€‚",
      "tips": ""
    },
    "This example presents a photo with a block of text over the lower portion of the photo. To improve readability of the text without completely obscuring that portion of the photo, thereâ€™s a mostly transparent background behind the text. The text wraps to fit within the width of the photo. The textâ€™s background sizes to fit around the text. The CaptionedPhoto view arranges the image and provides the text to a Caption view in the imageâ€™s overlay(alignment:content:).": {
      "zh": "è¿™ä¸ªä¾‹å­å±•ç¤ºäº†ä¸€å¼ ç…§ç‰‡ï¼Œç…§ç‰‡çš„ä¸‹åŠéƒ¨åˆ†æœ‰ä¸€å—æ–‡æœ¬ã€‚ä¸ºäº†åœ¨æé«˜æ–‡æœ¬å¯è¯»æ€§çš„åŒæ—¶ï¼Œåˆä¸å®Œå…¨é®æŒ¡ä½ç…§ç‰‡çš„è¿™éƒ¨åˆ†å†…å®¹ï¼Œæ–‡æœ¬èƒŒåä¼šæœ‰ä¸€ä¸ªå‡ ä¹é€æ˜çš„èƒŒæ™¯ã€‚ æ–‡æœ¬ä¼šè‡ªåŠ¨æ¢è¡Œä»¥é€‚åº”ç…§ç‰‡çš„å®½åº¦ã€‚æ–‡æœ¬çš„èƒŒæ™¯ä¼šæ ¹æ®å…¶å¤§å°è¿›è¡Œè°ƒæ•´ã€‚CaptionedPhoto è§†å›¾ä¼šæ˜¾ç¤ºç…§ç‰‡ï¼Œå¹¶å°†æ–‡æœ¬ä¼ ç»™ä¸€ä¸ª Caption è§†å›¾ï¼Œå…¶æ˜¯åœ¨å›¾ç‰‡çš„ overlay(alignment:content:) ä¿®é¥°ç¬¦ä¸­å®šä¹‰çš„ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "CaptionedPhoto is a custom View that defines the layout of a photo and another custom Caption view, which defines the layout of the caption text that appears on top of the image.": {
      "zh": "CaptionedPhoto æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰è§†å›¾ï¼Œå®ƒå®šä¹‰äº†ç…§ç‰‡ä»¥åŠå¦ä¸€ä¸ªè‡ªå®šä¹‰ Caption è§†å›¾çš„å¸ƒå±€ï¼Œåè€…åˆ™å®šä¹‰äº†æ˜¾ç¤ºåœ¨å›¾ç‰‡ä¸Šçš„æ ‡é¢˜æ–‡æœ¬çš„å¸ƒå±€ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "This view defines an assetName property to hold the name of the image asset.": {
      "zh": "è¿™ä¸ªè§†å›¾å®šä¹‰äº†ä¸€ä¸ª assetName å±æ€§ï¼Œç”¨äºä¿å­˜å›¾ç‰‡èµ„æºçš„åç§°ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "This view also defines a captionText property to contain the caption text that it eventually passes along to the Caption view.": {
      "zh": "è¿™ä¸ªè§†å›¾è¿˜å®šä¹‰äº†ä¸€ä¸ª captionText å±æ€§ï¼Œç”¨äºä¿å­˜æœ€ç»ˆä¼ é€’ç»™ Caption è§†å›¾çš„æ ‡é¢˜æ–‡æœ¬ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "This Image view initializer retrieves a photo or graphic by name from your app and displays it.": {
      "zh": "è¿™ä¸ª Image è§†å›¾çš„åˆå§‹åŒ–ç¨‹åºï¼Œä»ä½  app ä¸­é€šè¿‡ä¼ å…¥çš„åå­—æ£€ç´¢ç…§ç‰‡æˆ–å›¾å½¢ï¼Œå¹¶æ˜¾ç¤ºå®ƒã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "By default, an Image displays an image at its original size. The resizable(capInsets:resizingMode:) and scaledToFit() modifiers adjust this Image to fit within the available space.": {
      "zh": "é»˜è®¤æƒ…å†µä¸‹ï¼ŒImage è§†å›¾ä¼šä»¥å…¶åŸå§‹å°ºå¯¸æ˜¾ç¤ºå›¾ç‰‡ã€‚é€šè¿‡ä½¿ç”¨ resizable(capInsets:resizingMode:) å’Œ scaledToFit() ä¿®é¥°ç¬¦ï¼Œå¯ä»¥è°ƒæ•´ Image ä»¥é€‚åº”å¯ç”¨ç©ºé—´ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "The Caption custom view defines the text and its background.": {
      "zh": "Caption è‡ªå®šä¹‰è§†å›¾å®šä¹‰äº†æ–‡æœ¬åŠå…¶èƒŒæ™¯ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ä¸ƒæ­¥",
      "tips": ""
    },
    "Defining the caption inside overlay(alignment:content:) declares that the caption belongs in front of the image. The size of the primary view limits the size of the overlay(alignment:content:) that modifies the primary view.": {
      "zh": "åœ¨ overlay(alignment:content:) ä¸­å®šä¹‰çš„ Caption è§†å›¾ä½äºå›¾ç‰‡çš„ä¸Šæ–¹ã€‚çˆ¶è§†å›¾çš„å¤§å°é™åˆ¶äº†ä½œç”¨äºçˆ¶è§†å›¾çš„ overlay(alignment:content:) çš„å¤§å°ã€‚",
      "tips": ""
    },
    "Specifying an alignment of bottom pushes the overlay(alignment:content:) modifierâ€™s contents to the bottom center of the primary view.": {
      "zh": "é€šè¿‡æŒ‡å®š alignment å‚æ•°ä¸º bottomï¼Œå¯ä»¥å°† overlay(alignment:content:) ä¿®é¥°ç¬¦çš„å†…å®¹æ”¾åˆ°çˆ¶è§†å›¾çš„åº•éƒ¨ä¸­å¿ƒä½ç½®ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨é‡Š",
      "tips": ""
    },
    "An overlay can be smaller than the view it modifies.": {
      "zh": "ä¸€ä¸ª overlay å¯ä»¥æ¯”å®ƒæ‰€ä¿®æ”¹çš„è§†å›¾å°ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "ç¬¬å…«æ­¥",
      "tips": ""
    },
    "Clipping the view to a RoundedRectangle rounds the corners of the image without changing its size or position.": {
      "zh": "å°†è§†å›¾å‰ªåˆ‡ä¸ºä¸€ä¸ª RoundedRectangleï¼Œå¯ä»¥åœ¨ä¸æ”¹å˜å…¶å¤§å°æˆ–ä½ç½®çš„æƒ…å†µä¸‹ï¼Œå°†å›¾ç‰‡çš„å››ä¸ªè§’å˜ä¸ºåœ†è§’ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®è·µ",
      "tips": ""
    },
    "Change the cornerRadius value to a larger number to see its effect on the photoâ€™s corners.": {
      "zh": "å°† cornerRadius çš„å€¼æ›´æ”¹ä¸ºè¾ƒå¤§çš„æ•°å­—ï¼Œä»¥æŸ¥çœ‹å…¶å¯¹ç…§ç‰‡å››ä¸ªè§’çš„å½±å“ã€‚",
      "tips": ""
    },
    "Step 9": {
      "zh": "ç¬¬ä¹æ­¥",
      "tips": ""
    },
    "This padding(_:_:) puts some space between all four edges of the photo and its containing view.": {
      "zh": "padding(::) ä¿®é¥°ç¬¦åœ¨ç…§ç‰‡çš„å››ä¸ªè¾¹ç¼˜å’Œå…¶çˆ¶è§†å›¾ä¹‹é—´æ·»åŠ äº†ä¸€äº›é—´è·ã€‚",
      "tips": ""
    },
    "Delete the padding(_:_:) modifier to see how that changes the layout. The padding modifier also appears twice in the Caption view. Remove each of those as well to see how their absence affects the layout.": {
      "zh": "åˆ é™¤ padding(::) ä¿®é¥°ç¬¦æ¥çœ‹çœ‹å¸ƒå±€æ˜¯å¦‚ä½•å˜åŒ–çš„ã€‚padding ä¿®é¥°ç¬¦ä¹ŸåŒæ ·åœ¨ Caption è§†å›¾ä¸­å‡ºç°äº†ä¸¤æ¬¡ã€‚åŒæ ·åœ°ï¼Œåˆ é™¤æ¯ä¸ªä¿®é¥°ç¬¦ä»¥æŸ¥çœ‹å…¶æ˜¯å¦‚ä½•å½±å“å¸ƒå±€çš„ã€‚",
      "tips": ""
    },
    "Define a background": {
      "zh": "å®šä¹‰ä¸€ä¸ª background",
      "tips": ""
    },
    "The overlay(alignment:content:) on the CaptionedPhoto contains a Caption view to display the caption text.": {
      "zh": "åœ¨ CaptionedPhoto çš„ overlay(alignment:content:) ä¿®é¥°ç¬¦ä¸­åŒ…å«äº†ä¸€ä¸ªç”¨äºæ˜¾ç¤ºæ ‡é¢˜æ–‡æœ¬çš„ Caption è§†å›¾ã€‚",
      "tips": ""
    },
    "The Caption view uses the background(_:in:fillStyle:) modifier to place a shape behind the text that partially obscures any content behind it â€” in this example, the photo â€” to provide higher contrast for the text.": {
      "zh": "Caption è§†å›¾ä½¿ç”¨ background(_:in:fillStyle:) ä¿®é¥°ç¬¦åœ¨æ–‡æœ¬åé¢æ”¾ç½®äº†ä¸€ä¸ªå½¢çŠ¶æ¥é®æŒ¡å…¶åé¢çš„ä»»ä½•å†…å®¹ï¼ˆåœ¨æœ¬ä¾‹ä¸­æ˜¯ç…§ç‰‡ï¼‰ï¼Œä»¥æé«˜æ–‡æœ¬çš„å¯¹æ¯”åº¦ã€‚",
      "tips": ""
    },
    "This padding(_:_:) modifier adds some space between the words and the edges of the contrasting background underneath. The structure of the code matches the visual appearance of the view â€” the padding is between the text and the background.": {
      "zh": "padding(::) ä¿®é¥°ç¬¦åœ¨æ–‡æœ¬å’ŒèƒŒæ™¯çš„å››æ¡è¾¹ä¹‹é—´æ·»åŠ ä¸€äº›é—´è·ã€‚ä»£ç çš„ç»“æ„ä¸è§†å›¾çš„å¤–è§‚ç›¸åŒ¹é… - é—´è·ä½äºæ–‡æœ¬å’ŒèƒŒæ™¯ä¹‹é—´ã€‚",
      "tips": ""
    },
    "Important": {
      "zh": "é‡è¦æç¤º",
      "tips": ""
    },
    "Choose carefully how to combine padding with an overlay or background modifier. If you pad the primary view before modifying it with the overlay or background, the system uses the size of the padded primary view to calculate the placement of the secondary view. Apply the padding after the overlay or background to put a little space around the view that includes both layers.": {
      "zh": "åœ¨ä½¿ç”¨ padding ä¿®é¥°ç¬¦ ä¸overlay æˆ– background ä¿®é¥°ç¬¦ç»“åˆæ—¶ï¼Œéœ€è¦è°¨æ…é€‰æ‹©ä½¿ç”¨çš„é¡ºåºã€‚ å¦‚æœåœ¨ä½¿ç”¨ overlay æˆ– background ä¿®é¥°ç¬¦ä¹‹å‰å¯¹ä¸»è¦è§†å›¾åº”ç”¨ padding ä¿®é¥°ç¬¦ï¼Œç³»ç»Ÿå°†ä½¿ç”¨å¸¦æœ‰è¾¹è·çš„ä¸»è¦è§†å›¾çš„å¤§å°æ¥è®¡ç®—æ¬¡è¦è§†å›¾çš„ä½ç½®ã€‚ åœ¨ overlay æˆ– background ä¿®é¥°ç¬¦ä¹‹ååº”ç”¨ padding çš„è¯ï¼Œä¼šåœ¨åŒ…å«ä¸¤ä¸ªå›¾å±‚çš„è§†å›¾ä¸­ç•™å‡ºä¸€äº›ç©ºé—´ã€‚",
      "tips": ""
    },
    "A background modifier like background(_:in:fillStyle:) is similar to an overlay modifier, in that its content bases its size on the size of the view it modifies. However, a background modifier puts its contents behind the view it modifies, rather than in front.": {
      "zh": "å’Œ overlay ä¿®é¥°ç¬¦ç±»ä¼¼ï¼Œbackground ä¿®é¥°ç¬¦ï¼ˆå¦‚ background(_:in:fillStyle:)ï¼‰çš„å†…å®¹å¤§å°ä¹ŸåŸºäºæ‰€ä¿®æ”¹çš„è§†å›¾å¤§å°ã€‚ä½†æ˜¯ background ä¿®é¥°ç¬¦æ˜¯å°†å…¶å†…å®¹æ”¾åœ¨æ‰€ä¿®æ”¹çš„è§†å›¾çš„èƒŒåï¼Œè€Œä¸æ˜¯åœ¨å‰é¢ã€‚",
      "tips": ""
    },
    "To provide high contrast whether or not people use Dark Mode, this background(_:in:fillstyle:) modifier uses a custom color with partial opacity.": {
      "zh": "ä¸ºäº†æ— è®ºç”¨æˆ·æ˜¯å¦ä½¿ç”¨é»‘æš—æ¨¡å¼éƒ½æä¾›é«˜å¯¹æ¯”åº¦ï¼Œbackground(_:in:fillStyle:) ä¿®é¥°ç¬¦ä½¿ç”¨äº†ä¸€ä¸ªå…·æœ‰ä¸€å®šä¸é€æ˜åº¦çš„è‡ªå®šä¹‰é¢œè‰²ã€‚",
      "tips": ""
    },
    "The TextContrast color set in this projectâ€™s asset catalog defines separate color values for light and dark appearances.": {
      "zh": "åœ¨é¡¹ç›®çš„èµ„æºç›®å½•ä¸­ï¼ŒTextContrast é¢œè‰²é›†åˆ†åˆ«ä¸ºä¸åŒçš„å¤–è§‚ï¼ˆæ˜äº®å’Œæš—é»‘ï¼‰å®šä¹‰äº†é¢œè‰²å€¼ã€‚",
      "tips": ""
    },
    "RoundedRectangle, as a Shape, accepts whatever size its containing view proposes.": {
      "zh": "ä½œä¸ºä¸€ä¸ªå½¢çŠ¶ï¼ŒRoundedRectangle æ¥å—å…¶çˆ¶è§†å›¾æä¾›çš„ä»»ä½•å°ºå¯¸ã€‚",
      "tips": ""
    },
    "In this case, the background(_:in:fillstyle:) modifier creates that containing view, and any background modifier determines its size from the view it modifies. This results in a RoundedRectangle that is the same size as the padding around the Text view.": {
      "zh": "åœ¨è¿™ç§ä¾‹å­ä¸­ï¼Œbackground(_:in:fillStyle:) ä¿®é¥°ç¬¦åˆ›å»ºäº†åŒ…å« RoundedRectangle çš„è§†å›¾ï¼Œè€Œä»»ä½• background ä¿®é¥°ç¬¦éƒ½ä¼šæ ¹æ®å®ƒæ‰€ä¿®é¥°çš„è§†å›¾ç¡®å®šå…¶å¤§å°ã€‚ è¿™å°±å¯¼è‡´ RoundedRectangle çš„å¤§å°ä¸ Text è§†å›¾å‘¨å›´çš„paddingç›¸åŒã€‚",
      "tips": ""
    },
    "This additional padding(_:_:) around the background adds space between the outside of the Caption view and the container it appears inside; in this case, CaptionedPhoto is the containing view.": {
      "zh": "åœ¨ background å‘¨å›´æ·»åŠ é¢å¤–çš„ padding(::)ï¼Œä¼šåœ¨ Caption è§†å›¾çš„å¤–å›´å’Œå…¶æ‰€åœ¨çš„å®¹å™¨ä¹‹é—´å¢åŠ ç©ºé—´ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼ŒCaptionedPhoto å°±æ˜¯å®¹å™¨è§†å›¾ã€‚",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ä¸€èŠ‚",
      "tips": ""
    },
    "The scaled image is the only view at the top level of this body, so the image determines the size of the CaptionedPhoto view. For more information about resizing images, see Fitting images into available space.": {
      "zh": "å¯¹ body å±æ€§è¿”å›çš„è§†å›¾æ¥è¯´ï¼Œç¼©æ”¾åçš„ Image è§†å›¾ä½¿å…¶é¡¶å±‚ä¸­å”¯ä¸€çš„è§†å›¾ï¼Œå› æ­¤å®ƒä¹Ÿå†³å®šäº† CaptionedPhoto è§†å›¾çš„å¤§å°ã€‚æœ‰å…³è°ƒæ•´å›¾ç‰‡å¤§å°çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ã€ŠFitting images into available spaceã€‹ã€‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬äºŒèŠ‚",
      "tips": ""
    }
  },
  "swiftui-concepts/maintaining-the-adaptable-sizes-of-built-in-views": {
    "Maintaining the adaptable sizes of built-in views": {
      "zh": "ä¿æŒå†…å»ºè§†å›¾çš„å¯è‡ªé€‚åº”å°ºå¯¸",
      "tips": ""
    },
    "Keep your appâ€™s view layouts fluid on any device for each type of content your app displays.": {
      "zh": "å¯¹äºæ¯ç§åœ¨ä½  app ä¸Šæ˜¾ç¤ºçš„å†…å®¹ç±»å‹ï¼Œç¡®ä¿å…¶è§†å›¾å¸ƒå±€å¯ä»¥çµæ´»åœ°é€‚åº”ä»»ä½•è®¾å¤‡ã€‚",
      "tips": ""
    },
    "The views you define with SwiftUI either directly contain views that SwiftUI provides, or use other custom views that contain these built-in views. SwiftUI views determine their own size, and understanding how to modify the size of built-in views while preserving their adaptability is the best way to create a fluid layout without complicating your code.": {
      "zh": "ä½ åœ¨ SwiftUI ä¸­å®šä¹‰çš„è§†å›¾è¦ä¹ˆç›´æ¥ä½¿ç”¨ SwiftUI å†…ç½®çš„è§†å›¾ï¼Œè¦ä¹ˆä½¿ç”¨é‚£äº›åŒ…å«è¿™äº›å†…ç½®è§†å›¾çš„å…¶ä»–è‡ªå®šä¹‰è§†å›¾ã€‚ è€Œåˆ›å»ºçµæ´»å¸ƒå±€ï¼Œå¹¶ä¸”ä¸ä¼šä½¿ä»£ç å¤æ‚åŒ–çš„æœ€ä½³æ–¹å¼ï¼Œå°±æ˜¯è®© SwiftUI çš„è§†å›¾è‡ªå·±å†³å®šå…¶è‡ªèº«çš„å¤§å°ï¼Œä»¥åŠéœ€è¦ç†è§£åœ¨ä¿æŒå…¶å¯è‡ªé€‚åº”çš„åŒæ—¶å¦‚ä½•ä¿®æ”¹å†…ç½®è§†å›¾çš„å°ºå¯¸ã€‚",
      "tips": ""
    },
    "Text and symbols": {
      "zh": "æ–‡æœ¬å’Œç¬¦å·",
      "tips": ""
    },
    "When defining the layout for your app, text and symbols play a central role in conveying information to people â€“ in navigation links, button labels, tables, and more. Text and symbols that display information or label other elements need to have enough space to display their contents.": {
      "zh": "åœ¨å®šä¹‰ä½  app çš„å¸ƒå±€æ—¶ï¼Œä¾‹å¦‚åœ¨å¯¼èˆªé“¾æ¥ã€æŒ‰é’®æ ‡ç­¾ã€è¡¨æ ¼ç­‰å‘äººä»¬ä¼ è¾¾ä¿¡æ¯è¿™ä¸€æ–¹é¢ï¼Œæ–‡æœ¬å’Œç¬¦å·èµ·åˆ°äº†æ ¸å¿ƒçš„ä½œç”¨ã€‚å½“æ–‡æœ¬å’Œç¬¦å·ä¸ºäº†æ˜¾ç¤ºä¿¡æ¯æˆ–æ ‡è®°å…¶ä»–å…ƒç´ æ—¶ï¼Œéœ€è¦æœ‰è¶³å¤Ÿçš„ç©ºé—´æ¥æ˜¾ç¤ºå…¶å†…å®¹ã€‚",
      "tips": ""
    },
    "Text": {
      "zh": "æ–‡æœ¬",
      "tips": ""
    },
    "A Text view displays read-only text. Its contents could be a short String, like the title of a play or the heading of a section. A Text view could also display a much longer String, like all of the actorsâ€™ lines for a scene in the play.": {
      "zh": "Text è§†å›¾è¢«ç”¨æ¥æ˜¾ç¤ºåªè¯»çš„æ–‡æœ¬ã€‚å®ƒçš„å†…å®¹å³å¯ä»¥æ˜¯åƒæˆå‰§çš„åå­—æˆ–ç« èŠ‚çš„æ ‡é¢˜ä¸€æ ·çš„çŸ­å­—ç¬¦ä¸²ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥æ˜¾ç¤ºä¸€æ®µéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œæ¯”å¦‚æˆå‰§ä¸­ä¸€åœºæˆé‡Œæ‰€æœ‰æ¼”å‘˜çš„å°è¯ã€‚",
      "tips": ""
    },
    "When you declare a Text view in your layout, give the system semantic information about your text with the Font attribute. The system chooses font faces and sizes so that, for example, a Text with the title font is more prominent than one with body or caption.": {
      "zh": "å½“ä½ åœ¨å¸ƒå±€ä¸­å£°æ˜ä¸€ä¸ª Text è§†å›¾æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ Font å±æ€§æ¥å‘ç³»ç»Ÿæä¾›å…³äºæ–‡æœ¬çš„è¯­ä¹‰ä¿¡æ¯ã€‚ç³»ç»Ÿä¼šæ ¹æ®è¿™ä¸ªå±æ€§é€‰æ‹©å­—ä½“æ ·å¼å’Œå¤§å°ï¼Œä¾‹å¦‚ï¼Œä½¿ç”¨ title å­—ä½“çš„æ–‡æœ¬å°±ä¼šæ¯”ä½¿ç”¨ body æˆ– caption å­—ä½“çš„æ–‡æœ¬æ›´åŠ æ˜¾çœ¼ã€‚",
      "tips": ""
    },
    "A Text view can adjust to some space constraints with line-wrapping or truncation, but it doesnâ€™t change font size to accommodate situations where its ideal size is smaller or larger than the available space.": {
      "zh": "Text è§†å›¾å¯ä»¥é€šè¿‡æ¢è¡Œæˆ–æˆªæ–­æ¥é€‚åº”ä¸€äº›ç©ºé—´ä¸Šçš„é™åˆ¶ï¼Œä½†å®ƒä¸ä¼šæ”¹å˜å­—ä½“å¤§å°ä»¥é€‚åº”å…¶ç†æƒ³å°ºå¯¸ä¸å¯ç”¨ç©ºé—´ä¸åŒ¹é…çš„æƒ…å†µã€‚",
      "tips": ""
    },
    "For more information about localization, see Preparing views for localization. For guidance about supporting Dynamic Type, see Applying custom fonts to text.": {
      "zh": "æƒ³äº†è§£æ›´å¤šå…³äºæœ¬åœ°åŒ–çš„ä¿¡æ¯ï¼Œè¯·å‚è€ƒ \"Preparing views for localization\"ã€‚è¯·å‚è€ƒ \"Applying custom fonts to text\" ç›¸å…³å†…å®¹ï¼Œä»¥è·å–å…³äºæ”¯æŒåŠ¨æ€å­—ä½“çš„æŒ‡å¯¼",
      "tips": ""
    },
    "Symbols": {
      "zh": "ç¬¦å·",
      "tips": ""
    },
    "Symbols, such as the iconography that SF Symbols provides, can denote common app features, like folders, heart shapes for favorites, or a camera icon to access the camera. Effective symbols streamline your appâ€™s UI, and are easily recognizable by the people who use your app. You can customize their colors and sizes using standard view modifiers provided in SwiftUI. Even though you specify a system or custom symbol in an Image, treat SF Symbols more like text. To adjust the size and weight of a symbol, specify a semantic Font, like title, just like you would for a Text view.": {
      "zh": "å°±åƒ SF Symbols æä¾›äº†å¾ˆå¤šå›¾æ ‡ä¸€æ ·ï¼Œç¬¦å·å¯ä»¥ç”¨æ¥è¡¨ç¤ºä¸€äº›å¸¸è§çš„ app åŠŸèƒ½ï¼Œä¾‹å¦‚ï¼šæ–‡ä»¶å¤¹ã€ç”¨æ¥è¡¨ç¤ºæ”¶è—çš„å¿ƒå½¢å½¢çŠ¶ã€æˆ–ç”¨æ¥è®¿é—®ç›¸æœºçš„ç›¸æœºå›¾æ ‡ã€‚ å¯¹äºé‚£äº›ä½¿ç”¨ä½  app çš„äººæ¥è¯´ï¼Œæœ‰æ•ˆçš„å›¾æ ‡ä¸ä½†èƒ½ç®€åŒ–ç•Œé¢ï¼Œè¿˜èƒ½è®©äººè½»æ¾åœ°è¯†åˆ«å‡ºå®ƒã€‚ä½ å¯ä»¥ä½¿ç”¨ SwiftUI å·²ç»æä¾›çš„é‚£äº›è§†å›¾ä¿®é¥°ç¬¦æ¥è‡ªå®šä¹‰å®ƒä»¬çš„é¢œè‰²å’Œå¤§å°ã€‚ å°½ç®¡ä½ æ˜¯æŠŠç³»ç»Ÿï¼ˆä¾‹å¦‚ SF Symbolsï¼‰æˆ–è‡ªå®šä¹‰çš„ç¬¦å·æ”¾åœ¨ä¸€ä¸ª Image è§†å›¾é‡Œï¼Œä½†åœ¨ä½¿ç”¨ä¸Šæ›´åƒæ˜¯æ“ä½œæ–‡æœ¬ã€‚ è¦è°ƒæ•´ç¬¦å·çš„å¤§å°å’Œç²—ç»†ï¼Œå°±å¾—åƒä¹‹å‰ä¸º Text è§†å›¾æ‰€åšçš„é‚£æ ·ï¼Œé€šè¿‡è®¾ç½® Font å±æ€§æ¥è¾¾åˆ°ç›®çš„ï¼Œä¾‹å¦‚è®¾ç½®å…¶ä¸º titleã€‚",
      "tips": ""
    },
    "The following example uses an HStack to create a row of three Image views that display icons from SF Symbols.": {
      "zh": "ä»¥ä¸‹ç¤ºä¾‹ä½¿ç”¨äº† HStack åˆ›å»ºäº†ä¸€è¡ŒåŒ…å«ä¸‰ä¸ª Image è§†å›¾çš„å¸ƒå±€ï¼Œæ¯ä¸ªè§†å›¾æ˜¾ç¤ºä¸€ä¸ªæ¥è‡ª SF Symbols çš„å›¾æ ‡ã€‚",
      "tips": ""
    },
    "Labels": {
      "zh": "æ ‡ç­¾",
      "tips": ""
    },
    "To use both text and a symbol to represent a single element in your app, use a Label. A Label takes care of matching its title and icon sizes and their alignment. The following code defines a Label that combines an SF Symbol of some books, with some text for its title. The Label applies the largeTitle font to both the icon and the title. The titleAndIcon style tells the view to display both its title and icon, overriding any built-in or custom LabelStyle that a containing view might specify.": {
      "zh": "è¦æƒ³åœ¨ app ä¸­æŠŠæ–‡æœ¬å’Œç¬¦å·ç»„åˆè¡¨ç¤ºæˆå•ä¸ªç•Œé¢å…ƒç´ çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Labelã€‚Label è´Ÿè´£å¤„ç†æ ‡é¢˜å’Œå›¾æ ‡çš„å¤§å°ä»¥åŠå®ƒä»¬çš„å¯¹é½æ–¹å¼ã€‚ ä»¥ä¸‹ä»£ç å®šä¹‰äº†ä¸€ä¸ª Labelï¼Œå®ƒç”¨æŸä¸ªåä¸º books çš„ SF Symbol ç¬¦å·ä½œä¸ºå›¾æ ‡ï¼Œä»¥åŠè‹¥å¹²æ–‡å­—ä½œä¸ºæ ‡é¢˜ã€‚è¿™ä¸ª Label å°† largeTitle å­—ä½“åº”ç”¨åˆ°å›¾æ ‡å’Œæ ‡é¢˜ä¸Šã€‚ titleAndIcon æ ·å¼åˆ™å‘Šè¯‰è§†å›¾åŒæ—¶æ˜¾ç¤ºæ ‡é¢˜å’Œå›¾æ ‡ï¼Œå¹¶ä¸”è¦†ç›–æ‰ä»»ä½•å†…ç½®æˆ–çˆ¶è§†å›¾å¯èƒ½æŒ‡å®šçš„è‡ªå®šä¹‰ LabelStyle å±æ€§ã€‚",
      "tips": ""
    },
    "Controls": {
      "zh": "æ§ä»¶",
      "tips": ""
    },
    "Views that people interact with come in discrete sizes, to maintain consistency when several elements of the same type appear together, like in a Settings pane. Controls also need to be large enough for people to accurately click or tap. You can use view modifiers to choose among these sizes. For example, you can use the controlSize(_:) modifier to make a control smaller or larger, or you can use the progressViewStyle(_:) modifier to choose a linear or circular appearance for a progress bar.": {
      "zh": "äººä»¬ä¸ä¹‹äº¤äº’çš„è§†å›¾éƒ½å…·æœ‰å„è‡ªçš„å°ºå¯¸ï¼Œä¾‹å¦‚åœ¨è®¾ç½®é¢æ¿ä¸­ï¼Œå½“åŒä¸€ç±»å‹çš„å¤šä¸ªç•Œé¢å…ƒç´ ä¸€èµ·å‡ºç°æ—¶è¦ä¿æŒå…¶ä¸€è‡´æ€§ã€‚æ§ä»¶åŒæ ·ä¹Ÿéœ€è¦è¶³å¤Ÿå¤§ï¼Œä»¥ä¾¿äººä»¬èƒ½å¤Ÿå‡†ç¡®åœ°ç‚¹å‡»æˆ–è§¦æ‘¸ã€‚ä½ å¯ä»¥ä½¿ç”¨è§†å›¾ä¿®é¥°ç¬¦åœ¨å¤šä¸ªå°ºå¯¸ä¹‹é—´è¿›è¡Œé€‰æ‹©ã€‚ ä¾‹å¦‚ï¼Œå¯ä»¥ä½¿ç”¨c ontrolSize(:) ä¿®é¥°ç¬¦ä½¿æ§ä»¶å˜å°æˆ–å˜å¤§ï¼Œæˆ–å¯ä»¥ä½¿ç”¨ progressViewStyle(:) ä¿®é¥°ç¬¦ä¸ºè¿›åº¦æ¡é€‰æ‹©çº¿æ€§æˆ–åœ†å½¢å¤–è§‚ã€‚",
      "tips": ""
    },
    "The following example shows a Picker and a Button with different ControlSize values.": {
      "zh": "ä»¥ä¸‹ç¤ºä¾‹å±•ç¤ºäº†å…·æœ‰ä¸åŒ ControlSize å€¼çš„ä¸€ä¸ª Picker å’Œä¸€ä¸ª Buttonã€‚",
      "tips": ""
    },
    "There are general-purpose controls like Menu and Link, and specialized views like EditButton and ColorPicker. Use these views to provide familiar UI elements rather than creating custom controls that youâ€™ll need to maintain. To explore more of these built-in views, see Controls and indicators.": {
      "zh": "ç³»ç»Ÿä¸ä½†æä¾›äº†ä¾‹å¦‚ Menu å’Œ Link è¿™æ ·çš„é€šç”¨æ§ä»¶ï¼Œä¹Ÿæœ‰åƒæ˜¯ EditButton å’Œ ColorPicker è¿™æ ·çš„ä¸“ç”¨è§†å›¾ã€‚ä½¿ç”¨è¿™äº›è§†å›¾æ¥æä¾›ä»¤äººç†Ÿæ‚‰çš„ç•Œé¢å…ƒç´ ï¼Œè€Œä¸æ˜¯åˆ›å»ºéœ€è¦ä½ è‡ªå·±ç»´æŠ¤çš„è‡ªå®šä¹‰æ§ä»¶ã€‚è¦äº†è§£æ›´å¤šå…³äºè¿™äº›å†…ç½®è§†å›¾çš„å†…å®¹ï¼Œè¯·å‚é˜… \"Controls and indicators\"",
      "tips": ""
    },
    "Images and shapes": {
      "zh": "å›¾ç‰‡å’Œå½¢çŠ¶",
      "tips": ""
    },
    "Graphical elements, such as images and shapes, can add a level of visual enhancement for your app. These can vary from product images for a shopping app, achievements for a game, or a dynamic background pattern you create by layering and aligning various shapes.": {
      "zh": "åƒæ˜¯å›¾ç‰‡å’Œå½¢çŠ¶è¿™æ ·çš„å›¾å½¢å…ƒç´ ï¼Œå¯ä»¥ä¸ºä½ çš„ app æå‡è§†è§‰æ•ˆæœã€‚è¿™äº›å¯ä»¥æ˜¯æŸä¸ªè´­ç‰© app çš„äº§å“å›¾ç‰‡ã€æ¸¸æˆä¸­çš„æˆå°±ã€æˆ–é€šè¿‡å åŠ å’Œå¯¹é½å„ç§å½¢çŠ¶è€Œåˆ›å»ºçš„åŠ¨æ€èƒŒæ™¯å›¾æ¡ˆã€‚",
      "tips": ""
    },
    "Images": {
      "zh": "å›¾ç‰‡",
      "tips": ""
    },
    "Display photos and other rich graphics in an Image. By default, an Image displays at the assetâ€™s original size. You can add modifiers like resizable(capInsets:resizingMode:) and scaledToFit() or scaledToFill() to scale it to the available space.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ Image æ¥æ˜¾ç¤ºç…§ç‰‡å’Œå…¶ä»–ä¸°å¯Œçš„å›¾å½¢å†…å®¹ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼ŒImage ä¼šæ˜¾ç¤ºèµ„æºçš„åŸå§‹å°ºå¯¸ã€‚ ä½ å¯ä»¥æ·»åŠ åƒæ˜¯ resizable(capInsets:resizingMode:)ã€scaledToFit()æˆ–scaledToFill() è¿™æ ·çš„ä¿®é¥°ç¬¦ï¼Œå°†å…¶ç¼©æ”¾åˆ°é€‚åˆçš„å°ºå¯¸ã€‚",
      "tips": ""
    },
    "If youâ€™re accessing an image asset from a server, use an AsyncImage to handle the download while keeping your app responsive.": {
      "zh": "å¦‚æœä½ è¦è®¿é—®æœåŠ¡å™¨ä¸Šçš„å›¾ç‰‡èµ„æºï¼Œé‚£ä¹ˆä¸ºäº†ä¿æŒ app çš„å“åº”æ€§ï¼Œè¯·ä½¿ç”¨ AsyncImage æ¥å¤„ç†ä¸‹è½½æ“ä½œã€‚",
      "tips": ""
    },
    "For more information about working with images, see Fitting images into available space.": {
      "zh": "æœ‰å…³ä½¿ç”¨å›¾åƒçš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… \"Fitting images into available space\"ã€‚",
      "tips": ""
    },
    "Shapes": {
      "zh": "å½¢çŠ¶",
      "tips": ""
    },
    "SwiftUI provides several common shapes, and modifiers to change their size, color, or other aspects of their appearance. Use a single shape or a composition of multiple shapes to create a background, border, or other visual element. You can define a shapeâ€™s size with a modifier like frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:), or allow it to fill all available space.": {
      "zh": "SwiftUI æä¾›äº†å‡ ç§å¸¸è§çš„å½¢çŠ¶ï¼Œå¹¶æä¾›ä¿®æ”¹å™¨æ¥æ”¹å˜å¤§å°ã€é¢œè‰²æˆ–å¤–è§‚çš„å…¶ä»–æ–¹é¢ã€‚å¯ä»¥ä½¿ç”¨å•ä¸ªå½¢çŠ¶æˆ–ç»„åˆå¤šä¸ªå½¢çŠ¶ï¼Œæ¥åˆ›å»ºèƒŒæ™¯ã€è¾¹æ¡†æˆ–å…¶ä»–è§†è§‰å…ƒç´ ã€‚ ä½ å¯ä»¥ä½¿ç”¨ frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:) ç­‰ä¿®é¥°å™¨æ¥å®šä¹‰å½¢çŠ¶çš„å¤§å°ï¼Œæˆ–å…è®¸å®ƒå¡«å……æ‰€æœ‰å¯ç”¨ç©ºé—´ã€‚",
      "tips": ""
    },
    "The following example shows three different shapes. The foregroundColor(_:) on each shape customizes that shapeâ€™s fill color. The RoundedRectangle includes values for the cornerRadius and style parameters to define the rounded corners. The HStack provides some default spacing between each shape and, to give each shape a square space to fill, the aspectRatio(_:contentMode:) modifier makes the HStack three times as wide as it is tall.": {
      "zh": "ä»¥ä¸‹ç¤ºä¾‹å±•ç¤ºäº†ä¸‰ç§ä¸åŒçš„å½¢çŠ¶ã€‚æ¯ä¸ªå½¢çŠ¶éƒ½ç”¨ foregroundColor(_:) è‡ªå®šä¹‰äº†å¡«å……è‰²ã€‚RoundedRectangle ä¸ºäº†å®šä¹‰åœ†è§’ï¼Œåœ¨åˆå§‹åŒ–æ–¹æ³•ä¸­æŒ‡å®šäº† cornerRadius å’Œ style å‚æ•°ã€‚ HStack ä¸ºæ¯ä¸ªå½¢çŠ¶ä¹‹é—´æä¾›äº†é»˜è®¤çš„é—´è·ï¼Œå¹¶ä¸”ä¸ºäº†æ¯ä¸ªå½¢çŠ¶çš„å¡«å……åŒºåŸŸéƒ½æ˜¯æ­£æ–¹å½¢ï¼Œä½¿ç”¨äº† aspectRatio(:contentMode:) ä¿®é¥°ç¬¦ä½¿å¾—å®½åº¦æ˜¯é«˜åº¦çš„ä¸‰å€ã€‚",
      "tips": ""
    },
    "For an example of the rich possibilities of composing shapes, see Drawing Paths and Shapes.": {
      "zh": "æœ‰ä¸°å¯Œçš„å¯èƒ½æ€§æ¥ç»„åˆå½¢çŠ¶ï¼Œè¦äº†è§£å…¶æœ‰å…³ç¤ºä¾‹çš„è¯ï¼Œè¯·å‚é˜… \"Drawing Paths and Shapes\"ã€‚",
      "tips": ""
    }
  },
  "swiftui-concepts/organizing-and-aligning-content-with-stacks": {
    "Organizing and aligning content with stacks": {
      "zh": "ä½¿ç”¨å„ç§ Stack è§†å›¾æ¥ç»„ç»‡å’Œå¯¹é½å†…å®¹",
      "tips": ""
    },
    "Create dynamic alignments that adapt to data and environment changes using stacks.": {
      "zh": "ä½¿ç”¨ Stack è§†å›¾åˆ›å»ºèƒ½å¤Ÿé€‚åº”æ•°æ®å’Œç¯å¢ƒå˜åŒ–çš„åŠ¨æ€å¯¹é½æ–¹å¼ã€‚",
      "tips": ""
    },
    "When you have information to communicate that draws from a changeable data source that includes text and images, itâ€™s important to align the content in a way that can adapt. This tutorial walks through using stacks to align content in rows and columns. It also uses stacks to create graphic elements that help organize information.": {
      "zh": "å½“ä½ éœ€è¦ä¼ è¾¾ä¿¡æ¯ï¼Œè€Œè¿™ä¸ªä¿¡æ¯æ˜¯ä»ä¸€ä¸ªåŒ…å«æ–‡æœ¬å’Œå›¾ç‰‡çš„å¯å˜æ•°æ®æºä¸­è·å–æ—¶ï¼Œå°†è¿™äº›å†…å®¹ä»¥è‡ªé€‚åº”çš„æ–¹å¼å¯¹é½éå¸¸é‡è¦ã€‚ æœ¬æ•™ç¨‹å°†ä¼šä»‹ç»å¦‚ä½•ä½¿ç”¨ Stack æ¥å°†å†…å®¹æŒ‰è¡Œå’Œåˆ—è¿›è¡Œå¯¹é½ã€‚åŒæ—¶å®ƒè¿˜è¢«ç”¨æ¥åˆ›å»ºå›¾å½¢å…ƒç´ ï¼Œä»¥å¸®åŠ©ç»„ç»‡ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "è¦å®è·µè¿™æ®µä»£ç çš„è¯ï¼Œè¯·ä¸‹è½½é¡¹ç›®æ–‡ä»¶å¹¶åœ¨ Xcode ä¸­æ‰“å¼€ç¤ºä¾‹ã€‚",
      "tips": ""
    },
    "Manage related data with a view model": {
      "zh": "ä½¿ç”¨ä¸€ä¸ª view model ç®¡ç†ç›¸å…³æ•°æ®",
      "tips": ""
    },
    "The first step in defining a view is to identify the data that the view displays. This view layout displays the details of an upcoming event, including the eventâ€™s name, date, and location. It also includes an icon indicating the type of event.": {
      "zh": "å®šä¹‰è§†å›¾çš„ç¬¬ä¸€æ­¥æ˜¯ç¡®å®šè¦æ˜¾ç¤ºå“ªäº›æ•°æ®ã€‚æœ¬ä¾‹å­çš„è§†å›¾å¸ƒå±€æ˜¾ç¤ºäº†å³å°†ä¸¾è¡Œæ´»åŠ¨çš„è¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ´»åŠ¨çš„åç§°ã€æ—¥æœŸå’Œåœ°ç‚¹ã€‚å®ƒè¿˜åŒ…æ‹¬ä¸€ä¸ªæ ‡æ˜æ´»åŠ¨ç±»å‹çš„å›¾æ ‡ã€‚",
      "tips": ""
    },
    "To organize that related data into a view model, this sample defines a custom structure.": {
      "zh": "ä¸ºäº†å°†ç›¸å…³æ•°æ®ç»„ç»‡æˆä¸€ä¸ª view modelï¼Œè¿™ä¸ªç¤ºä¾‹å®šä¹‰äº†ä¸€ä¸ªè‡ªå®šä¹‰ç»“æ„ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "This Event struct defines all the data for the event. The date is a Date value rather than a formatted String so the view can specify the date format. The symbol property is the name of an SF Symbol for the EventTile to display.": {
      "zh": "è¿™ä¸ª Event ç»“æ„å®šä¹‰äº†æ´»åŠ¨æ‰€æœ‰æ‰€éœ€æ•°æ®ã€‚date å±æ€§çš„ç±»å‹æ˜¯ Dateï¼Œè€Œä¸æ˜¯ä¸€ä¸ªè¢«æ ¼å¼åŒ–çš„å­—ç¬¦ä¸²ï¼Œè¿™æ ·è§†å›¾å°±å¯ä»¥è‡ªå·±æŒ‡å®šéœ€è¦æ˜¾ç¤ºçš„æ—¥æœŸæ ¼å¼ã€‚ symbol å±æ€§æ˜¯ä¸€ä¸ª SF Symbol ç¬¦å·çš„åç§°ï¼Œç”¨æ¥åœ¨ EventTile è§†å›¾ä¸­æ˜¾ç¤ºã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "The EventTile gets all the data for a specific instance from the Event structure in the tileâ€™s event property.": {
      "zh": "EventTile å¯ä»¥ä»ç±»å‹æ˜¯ Event çš„ event å±æ€§ä¸­è·å–ä¸€ä¸ªæŒ‡å®šäº‹ä»¶çš„æ‰€æœ‰æ•°æ®ã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "Define a view with nested stacks": {
      "zh": "å®šä¹‰ä¸€ä¸ªå¸¦æœ‰åµŒå¥— Stack çš„è§†å›¾",
      "tips": ""
    },
    "After you define a data model, you can create views to display that data, and organize those views with stacks and alignment.": {
      "zh": "åœ¨å®šä¹‰äº†æ•°æ®æ¨¡å‹ä¹‹åï¼Œå¯ä»¥åˆ›å»ºå„ç§è§†å›¾æ¥æ˜¾ç¤ºè¿™äº›æ•°æ®ï¼Œæ›´å¯ä»¥é…åˆç€ alignment å‚æ•°ä½¿ç”¨å„ç§ Stack æ¥ç»„ç»‡è¿™äº›è§†å›¾ã€‚",
      "tips": ""
    },
    "A VStack arranges the text in a column, and an HStack aligns the icon with the title text.": {
      "zh": "VStack å°†æ–‡æœ¬æŒ‰åˆ—æ’åˆ—ï¼Œè€Œ HStack å°†å›¾æ ‡ä¸æ ‡é¢˜æ–‡æœ¬æ°´å¹³å¯¹é½ã€‚",
      "tips": ""
    },
    "The leading alignment on the VStack overrides the stackâ€™s default center alignment.": {
      "zh": "VStack çš„é»˜è®¤å¯¹é½æ–¹å¼æ˜¯ centerï¼Œè¿™é‡Œç”¨ leading è¦†ç›–äº†å®ƒã€‚",
      "tips": ""
    },
    "The Text initializer init(_:format:) formats a date.": {
      "zh": "Text çš„åˆå§‹åŒ–æ–¹æ³• init(_:format:) å¯ä»¥æ ¼å¼åŒ–ä¸€ä¸ªæ—¥æœŸã€‚",
      "tips": ""
    },
    "This initializer automatically accounts for environment-specific conditions, like the current calendar and locale.": {
      "zh": "è¯¥åˆå§‹åŒ–æ–¹æ³•ä¼šè‡ªåŠ¨å¤„ç†ç‰¹å®šçš„ç¯å¢ƒæ¡ä»¶ï¼Œä¾‹å¦‚å½“å‰çš„æ—¥å†å’Œè¯­è¨€ç¯å¢ƒã€‚",
      "tips": ""
    },
    "The title font makes the title text and the gift image more prominent than any content in the default body font.": {
      "zh": "title å­—ä½“ä½¿å¾—æ ‡é¢˜æ–‡æœ¬å’Œç¤¼ç‰©å›¾ç‰‡æ¯”ä½¿ç”¨é»˜è®¤ body å­—ä½“çš„å…¶ä»–å†…å®¹è¦æ›´åŠ æ˜¾çœ¼ã€‚",
      "tips": ""
    },
    "The precise font size and weight depend on the environment, including the userâ€™s current Dynamic Type settings.": {
      "zh": "è€Œå­—ä½“ç¡®åˆ‡çš„å¤§å°å’Œå­—é‡åˆ™å–å†³äºå…·ä½“çš„ç¯å¢ƒï¼ŒåŒ…æ‹¬ç”¨æˆ·å½“å‰åŠ¨æ€ç±»å‹çš„è®¾ç½®ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®è·µ",
      "tips": ""
    },
    "Customize this symbol with the techniques in Configuring and displaying symbol images in your UI.": {
      "zh": "ä½¿ç”¨ã€ŠConfiguring and displaying symbol images in your UIã€‹ä¸­ä»‹ç»çš„æŠ€å·§æ¥è‡ªå®šä¹‰æ­¤ç¬¦å·ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "The firstTextBaseline alignment in the HStack aligns the gift image with the title text.": {
      "zh": "åœ¨ HStack ä¸­ï¼Œä½¿ç”¨ firstTextBaseline å¯¹é½æ–¹å¼å¯ä»¥å°†ç¤¼ç‰©å›¾ç‰‡ä¸æ ‡é¢˜æ–‡æœ¬å¯¹é½ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨é‡Š",
      "tips": ""
    },
    "If youâ€™re arranging text and a symbol that only need to align with each other, itâ€™s better to use a Label. Label aligns its icon to the first baseline of its title by default, and adapts to the context in which it appears.": {
      "zh": "å¦‚æœä½ è¦æ’åˆ—çš„æ–‡æœ¬å’Œç¬¦å·ï¼Œå®ƒä»¬åªéœ€è¦ç›¸äº’å¯¹é½ï¼Œé‚£ä¹ˆæœ€å¥½ä½¿ç”¨ Labelã€‚ Label é»˜è®¤å°†å…¶å›¾æ ‡ä¸æ ‡é¢˜çš„ç¬¬ä¸€åŸºçº¿å¯¹é½ï¼Œå¹¶æ ¹æ®å‡ºç°çš„ä¸Šä¸‹æ–‡è¿›è¡Œé€‚åº”ã€‚",
      "tips": ""
    },
    "Add a background with layered shapes": {
      "zh": "æ·»åŠ ä¸€ä¸ªå…·æœ‰å¤šå±‚å½¢çŠ¶çš„èƒŒæ™¯",
      "tips": ""
    },
    "To indicate that all of this information represents a single event, a background(alignment:content:) modifier contains a ZStack of Shape views.": {
      "zh": "ä¸ºäº†è¡¨æ˜æ‰€æœ‰è¿™äº›ä¿¡æ¯éƒ½ä»£è¡¨åŒä¸€ä¸ªäº‹ä»¶ï¼Œå¯ä»¥ä½¿ç”¨ background(alignment:content:) ä¿®é¥°ç¬¦æ¥æ·»åŠ ä¸€ä¸ªåŒ…å«å¤šä¸ªå½¢çŠ¶è§†å›¾çš„ ZStack ä½œä¸ºèƒŒæ™¯ã€‚",
      "tips": ""
    },
    "This defines a background that adapts to the size of the information the main view displays.": {
      "zh": "è¿™æ ·å®šä¹‰çš„èƒŒæ™¯ä¼šè‡ªé€‚åº”ä¸»è§†å›¾æ˜¾ç¤ºçš„ä¿¡æ¯å¤§å°ã€‚",
      "tips": ""
    },
    "To make the background bigger than the HStack that encloses all the content, this padding(_:_:) modifier adds some space on all four edges of the view.": {
      "zh": "ä¸ºäº†ä½¿èƒŒæ™¯æ¯”åŒ…å«äº†æ‰€æœ‰å†…å®¹çš„ HStack æ›´å¤§ï¼Œè¿™ä¸ª padding(::) ä¿®é¥°ç¬¦çš„ä½œç”¨æ˜¯åœ¨è§†å›¾çš„å››ä¸ªè¾¹ç¼˜å†æ·»åŠ ä¸€äº›ç©ºé—´ã€‚",
      "tips": ""
    },
    "This second use of the same padding(_:_:) modifier on the main content adds space for the stripe at the top of the view, in addition to the space defined by the previous padding(_:_:) modifier.": {
      "zh": "é™¤äº†å‰ä¸€ä¸ª padding(::) ä¿®é¥°ç¬¦æ·»åŠ çš„ç©ºé—´ä¹‹å¤–ï¼Œè¿™é‡Œå¯¹ä¸»å†…å®¹åˆä½¿ç”¨äº†ä¸€æ¬¡ padding(_:_:) ä¿®é¥°ç¬¦ï¼Œè¿™æ¬¡æ˜¯åœ¨é¡¶éƒ¨æ·»åŠ äº†æ˜¾ç¤ºæ¡çº¹æ‰€éœ€è¦çš„ç©ºé—´ã€‚",
      "tips": ""
    },
    "A background(alignment:content:) modifier bases its size on the size of the view it modifies, and puts its contents behind that view.": {
      "zh": "background(alignment:content:) ä¿®é¥°ç¬¦æ‰€äº§ç”Ÿçš„å†…å®¹å¤§å°æ˜¯åŸºäºæ‰€ä¿®æ”¹çš„è§†å›¾å¤§å°ï¼Œå¹¶å°†å…¶å†…å®¹æ”¾ç½®åœ¨è¯¥è§†å›¾çš„åé¢ã€‚",
      "tips": ""
    },
    "This top-aligned ZStack layers the brighter stripe Rectangle over the Rectangle that fills the background of the EventTile.": {
      "zh": "è¿™ä¸ªä»¥é¡¶éƒ¨å¯¹é½çš„ ZStackï¼Œå°†é¢œè‰²è¾ƒäº®çš„æ¡çº¹çŸ©å½¢ï¼Œæ”¾åœ¨äº†é‚£ä¸ªä½œä¸º EventTile èƒŒæ™¯è€Œè¢«å¡«å……çš„çŸ©å½¢ä¸Šé¢ã€‚",
      "tips": ""
    },
    "The stackâ€™s alignment puts the stripe at the top of the EventTile.": {
      "zh": "è¿™ä¸ª stack çš„å¯¹é½æ–¹å¼å°†æ¡çº¹æ”¾ç½®åœ¨äº† EventTile çš„é¡¶éƒ¨ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "This frame(width:height:alignment:) modifier specifies the height of the stripe, leaving its width dependent on its containing view.": {
      "zh": "frame(width:height:alignment:) ä¿®é¥°ç¬¦æŒ‡å®šäº†æ¡çº¹çš„é«˜åº¦ï¼Œå¹¶è®©å…¶å®½åº¦ä¾èµ–äºçˆ¶è§†å›¾ã€‚",
      "tips": ""
    },
    "Specifying a frame on a decorative Shape like this stripe is a common pattern.": {
      "zh": "å¯¹äºåƒæ˜¯è¿™ç§æ¡çº¹ä¸€æ ·çš„è£…é¥°æ€§å½¢çŠ¶ï¼Œåœ¨å…¶ä¸Šè®¾ç½® frame å±æ€§æ˜¯ä¸€ç§å¸¸è§çš„æ¨¡å¼ã€‚",
      "tips": ""
    },
    "Specifying frames on text and controls may interfere with the sizing behavior and usability of those views. To learn best practices for adjusting the size of various views, see Maintaining the adaptable sizes of built-in views.": {
      "zh": "åœ¨æ–‡æœ¬å’Œæ§ä»¶ä¸Šè®¾ç½® frame å±æ€§å¯èƒ½ä¼šå¦¨ç¢è¿™äº›è§†å›¾åœ¨è°ƒæ•´å°ºå¯¸æ—¶çš„è¡Œä¸ºå’Œå¯ç”¨æ€§ã€‚ è¦äº†è§£æœ‰å…³è°ƒæ•´å„ç§è§†å›¾å¤§å°çš„æœ€ä½³å®è·µï¼Œè¯·å‚é˜…ã€ŠMaintaining the adaptable sizes of built-in viewsã€‹ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ä¸ƒæ­¥",
      "tips": ""
    },
    "Clipping the final view with clipShape(_:style:) and the RoundedRectangle shape applies the rounded corners only to the outermost edges, rather than rounding the corners of each view.": {
      "zh": "å¯¹æœ€ç»ˆç”Ÿæˆçš„è§†å›¾ä½¿ç”¨ clipShape(_:style:) ä¿®é¥°ç¬¦ï¼Œå¹¶è®¾ç½® RoundedRectangle å½¢çŠ¶è¿›è¡Œå‰ªè£ï¼Œä¼šè®©åœ†è§’ä»…åº”ç”¨äºæœ€å¤–å±‚ï¼Œè€Œä¸æ˜¯æ¯ä¸ªè§†å›¾éƒ½ä¼šç”Ÿæˆåœ†è§’ã€‚",
      "tips": ""
    },
    "This avoids rounding the bottom corners of the stripe Rectangle.": {
      "zh": "è¿™æ ·çš„è¯ï¼Œæ¡çº¹çŸ©å½¢åº•éƒ¨çš„ä¸¤ä¸ªè§’å°±ä¸ä¼šæ˜¯åœ†è§’äº†ã€‚",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ä¸€èŠ‚",
      "tips": ""
    },
    "Three different parts of the EventTile view need to use the height of the top stripe, so itâ€™s also a property outside of the body.": {
      "zh": "EventTile è§†å›¾çš„ä¸‰ä¸ªä¸åŒéƒ¨åˆ†éƒ½éœ€è¦ä½¿ç”¨åˆ°é¡¶éƒ¨æ¡çº¹çš„é«˜åº¦ï¼Œå› æ­¤ä¹ŸæŠŠè¿™ä¸ªé«˜åº¦å®šä¹‰æˆä¸€ä¸ªå®ä¾‹å±æ€§ã€‚",
      "tips": ""
    },
    "This is the only constant that specifies a dimension in this layout. All the other dimensions of this view depend on the data in the Event and semantic values in modifiers, such as font(_:).": {
      "zh": "è¿™æ˜¯æ­¤å¸ƒå±€ä¸­å”¯ä¸€ä¸€ä¸ªå…³äºå°ºå¯¸çš„å¸¸é‡ã€‚æ­¤è§†å›¾æ‰€æœ‰å…¶ä»–å’Œå°ºå¯¸æœ‰å…³çš„è®¾ç½®éƒ½å–å†³äº Event ä¸­çš„æ•°æ®å’Œä¿®é¥°ç¬¦ä¸­çš„å€¼ï¼Œä¾‹å¦‚font(_: )ã€‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬äºŒèŠ‚",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ä¸‰èŠ‚",
      "tips": ""
    },
    "Applying the teal foregroundColor(_:) to the stack specifies the color for both of the Rectangle views in the stack.": {
      "zh": "é€šè¿‡æŠŠ teal ä¼ é€’ç»™ foregroundColor(_:)ï¼Œä¼šæŠŠè¿™ä¸ªé¢œè‰²ä¸€å¹¶ä½œç”¨äº stack æ‰€åŒ…å«çš„è¿™ä¸¤ä¸ªçŸ©å½¢ä¸Šã€‚",
      "tips": ""
    }
  },
  "swiftui-concepts/scaling-views-to-complement-text": {
    "View layout": {
      "zh": "è§†å›¾å¸ƒå±€",
      "tips": ""
    },
    "Scaling views to complement text": {
      "zh": "å°†è§†å›¾è¿›è¡Œç¼©æ”¾ä»¥è¡¥è¶³æ–‡æœ¬",
      "tips": ""
    },
    "Construct a layout that adapts to font styles, Dynamic Type, and varying string lengths.": {
      "zh": "ä¸ºäº†é€‚é…å­—ä½“æ ·å¼ã€åŠ¨æ€ç±»å‹å’Œä¸åŒé•¿åº¦çš„å­—ç¬¦ä¸²è€Œæ„å»ºä¸€ä¸ªå¸ƒå±€",
      "tips": ""
    },
    "When composing a view that includes text, itâ€™s important to define other elements relative to that text, like a symbol or padding, so the view adapts to the textâ€™s size.": {
      "zh": "å½“æ„å»ºä¸€ä¸ªåŒ…å«æ–‡æœ¬çš„è§†å›¾æ—¶ï¼Œç›¸å¯¹æ–‡æœ¬æœ¬èº«æ¥è¯´ï¼Œæ›´é‡è¦çš„æ˜¯å®šä¹‰å…¶å®ƒåƒæ˜¯ç¬¦å·æˆ–è¾¹è·è¿™æ ·çš„å…ƒç´ ï¼Œä»¥ä¾¿è§†å›¾èƒ½å¤Ÿé€‚é…æ–‡æœ¬çš„å¤§å°ã€‚",
      "tips": ""
    },
    "The symbol and padding can adapt as the text content changes for localizations, Dynamic Type sizes, or to display a different phrase.": {
      "zh": "å½“æ–‡æœ¬å†…å®¹å› ä¸ºæœ¬åœ°åŒ–ã€åŠ¨æ€ç±»å‹å¤§å°æˆ–æ˜¾ç¤ºäº†ä¸€æ®µä¸åŒçŸ­è¯­è€Œå‘ç”Ÿå˜åŒ–æ—¶ï¼Œç¬¦å·å’Œè¾¹è·å¯ä»¥è¿›è¡Œé€‚åº”è°ƒæ•´ã€‚",
      "tips": ""
    },
    "Section 1": {
      "zh": "ç¬¬ä¸€èŠ‚",
      "tips": ""
    },
    "Associate content with the text": {
      "zh": "å°†å†…å®¹ä¸æ–‡æœ¬å…³è”èµ·æ¥",
      "tips": ""
    },
    "This example coordinates a name and a symbol to represent a single item with a Label. It also defines a Capsule in a background(alignment:content:) modifier, to maintain a consistent margin around the Label.": {
      "zh": "ä»¥ä¸‹ç¤ºä¾‹å°†ä¸€ä¸ªæ ‡é¢˜å’Œç¬¦å·åˆå¹¶èµ·æ¥ç”¨ä¸€ä¸ª Label è¡¨ç¤ºæˆå•ä¸ªå¯¹è±¡ã€‚å®ƒè¿˜åœ¨è°ƒç”¨ background(alignment:content:) ä¿®é¥°ç¬¦çš„åœ°æ–¹ä¼ å…¥äº†ä¸€ä¸ª Capsule å½¢çŠ¶ï¼Œï¼Œä»¥ä½¿æ ‡ç­¾å‘¨å›´çš„è¾¹è·ä¿æŒä¸€è‡´ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ä¸€æ­¥",
      "tips": ""
    },
    "To make KeywordBubble reusable, the labelâ€™s text and symbol name are properties of the view. When another view uses a KeywordBubble, that other view specifies the text and symbol to display.": {
      "zh": "ä¸ºä½¿ KeywordBubble å¯é‡ç”¨ï¼ŒæŠŠæ ‡ç­¾çš„æ–‡æœ¬å’Œç¬¦å·åç§°éƒ½å£°æ˜æˆè¯¥è§†å›¾çš„å±æ€§ã€‚å½“å¦ä¸€ä¸ªè§†å›¾è¦ä½¿ç”¨ KeywordBubble æ—¶ï¼Œè¯¥è§†å›¾å¯ä»¥æŒ‡å®šè¦æ˜¾ç¤ºçš„æ–‡æœ¬å’Œç¬¦å·ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬äºŒæ­¥",
      "tips": ""
    },
    "Label is a built-in view that arranges the text and the symbol, the main content of this view. Label adjusts the symbolâ€™s size and aligns the two pieces of content, so you donâ€™t have to manually align the Text with an Image.": {
      "zh": "Label æ˜¯ä¸€ä¸ªç”¨äºæ’åˆ—æ–‡æœ¬å’Œç¬¦å·çš„å†…ç½®è§†å›¾ï¼Œè¿™ä¸¤ä¸ªæ˜¯å…¶ä¸»è¦å†…å®¹ã€‚Label ä¼šè‡ªåŠ¨è°ƒæ•´ç¬¦å·çš„å¤§å°å¹¶å¯¹é½è¿™ä¸¤å—å†…å®¹ï¼Œå› æ­¤ä½ æ— éœ€æ‰‹åŠ¨å°† Text ä¸ä¸€ä¸ª Image å¯¹é½ã€‚",
      "tips": ""
    },
    "The name parameter retrieves a system image to display. To look up the names of available system images, download the SF Symbols app.": {
      "zh": "symbol å‚æ•°ç”¨æ¥è·å–ä¸€ä¸ªè¦æ˜¾ç¤ºçš„ç³»ç»Ÿå›¾ç‰‡ã€‚è¦æŸ¥æ‰¾å¯ç”¨çš„ç³»ç»Ÿå›¾ç‰‡åç§°ï¼Œä½ å¯ä»¥ä¸‹è½½ SF Symbols è¿™ä¸ª appã€‚",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ä¸‰æ­¥",
      "tips": ""
    },
    "A Label applies the same font to both the text and image. An image that displays an SF Symbol uses font information to determine its size and position.": {
      "zh": "Label ä¼šå¯¹æ–‡æœ¬å’Œå›¾ç‰‡åº”ç”¨ç›¸åŒçš„å­—ä½“ã€‚ä¸€ä¸ªæ˜¾ç¤º SF Symbol ç¬¦å·çš„å›¾ç‰‡ä½¿ç”¨å­—ä½“ä¿¡æ¯æ¥ç¡®å®šå…¶å¤§å°å’Œä½ç½®ã€‚",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®è·µ",
      "tips": ""
    },
    "Try some other Font.TextStyle values, like Font.TextStyle.largeTitle or Font.TextStyle.caption to see how the sizes of the word and the leaf symbol change.": {
      "zh": "è®©æˆ‘ä»¬å°è¯•ä¸€äº›å…¶ä»–çš„ Font.TextStyle å€¼ï¼Œå¦‚ Font.TextStyle.largeTitle æˆ– Font.TextStyle.captionï¼Œæ¥çœ‹çœ‹æ ‡é¢˜å’Œå¶å­ç¬¦å·çš„å¤§å°å¦‚ä½•å˜åŒ–ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬å››æ­¥",
      "tips": ""
    },
    "Using the padding(_:_:) modifier without any arguments creates a view that adds a default amount of space on all four edges of the view that it modifies.": {
      "zh": "åœ¨ä¸æä¾›å‚æ•°çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨ padding(_:_:) ä¿®é¥°ç¬¦ä¼šç»™æ‰€åˆ›å»ºè§†å›¾çš„å››ä¸ªè¾¹ç¼˜ä¸Šæ·»åŠ é»˜è®¤çš„é—´è·ç©ºé—´ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬äº”æ­¥",
      "tips": ""
    },
    "The Capsule shape provides a rounded rectangle that expands to fill its container. The fill(_:style:) modifier specifies the color of the capsule, and opacity(_:) gives the capsule a bit of transparency.": {
      "zh": "Capsule å½¢çŠ¶æä¾›äº†ä¸€ä¸ªåœ†è§’çŸ©å½¢ï¼Œå®ƒä¼šæ‰©å±•å¹¶å¡«å……å…¶å®¹å™¨ã€‚fill(_:style:) ä¿®é¥°ç¬¦ç”¨äºæŒ‡å®šå…¶å¡«å……è‰²ï¼Œè€Œ opacity(_:) åˆ™ç»™å®ƒæ·»åŠ äº†ä¸€ç‚¹é€æ˜åº¦ã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬å…­æ­¥",
      "tips": ""
    },
    "To specify that the capsule belongs behind the text and symbol, the code defines the capsule inside a background(alignment:content:) modifier.": {
      "zh": "ä¸ºäº†æŠŠè¿™ä¸ªå½¢çŠ¶æ”¾åˆ°æ–‡æœ¬å’Œç¬¦å·çš„ä¸‹é¢ï¼ŒæŠŠå®šä¹‰å®ƒçš„ä»£ç æ”¾åˆ° background(alignment:content:) ä¿®é¥°ç¬¦çš„ content å‚æ•°ä¸­ã€‚",
      "tips": ""
    },
    "The capsuleâ€™s size includes the padding around the Label because the background modifier is after the padding modifier.": {
      "zh": "ç”±äº background ä¿®é¥°ç¬¦ä½äº padding ä¿®é¥°ç¬¦ä¹‹åï¼Œæ‰€ä»¥èƒ¶å›Šçš„å¤§å°åŒ…å«äº†æ ‡ç­¾å››å‘¨çš„å¡«å……ç©ºé—´ã€‚",
      "tips": ""
    },
    "Section 2": {
      "zh": "ç¬¬äºŒèŠ‚",
      "tips": ""
    },
    "Preview a custom view in Xcode": {
      "zh": "åœ¨ Xcode ä¸­é¢„è§ˆè‡ªå®šä¹‰è§†å›¾",
      "tips": ""
    },
    "Xcode provides a Canvas where you can preview layouts as your code changes. To see a preview of a custom SwiftUI view, implement the PreviewProvider protocol. The Canvas can display several variants of your view so you can see how it adapts to different environments.": {
      "zh": "Xcode æä¾›äº†ä¸€ä¸ªåä¸º Canvas çš„çª—å£ï¼Œå®ƒå¯ä»¥è®©ä½ åœ¨ä»£ç æ›´æ”¹æ—¶é¢„è§ˆå¸ƒå±€ã€‚è¦é¢„è§ˆä¸€ä¸ªè‡ªå®šä¹‰ SwiftUI è§†å›¾çš„è¯ï¼Œéœ€ä¸ºè¿™ä¸ªè§†å›¾å®ç° PreviewProvider åè®®ã€‚ Canvas å¯ä»¥æ˜¾ç¤ºä½ è¿™ä¸ªè§†å›¾çš„å¤šä¸ªå˜ä½“ï¼Œä»¥ä¾¿å¯ä»¥çœ‹åˆ°å®ƒå¦‚ä½•é€‚åº”ä¸åŒçš„ç¯å¢ƒã€‚",
      "tips": ""
    },
    "You can see a live preview of a SwiftUI View in Xcode side by side with the code that defines it.": {
      "zh": "åœ¨ Xcode ä¸­ï¼Œä½ å¯ä»¥åœ¨å®šä¹‰ä¸€ä¸ª SwiftUI è§†å›¾çš„ä»£ç æ—è¾¹ï¼Œå®æ—¶é¢„è§ˆè¿™ä¸ªè§†å›¾ã€‚",
      "tips": ""
    },
    "To preview a custom view, implement the PreviewProvider protocol by defining a static previews property.": {
      "zh": "è¦é¢„è§ˆè‡ªå®šä¹‰è§†å›¾ï¼Œéœ€å®ç° PreviewProvider åè®®ï¼Œå¹¶å®šä¹‰ä¸€ä¸ªåä¸º previews çš„é™æ€å±æ€§ã€‚",
      "tips": ""
    },
    "To verify whether your view works with a range of inputs, configure more than one preview, and define static data to display in each preview.": {
      "zh": "ä¸ºäº†éªŒè¯ä½ çš„è§†å›¾æ˜¯å¦é€‚ç”¨äºå„ç§è¾“å…¥ï¼Œå¯ä»¥é…ç½®å¤šä¸ªè§†å›¾ä»¥ä¾›é¢„è§ˆï¼Œå¹¶ä¸ºæ¯ä¸ªè§†å›¾å®šä¹‰è¦æ˜¾ç¤ºçš„é™æ€æ•°æ®ã€‚",
      "tips": ""
    },
    "The keywords array defines two String values of different lengths. The previews property defines both of these in a VStack to display how the KeywordBubble view adapts to the text length.": {
      "zh": "keywords æ•°ç»„åŒ…å«äº†ä¸¤ä¸ªä¸åŒé•¿åº¦çš„å­—ç¬¦ä¸²ã€‚previews å±æ€§åˆ™ç”¨è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²ç”Ÿæˆäº†ä¸¤ä¸ª KeywordBubble è§†å›¾ï¼Œå¹¶æŠŠå®ƒä»¬æ”¾åˆ°äº†ä¸€ä¸ª VStack ä¸­ï¼Œä»¥å±•ç¤º KeywordBubble è§†å›¾å¦‚ä½•é€‚åº”ä¸åŒé•¿åº¦çš„æ–‡æœ¬ã€‚",
      "tips": ""
    },
    "This line defines the KeywordBubble view, and provides the text and image for it.": {
      "zh": "è¿™è¡Œä»£ç å®šä¹‰äº† KeywordBubble è§†å›¾ï¼Œå¹¶ä¸ºå…¶æä¾›äº†æ–‡æœ¬å’Œå›¾ç‰‡ã€‚",
      "tips": ""
    },
    "Try replacing leaf with the name of another SF Symbol. For more information about customizing the appearance of SF Symbols, see SF Symbols in the Human Interface Guidelines.": {
      "zh": "è¯·å°è¯•ç”¨å¦å¤–ä¸€ä¸ª SF Symbol ç¬¦å·çš„åå­—æ›¿æ¢å½“å‰çš„ leafã€‚è¦äº†è§£æ›´å¤šå…³äºè‡ªå®šä¹‰ SF Symbols å¤–è§‚çš„ä¿¡æ¯ï¼Œè¯·å‚è€ƒäººæœºç•Œé¢æŒ‡å—ä¸­çš„ SF Symbols éƒ¨åˆ†ã€‚",
      "tips": ""
    },
    "To verify how your view looks with the full range of Dynamic Type text sizes, choose Variants > Dynamic Type Variants in the Xcode Canvas view.": {
      "zh": "è¦éªŒè¯ä½ çš„è§†å›¾åœ¨æ‰€æœ‰åŠ¨æ€ç±»å‹æ–‡æœ¬å¤§å°ä¸‹çš„å¤–è§‚ï¼Œè¯·åœ¨ Xcode çš„ Canvas çª—å£ä¸­é€‰æ‹© \"Variants > Dynamic Type Variants\"ã€‚",
      "tips": ""
    },
    "Section 3": {
      "zh": "ç¬¬ä¸‰èŠ‚",
      "tips": ""
    },
    "Adjust dimensions with ScaledMetric": {
      "zh": "ä½¿ç”¨ ScaledMetric è°ƒæ•´å°ºå¯¸",
      "tips": ""
    },
    "The default values for dimensions such as the padding on this view, or the width and height of a frame arenâ€™t always going to work for your layout. In many cases, you can design a small set of values to use across a range of environments. But there are over one hundred combinations of Dynamic Type settings and Font.TextStyle options, so choosing a specific value for each isnâ€™t really practical. When you need to provide a numeric value that adapts to the environmentâ€™s effective font size, use the ScaledMetric property wrapper.": {
      "zh": "å¯¹äºåƒæ˜¯è§†å›¾ä¸Šçš„å¡«å……ã€å®½åº¦å’Œé«˜åº¦ç­‰è¿™æ ·ç»´åº¦çš„é»˜è®¤å€¼ï¼Œå¹¶ä¸æ€»æ˜¯é€‚ç”¨äºä½ çš„å¸ƒå±€ã€‚è®¸å¤šæƒ…å†µä¸‹ï¼Œä½ å¯ä»¥è®¾è®¡ä¸€å°ç»„å€¼ï¼Œè®©å…¶åœ¨å„ç§ç¯å¢ƒä¸­ä½¿ç”¨ã€‚ ä½†æ˜¯ï¼ŒåŠ¨æ€ç±»å‹çš„è®¾ç½®å€¼å’Œ Font.TextStyle çš„é€‰é¡¹ä¹‹é—´æœ‰è¶…è¿‡ä¸€ç™¾ç§ç»„åˆï¼Œå› æ­¤ä¸ºæ¯ä¸ªç»„åˆé€‰æ‹©ç‰¹å®šçš„å€¼å¹¶ä¸å®é™…ã€‚å½“ä½ éœ€è¦æä¾›ä¸€ä¸ªèƒ½æ ¹æ®ç¯å¢ƒçš„å®é™…å­—ä½“å¤§å°è‡ªé€‚åº”çš„æ•°å€¼æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ ScaledMetric å±æ€§åŒ…è£…å™¨ã€‚",
      "tips": ""
    },
    "Look at the KeywordBubbleDefaultPadding preview for the AX 5 text size. With the default padding, the tip of the leaf symbol collides with the edge of the Capsule shape.": {
      "zh": "æŸ¥çœ‹ KeywordBubbleDefaultPadding åœ¨ AX 5 æ–‡æœ¬å¤§å°ä¸‹çš„é¢„è§ˆã€‚å› ä¸ºä½¿ç”¨é»˜è®¤å€¼æ¥å¡«å……å››å‘¨ï¼Œæ‰€ä»¥å¶å­ç¬¦å·çš„å°–å°–å¤´å·²ç»ä¸ Capsule å½¢çŠ¶çš„è¾¹ç¼˜äº§ç”Ÿç¢°æ’ã€‚",
      "tips": ""
    },
    "To keep the content inside the bubble at large text sizes without adding too much padding for small text sizes, define a custom padding metric that scales with the text size.": {
      "zh": "ä¸ºäº†è®©å†…å®¹åœ¨å¤§æ–‡å­—å°ºå¯¸ä¸‹ä¿æŒåœ¨å½¢çŠ¶å†…éƒ¨ï¼Œè€Œåœ¨å°æ–‡å­—å°ºå¯¸ä¸‹åˆä¸å¿…å¢åŠ è¿‡å¤šçš„å¡«å……å€¼ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªéšæ–‡å­—å°ºå¯¸ç¼©æ”¾çš„è‡ªå®šä¹‰å¡«å……å€¼ã€‚",
      "tips": ""
    },
    "This paddingWidth variable provides a value of 14.5 for content in a DynamicTypeSize.large Dynamic Type environment. With the ScaledMetric property wrapper, the value is proportionally larger or smaller, according to the current value of dynamicTypeSize.": {
      "zh": "ä¸ºå†…å®¹åœ¨ DynamicTypeSize.large åŠ¨æ€ç±»å‹ç¯å¢ƒä¸‹ï¼Œå®šä¹‰ä¸€ä¸ªåä¸º paddingWidth çš„å˜é‡å¹¶æŠŠå…¶å€¼è®¾ç½®æˆ 14.5ã€‚ä½¿ç”¨ ScaledMetric å±æ€§åŒ…è£…å™¨ï¼Œè¯¥å€¼å°†æ ¹æ® dynamicTypeSize çš„å½“å‰å€¼æŒ‰æ¯”ä¾‹å˜å¤§æˆ–å˜å°ã€‚",
      "tips": ""
    },
    "For more information about using ScaledMetric to scale dimensions in proportion to text, see Applying custom fonts to text.": {
      "zh": "æœ‰å…³ä½¿ç”¨ ScaledMetric æŒ‰æ¯”ä¾‹ç¼©æ”¾å°ºå¯¸ä»¥é€‚åº”æ–‡æœ¬çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… \"Applying custom fonts to text\"ã€‚",
      "tips": ""
    },
    "The Label uses the Font.TextStyle.title style to define the text size.": {
      "zh": "ä½¿ç”¨ Font.TextStyle.title æ ·å¼æ¥å®šä¹‰æ–‡æœ¬çš„å¤§å°",
      "tips": ""
    },
    "Specifying Font.TextStyle.title for the textStyle parameter indicates that this metric scales with, or is relative to, the title style.": {
      "zh": "è®¾ç½® Font.TextStyle.title ä½œä¸º textStyle å‚æ•°çš„å€¼ï¼Œè¡¨ç¤ºæ­¤åº¦é‡æŒ‰ç…§ title æ ·å¼è¿›è¡Œç¼©æ”¾ï¼Œæˆ–è€…è¯´ä»¥ title æ ·å¼ä¸ºåŸºç¡€è¿›è¡Œè®¡ç®—ã€‚",
      "tips": ""
    },
    "The padding(_:) modifier adds a specific amount of space, in points, around the label on all four edges. Because paddingWidth is a ScaledMetric, padding(_:) adds more space when the Label uses a larger text size.": {
      "zh": "padding(_:) ä¿®é¥°ç¬¦ç”¨æŒ‡å®šå€¼ï¼ˆä»¥ç‚¹ä¸ºå•ä½ï¼‰è®¾ç½®æ ‡ç­¾å››å‘¨çš„å¡«å……ç©ºé—´ã€‚ç”±äº paddingWidth æ˜¯ä¸€ä¸ª ScaledMetricï¼Œå½“æ ‡ç­¾ä½¿ç”¨æ›´å¤§çš„æ–‡æœ¬å¤§å°æ—¶ï¼Œpadding(_:) ä¼šè¢«è®¾ç½®æ›´å¤§çš„å¡«å……å€¼ã€‚",
      "tips": ""
    },
    "With the ScaledMetric variable padding, all the Dynamic Type variants now have padding between the leaf symbol and the edge of the Capsule shape in the background.": {
      "zh": "å› ä¸ºä½¿ç”¨äº† ScaledMetric å˜é‡æ¥è®¾ç½®è¾¹è·ï¼Œæ‰€ä»¥ç°åœ¨åœ¨æ‰€æœ‰çš„åŠ¨æ€ç±»å‹å˜ä½“ä¸­ï¼Œå¶å­ç¬¦å·å’Œå½¢çŠ¶çš„è¾¹ç¼˜ä¹‹é—´æ€»ä¼šæœ‰å¡«å……ç©ºé—´ã€‚",
      "tips": ""
    }
  },
  "swiftui-concepts/specifying-the-view-hierarchy-of-an-app-using-a-scene": {
    "Note": {
      "zh": "æ³¨é‡Š",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "ä¸‹è½½é¡¹ç›®æ–‡ä»¶å¹¶åœ¨ Xcode ä¸­æ‰“å¼€ç¤ºä¾‹ï¼Œä»¥å°è¯•ä»£ç ã€‚",
      "tips": ""
    },
    "Refactor the code to use custom scenes": {
      "zh": "é‡æ„ä»£ç ä»¥ä½¿ç”¨ custom scenesï¼ˆè‡ªå®šä¹‰åœºæ™¯ï¼‰",
      "tips": ""
    },
    "A scene contains the view hierarchy of your app.": {
      "zh": "sceneï¼ˆåœºæ™¯ï¼‰åŒ…å«äº† app çš„ view hierachyï¼ˆè§†å›¾æ ‘ï¼‰ã€‚",
      "tips": ""
    },
    "Letâ€™s look at the view hierarchy the sample defines for macOS.": {
      "zh": "è®©æˆ‘ä»¬çœ‹çœ‹ç¤ºä¾‹ä¸­ä¸º macOS å®šä¹‰çš„ view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰ã€‚",
      "tips": ""
    },
    "The iPhone version of the app displays a scene with a tabbed user interface, while the Mac version displays a scene with split view interface. The Mac app also displays the secondary scene Settings when you select the Preferences item under the app menu.": {
      "zh": "iPhone ç‰ˆæœ¬çš„ app æ˜¾ç¤ºäº†ä¸€ä¸ªå¸¦æœ‰ tabbed user interfaceï¼ˆé€‰é¡¹å¡å¼ç”¨æˆ·ç•Œé¢ï¼‰çš„ sceneï¼ˆåœºæ™¯ï¼‰ï¼Œè€Œ Mac ç‰ˆæœ¬æ˜¾ç¤ºäº†ä¸€ä¸ªå¸¦æœ‰ split view interfaceï¼ˆåˆ†å‰²è§†å›¾ç•Œé¢ï¼‰çš„ sceneï¼ˆåœºæ™¯ï¼‰ã€‚å½“ä½ åœ¨ Mac app èœå•ä¸‹é€‰æ‹© Preferencesï¼ˆåå¥½è®¾ç½®ï¼‰é¡¹æ—¶ï¼Œè¿˜ä¼šæ˜¾ç¤º secondary sceneï¼ˆæ¬¡è¦åœºæ™¯ï¼‰Settingsï¼ˆè®¾ç½®ï¼‰ã€‚",
      "tips": ""
    },
    "Step 5": {
      "zh": "ç¬¬ 5 æ­¥",
      "tips": ""
    },
    "To describe the scene that displays on iOS devices, the sample includes the custom scene MyScene, which is a structure that conforms to the Scene protocol.": {
      "zh": "ä¸ºäº†æè¿°åœ¨ iOS è®¾å¤‡ä¸Šæ˜¾ç¤ºçš„ sceneï¼ˆåœºæ™¯ï¼‰ï¼Œç¤ºä¾‹åŒ…å«äº†ä¸€ä¸ªè‡ªå®šä¹‰ sceneï¼ˆåœºæ™¯ï¼‰ MySceneï¼Œè¿™ä¸ªç»“æ„ä½“éµå¾ªäº† Scene protocolï¼ˆåœºæ™¯åè®®ï¼‰ã€‚",
      "tips": ""
    },
    "To compile the first view hierarchy for iOS, the sample uses a platform conditional compilation block that tells the Swift compiler to compile the code only when the target platform is iOS.": {
      "zh": "ä¸ºäº†åœ¨ iOS ä¸Šç¼–è¯‘ç¬¬ä¸€ä¸ª view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰ï¼Œç¤ºä¾‹å†…ä½¿ç”¨äº† platform conditional compilation blockï¼ˆå¹³å°æ¡ä»¶ç¼–è¯‘å—ï¼‰ï¼Œå®ƒå‘Šè¯‰ Swift ç¼–è¯‘å™¨åªåœ¨ç›®æ ‡å¹³å°ä¸º iOS æ—¶æ‰ç¼–è¯‘è¿™éƒ¨åˆ†ä»£ç ã€‚",
      "tips": ""
    },
    "Unlike the previous hierarchy, the root node of this hierarchy is the custom view, AlternativeContentView.": {
      "zh": "ä¸åƒä¹‹å‰çš„ hierarchyï¼ˆè§†å›¾æ ‘ï¼‰ï¼Œè¿™ä¸ª hierarchyï¼ˆè§†å›¾æ ‘ï¼‰çš„æ ¹èŠ‚ç‚¹æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰è§†å›¾ AlternativeContentViewã€‚",
      "tips": ""
    },
    "Specifying the view hierarchy of an app using a scene": {
      "zh": "ä½¿ç”¨ sceneï¼ˆåœºæ™¯ï¼‰æŒ‡å®š app çš„ view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰",
      "tips": ""
    },
    "However, after refactoring the code, the MyApp structure is easier to read and maintain.": {
      "zh": "ç„¶è€Œï¼Œåœ¨é‡æ„ä»£ç ä¹‹åï¼ŒMyApp ç»“æ„ä½“æ›´æ˜“è¯»ï¼Œæ›´æ˜“ç»´æŠ¤ã€‚",
      "tips": ""
    },
    "Each of these views apply the tabItem(_:) modifier, which tells the TabView the image and text to display in each tab.": {
      "zh": "è¿™äº›è§†å›¾éƒ½åº”ç”¨äº† tabItem(_:)ï¼ˆé€‰é¡¹å¡é¡¹ï¼‰ä¿®é¥°ç¬¦ï¼Œå®ƒå‘Šè¯‰ TabView åœ¨æ¯ä¸ªé€‰é¡¹å¡ä¸­æ˜¾ç¤ºçš„å›¾åƒå’Œæ–‡æœ¬ã€‚",
      "tips": ""
    },
    "The source code in the MyApp structure does the job of defining view hierarchies different versions of the sample app, but the code is lengthy making it difficult to maintain. One improvement that can help make the code more readable and easier to maintain is to use custom scenes. A custom scene is one that you compose from other scenes.": {
      "zh": "MyApp ç»“æ„ä½“å†…çš„ä»£ç èµ·åˆ°äº†å®šä¹‰ä¸åŒç¤ºä¾‹ app ç‰ˆæœ¬çš„ view hierarchiesï¼ˆè§†å›¾æ ‘ï¼‰çš„ä½œç”¨ï¼Œä½†æ˜¯ä»£ç å†—é•¿ï¼Œéš¾ä»¥ç»´æŠ¤ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ custom scenesï¼ˆè‡ªå®šä¹‰åœºæ™¯ï¼‰ä½¿ä»£ç æ›´æ˜“è¯»ï¼Œæ›´æ˜“ç»´æŠ¤ã€‚custom sceneï¼ˆè‡ªå®šä¹‰åœºæ™¯ï¼‰æ˜¯ç”±å…¶ä»–åœºæ™¯ç»„æˆçš„åœºæ™¯ã€‚",
      "tips": ""
    },
    "Keep your appâ€™s view layouts fluid on any device for each type of content your app displays.": {
      "zh": "ä½¿ä½ çš„ app çš„è§†å›¾å¸ƒå±€ï¼Œå†…å®¹ï¼Œåœ¨ä»»ä½•è®¾å¤‡ä¸Šéƒ½èƒ½æµç•…æ˜¾ç¤ºã€‚",
      "tips": ""
    },
    "Step 6": {
      "zh": "ç¬¬ 6 æ­¥",
      "tips": ""
    },
    "The root node of the view hierarchy is TabView, a container view that provides tabs that people can use to switch between different subviews.": {
      "zh": "view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰çš„æ ¹ç»“ç‚¹æ˜¯ TabViewï¼Œå®ƒæ˜¯ä¸€ä¸ªè§†å›¾å®¹å™¨ï¼Œæä¾›äº† tabsï¼ˆé€‰é¡¹å¡ï¼‰ï¼Œç”¨æˆ·å¯ä»¥ä½¿ç”¨å®ƒä»¬åœ¨ä¸åŒçš„å­è§†å›¾ä¹‹é—´åˆ‡æ¢ã€‚",
      "tips": ""
    },
    "Create custom scenes": {
      "zh": "åˆ›å»ºè‡ªå®šä¹‰åœºæ™¯",
      "tips": ""
    },
    "Experiment": {
      "zh": "å®è·µ",
      "tips": ""
    },
    "Hereâ€™s the view hierarchy discussed in the previous section.": {
      "zh": "è¿™æ˜¯ä¸Šä¸€èŠ‚ä¸­è®¨è®ºçš„ view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰ã€‚",
      "tips": ""
    },
    "A structure that conforms to Scene must implement the computed property body, just like structures that conform to the App protocol do.": {
      "zh": "éµå¾ª Scene protocolï¼ˆåœºæ™¯åè®®ï¼‰çš„ç»“æ„ä½“å¿…é¡»å®ç° computed property bodyï¼ˆè®¡ç®—å±æ€§ - ä¸»ä½“ï¼‰ï¼Œå¦‚åŒç¬¦åˆ App protocolï¼ˆåº”ç”¨ç¨‹åºåè®®ï¼‰çš„ç»“æ„ä½“ã€‚",
      "tips": ""
    },
    "Define another view hierarchy": {
      "zh": "å®šä¹‰å¦ä¸€ä¸ª view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰",
      "tips": ""
    },
    "The code for this scene is the same code from the MyApp structure, discussed in the Define another view hierarchy section.": {
      "zh": "åœ¨è¿™ä¸ª sceneï¼ˆåœºæ™¯ï¼‰å†…çš„ä»£ç å’Œåœ¨ Define another view hierarchyï¼ˆå®šä¹‰å¦ä¸€ä¸ªè§†å›¾æ ‘ï¼‰ç« èŠ‚ä¸­è®¨è®ºçš„ MyApp ç»“æ„ä½“å†…çš„ä»£ç æ˜¯ä¸€æ ·çš„ã€‚",
      "tips": ""
    },
    "Hereâ€™s how the scenes appear when you run the app on iPhone and Mac.": {
      "zh": "ä»¥ä¸‹æ˜¯åœ¨ iPhone å’Œ Mac ä¸Šè¿è¡Œ app æ—¶çš„åœºæ™¯ã€‚",
      "tips": ""
    },
    "The computed body property can return one or more primary and secondary scenes.": {
      "zh": "computed body propertyï¼ˆè®¡ç®—çš„ body å±æ€§ï¼‰å¯ä»¥è¿”å›ä¸€ä¸ªæˆ–å¤šä¸ªä¸»è¦åœºæ™¯å’Œæ¬¡è¦åœºæ™¯ã€‚",
      "tips": ""
    },
    "The MyApp structure implements the computed property body, which returns a scene.": {
      "zh": "MyApp structï¼ˆç»“æ„ä½“ï¼‰å®ç°äº† body computed propertyï¼ˆè®¡ç®—å±æ€§ï¼‰ï¼Œè¯¥å±æ€§è¿”å›ä¸€ä¸ª sceneï¼ˆåœºæ™¯ï¼‰ã€‚",
      "tips": ""
    },
    "A conditional compilation block tells the Swift compiler to conditionally compile the code block depending on the value of one or more compilation conditions. For more information about conditional compilation blocks, see Compiler Control Statements": {
      "zh": "conditional compilation blockï¼ˆæ¡ä»¶ç¼–è¯‘å—ï¼‰å‘Šè¯‰ Swift ç¼–è¯‘å™¨æ ¹æ®ä¸€ä¸ªæˆ–å¤šä¸ªç¼–è¯‘æ¡ä»¶æ¥ç¼–è¯‘ä»£ç å—ã€‚æœ‰å…³æ¡ä»¶ç¼–è¯‘å—çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… Compiler Control Statementsï¼ˆç¼–è¯‘å™¨æ§åˆ¶è¯­å¥ï¼‰ã€‚",
      "tips": ""
    },
    "For macOS, the sample includes another custom scene, MyAlternativeScene, which is another structure that conforms to Scene.": {
      "zh": "å¯¹äº macOSï¼Œè¯¥ç¤ºä¾‹åŒ…å«å¦ä¸€ä¸ªè‡ªå®šä¹‰åœºæ™¯ - MyAlternativeSceneï¼Œè¿™æ˜¯å¦ä¸€ä¸ªéµå¾ª Sceneï¼ˆåœºæ™¯åè®®ï¼‰çš„ç»“æ„ä½“ã€‚",
      "tips": ""
    },
    "This approach can make the implementation of computed property body more difficult to maintain.": {
      "zh": "è¿™ç§å®ç°æ–¹æ³•ä½¿è®¡ç®—å±æ€§ body å˜å¾—éš¾ä»¥ç»´æŠ¤ã€‚",
      "tips": ""
    },
    "It too implements the computed body property.": {
      "zh": "ä»–ä¹Ÿå®ç°äº† computed body propertyï¼ˆè®¡ç®—å±æ€§ - ä¸»ä½“ï¼‰ã€‚",
      "tips": ""
    },
    "The sample defines the other view hierarchy in a WindowGroup scene.": {
      "zh": "ç¤ºä¾‹å®šä¹‰äº† WindowGroup sceneï¼ˆçª—å£ç»„åœºæ™¯ï¼‰ä¸­çš„å…¶ä»– view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰ã€‚",
      "tips": ""
    },
    "Step 8": {
      "zh": "ç¬¬ 8 æ­¥",
      "tips": ""
    },
    "Step 3": {
      "zh": "ç¬¬ 3 æ­¥",
      "tips": ""
    },
    "This sample uses a journaling app as an example. To describe the view hierarchy of the appâ€™s user interface, the MyApp structure declares a scene and its contents. Letâ€™s take a look at the structure and its scene.": {
      "zh": "æ­¤ç¤ºä¾‹ä»¥ä¸€ä¸ªæ—¥è®° app ä½œä¸ºä¾‹å­ã€‚ä¸ºäº†æè¿° app ç”¨æˆ·ç•Œé¢çš„ view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰ï¼ŒMyApp structï¼ˆç»“æ„ä½“ï¼‰å£°æ˜äº†ä¸€ä¸ª sceneï¼ˆåœºæ™¯ï¼‰åŠå…¶å†…å®¹ã€‚è®©æˆ‘ä»¬çœ‹çœ‹è¿™ä¸ª struct å’Œå®ƒçš„ sceneã€‚",
      "tips": ""
    },
    "The Settings scene is only available in macOS.": {
      "zh": "è®¾ç½®åœºæ™¯ï¼ˆSettings sceneï¼‰ä»…åœ¨ macOS ä¸­å¯ç”¨ã€‚",
      "tips": ""
    },
    "Step 4": {
      "zh": "ç¬¬ 4 æ­¥",
      "tips": ""
    },
    "The TabView contains two subviews, ContentView and SettingsView.": {
      "zh": "TabViewï¼ˆæ ‡ç­¾é¡µè§†å›¾ï¼‰åŒ…å«äº†ä¸¤ä¸ªå­è§†å›¾ï¼ŒContentViewï¼ˆå†…å®¹è§†å›¾ï¼‰å’Œ SettingsViewï¼ˆè®¾ç½®è§†å›¾ï¼‰ã€‚",
      "tips": ""
    },
    "Maintaining the adaptable sizes of built-in views": {
      "zh": "ç»´æŠ¤è‡ªé€‚åº”å°ºå¯¸çš„è§†å›¾",
      "tips": ""
    },
    "The sample defines the view hierarchy using a WindowGroup scene that contains a TabView. In turn, the TabView contains two subviews: ContentView and SettingsView.": {
      "zh": "ç¤ºä¾‹å†…åˆ©ç”¨ WindowGroup scene å®šä¹‰äº† view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰ï¼Œå…¶ä¸­åŒ…å«äº† TabViewï¼ˆæ ‡ç­¾é¡µè§†å›¾ï¼‰ã€‚TabView å†…ä¹ŸåŒ…å«äº†ä¸¤ä¸ªå­è§†å›¾ï¼ŒContentViewï¼ˆå†…å®¹è§†å›¾ï¼‰ å’Œ SettingsViewï¼ˆè®¾ç½®è§†å›¾ï¼‰ã€‚",
      "tips": ""
    },
    "SwiftUI provides building blocks that help you create the user interface of your app. One of those building blocks is Scene, which contains a view hierarchy that defines the user interface of your app. You can specify your appâ€™s view hierarchy in a scene that SwiftUI provides, or you can create a custom scene. This tutorial walks you through both approaches.": {
      "zh": "SwiftUI æä¾›äº† building blocksï¼ˆæ„å»ºå—ï¼‰æ¥å¸®åŠ©ä½ åˆ›å»º app çš„ç”¨æˆ·ç•Œé¢ã€‚å…¶ä¸­ä¹‹ä¸€å°±æ˜¯ Sceneï¼Œå®ƒåŒ…å«äº†å®šä¹‰ä½  app ç”¨æˆ·ç•Œé¢çš„ view hierachyï¼ˆè§†å›¾æ ‘ï¼‰ã€‚ä½ å¯ä»¥åœ¨ SwiftUI æä¾›çš„ sceneï¼ˆåœºæ™¯ï¼‰æŒ‡å®šä½  app çš„ view hierachyï¼Œä¹Ÿå¯ä»¥åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰çš„ sceneã€‚æœ¬æ•™ç¨‹å°†å¼•å¯¼ä½ å®Œæˆè¿™ä¸¤ç§æ–¹æ³•ã€‚",
      "tips": ""
    },
    "The root node of the previous view hierarchy is the container view, TabView.": {
      "zh": "å‰é¢æåˆ°çš„ view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰çš„æ ¹èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå« TabViewï¼ˆæ ‡ç­¾é¡µè§†å›¾ï¼‰çš„å®¹å™¨è§†å›¾ã€‚",
      "tips": ""
    },
    "Both are custom views. ContentView displays a list of journal entries, and SettingsView displays other views that let people edit the settings for the app, such as the account associated with the journal.": {
      "zh": "ä¸¤ä¸ªè§†å›¾éƒ½æ˜¯è‡ªå®šä¹‰è§†å›¾ã€‚ContentViewï¼ˆå†…å®¹è§†å›¾ï¼‰å±•ç¤ºäº†æ—¥è®° app è®°å½•çš„åˆ—è¡¨ï¼ŒåŒæ—¶ SettingsViewï¼ˆè®¾ç½®è§†å›¾ï¼‰å±•ç¤ºäº†èƒ½å¤Ÿè®©ç”¨æˆ·ç¼–è¾‘ app å†…è®¾ç½®çš„è§†å›¾ï¼Œå¦‚è®¾ç½®ä¸æ—¥è®°å…³è”çš„è´¦æˆ·ã€‚",
      "tips": ""
    },
    "Add a scene to the app": {
      "zh": "åœ¨ app å†…æ·»åŠ  sceneï¼ˆåœºæ™¯ï¼‰ã€‚",
      "tips": ""
    },
    "The sample uses the secondary scene Settings to provide a Settings menu item thatâ€™s available in the app menu, which is a common feature of Mac apps.": {
      "zh": "ç¤ºä¾‹ä¸­ä½¿ç”¨äº† secondary sceneï¼ˆæ¬¡è¦åœºæ™¯ï¼‰çš„ Settingsï¼ˆè®¾ç½®ï¼‰ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªåœ¨ app èœå•ä¸­å¯ç”¨çš„ Settings menuï¼ˆè®¾ç½®èœå•é¡¹ï¼‰ï¼Œè¿™åœ¨ Mac app ä¸­éå¸¸å¸¸è§ã€‚",
      "tips": ""
    },
    "Step 1": {
      "zh": "ç¬¬ 1 æ­¥",
      "tips": ""
    },
    "In this sample, body returns the primary scene WindowGroup, which describes the view hierarchy of the sampleâ€™s main window.": {
      "zh": "åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œbody è¿”å›äº†ä¸»åœºæ™¯ WindowGroupï¼ˆçª—å£ç»„ï¼‰ï¼Œä»–æè¿°äº†ç¤ºä¾‹ä¸»çª—å£çš„ view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰ã€‚",
      "tips": ""
    },
    "The entry point and MyApp structure are responsible for the start up of the app. Each SwiftUI app has one and only one entry point and main app structure.": {
      "zh": "entry pointï¼ˆå…¥å£ç‚¹ï¼‰å’Œ MyApp ç»“æ„ä½“è´Ÿè´£ app çš„å¯åŠ¨ã€‚æ¯ä¸ª SwiftUI app æœ‰ä¸”åªæœ‰ä¸€ä¸ª entry point å’Œä¸€ä¸ª main app structï¼ˆä¸» app ç»“æ„ä½“ï¼‰ã€‚",
      "tips": ""
    },
    "With two separate view hierarchies defined, the sample must specify which one to use based on the target platform.": {
      "zh": "åœ¨å®šä¹‰äº†ä¸¤ä¸ªå•ç‹¬çš„ view hierarchiesï¼ˆè§†å›¾æ ‘ï¼‰åï¼Œç¤ºä¾‹ app å†…çš„ä»£ç å¿…é¡»æ ¹æ®ä¸åŒçš„å¹³å°æ¥æŒ‡å®šæ‰€ä½¿ç”¨çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "Before refactoring the MyApp structure to use the custom scenes, the code is fairly long and complex.": {
      "zh": "åœ¨é‡æ„ MyApp ç»“æ„ä½“ä»¥ä½¿ç”¨è‡ªå®šä¹‰ scenesï¼ˆåœºæ™¯ï¼‰ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹çœ‹ä»£ç ï¼Œå®ƒä¼¼ä¹æœ‰ç‚¹å†—é•¿ä¸”å¤æ‚ã€‚",
      "tips": ""
    },
    "The computed body property includes the secondary scene Settings. This scene is only available in macOS, so itâ€™s placed inside a platform conditional compilation block.": {
      "zh": "computed body propertyï¼ˆè®¡ç®—ä¸»ä½“å±æ€§ï¼‰åŒ…å«äº† secondary sceneï¼ˆæ¬¡è¦åœºæ™¯ï¼‰ Settingsï¼ˆè®¾ç½®ï¼‰ã€‚æ­¤ sceneï¼ˆåœºæ™¯ï¼‰ä»…åœ¨ macOS ä¸­å¯ç”¨ï¼Œæ‰€ä»¥å®ƒè¢«æ”¾ç½®åœ¨äº†ä¸€ä¸ª platform conditional compilation blockï¼ˆå¹³å°æ¡ä»¶ç¼–è¯‘å—ï¼‰å†…ã€‚",
      "tips": ""
    },
    "The sample defines an entry point using the @main attribute and the structure MyApp, which conforms to the App protocol.": {
      "zh": "è¯¥ç¤ºä¾‹ä½¿ç”¨ @main å±æ€§å®šä¹‰äº† app entry pointï¼ˆapp çš„å…¥å£ï¼‰ï¼Œä»¥åŠä¸€ä¸ªéµå¾ª App protocolï¼ˆApp åè®®ï¼‰çš„ç»“æ„ä½“ MyAppã€‚",
      "tips": ""
    },
    "The WindowGroup scene is one of the more commonly used scenes. It provides platform-specific behaviors for your app, such as supporting multiple windows in macOS and iPadOS. For more information about this scene as well as other scenes that SwiftUI provides, see Scenes.": {
      "zh": "WindowGroup sceneï¼ˆçª—å£ç»„åœºæ™¯ï¼‰æ˜¯æœ€å¸¸ç”¨çš„åœºæ™¯ä¹‹ä¸€ã€‚å®ƒä¸ºä½ çš„ app åœ¨ä¸åŒå¹³å°åšäº†é’ˆå¯¹æ€§çš„ä¼˜åŒ–ï¼Œä¾‹å¦‚åœ¨ macOS å’Œ iPadOS ä¸Šæ”¯æŒå¤šçª—å£ã€‚æ›´å¤šæœ‰å…³æ­¤ sceneï¼ˆåœºæ™¯ï¼‰æˆ–å…¶ä»– SwfitUI æä¾›çš„åœºæ™¯ï¼Œè¯·å‚é˜… Scenesï¼ˆåœºæ™¯ï¼‰ã€‚",
      "tips": ""
    },
    "Step 2": {
      "zh": "ç¬¬ 2 æ­¥",
      "tips": ""
    },
    "The Settings scene contains the custom view, SettingView, which displays app settings in a window that the Settings menu item provides.": {
      "zh": "Settings sceneï¼ˆè®¾ç½®åœºæ™¯ï¼‰åŒ…å«äº†ä¸€ä¸ªè‡ªå®šä¹‰è§†å›¾ - SettingsViewï¼ˆè®¾ç½®è§†å›¾ï¼‰ï¼Œå®ƒåœ¨ Settings menu itemï¼ˆè®¾ç½®èœå•é¡¹ï¼‰æ‰€æä¾›çš„çª—å£ä¸­æ˜¾ç¤º app çš„è®¾ç½®ã€‚",
      "tips": ""
    },
    "Change the code so that the sample uses MyScene in macOS and MyAlternativeScene in iOS.": {
      "zh": "å°è¯•æ›´æ”¹ä»£ç ï¼Œåœ¨ macOS ä¸­ä½¿ç”¨ MySceneï¼Œè€Œåœ¨ iOS ä¸­ä½¿ç”¨ MyAlternativeSceneã€‚",
      "tips": ""
    },
    "The implementation of body uses the same code from the MyApp structure, covered in the Add a scene to the app section of this tutorial.": {
      "zh": "bodyï¼ˆä¸»ä½“ï¼‰å†…çš„å®ç°ä½¿ç”¨äº†ä¸ MyApp ç»“æ„ä½“ç›¸åŒçš„ä»£ç ï¼Œåœ¨æœ¬æ•™ç¨‹çš„ Add a scene to the appï¼ˆåœ¨ app ä¸­æ·»åŠ åœºæ™¯ï¼‰ç« èŠ‚ä¸­æœ‰æ‰€ä»‹ç»ã€‚",
      "tips": ""
    },
    "The sample app runs on multiple devices including iPhone and Mac. But the view hierarchy described in the previous section doesnâ€™t look quite right in macOS. So the sample declares another view hierarchy that takes advantage of features specific to the Mac.": {
      "zh": "ç¤ºä¾‹ app å¯ä»¥è¿è¡Œåœ¨å¤šè®¾å¤‡ä¸Šï¼ŒåŒ…æ‹¬ iPhone å’Œ Macã€‚ä½†æ˜¯åœ¨ä¹‹å‰ç« èŠ‚çš„ view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰åœ¨ macOS ä¸Šçœ‹èµ·æ¥å¹¶ä¸æ˜¯éå¸¸çš„å¥½ã€‚å› æ­¤ï¼Œåœ¨ç¤ºä¾‹ä¸­å£°æ˜äº†å¦ä¸€ä¸ª view hierarchyï¼Œä»¥ä¾¿èƒ½å¤Ÿè¾ƒå¥½çš„é€‚é… Macï¼Œå¹¶åˆ©ç”¨å…¶ä¸­çš„ç‰¹æ€§ã€‚",
      "tips": ""
    },
    "With the MyScene and MyAlternativeScene in place, the final step is to refactor the code in the MyApp structure so that it uses the custom scenes.": {
      "zh": "åœ¨å®Œæˆ MyScene å’Œ MyAlternativeScene åï¼Œæœ€åä¸€æ­¥å°±æ˜¯é‡æ„ MyApp ç»“æ„ä½“å†…çš„ä»£ç ï¼Œä»¥ä½¿ç”¨è‡ªå®šä¹‰åœºæ™¯ã€‚",
      "tips": ""
    },
    "Step 7": {
      "zh": "ç¬¬ 7 æ­¥",
      "tips": ""
    },
    "The app uses a separate platform conditional to compile the scenes that the Mac app uses.": {
      "zh": "è¯¥ app ä½¿ç”¨äº†ä¸€ä¸ªå•ç‹¬çš„ platform conditionalï¼ˆå¹³å°æ¡ä»¶ç¼–è¯‘ï¼‰æ¥ç¼–è¯‘ Mac app æ‰€ä½¿ç”¨çš„ scenesï¼ˆåœºæ™¯ï¼‰ã€‚",
      "tips": ""
    },
    "When the sample app runs, it displays the view hierarchy described in the WindowGroup scene, which is a tab interface with two tabs: Journal and Settings.": {
      "zh": "å½“ç¤ºä¾‹ app è¿è¡Œæ—¶ï¼Œä»–å°†æ˜¾ç¤º WindowGroup sceneï¼ˆçª—å£ç»„åœºæ™¯ï¼‰æè¿°çš„ view hierarchyï¼ˆè§†å›¾æ ‘ï¼‰ï¼Œè¿™æ˜¯ä¸€ä¸ªå¸¦æœ‰æ—¥è®°å’Œè®¾ç½®ä¸¤ä¸ªæ ‡ç­¾çš„æ ‡ç­¾é¡µã€‚",
      "tips": ""
    }
  },
  "visionos/adding-3d-content-to-your-app": {
    "Adding 3D content to your app": {
      "zh": "ä¸º App å¢æ·» 3D å†…å®¹",
      "tips": ""
    },
    "Add depth and dimension to your visionOS app and discover how to incorporate your appâ€™s content into a personâ€™s surroundings.": {
      "zh": "åœ¨ä½ çš„ visionOS App ä¸­æ·»åŠ â€œæ·±åº¦â€â€”â€”è¿™ä¸ªç¬¬ä¸‰ä¸ªç»´åº¦ï¼ˆ z è½´ï¼‰ï¼Œä»¥åŠäº†è§£å¦‚ä½•å°†ä½ çš„åº”ç”¨ç¨‹åºèå…¥åˆ°ç”¨æˆ·çš„å‘¨å›´ç¯å¢ƒä¸­ã€‚",
      "tips": "è¯‘è€…æ³¨ï¼š depth ï¼Œè¿™é‡Œç¿»è¯‘æˆâ€œæ·±åº¦â€ï¼Œå³ä¸ºç©ºé—´æ·±åº¦ï¼Œä¹Ÿå«çºµæ·±ã€‚æ˜¯ç‰©ä½“åœ¨ç©ºé—´è·ç¦»ä¸‹ï¼Œäº§ç”Ÿçš„è§†è§‰ç„¦ç‚¹ï¼Œå¹¶å¯¼è‡´æ‰€æœ‰ç‰©ä½“å›´ç»•è¿™ä¸ªç„¦ç‚¹èšæ‹¢çš„èšç„¦æ–¹å¼ã€‚é€šä¿—è®²å°±æ˜¯äººåœ¨ä¸€å‰¯ç”»é¢ä¸­æ„Ÿè§‰åˆ°çš„å¼ºçƒˆçš„è¿œè¿‘å¯¹æ¯”ã€‚æ‰€ä»¥ï¼Œç”¨æˆ·é€šè¿‡çºµæ·±æ¥è¥é€ ç”»é¢çš„ç«‹ä½“æ„Ÿã€‚"
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "A device with a stereoscopic display lets people experience 3D content in a way that feels more real. Content appears to have real depth, and people can view it from different angles, making it seem like itâ€™s there in front of them.": {
      "zh": "ç«‹ä½“æ˜¾ç¤ºå¯ä»¥è®©äººæ„Ÿå—åˆ°æ›´çœŸå®çš„ 3D å†…å®¹ã€‚ 3D å†…å®¹å¢æ·»è®©äººæ„Ÿè§‰æ›´åŠ çœŸå®çš„è§†è§‰æ·±åº¦ï¼Œç”¨æˆ·å¯ä»¥ä»ä¸åŒè§’åº¦è§‚çœ‹ï¼Œä»¿ä½›è¿™äº›å†…å®¹çœŸçš„å°±åœ¨ä»–ä»¬çš„é¢å‰ã€‚",
      "tips": ""
    },
    "When building an app for visionOS, think about ways you might add depth to your appâ€™s interface. The system provides several ways to display 3D content, including in your existing windows, in a volume, and in an immersive space. Choose the options that work best for your app and the content you offer.": {
      "zh": "åœ¨æ„å»º visionOS åº”ç”¨ç¨‹åºï¼Œå°±è¦è€ƒè™‘åœ¨ä½ çš„åº”ç”¨ç¨‹åºä¸­æ·»åŠ æ·±åº¦ï¼ˆ z è½´ï¼‰è¿™ä¸ªçº¬åº¦ã€‚ç³»ç»Ÿæä¾›äº†å¤šç§æ–¹å¼å±•ç¤º 3D å†…å®¹ï¼ŒåŒ…æ‹¬åœ¨å·²æœ‰çš„ 2D çª—å£( window )ï¼Œç«‹ä½“çª—å£( volume )ï¼Œæˆ–è€…è™šæ‹Ÿç©ºé—´( ImmersiveSpace )ã€‚ æ ¹æ®ä½  App ä¸­å†…å®¹é€‰æ‹©æœ€é€‚åˆå±•ç¤ºæ–¹å¼ã€‚",
      "tips": ""
    },
    "Add depth to traditional 2D windows": {
      "zh": "åœ¨äºŒç»´å¹³é¢çª—å£æ·»åŠ æ·±åº¦ï¼ˆ z è½´ï¼‰ç»´åº¦",
      "tips": ""
    },
    "Windows are an important part of your appâ€™s interface. With visionOS, apps automatically get materials with the visionOS look and feel, fully resizable windows with spacing tuned for eyes and hands input, and access to highlighting adjustments for your custom controls.": {
      "zh": "äºŒç»´å¹³é¢çª—å£( window )æ˜¯åº”ç”¨ç¨‹åºç•Œé¢çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚ visionOS ç³»ç»Ÿä¸‹çš„åº”ç”¨è½¯ä»¶ç•Œé¢å¯è‡ªåŠ¨è·å¾— visionOS ç³»ç»Ÿé£æ ¼å…ƒç´ ï¼Œå¹¶ä¸”å¯ç´§ç´§è·Ÿéšç”¨æˆ·æ‰‹å’Œçœ¼çš„ç§»åŠ¨ï¼Œçµæ´»åœ°è°ƒæ•´çª—å£çš„å¤§å°ï¼ŒåŒæ—¶çªå‡ºæ˜¾ç¤ºä½ çš„è‡ªå®šä¹‰æ§ä»¶ã€‚",
      "tips": ""
    },
    "Incorporate depth effects into your custom views as needed, and use 3D layout options to arrange views in your windows.": {
      "zh": "æ ¹æ®éœ€æ±‚åœ¨ä½ çš„è‡ªå®šä¹‰è§†å›¾ä¸­æ·»åŠ  æ·±åº¦æ•ˆåº”ï¼Œå¹¶ä½¿ç”¨ä¸‹é¢è¿™äº› 3D å¸ƒå±€é€‰é¡¹åœ¨ä½ çš„äºŒç»´å¹³é¢çª—å£( window )ä¸­æ‘†è®¾è§†å›¾( view )ã€‚",
      "tips": ""
    },
    "Apply a shadow(color:radius:x:y:) or visualEffect(_:) modifier to the view.": {
      "zh": "ä½¿ç”¨ shadow(color:radius:x:y:) æˆ–è€… visualEffect(_:) ä¿®æ”¹è§†å›¾( view )æ˜¾ç¤ºå¤–è§‚ï¼Œä½¿å…¶æ›´å…·æœ‰æ·±åº¦æ•ˆæœã€‚",
      "tips": ""
    },
    "Lift or highlight the view when someone looks at it using a hoverEffect(_:isEnabled:) modifier.": {
      "zh": "ä½¿ç”¨ hoverEffect(_:isEnabled:) æ–¹æ³•ï¼Œä½¿è§†å›¾( view )èƒ½å¤Ÿä»¥çªå‡ºç§»åŠ¨æˆ–é«˜äº®çš„æ–¹å¼å“åº”ç”¨æˆ·è§†çº¿å…³æ³¨ã€‚",
      "tips": ""
    },
    "Lay out views using a ZStack.": {
      "zh": "ä½¿ç”¨ ZStack åœ¨ Z è½´(æ·±åº¦ç»´åº¦)å¸ƒå±€è§†å›¾( view )ã€‚",
      "tips": ""
    },
    "Animate view-related changes with transform3DEffect(_:).": {
      "zh": "ä½¿ç”¨ transform3DEffect(_:) ï¼Œä¸ºè§†å›¾( view )å˜åŒ–æ·»åŠ  3D åŠ¨ç”»æ•ˆæœã€‚",
      "tips": ""
    },
    "Rotate the view using a rotation3DEffect(_:axis:anchor:anchorZ:perspective:) modifier.": {
      "zh": "ä½¿ç”¨ rotation3DEffect(_:axis:anchor:anchorZ:perspective:) æ¥æ—‹è½¬è§†å›¾ã€‚",
      "tips": ""
    },
    "In addition to giving 2D views more depth, you can also add static 3D models to your 2D windows. The Model3D view loads a USDZ file or other asset type and displays it at its intrinsic size in your window. Use this in places where you already have the model data in your app, or can download it from the network. For example, a shopping app might use this type of view to display a 3D version of a product.": {
      "zh": "å¦å¤–ï¼Œä½ ä¹Ÿå¯ä»¥åœ¨äºŒç»´å¹³é¢çª—å£( window )æ·»åŠ é™æ€ 3D æ¨¡å‹ï¼Œæ¥ä¸º 2D è§†å›¾( view )å¢åŠ è§†è§‰æ·±åº¦ã€‚ Model3D è§†å›¾ç±»å‹å¯ä»¥åŠ è½½ USDZ æ–‡ä»¶ï¼Œæˆ–è€…ä»¥ Asset æ–¹å¼åŠ è½½ï¼Œå¹¶åœ¨çª—å£( window )ä»¥æ–‡ä»¶çš„å›ºæœ‰å°ºå¯¸å±•ç¤ºã€‚é€šè¿‡è¿™ç§æ–¹å¼å±•ç¤º 3D å†…å®¹ï¼Œå‰ææ˜¯ä½ å·²ç»æœ‰äº†å¯å±•ç¤ºçš„æ¨¡å‹æ•°æ®ï¼Œæ¨¡å‹æ•°æ®å¯ä»¥æ˜¯æ”¾åœ¨ App æœ¬åœ°ï¼Œæˆ–è€…é€šè¿‡ç½‘ç»œåŠ è½½ã€‚ä¾‹å¦‚ï¼Œç”µå•†ç±»çš„ App å¯ä»¥ä½¿ç”¨ Model3D ç±»å‹è§†å›¾æ¥å±•ç¤ºå•†å“çš„ 3D æ•ˆæœã€‚",
      "tips": ""
    },
    "Display dynamic 3D scenes using RealityKit": {
      "zh": "ä½¿ç”¨ RealityKit å±•ç¤ºåŠ¨æ€çš„ 3D åœºæ™¯",
      "tips": ""
    },
    "RealityKit is Appleâ€™s technology for building 3D models and scenes that you update dynamically onscreen. In visionOS, use RealityKit and SwiftUI together to seamlessly couple your appâ€™s 2D and 3D content. Load existing USDZ assets or create scenes in Reality Composer Pro that incorporate animation, physics, lighting, sounds, and custom behaviors for your content. To use a Reality Composer Pro project in your app, add the Swift package to your Xcode project and import its module in your Swift file. For for information, see Managing files and folders in your Xcode project.": {
      "zh": "RealityKit æ˜¯è‹¹æœä¸ºæ„å»º 3D æ¨¡å‹ï¼Œä»¥åŠåœ¨å±å¹•ä¸­åŠ¨æ€æ›´æ–°åœºæ™¯ï¼Œè€Œå¼€å‘çš„æ¡†æ¶ã€‚åœ¨ visionOS ç³»ç»Ÿä¸­ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ RealityKit å’Œ`SwiftUI å°† App ä¸­ 2D å’Œ 3D å†…å®¹ä¸æ»‘çš„èåˆèµ·æ¥ã€‚åŠ è½½ç°æœ‰çš„ USDZ Assetsï¼Œæˆ–è€…ä½¿ç”¨ Reality Composer Proï¼Œä¸ºä½ çš„ App å†…å®¹ï¼Œåˆ›å»ºä¸€ä¸ªå¯Œæœ‰åŠ¨ç”»ï¼Œç¬¦åˆç‰©ç†ç‰¹æ€§ï¼Œæœ‰å…‰å½±æ•ˆæœï¼ŒéŸ³æ•ˆï¼Œå’Œè‡ªå®šä¹‰è¡Œä¸ºçš„åœºæ™¯ã€‚ä»¥ Swift Package æ–¹å¼å°† Reality Composer Pro project æ·»åŠ å…³è”åˆ°ä½ çš„ Xcode é¡¹ç›®ä¸­ï¼Œç„¶ååœ¨ä½ çš„ Xcode é¡¹ç›® Swift ä»£ç ä¸­ï¼Œä½¿ç”¨ import ModuleName æ–¹å¼å¼•ç”¨ã€‚(å’Œä½¿ç”¨å’Œè‹¹æœå…¶ä»– Framework ä¸€æ ·ï¼Œç”¨ ModuleName æ¥å¼•ç”¨)ã€‚æ›´å¤šå…³äºæ€æ ·ç®¡ç†é¡¹ç›®æ–‡ä»¶ï¼Œè¯·å‚ç…§ Managing files and folders in your Xcode project ã€‚",
      "tips": "è¯‘è€…æ¨èï¼šæ›´å¤šå…³äº Creating 3D Content with Reality Composer æ–‡æ¡£ å’Œ  Meet Reality Composer Pro è§†é¢‘ã€‚"
    },
    "When youâ€™re ready to display 3D content in your interface, use a RealityView. This SwiftUI view serves as a container for your RealityKit content, and lets you update that content using familiar SwiftUI techniques.": {
      "zh": "ä½¿ç”¨ RealityView åœ¨ç”¨æˆ·ç•Œé¢ä¸­å±•ç¤º 3D å†…å®¹ã€‚è¿™ä¸ª SwiftUI å°±åƒæ˜¯ä¸€ä¸ªç››æ”¾ RealityKit å†…å®¹(å°±æ˜¯ 3D å†…å®¹)çš„å®¹å™¨ï¼Œæ¥ä¸‹æ¥ä½ å¯ä»¥ä½¿ç”¨ç†Ÿæ‚‰çš„ SwiftUI æŠ€æœ¯æ›´æ–° 3D å†…å®¹ã€‚",
      "tips": ""
    },
    "The following example shows a view that uses a RealityView to display a 3D sphere. The code in the viewâ€™s closure creates a RealityKit entity for the sphere, applies a texture to the surface of the sphere, and adds the sphere to the viewâ€™s content.": {
      "zh": "ä¸‹é¢çš„ç¤ºä¾‹ä»£ç å±•ç¤ºäº†åœ¨è§†å›¾( view )ä¸­ä½¿ç”¨ RealityView å±•ç¤ºä¸€ä¸ª 3D çƒä½“ã€‚åœ¨è§†å›¾( view )çš„é—­åŒ…ä¸­åˆ›å»ºä¸€ä¸ªè¡¨é¢å…‰æ»‘çš„ RealityKit çƒä½“ï¼Œç„¶åæŠŠçƒä½“æ·»åŠ åˆ°è§†å›¾( view )ä¸­ã€‚",
      "tips": ""
    },
    "When SwiftUI displays your RealityView, it executes your code once to create the entities and other content. Because creating entities is relatively expensive, the view runs your creation code only once. When you want to update the state of your entities, change the state of your view and use an update closure to apply those changes to your content. The following example uses an update closure to change the size of the sphere when the value in the scale property changes:": {
      "zh": "å½“ SwiftUI è¦æ˜¾ç¤º RealityView æ—¶ï¼Œå®ƒåªä¼šæ‰§è¡Œä¸€æ¬¡é—­åŒ…çš„ä»£ç æ¥åˆ›å»ºå®ä½“å’Œå…¶ä»–å†…å®¹ã€‚å› ä¸º 3D å®ä½“åˆ›å»ºç›¸å½“çš„æ¶ˆè€—æ€§èƒ½ï¼Œæ‰€ä»¥è§†å›¾( view )åªä¼šæ‰§è¡Œä¸€æ¬¡åˆ›å»ºä»£ç ã€‚å½“éœ€è¦æ›´æ–° 3D å®ä½“æ˜¾ç¤ºçŠ¶æ€æ—¶ï¼Œé‚£ä¹ˆå°±æ”¹å˜ç›¸åº”è§†å›¾( view )çš„æ˜¾ç¤ºçŠ¶æ€ï¼Œå¹¶é€šè¿‡æ›´æ–°é—­åŒ…æ¥å®ç°æ˜¾ç¤ºå†…å®¹çš„å˜åŒ–ã€‚ä¸‹é¢çš„ç¤ºä¾‹ä»£ç ï¼Œåœ¨æ›´æ–°é—­åŒ…ä¸­ï¼Œé€šè¿‡æ”¹å˜æ¨¡å‹çš„ transform.scale å±æ€§æ¥æ”¹å˜çƒä½“çš„å¤§å°ï¼š",
      "tips": ""
    },
    "For information about how to create content using RealityKit, see RealityKit.": {
      "zh": "æ›´å¤šå…³äºå¦‚ä½•ä½¿ç”¨ RealityKit åˆ›å»º 3D å†…å®¹çš„ï¼Œè¯·å‚ç…§ RealityKit ã€‚",
      "tips": ""
    },
    "Respond to interactions with RealityKit content": {
      "zh": "å¦‚ä½•å“åº”ä¸ RealityKit å†…å®¹çš„äº¤äº’",
      "tips": ""
    },
    "To handle interactions with the entities of your RealityKit scenes:": {
      "zh": "å¤„ç†ä¸ RealityKit åœºæ™¯é‡Œå®ä½“çš„äº¤äº’ï¼š",
      "tips": ""
    },
    "Attach a gesture recognizer to your RealityView and add the targetedToAnyEntity() modifier to it.": {
      "zh": "åˆ›å»ºæ‰‹åŠ¿è¯†åˆ«å™¨ TapGesture ï¼Œç„¶åé€šè¿‡ targetedToAnyEntity() ä¿®æ”¹æ‰‹åŠ¿è¯†åˆ«å™¨å‚æ•°ï¼Œå¹¶å°†æ‰‹åŠ¿è¯†åˆ«å™¨æ·»åŠ åˆ° RealityView ä¸Šã€‚",
      "tips": ""
    },
    "Attach an InputTargetComponent to the entity or one of its parent entities.": {
      "zh": "åœ¨å®ä½“æˆ–è€…çˆ¶å®ä½“ä¸­æ·»åŠ  InputTargetComponent å®ä¾‹ã€‚",
      "tips": ""
    },
    "Add collision shapes to the RealityKit entities that support interactions.": {
      "zh": "ç»™ RealityKit å®ä½“æ·»åŠ è§¦æ‘¸å½¢çŠ¶ï¼Œè®©å®ƒæ”¯æŒäº¤äº’ã€‚",
      "tips": ""
    },
    "The targetedToAnyEntity() modifier provides a bridge between the gesture recognizer and your RealityKit content. For example, to recognize when someone drags an entity, specify a DragGesture and add the modifier to it. When the specified gesture occurs on an entity, SwiftUI executes the provided closure.": {
      "zh": "targetedToAnyEntity() ä¿®æ”¹å™¨æ˜¯é“¾æ¥æ‰‹åŠ¿è¯†åˆ«å™¨å’Œ RealityKit å†…å®¹çš„æ¡¥æ¢ã€‚ä¾‹å¦‚ï¼Œåˆ›å»º DragGesture æ‰‹åŠ¿ï¼Œé€šè¿‡æ‰‹åŠ¿ä¿®é¥°ç¬¦è®¾ç½®å‚æ•°å’Œå“åº”é—­åŒ…ï¼Œç„¶åæŠŠæ‰‹åŠ¿æ·»åŠ åˆ°å®ä½“ä¸Šï¼Œè¿™æ ·å®ä½“å°±å¯ä»¥å“åº”ç”¨æˆ·çš„æ‹–æ‹½ã€‚å½“å®ä½“æœ‰äº†æ‰‹åŠ¿è¯†åˆ«å™¨ï¼Œ SwiftUI æ‰§è¡Œæä¾›çš„å“åº”é—­åŒ…ä¸­çš„ä»£ç ã€‚",
      "tips": ""
    },
    "The following example adds a tap gesture recognizer to the sphere view from the previous example. The code also adds InputTargetComponent and CollisionComponent components to the shape to allow the interactions to occur. If you omit these components, the view doesnâ€™t detect the interactions with your entity.": {
      "zh": "ä¸‹é¢çš„ç¤ºä¾‹ä»£ç æ˜¯åœ¨å‰é¢çš„ä¾‹å­çš„åŸºç¡€ä¸Šç»™ SphereView æ·»åŠ æ‰‹åŠ¿è¯†åˆ«å™¨ã€‚åŒæ—¶ä¹Ÿåœ¨æ¨¡å‹ä¸­æ·»åŠ  InputTargetComponent å’Œç›¸åº”è§¦æ‘¸å½¢çŠ¶çš„ CollisionComponent ï¼Œè¿™æ ·å®ä½“ä¾¿èƒ½å¤Ÿè¿›è¡Œäº¤äº’ã€‚å¦‚æœä¸æ·»åŠ è¿™äº›ç»„ä»¶ï¼Œè§†å›¾( view )ä¸ä¼šæŠŠäº¤äº’äº‹ä»¶åˆ†å‘åˆ°ç›¸åº”çš„å®ä½“ä¸Šã€‚",
      "tips": ""
    },
    "Display 3D content in a volume": {
      "zh": "åœ¨ä¸‰ç»´ç«‹ä½“çª—å£( volume )ä¸­å±•ç¤º 3D å†…å®¹",
      "tips": ""
    },
    "A volume is a type of window that grows in three dimensions to match the size of the content it contains. Windows and volumes both accommodate 2D and 3D content, and are alike in many ways. However, windows clip 3D content that extends too far from the windowâ€™s surface, so volumes are the better choice for content that is primarily 3D.": {
      "zh": "ä¸‰ç»´ç«‹ä½“çª—å£( volume )æ˜¯ä¸€ç§æœ‰ä¸‰ä¸ªç»´åº¦çª—å£(å³ volumetric window)ï¼Œå®ƒç¬¦åˆæ˜¾ç¤º 3D å†…å®¹éœ€æ±‚ã€‚äºŒç»´å¹³é¢çª—å£( window )å’Œä¸‰ç»´ç«‹ä½“çª—å£( volume )å‡å¯å®¹çº³ 2D å’Œ 3D å†…å®¹ï¼Œè€Œä¸”å®ƒä»¬æœ‰è®¸å¤šç›¸ä¼¼ä¹‹å¤„ã€‚ç„¶è€Œï¼ŒäºŒç»´å¹³é¢çª—å£( window )ä¼šæŠŠè¶…å‡ºæ˜¾ç¤ºåŒºåŸŸå¤ªå¤šçš„ 3D å†…å®¹å‰ªåˆ‡æ‰ï¼Œæ‰€ä»¥ï¼Œå¯¹äºä»¥æ˜¾ç¤º 3D ä¸ºä¸»çš„å†…å®¹ï¼Œä¸‰ç»´ç«‹ä½“çª—å£( volume )æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚",
      "tips": ""
    },
    "To create a volume, add a WindowGroup scene to your app and set its style to volumetric. This style tells SwiftUI to create a window for 3D content. Include any 2D or 3D views you want in your volume. You can also add a RealityView to build your content using RealityKit. The following example creates a volume with a static 3D model of some balloons stored in the appâ€™s bundle:": {
      "zh": "åœ¨Appä¸­æ·»åŠ  WindowGroup Sceneï¼Œå¹¶å°† windowStyle è®¾ç½®ä¸º volumetric ï¼Œè¿™æ ·å°±åˆ›å»ºäº†ä¸€ä¸ªä¸‰ç»´ç«‹ä½“çª—å£( volume )ã€‚è¿™ç§ windowStyle æŒ‡å®š SwiftUI åˆ›å»ºä¸€ä¸ªæ˜¾ç¤º 3D å†…å®¹çš„ window ã€‚ä¸‰ç»´ç«‹ä½“çª—å£( volume )æ—¢å¯ä»¥åŒ…å« 2D è§†å›¾ï¼Œä¹Ÿå¯ä»¥åŒ…å« 3D è§†å›¾ã€‚æ‰€ä»¥ï¼Œä½ å¯ä»¥ä½¿ç”¨ RealityKit åˆ›å»º RealityView å®ä¾‹ï¼Œæ¥æ„é€  App å†…å®¹ã€‚ä¸‹é¢çš„ä¾‹å­ä»£ç ï¼Œä½¿ç”¨åº”ç”¨åŒ…( App Bundle )ä¸­çš„ balloons é™æ€ 3D æ¨¡å‹ä¸ºå†…å®¹åˆ›å»ºä¸€ä¸ªä¸‰ç»´ç«‹ä½“çª—å£( volume )ï¼š",
      "tips": ""
    },
    "Windows and volumes are a convenient way to display bounded 2D and 3D content, but your app doesnâ€™t control the placement of that content in the personâ€™s surroundings. The system sets the initial position of each window and volume at display time. The system also adds a window bar to allow someone to reposition the window or resize it.": {
      "zh": "ä½¿ç”¨äºŒç»´å¹³é¢çª—å£( window )å’Œä¸‰ç»´ç«‹ä½“çª—å£( volume )å±•ç¤ºæœ‰é™çš„ 2D å’Œ 3D å†…å®¹æ˜¯ä¸€ç§å¾ˆä¾¿æ·çš„æ–¹å¼ï¼Œä½†æ˜¯åŒæ—¶ï¼Œä½ å°±ä¸èƒ½åœ¨æ§åˆ¶ä½ è¦æ˜¾ç¤ºçš„å†…å®¹åœ¨ç”¨æˆ·å‘¨å›´ç¯å¢ƒä¸­çš„ä½ç½®ã€‚ç³»ç»Ÿä¼šåœ¨è¦æ˜¾ç¤ºäºŒç»´å¹³é¢çª—å£( window )å’Œä¸‰ç»´ç«‹ä½“çª—å£( volume )çš„æ—¶å€™è®¾ç½®å…¶åˆå§‹ä½ç½®ã€‚ç³»ç»Ÿä¹Ÿä¼šä¸ºå…¶æ·»åŠ ä¸€ä¸ªå·¥å…·æ ( window bar )ï¼Œä»¥ä¾¿ç”¨æˆ·ç§»åŠ¨æˆ–è€…ç¼©æ”¾çª—å£ã€‚",
      "tips": ""
    },
    "For more information about when to use volumes, see Human Interface Guidelines > Windows.": {
      "zh": "äº†è§£æ›´å¤šå…³äºâ€œä»€ä¹ˆæƒ…å†µä¸‹ä½¿ç”¨ä¸‰ç»´ç«‹ä½“çª—å£( volume )â€ï¼Œå‚ç…§ Human Interface Guidelines > Windows",
      "tips": ""
    },
    "Display 3D content in a personâ€™s surroundings": {
      "zh": "åœ¨ç”¨æˆ·å‘¨å›´ç¯å¢ƒä¸­çš„å±•ç¤º 3D å†…å®¹",
      "tips": ""
    },
    "When you need more control over the placement of your appâ€™s content, add that content to an ImmersiveSpace. An immersive space offers an unbounded area for your content, and you control the size and placement of content within the space. After receiving permission from the user, you can also use ARKit with an immersive space to integrate content into their surroundings. For example, you can use ARKit scene reconstruction to obtain a mesh of furniture and nearby objects and have your content interact with that mesh.": {
      "zh": "å½“ä½ éœ€è¦å®šä¹‰ App å†…å®¹æ‰€è¦å±•ç¤ºçš„ä½ç½®ï¼Œé‚£ä¹ˆå°±ä½¿ç”¨ ImmersiveSpace å±•ç¤ºç›¸åº”å†…å®¹ã€‚æ²‰æµ¸å¼ç©ºé—´( immersive space )æä¾›æ— é™åŒºåŸŸæ¥å±•ç¤ºä½ çš„ 3D å†…å®¹ï¼Œå¹¶ä¸”åœ¨è¿™ä¸ªç©ºé—´é‡Œä½ å¯ä»¥æ§åˆ¶ 3D å†…å®¹çš„å¤§å°å’Œä½ç½®ã€‚åœ¨è·å¾—ç”¨æˆ·è®¸å¯åï¼Œä½ è¿˜å¯ä»¥å°† ARKit ä¸æ²‰æµ¸å¼ç©ºé—´( immersive space )ç»“åˆä½¿ç”¨ï¼Œå°†å†…å®¹æ•´åˆåˆ°ç”¨æˆ·å‘¨å›´çš„ç¯å¢ƒä¸­ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥ä½¿ç”¨ ARKit åœºæ™¯é‡å»ºæ¥è·å–å®¶å…·å’Œé™„è¿‘ç‰©ä½“çš„ä¸‰ç»´ç½‘æ ¼ç»“æ„ï¼Œå¹¶è®©ä½ çš„å†…å®¹ä¸è¯¥ä¸‰ç»´ç½‘æ ¼ç»“æ„è¿›è¡Œç›¸äº’èåˆã€‚",
      "tips": ""
    },
    "An ImmersiveSpace is a scene type that you create alongside your appâ€™s other scenes. The following example shows an app that contains an immersive space and a window:": {
      "zh": "ImmersiveSpace æ˜¯ä¸€ç§ç‰¹å®šç±»å‹çš„ Scene ï¼Œå¯ä»¥å’Œ App ä¸­å…¶ä»–çš„ Scene ä¸€èµ·åˆ›å»ºã€‚ä¸‹é¢çš„ä¾‹å­å±•ç¤ºäº†åŒ…å«äº†æ²‰æµ¸å¼ç©ºé—´( immersive space )å’Œæ™®é€šçª—å£( window )çš„ App çš„ä»£ç ï¼š",
      "tips": ""
    },
    "If you donâ€™t add a style modifier to your ImmersiveSpace declaration, the system creates that space using the mixed style. This style displays your content together with the passthrough content that shows the personâ€™s surroundings. Other styles let you hide passthrough to varying degrees. Use the immersionStyle(selection:in:) modifier to specify which styles your space supports. If you specify more than one style, you can toggle between the styles using the selection parameter of the modifier.": {
      "zh": "å¦‚æœåœ¨åˆ›å»º ImmersiveSpace æ—¶æ²¡æœ‰åˆ¶å®šç±»å‹ï¼Œç³»ç»Ÿä¼šé»˜è®¤åˆ›å»ºä¸€ä¸ª mixed ç±»å‹çš„ç©ºé—´ã€‚è¿™ä¸ªç±»å‹ä¼šå°†ä½ çš„å†…å®¹å’Œè´¯ç©¿ç”¨æˆ·å‘¨å›´ç¯å¢ƒçš„å†…å®¹èåˆåœ¨ä¸€èµ·å±•ç¤ºã€‚å…¶ä»–æ²‰æµ¸ç±»å‹ä¼šä¸åŒç¨‹åº¦çš„éšè—å‘¨å›´ç¯å¢ƒå†…å®¹ã€‚è°ƒç”¨ immersionStyle(selection:in:) æŒ‡å®šä½ çš„ç©ºé—´æ”¯æŒä»€ä¹ˆæ²‰æµ¸ç±»å‹ã€‚å¦‚æœæŒ‡å®šäº†å¤šä¸ªæ ·å¼ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ä¿®æ”¹å™¨çš„ selection å‚æ•°åœ¨æ ·å¼ä¹‹é—´åˆ‡æ¢ã€‚",
      "tips": ""
    },
    "Warning": {
      "zh": "è­¦å‘Š",
      "tips": ""
    },
    "Be mindful of how much content you include in immersive scenes that use the mixed style. Content that fills a significant portion of the screen, even if that content is partially transparent, can prevent the person from seeing potential hazards in their surroundings. If you want to immerse the person in your content, configure your space with the full style. For more information, see, Creating fully immersive experiences in your app.": {
      "zh": "è¯·æ³¨æ„ä¸€ä¸‹åœ¨æ²‰æµ¸å¼åœºæ™¯( immersive scenes )ä¸­æœ‰å¤šå°‘å†…å®¹ä½¿ç”¨ mixed ç±»å‹ã€‚å› ä¸ºå¦‚æœ 3D å†…å®¹å æ»¡å±å¹•å¾ˆå¤§ä¸€éƒ¨åˆ†çš„ï¼Œå³ä½¿å¯ä»¥çœ‹è§éƒ¨åˆ†å‘¨å›´ç¯å¢ƒï¼Œä¹Ÿå¯èƒ½ä½¿ç”¨æˆ·å®Œå…¨æ— æ³•çœ‹åˆ°å‘¨å›´ç¯å¢ƒä¸­çš„æ½œåœ¨å±é™©ã€‚å¦‚æœæƒ³è®©ç”¨æˆ·å®Œå…¨æ²‰æµ¸åœ¨ä½ çš„å†…å®¹ä¸­ï¼Œè¯·ä½¿ full é…ç½®ä½ çš„ç©ºé—´ã€‚å¦‚éœ€äº†è§£æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… Creating fully immersive experiences in your app ã€‚",
      "tips": ""
    },
    "Remember to set the position of items you place in an ImmersiveSpace. Position SwiftUI views using modifiers, and position a RealityKit entity using its transform component. SwiftUI places the origin of a space at a personâ€™s feet initially, but can change this origin in response to other events. For example, the system might shift the origin to accommodate a SharePlay activity that displays your content with Spatial Personas. If you need to position SwiftUI views and RealityKit entities relative to one another, perform any needed coordinate conversions using the methods in the content parameter of RealityView.": {
      "zh": "è®°å¾—åœ¨ ImmersiveSpace ä¸­è®¾ç½®å®ä½“çš„ä½ç½®ã€‚ SwiftUI ä¸­ï¼Œé€šè¿‡ç›¸åº”çš„ä¿®æ”¹å™¨ position(x:y:) ã€ position(_:CGPoint) è®¾ç½®è§†å›¾çš„ä½ç½®ï¼Œå¯¹äº RealityKit å®ä½“ï¼Œåˆ™æ˜¯é€šè¿‡è®¾ç½® transform ç›¸å…³çš„å±æ€§ï¼Œæ¥è®¾ç½®å®ä½“çš„ä½ç½®ã€‚SwiftUI ä¼šä»¥ç”¨æˆ·æ‰€ç«™çš„ä½ç½®ä½œä¸ºç©ºé—´åŸç‚¹åˆå§‹ä½ç½®ï¼Œä½†æ˜¯åŸç‚¹ä½ç½®å¯ä»¥éšå…¶ä»–äº‹ä»¶è€Œæ”¹å˜ã€‚ä¾‹å¦‚ï¼Œå½“éœ€è¦åŒæ—¶å±•ç¤ºæœ‰ç”¨æˆ·è™šæ‹Ÿè§’è‰²çš„ SharePlay Activity å’Œ ä½ çš„ 3D å†…å®¹æ—¶ï¼Œç³»ç»Ÿä¼šå¹³ç§»ä½ çš„ç©ºé—´åŸç‚¹çš„ä½ç½®ã€‚å¦‚æœéœ€è¦å¯¹ SwiftUI è§†å›¾å’Œ RealityKit å®ä½“è¿›è¡Œç›¸å¯¹å®šä½ï¼Œè¯·ä½¿ç”¨ RealityView å’Œ RealityViewContent çš„å‚æ•°å’Œæ–¹æ³•æ¥å®ç°æ‰€éœ€çš„åæ ‡è½¬æ¢ã€‚",
      "tips": "è¯‘è€…æ³¨ï¼šè¿™é‡Œå°† Spatial Personas ç¿»è¯‘ä¸ºâ€œç”¨æˆ·è™šæ‹Ÿè§’è‰²â€ï¼Œæ˜¯ç”¨æˆ·çš„æ‹ŸçœŸå½¢è±¡ï¼Œæ˜¯è‹¹æœçš„ä¸€é¡¹æ–°æŠ€æœ¯ã€‚æ›´å¤šå…³äº SharePlay activity å’Œ Spatial Personasï¼Œå¯ä»¥é€šè¿‡ Design spatial SharePlay experiences è§†é¢‘äº†è§£ã€‚"
    },
    "To display your ImmersiveSpace scene, open it using the openImmersiveSpace action, which you obtain from the SwiftUI environment. This action runs asynchronously and uses the provided information to find and initialize your scene. The following example shows a button that opens the space with the solarSystem identifier:": {
      "zh": "åœ¨ SwiftUI ç¯å¢ƒä¸­ï¼Œé€šè¿‡ openImmersiveSpace æ–¹æ³•ï¼Œæ˜¾ç¤ºä½ çš„ ImmersiveSpace Sceneã€‚ç³»ç»Ÿä¼šå¼‚æ­¥æ‰§è¡Œè¿™ä¸ªæ–¹æ³•ï¼Œå¹¶é€šè¿‡å·²æœ‰çš„ä¿¡æ¯åˆå§‹åŒ–ä½ çš„ Scene ã€‚ä¸‹åˆ—å®ä¾‹ä»£ç å±•ç¤ºäº†ç‚¹å‡»æŒ‰é’®ï¼Œé€šè¿‡ solarSystem çš„å”¯ä¸€æ ‡è¯†ç¬¦æ‰“å¼€è¿™ä¸ªè™šæ‹Ÿç©ºé—´ã€‚",
      "tips": ""
    },
    "When an app presents an ImmersiveSpace, the system hides the content of other apps to prevent visual conflicts. The other apps remain hidden while your space is visible but return when you dismiss it. If your app defines multiple spaces, you must dismiss the currently visible space before displaying a different space. If you donâ€™t dismiss the visible space, the system issues a runtime warning when you try to open the other space.": {
      "zh": "å½“åº”ç”¨ç¨‹åºå±•ç¤ºä¸€ä¸ªè™šæ‹Ÿç©ºé—´â€”â€” ImmersiveSpace æ—¶ï¼Œç³»ç»Ÿä¸ºäº†é˜²æ­¢è§†è§‰å†²çªä¼šéšè—å…¶ä»– App çš„å†…å®¹ã€‚å½“ä½ çš„è™šæ‹Ÿç©ºé—´å±•ç¤ºç€çš„æ—¶å€™ï¼Œå…¶ä»–åº”ç”¨ç¨‹åºä¼šä¸€ç›´è¢«éšè—ç€ï¼Œç›´åˆ°ç”¨æˆ·é€€å‡ºäº†ä½ çš„è™šæ‹Ÿç©ºé—´ï¼Œå…¶ä»–åº”ç”¨ç¨‹åºæ‰ä¼šæ¢å¤æ˜¾ç¤ºã€‚å½“ä½ æ²¡æœ‰é€€å‡ºå½“å‰æ˜¾ç¤ºçš„è™šæ‹Ÿç©ºé—´ï¼Œè€Œå»æ‰“å¼€å¦ä¸€ä¸ªè™šæ‹Ÿç©ºé—´ï¼Œç³»ç»Ÿå°±ä¼šæŠ›å‡ºä¸€ä¸ªè¿è¡Œæ—¶çš„é”™è¯¯ã€‚",
      "tips": ""
    }
  },
  "visionos/adopting-best-practices-for-privacy": {
    "Adopting best practices for privacy and user preferences": {
      "zh": "éµå¾ªéšç§å’Œç”¨æˆ·åå¥½çš„æœ€ä¼˜åšæ³•",
      "tips": ""
    },
    "Minimize your use of sensitive information and provide a clear statement of what information you do use and how you use it.": {
      "zh": "å°½å¯èƒ½å°‘åœ°ä½¿ç”¨éšç§ä¿¡æ¯ï¼Œå‘ç”¨æˆ·æä¾›æ¸…æ™°çš„è¯´æ˜ï¼Œæ˜ç¡®å‘ŠçŸ¥æ‚¨æ‰€ä½¿ç”¨çš„ä¿¡æ¯åŠå…¶ä½¿ç”¨æ–¹å¼ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è§ˆ",
      "tips": ""
    },
    "To protect user privacy, the system handles camera and sensor inputs without passing the information to apps directly. Instead, the system enables your app to seamlessly interact with a userâ€™s surroundings and to automatically receive input from the user. For example, the system handles the eye- and hand-position data needed to detect interactions with your appâ€™s content. Similarly, the system provides a way to automatically alter a viewâ€™s appearance when someone looks at it, without your app ever knowing what the user is looking at.": {
      "zh": "ä¸ºä¿éšœç”¨æˆ·éšç§ï¼Œç³»ç»Ÿä¼šç›´æ¥å¤„ç†æ‘„åƒå¤´å’Œä¼ æ„Ÿå™¨æ‰€è¾“å…¥çš„ä¿¡æ¯ï¼Œè€Œéä¼ ç»™åº”ç”¨ç¨‹åºã€‚ç³»ç»Ÿçš„è¿™ç§è®¾è®¡è®©æ‚¨çš„åº”ç”¨èƒ½å¤Ÿä¸ç”¨æˆ·çš„å‘¨é­ç¯å¢ƒæ— ç¼äº’åŠ¨ï¼Œå¹¶è‡ªåŠ¨æ¥æ”¶ç”¨æˆ·è¾“å…¥çš„ä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œç³»ç»Ÿä¼šå¤„ç†çœ¼ç›å’Œæ‰‹éƒ¨çš„ä½ç½®æ•°æ®ï¼Œè¿™å¯¹äºæ£€æµ‹ç”¨æˆ·ä¸æ‚¨åº”ç”¨å†…å®¹çš„äº’åŠ¨æ¥è¯´è‡³å…³é‡è¦ã€‚ç±»ä¼¼åœ°ï¼Œæ‚¨çš„åº”ç”¨æ— éœ€çŸ¥æ™“ç”¨æˆ·çš„å…·ä½“æ³¨è§†ç‚¹ï¼Œç³»ç»Ÿå°±èƒ½åœ¨ç”¨æˆ·çœ‹å‘æŸä¸ªè§†å›¾æ—¶è‡ªåŠ¨æ”¹å˜å…¶å±•ç¤ºæ•ˆæœã€‚",
      "tips": ""
    },
    "In the few cases where you actually need access to hand position or information about the userâ€™s surroundings, the system requires you to obtain authorization from the user first.": {
      "zh": "åœ¨æå°‘æ•°æƒ…å†µä¸‹ï¼Œå¦‚æœæ‚¨çœŸçš„éœ€è¦è·å–ç”¨æˆ·æ‰‹éƒ¨ä½ç½®æˆ–å‘¨å›´ç¯å¢ƒä¿¡æ¯ï¼Œç³»ç»Ÿä¼šè¦æ±‚æ‚¨å¿…é¡»å…ˆè·å¾—ç”¨æˆ·çš„æˆæƒã€‚",
      "tips": ""
    },
    "Important": {
      "zh": "é‡è¦ä¿¡æ¯",
      "tips": ""
    },
    "Itâ€™s your responsibility to protect any data your app collects, and to use it in responsible and privacy-preserving ways. Donâ€™t ask for data that you donâ€™t need, be transparent about how you use the data you acquire, and respect the choices of the person whose data it is.": {
      "zh": "ä¿æŠ¤æ‚¨çš„åº”ç”¨æ‰€æ”¶é›†çš„ä»»ä½•æ•°æ®ï¼Œå¹¶ä»¥è´Ÿè´£ä»»å’Œå°Šé‡éšç§çš„æ–¹å¼ä½¿ç”¨è¿™äº›æ•°æ®æ˜¯æ‚¨çš„è´£ä»»ã€‚ä¸è¦ä»ç”¨æˆ·å¤„è·å–ä»»ä½•æ‚¨ä¸éœ€è¦çš„æ•°æ®ï¼Œå¯¹äºå¦‚ä½•ä½¿ç”¨æ‚¨æ‰€è·å–çš„æ•°æ®è¦ä¿æŒå…¬å¼€é€æ˜ï¼Œå¹¶å°Šé‡æ•°æ®æ‰€æœ‰è€…çš„é€‰æ‹©ã€‚",
      "tips": ""
    },
    "For information about how to specify the privacy data your app uses, see Describing data use in privacy manifests. For general information about privacy, see Protecting the Userâ€™s Privacy.": {
      "zh": "å…³äºå¦‚ä½•åœ¨éšç§æ¸…å•ä¸­æ˜ç¡®æ‚¨çš„åº”ç”¨æ‰€ä½¿ç”¨çš„éšç§æ•°æ®ï¼Œè¯¦è§â€œéšç§æ•°æ®ä½¿ç”¨è¯´æ˜â€ã€‚æœ‰å…³éšç§ä¿æŠ¤æ”¿ç­–çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…â€œä¿æŠ¤ç”¨æˆ·éšç§â€ã€‚",
      "tips": ""
    },
    "Adopt the system-provided input mechanisms": {
      "zh": "é‡‡ç”¨ç³»ç»Ÿæä¾›çš„è¾“å…¥æœºåˆ¶",
      "tips": ""
    },
    "On Apple Vision Pro, people use their eyes and hands to interact with the items they see in front of them. Where they look determines where the system applies focus, and a tap gesture with either hand generates a touch event on that focused item. The system can also detect when someoneâ€™s fingers interact with virtual items in the personâ€™s field of vision. When you adopt the standard UIKit and SwiftUI event-handling mechanisms, you get all of these interactions automatically.": {
      "zh": "åœ¨ Apple Vision Pro ä¸Šï¼Œç”¨æˆ·ä¼šé€šè¿‡çœ¼ç›å’Œæ‰‹ä¸ä»–ä»¬æ‰€è§åˆ°çš„ç‰©ä½“äº¤äº’ã€‚ä»–ä»¬çš„è§†çº¿æ‰€åœ¨ä¹‹å¤„å†³å®šäº†ç³»ç»Ÿçš„èšç„¦ç‚¹ï¼Œä»»ä½•ä¸€åªæ‰‹çš„è½»è§¦æ‰‹åŠ¿éƒ½ä¼šåœ¨æ‰€èšç„¦ç‰©ä½“ä¸Šäº§ç”Ÿä¸€ä¸ªè§¦æ‘¸äº‹ä»¶ã€‚ç³»ç»Ÿè¿˜èƒ½æ£€æµ‹ç”¨æˆ·çš„æ‰‹æŒ‡ä½•æ—¶ä¸å…¶è§†é‡ä¸­çš„è™šæ‹Ÿç‰©å“å‘ç”Ÿäº¤äº’ã€‚å½“æ‚¨é‡‡ç”¨æ ‡å‡†çš„ UIKit å’Œ SwiftUI äº‹ä»¶å¤„ç†æœºåˆ¶æ—¶ï¼Œè¿™äº›äº¤äº’éƒ½èƒ½è¢«è‡ªåŠ¨æ•æ‰å’Œå¤„ç†ã€‚",
      "tips": ""
    },
    "For most apps, the system-provided gesture recognizers are sufficient for responding to interactions. Although you can get the position of someoneâ€™s hands with ARKit, doing so isnâ€™t necessary for most apps. Collect hand-position data only when the system doesnâ€™t offer what you need. For example, you might use hand-position data to attach 3D content to the personâ€™s hands. Some other things to remember about hand-position data:": {
      "zh": "å¯¹äºå¤§éƒ¨åˆ†åº”ç”¨æ¥è¯´ï¼Œç³»ç»Ÿå†…ç½®çš„æ‰‹åŠ¿è¯†åˆ«åŠŸèƒ½å·²è¶³ä»¥åº”å¯¹ç”¨æˆ·çš„äº¤äº’ã€‚å°½ç®¡é€šè¿‡ ARKit å¯ä»¥è·å–ç”¨æˆ·æ‰‹éƒ¨çš„ä½ç½®ä¿¡æ¯ï¼Œä½†è¿™å¯¹äºå¤šæ•°åº”ç”¨æ¥è¯´å¹¶éå¿…éœ€ã€‚å»ºè®®æ‚¨åªåœ¨ç³»ç»Ÿæä¾›çš„åŠŸèƒ½æ— æ³•æ»¡è¶³ç‰¹å®šéœ€æ±‚æ—¶ï¼Œæ‰å‘ç”¨æˆ·æ”¶é›†æ‰‹éƒ¨ä½ç½®æ•°æ®ã€‚ä¸¾ä¾‹æ¥è¯´ï¼Œæ‚¨å¯èƒ½ä¼šåˆ©ç”¨æ‰‹éƒ¨ä½ç½®æ•°æ®å°† 3D å†…å®¹é™„åŠ åˆ°ç”¨æˆ·çš„æ‰‹ä¸Šã€‚åœ¨å¤„ç†æ‰‹éƒ¨ä½ç½®æ•°æ®æ—¶ï¼Œè¿˜æœ‰ä»¥ä¸‹å‡ ç‚¹éœ€è¦æ³¨æ„ï¼š",
      "tips": ""
    },
    "People can deny your request for access to hand-position data. Be prepared to handle situations where the data isnâ€™t available.": {
      "zh": "ç”¨æˆ·å¯èƒ½ä¼šæ‹’ç»æ‚¨è®¿é—®æ‰‹éƒ¨ä½ç½®æ•°æ®çš„è¯·æ±‚ã€‚æ‚¨éœ€è¦å‡†å¤‡å¥½å¤„ç†æ•°æ®ä¸å¯ç”¨çš„æƒ…å†µã€‚",
      "tips": ""
    },
    "You must present an immersive space to access hand data. When you open an immersive space, the system hides other apps.": {
      "zh": "æ‚¨å¿…é¡»æä¾›ä¸€ä¸ªæ²‰æµ¸å¼ç©ºé—´æ¥è®¿é—®æ‰‹éƒ¨æ•°æ®ã€‚å½“æ‚¨å¯åŠ¨ä¸€ä¸ªæ²‰æµ¸å¼ç©ºé—´æ—¶ï¼Œç³»ç»Ÿä¼šéšå»å…¶ä»–åº”ç”¨ã€‚",
      "tips": ""
    },
    "For information about how to handle the standard-system events, see the SwiftUI and UIKit documentation.": {
      "zh": "å…³äºå¦‚ä½•å¤„ç†æ ‡å‡†ç³»ç»Ÿäº‹ä»¶çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… SwiftUI å’Œ UIKit çš„æ–‡æ¡£ã€‚",
      "tips": ""
    },
    "Provide clear messaging around privacy-sensitive features": {
      "zh": "åœ¨æä¾›æ¶‰åŠéšç§çš„åŠŸèƒ½æ—¶ï¼Œè¯·æ˜ç¡®æä¾›æ¸…æ™°çš„å£°æ˜ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "The following ARKit features require you to provide a usage description string in your appâ€™s Info.plist file:": {
      "zh": "åœ¨ä½¿ç”¨ä»¥ä¸‹ ARKit åŠŸèƒ½æ—¶ï¼Œéœ€è¦æ‚¨åœ¨åº”ç”¨çš„ Info.plist æ–‡ä»¶ä¸­æä¾›æä¾›å­—ç¬¦ä¸²æ¥æè¿°ä½¿ç”¨ç›®çš„ï¼š",
      "tips": ""
    },
    "World-tracking data": {
      "zh": "ä¸–ç•Œè¿½è¸ªæ•°æ®",
      "tips": ""
    },
    "Hand-tracking data": {
      "zh": "æ‰‹éƒ¨è¿½è¸ªæ•°æ®",
      "tips": ""
    },
    "Other privacy-sensitive technologies in visionOS also require you to supply usage description strings. For example, you provide usage descriptions for the Core Location features you adopt. These strings communicate why your app needs the data, and how you plan to use the data to help the person using your app. The first time you request authorization to use the technology, the system prompts the person to grant or deny access to your app. The system includes your usage-description string in the dialog it displays.": {
      "zh": "åœ¨ visionOS ä¸­ï¼Œå…¶ä»–å’Œéšç§ç›¸å…³çš„æŠ€æœ¯ä¹Ÿéœ€è¦æ‚¨æä¾›ä½¿ç”¨æè¿°å­—ç¬¦ä¸²ã€‚ä¾‹å¦‚ï¼Œä½ éœ€è¦ä¸ºåº”ç”¨ä¸­ä½¿ç”¨ Core Location åŠŸèƒ½çš„åŸå› æä¾›ä½¿ç”¨è¯´æ˜ã€‚è¿™äº›å­—ç¬¦ä¸²åº”è¯¥èƒ½æ¸…æ¥šåœ°è¯´æ˜æ‚¨çš„åº”ç”¨ä¸ºä½•éœ€è¦è¿™äº›æ•°æ®ï¼Œä»¥åŠæ‚¨è®¡åˆ’å¦‚ä½•ä½¿ç”¨è¿™äº›æ•°æ®æ¥å¸®åŠ©ç”¨æˆ·ä½¿ç”¨äº§å“ã€‚å½“æ‚¨é¦–æ¬¡è¯·æ±‚ä½¿ç”¨æŸé¡¹æŠ€æœ¯çš„æˆæƒæ—¶ï¼Œç³»ç»Ÿä¼šæç¤ºç”¨æˆ·æ˜¯å¦æˆæƒæ‚¨çš„åº”ç”¨ä½¿ç”¨ã€‚ç³»ç»Ÿæ˜¾ç¤ºçš„å¯¹è¯æ¡†ä¸­å°†ä¼šåŒ…å«æ‚¨çš„ä½¿ç”¨æè¿°å­—ç¬¦ä¸²ã€‚",
      "tips": ""
    },
    "For information about requesting access to ARKit data, see ARKit. For guidance on how to craft good messages around privacy-friendly features, see Human Interface Guidelines.": {
      "zh": "æœ‰å…³è¯·æ±‚è®¿é—® ARKit æ•°æ®çš„ä¿¡æ¯ï¼Œè¯·å‚é˜… ARKit æ–‡æ¡£ã€‚æœ‰å…³å¦‚ä½•æ’°å†™éšç§å‹å¥½çš„æ’°å†™è‰¯å¥½ä¿¡æ¯çš„æŒ‡å—ï¼Œè¯·å‚é˜…â€œäººæœºç•Œé¢æŒ‡å—â€ã€‚",
      "tips": ""
    }
  },
  "visionos/adopting_the_system_player_interface_in_visionos": {
    "Adopting the system player interface in visionOS": {
      "zh": "åœ¨ visionOS ä¸­é‡‡ç”¨ç³»ç»Ÿæ’­æ”¾å™¨ç•Œé¢",
      "tips": ""
    },
    "Provide an optimized viewing experience for watching 3D video content.": {
      "zh": "ä¸ºè§‚çœ‹ 3D è§†é¢‘å†…å®¹æä¾›ä¼˜åŒ–çš„è§‚çœ‹ä½“éªŒã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "The recommended way to provide a video playback interface for your visionOS app is to adopt AVPlayerViewController. Using this class makes it simple to provide the same playback user interface and features found in system apps like TV and Music. It also provides essential system integration to deliver an optimal viewing experience whether youâ€™re playing standard 2D content or immersive 3D video with spatial audio. This article describes best practices for presenting the player in visionOS and covers the options the player provides to customize its user interface to best fit your app.": {
      "zh": "ä¸ºä½ çš„ visionOS åº”ç”¨æä¾›è§†é¢‘æ’­æ”¾ç•Œé¢çš„æ¨èæ–¹æ³•æ˜¯é‡‡ç”¨ AVPlayerViewControllerã€‚ä½¿ç”¨æ­¤ç±»å¯ä»¥è½»æ¾æä¾›ä¸ç³»ç»Ÿåº”ç”¨ï¼ˆå¦‚ç”µè§†å’ŒéŸ³ä¹ï¼‰ç›¸åŒçš„æ’­æ”¾ç•Œé¢å’ŒåŠŸèƒ½ã€‚å®ƒè¿˜æä¾›äº†å¿…è¦çš„ç³»ç»Ÿé›†æˆï¼Œæ— è®ºä½ æ˜¯æ’­æ”¾æ ‡å‡†çš„ 2D å†…å®¹è¿˜æ˜¯å¸¦æœ‰ç©ºé—´éŸ³é¢‘çš„æ²‰æµ¸å¼ 3D è§†é¢‘ï¼Œéƒ½èƒ½æä¾›æœ€ä½³çš„è§‚çœ‹ä½“éªŒã€‚æœ¬æ–‡ä»‹ç»äº†åœ¨ visionOS ä¸­å±•ç¤ºæ’­æ”¾å™¨çš„æœ€ä½³å®è·µï¼Œå¹¶æ¶µç›–äº†æ’­æ”¾å™¨æä¾›çš„è‡ªå®šä¹‰ç•Œé¢é€‰é¡¹ï¼Œä»¥æœ€é€‚åº”ä½ çš„åº”ç”¨ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "å¤‡æ³¨",
      "tips": ""
    },
    "In addition to providing the system playback interface, you can also use AVPlayerViewController to present a media-trimming experience similar to QuickTime Player in macOS. See Trimming and exporting media in visionOS for more information.": {
      "zh": "é™¤äº†æä¾›ç³»ç»Ÿæ’­æ”¾ç•Œé¢ï¼Œä½ è¿˜å¯ä»¥ä½¿ç”¨ AVPlayerViewController æä¾›ç±»ä¼¼äº macOS ä¸­ QuickTime Player çš„åª’ä½“å‰ªè¾‘ä½“éªŒã€‚æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è€ƒ visionOS ä¸­ä¿®å‰ªå’Œå¯¼å‡ºåª’ä½“ã€‚",
      "tips": ""
    },
    "Explore presentation options": {
      "zh": "æ¢ç´¢å±•ç¤ºæ–¹å¼",
      "tips": ""
    },
    "Use AVPlayerViewController to play video in windowed environments in visionOS. It automatically adapts its user interface to best fit its presentation. For example, when you present it nested inside another view, it displays an inline user interface:": {
      "zh": "ä½¿ç”¨ AVPlayerViewController åœ¨ visionOS çš„çª—å£ç¯å¢ƒä¸­æ’­æ”¾è§†é¢‘ï¼Œå®ƒä¼šè‡ªåŠ¨è°ƒæ•´å…¶ç”¨æˆ·ç•Œé¢ä»¥é€‚åº”å½“å‰å±•ç¤ºæ–¹å¼ã€‚ä¾‹å¦‚ï¼Œå½“ä½ å°†å…¶åµŒå¥—åœ¨å¦ä¸€ä¸ªè§†å›¾ä¸­æ—¶ï¼Œå®ƒä¼šæ˜¾ç¤ºä¸€ä¸ªå†…åµŒç”¨æˆ·ç•Œé¢ï¼š",
      "tips": ""
    },
    "When you present the player inline, it only displays standard 2D video. To play 3D content, present it fullscreen.": {
      "zh": "å½“ä½ ä»¥å†…åµŒæ–¹å¼å±•ç¤ºæ’­æ”¾å™¨æ—¶ï¼Œå®ƒä»…æ”¯æŒæ ‡å‡† 2D è§†é¢‘ã€‚å¦‚è¦æ’­æ”¾ 3D å†…å®¹ï¼Œè¯·ä½¿ç”¨å…¨å±å±•ç¤ºã€‚",
      "tips": ""
    },
    "Present the player in full-screen mode by setting it as the exclusive root view of your app, or by presenting it using the fullScreenCover(item:onDismiss:content:) modifier. In full-screen mode, the player presents a more content-forward design that dims the environment by default to provide more suitable viewing. This provides a streamlined viewing experience for both 2D and 3D content.": {
      "zh": "å°†æ’­æ”¾å™¨è®¾ç½®ä¸ºåº”ç”¨çš„å”¯ä¸€æ ¹è§†å›¾ï¼Œæˆ–ä½¿ç”¨ fullScreenCover(item:onDismiss:content:) ä¿®é¥°ç¬¦ï¼Œå¯ä»¥ä»¥å…¨å±æ¨¡å¼å±•ç¤ºæ’­æ”¾å™¨ã€‚åœ¨å…¨å±æ¨¡å¼ä¸‹ï¼Œæ’­æ”¾å™¨å‘ˆç°å‡ºä¸€ç§æ›´åŠ åå†…å®¹å¯¼å‘çš„è®¾è®¡ï¼Œé»˜è®¤ä¼šè°ƒæš—ç¯å¢ƒå…‰çº¿ï¼Œä»¥æä¾›æ›´åˆé€‚çš„è§‚çœ‹æ•ˆæœã€‚è¿™ä¸ºæ¬£èµ 2D å’Œ 3D å†…å®¹æä¾›äº†ä¼˜åŒ–çš„è§‚çœ‹ä½“éªŒã€‚",
      "tips": ""
    },
    "Display supporting metadata": {
      "zh": "æ˜¾ç¤ºç›¸å…³å…ƒæ•°æ®",
      "tips": ""
    },
    "The user interface displays a title view above the transport bar when the current player item contains title and subtitle metadata. When playing live-streaming content, the title view may also display a badge to indicate the content state to the viewer.": {
      "zh": "åœ¨å½“å‰æ’­æ”¾é¡¹ç›®åŒ…å«æ ‡é¢˜å’Œå‰¯æ ‡é¢˜å…ƒæ•°æ®æ—¶ï¼Œç”¨æˆ·ç•Œé¢ä¼šåœ¨æ’­æ”¾æ ä¸Šæ–¹æ˜¾ç¤ºæ ‡é¢˜è§†å›¾ã€‚å½“æ’­æ”¾å®æ—¶å†…å®¹æ—¶ï¼Œæ ‡é¢˜è§†å›¾è¿˜å¯èƒ½æ˜¾ç¤ºä¸€ä¸ªå¾½ç« ï¼Œå‘è§‚ä¼—æç¤ºå†…å®¹çŠ¶æ€ã€‚",
      "tips": ""
    },
    "The title view displays the values of an assetâ€™s commonIdentifierTitle and iTunesMetadataTrackSubTitle metadata items, when available. If your media doesnâ€™t provide embedded metadata, you can add supplemental metadata to display by creating instances of AVMetadataItem. The table below lists the metadata values the player user interface supports.": {
      "zh": "æ ‡é¢˜è§†å›¾ä¼šæ˜¾ç¤ºåª’ä½“å…ƒæ•°æ®é¡¹ commonIdentifierTitle å’Œ iTunesMetadataTrackSubTitle çš„å€¼ï¼ˆå¦‚å¯ç”¨ï¼‰ã€‚å¦‚æœä½ çš„åª’ä½“ä¸æä¾›åµŒå…¥çš„å…ƒæ•°æ®ï¼Œåˆ™å¯ä»¥é€šè¿‡åˆ›å»º AVMetadataItem çš„å®ä¾‹æ¥è¡¥å……å…ƒæ•°æ®ã€‚ä¸‹è¡¨åˆ—å‡ºäº†æ’­æ”¾å™¨ç”¨æˆ·ç•Œé¢æ”¯æŒçš„å…ƒæ•°æ®å€¼ã€‚",
      "tips": ""
    },
    "Metadata": {
      "zh": "å…ƒæ•°æ®",
      "tips": ""
    },
    "Identifier": {
      "zh": "æ ‡è¯†ç¬¦",
      "tips": ""
    },
    "Type": {
      "zh": "ç±»å‹",
      "tips": ""
    },
    "Title": {
      "zh": "æ ‡é¢˜",
      "tips": ""
    },
    "commonIdentifierTitle": {
      "zh": "commonIdentifierTitle",
      "tips": ""
    },
    "String": {
      "zh": "å­—ç¬¦ä¸²",
      "tips": ""
    },
    "Subtitle": {
      "zh": "å‰¯æ ‡é¢˜",
      "tips": ""
    },
    "iTunesMetadataTrackSubTitle": {
      "zh": "iTunesMetadataTrackSubTitle",
      "tips": ""
    },
    "Artwork": {
      "zh": "ä½œå“",
      "tips": ""
    },
    "commonIdentifierArtwork": {
      "zh": "commonIdentifierArtwork",
      "tips": ""
    },
    "Data": {
      "zh": "æ•°æ®",
      "tips": ""
    },
    "Description": {
      "zh": "æè¿°",
      "tips": ""
    },
    "commonIdentifierDescription": {
      "zh": "commonIdentifierDescription",
      "tips": ""
    },
    "Genre": {
      "zh": "ç±»å‹",
      "tips": ""
    },
    "quickTimeMetadataGenre": {
      "zh": "quickTimeMetadataGenre",
      "tips": ""
    },
    "Content rating": {
      "zh": "å†…å®¹åˆ†çº§",
      "tips": ""
    },
    "iTunesMetadataContentRating": {
      "zh": "iTunesMetadataContentRating",
      "tips": ""
    },
    "In an app that defines a simple structure to hold string and data items, you can map its values to their appropriate metadata identifiers and build an array of metadata items:": {
      "zh": "åœ¨ä¸€ä¸ªä½¿ç”¨ç®€å•ç»“æ„ä½“æ¥ä¿å­˜å­—ç¬¦ä¸²å’Œæ•°æ®çš„åº”ç”¨ä¸­ï¼Œä½ å¯ä»¥å°†è¿™äº›å€¼æ˜ å°„åˆ°ç›¸åº”çš„å…ƒæ•°æ®æ ‡è¯†ç¬¦ï¼Œå¹¶ç”Ÿæˆå…ƒæ•°æ®é¡¹æ•°ç»„ï¼š",
      "tips": ""
    },
    "To apply the metadata to the current player item, set the array of metadata items as the value of the player itemâ€™s externalMetadata property:": {
      "zh": "è‹¥è¦å°†å…ƒæ•°æ®åº”ç”¨äºå½“å‰æ’­æ”¾é¡¹ï¼Œå°†å…ƒæ•°æ®é¡¹æ•°ç»„èµ‹å€¼ç»™æ’­æ”¾é¡¹ç›®çš„ externalMetadata å±æ€§ï¼š",
      "tips": ""
    },
    "Only the title and subtitle values display in the title view. The player presents the other supported metadata values in its Info tab, which the section below describes.": {
      "zh": "æ ‡é¢˜è§†å›¾ä¸­ä»…æ˜¾ç¤ºæ ‡é¢˜å’Œå‰¯æ ‡é¢˜ã€‚æ’­æ”¾å™¨åœ¨å…¶â€œä¿¡æ¯â€é€‰é¡¹å¡ä¸­æ˜¾ç¤ºå…¶ä»–æ”¯æŒæ˜¾ç¤ºçš„å…ƒæ•°æ®å€¼ï¼Œæ–‡ç« çš„ä»¥ä¸‹éƒ¨åˆ†å°†å¯¹æ­¤è¿›è¡Œä»‹ç»ã€‚",
      "tips": ""
    },
    "Display custom informational views": {
      "zh": "æ˜¾ç¤ºè‡ªå®šä¹‰ä¿¡æ¯è§†å›¾",
      "tips": ""
    },
    "The visionOS player UI can display one or more content tabs in the user interface to show supporting information or related content. By default, the player presents an Info tab when an asset contains embedded metadata or when you set external metadata on the player item, as the Display supporting metadata section above describes.": {
      "zh": "visionOS æ’­æ”¾å™¨ UI å¯ä»¥åœ¨ç”¨æˆ·ç•Œé¢ä¸­æ˜¾ç¤ºä¸€ä¸ªæˆ–å¤šä¸ªå†…å®¹é€‰é¡¹å¡ï¼Œä»¥æ˜¾ç¤ºé™„å±ä¿¡æ¯æˆ–ç›¸å…³å†…å®¹ã€‚å½“åª’ä½“åŒ…å«å†…åµŒå…ƒæ•°æ®æˆ–åœ¨æ’­æ”¾å™¨é¡¹ç›®ä¸Šè®¾ç½®äº†å¤–éƒ¨å…ƒæ•°æ®æ—¶ï¼Œæ’­æ”¾å™¨ä¼šå¦‚ä¸Šé¢çš„â€œæ˜¾ç¤ºç›¸å…³å…ƒæ•°æ®â€ç« èŠ‚æ‰€è¿°ï¼Œé»˜è®¤æ˜¾ç¤ºâ€œä¿¡æ¯â€é€‰é¡¹å¡ã€‚",
      "tips": ""
    },
    "Your app can also present custom tabs to show supporting content. You define your tab content as standard SwiftUI views, wrap them in a UIHostingController, and set them as the customInfoViewControllers property. The player UI uses the title property of the hosting controller to display as the tab title in the interface, so set this value before setting it on the player view controller.": {
      "zh": "ä½ çš„åº”ç”¨è¿˜å¯ä»¥é€šè¿‡å±•ç¤ºè‡ªå®šä¹‰é€‰é¡¹å¡ä»¥æ˜¾ç¤ºç›¸å…³å†…å®¹ã€‚ä½ å¯ä»¥ä½¿ç”¨æ ‡å‡† SwiftUI è§†å›¾å®šä¹‰é€‰é¡¹å¡å†…å®¹ï¼Œå°†å®ƒä»¬åŒ…è£…åœ¨ UIHostingController ä¸­ï¼Œç„¶åå°†å®ƒä»¬è®¾ç½®ä¸º customInfoViewControllers å±æ€§ã€‚æ’­æ”¾å™¨ UI å°†æ‰˜ç®¡æ§åˆ¶å™¨çš„ title å±æ€§æ˜¾ç¤ºä¸ºé€‰é¡¹å¡ç•Œé¢æ ‡é¢˜ï¼Œå› æ­¤è¯·å…ˆè®¾ç½®å¥½æ­¤å€¼ï¼Œå†åœ¨æ’­æ”¾å™¨è§†å›¾æ§åˆ¶å™¨ä¸Šè®¾ç½®æ‰˜ç®¡æ§åˆ¶å™¨ã€‚",
      "tips": "Hosting controller è¯‘ä¸ºâ€œæ‰˜ç®¡æ§åˆ¶å™¨â€ã€‚"
    },
    "Present actions in the Info tab": {
      "zh": "åœ¨â€œä¿¡æ¯â€é€‰é¡¹å¡ä¸­æ˜¾ç¤ºæ“ä½œ",
      "tips": ""
    },
    "The player UI presents an Info tab when the asset it displays provides embedded or external metadata. The tabâ€™s view displays the metadata details, and it may show up to two UIAction controls along its trailing edge:": {
      "zh": "å½“æ’­æ”¾å™¨ UI æ˜¾ç¤ºçš„èµ„æºæä¾›å†…åµŒæˆ–å¤–éƒ¨å…ƒæ•°æ®æ—¶ï¼Œå®ƒä¼šæ˜¾ç¤ºä¸€ä¸ªâ€œä¿¡æ¯â€é€‰é¡¹å¡ã€‚é€‰é¡¹å¡è§†å›¾ä¼šæ˜¾ç¤ºå…ƒæ•°æ®è¯¦æƒ…ï¼Œå¹¶ä¸”æ²¿å³ä¾§è¾¹ç¼˜æ˜¾ç¤ºæœ€å¤šä¸¤ä¸ª UIAction æ§ä»¶ï¼š",
      "tips": ""
    },
    "Customize the actions the view presents by setting a value for the player view controllerâ€™s infoViewActions property. When playing nonlive content, this property contains a single-element array that presents an action to play the content from the beginning. You can replace the default value (if present), add an additional action, or set this property value to an empty array to display no actions. The example below shows how to add a Add to Favorites action to the view:": {
      "zh": "é€šè¿‡è®¾ç½®æ’­æ”¾å™¨è§†å›¾æ§åˆ¶å™¨çš„ infoViewActions å±æ€§æ¥è‡ªå®šä¹‰è§†å›¾æ‰€æ˜¾ç¤ºçš„æ“ä½œã€‚å½“æ’­æ”¾éå®æ—¶å†…å®¹æ—¶ï¼Œæ­¤å±æ€§é»˜è®¤ä¸ºä¸€ä¸ªå•å…ƒç´ æ•°ç»„ï¼Œç”¨äºå­˜æ”¾ä»å¤´æ’­æ”¾è§†é¢‘çš„æ“ä½œã€‚ä½ å¯ä»¥æ›¿æ¢é»˜è®¤å€¼ï¼ˆå¦‚å­˜åœ¨ï¼‰ã€æ·»åŠ å…¶ä»–æ“ä½œï¼Œæˆ–å°†æ­¤å±æ€§è®¾ç½®ä¸ºç©ºæ•°ç»„ä»è€Œä¸æ˜¾ç¤ºä»»ä½•æ“ä½œã€‚ä¸‹é¢çš„ç¤ºä¾‹æ¼”ç¤ºäº†å¦‚ä½•å‘è§†å›¾æ·»åŠ â€œæ·»åŠ åˆ°æ”¶è—å¤¹â€æ“ä½œï¼š",
      "tips": ""
    },
    "Display actions contextually": {
      "zh": "æ ¹æ®ä¸Šä¸‹æ–‡æƒ…æ™¯æ¥æ˜¾ç¤ºæ“ä½œ",
      "tips": ""
    },
    "You can use the visionOS player UI to present controls contextually, which your app displays for a specific range of time in the content and then dismiss. A common use for this type of control is a skip button that displays during the title sequence of a movie or TV show. People can tap the button to bypass the introduction and quickly skip to the main content.": {
      "zh": "ä½ å¯ä»¥è®© visionOS æ’­æ”¾å™¨ UI æ ¹æ®æƒ…æ™¯æ¥æ˜¾ç¤ºæ§ä»¶ï¼Œåº”ç”¨ä¼šåœ¨ä¸€å®šæ—¶é—´å†…åœ¨è§†é¢‘å†…å®¹ä¸­æ˜¾ç¤ºæ§ä»¶ï¼Œç„¶åéšè—ã€‚æ­¤ç±»æ§ä»¶çš„å¸¸è§ç”¨é€”æ˜¯åœ¨ç”µå½±æˆ–ç”µè§†èŠ‚ç›®çš„ç‰‡å¤´åºåˆ—ä¸­æ˜¾ç¤ºè·³è¿‡æŒ‰é’®ï¼Œç”¨æˆ·å¯ä»¥ç‚¹å‡»æ­¤æŒ‰é’®ç»•è¿‡ä»‹ç»å¹¶å¿«é€Ÿè·³è½¬åˆ°ä¸»è¦å†…å®¹ã€‚",
      "tips": ""
    },
    "AVPlayerViewController provides a contextualActions property you can use to specify one or more actions to present. The player displays them along the bottom-trailing side of the screen. The following code example shows a simple implementation of an action that seeks the player forward to the time of the main content:": {
      "zh": "AVPlayerViewController æä¾›äº†ä¸€ä¸ª contextualActions å±æ€§ï¼Œç”¨äºæŒ‡å®šæ˜¾ç¤ºä¸€ä¸ªæˆ–å¤šä¸ªæ“ä½œã€‚æ’­æ”¾å™¨åœ¨ç”»é¢çš„åº•éƒ¨é å³æ˜¾ç¤ºè¿™äº›æ“ä½œã€‚ä¸‹é¢çš„ä»£ç ç¤ºä¾‹æ¼”ç¤ºäº†ä¸€ä¸ªç®€å•çš„æ“ä½œï¼Œè¯¥æ“ä½œå°†æ’­æ”¾å™¨å‘å‰å¿«è¿›åˆ°ä¸»è¦å†…å®¹çš„å¼€å§‹æ—¶é—´ï¼š",
      "tips": ""
    },
    "When you set a value for the contextualActions property, the player presents the controls immediately. To present them only during a relevant section of the content, observe the player timing by adding a periodic or boundary time observer. The following example defines a periodic time observer that fires every second during normal playback. In each invocation, it evaluates the new time to determine whether it falls within the presentation range. If it does, the example sets the skip action as the contextual actions value; otherwise, it clears the value by setting it to an empty array.": {
      "zh": "å½“ä½ ä¸º contextualActions å±æ€§èµ‹å€¼åï¼Œæ’­æ”¾å™¨ä¼šç«‹å³æ˜¾ç¤ºå¯¹åº”çš„æ§ä»¶ã€‚å¦‚éœ€è¦ä»…åœ¨ä¸å†…å®¹ç›¸å…³çš„éƒ¨åˆ†æ˜¾ç¤ºæ“ä½œï¼Œè¯·é€šè¿‡æ·»åŠ å‘¨æœŸæ€§æˆ–è¾¹ç•Œæ€§æ—¶é—´è§‚å¯Ÿå™¨æ¥ç›‘è§†æ’­æ”¾æ—¶é—´ã€‚ä»¥ä¸‹ç¤ºä¾‹å®šä¹‰äº†ä¸€ä¸ªå‘¨æœŸæ€§æ—¶é—´è§‚å¯Ÿå™¨ï¼Œè¯¥è§‚å¯Ÿå™¨åœ¨è§†é¢‘æ’­æ”¾æœŸé—´æ¯ç§’é’Ÿè§¦å‘ä¸€æ¬¡ã€‚åœ¨æ¯æ¬¡è§¦å‘æ—¶ï¼Œå®ƒéƒ½ä¼šè¯„ä¼°å½“å‰æ’­æ”¾æ—¶é—´ï¼Œä»¥ç¡®è®¤å®ƒæ˜¯å¦åœ¨æ˜¾ç¤ºèŒƒå›´å†…ã€‚å¦‚æœæ˜¯ï¼Œåˆ™è¯¥ç¤ºä¾‹å°†è·³è¿‡è®¾ç½®ä¸ºå½“å‰æƒ…æ™¯çš„æ“ä½œï¼›å¦åˆ™ï¼Œå®ƒå°†é€šè¿‡å°†å€¼è®¾ç½®ä¸ºç©ºæ•°ç»„æ¥æ¸…é™¤æ‰€æœ‰æ“ä½œã€‚",
      "tips": ""
    }
  },
  "visionos/analyzing-the-performance-of-your-visionos-app": {
    "Analyzing the performance of your visionOS app": {
      "zh": "",
      "tips": ""
    },
    "Use the RealityKit Trace template in Instruments to evaluate and improve the performance of your visionOS app.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "To maintain the sense of immersion on Apple Vision Pro, the system attempts to provide the device displays with up-to-date imagery at a constant rate and respond to interactions with minimum latency. Any visual choppiness or delay in responsiveness interferes with the spatial experience. Higher power consumption over extended periods of time, or extreme power consumption over shorter periods of time, can trigger thermal mitigations that also impact the quality of the experience. Itâ€™s important to minimize your appâ€™s use of system resources to ensure your app performs well on the platform. Many of the same best practices and optimization procedures you use developing for other Apple platforms apply when developing for visionOS as well. For more information about optimizing your app on other platforms, see Improving your appâ€™s performance.": {
      "zh": "",
      "tips": ""
    },
    "To get useful information specific to rendering bottlenecks, high system power use, and other issues that effect the responsiveness of your visionOS app, profile your app with the RealityKit Trace template in Instruments. This template helps you identify:": {
      "zh": "",
      "tips": ""
    },
    "Complex content or content with frequent updates that cause the render server to miss deadlines and drop frames.": {
      "zh": "",
      "tips": ""
    },
    "Content and tasks that result in high system power use.": {
      "zh": "",
      "tips": ""
    },
    "Long running tasks on the the main thread that interfere with efficient processing of input events.": {
      "zh": "",
      "tips": ""
    },
    "Tasks running on other threads that donâ€™t complete in time to sync back to the main thread for view hierarchy updates.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "You can profile using a real device or a simulator, but to get the most accurate and actionable information, use a real device. Software and hardware differences between a simulator on your Mac and a real device prevent you from relying on timing information. Simulated devices are useful for quick iteration and improving performance aspects that arenâ€™t based on time.": {
      "zh": "",
      "tips": ""
    },
    "Open a new trace document": {
      "zh": "",
      "tips": ""
    },
    "To create a new trace document:": {
      "zh": "",
      "tips": ""
    },
    "Select your appâ€™s scheme and a visionOS run destination from the Xcode project window.": {
      "zh": "",
      "tips": ""
    },
    "Choose Product > Profile.": {
      "zh": "",
      "tips": ""
    },
    "Choose RealityKit Trace template": {
      "zh": "",
      "tips": ""
    },
    "Select the Choose button.": {
      "zh": "",
      "tips": ""
    },
    "Alternatively, launch Instruments and choose a target app from the template selection dialog.": {
      "zh": "",
      "tips": ""
    },
    "The RealityKit Trace template includes the following instruments:": {
      "zh": "",
      "tips": ""
    },
    "Captures frame render times and lifespans for frames the visionOS render server generates. This instrument indicates when frames miss rendering deadlines and provides average CPU and GPU render rates.": {
      "zh": "",
      "tips": ""
    },
    "Captures comprehensive timing information from the entire render pipeline including rendering, commits, animations, physics, and spatial systems. This instrument identifies potential bottlenecks in your appâ€™s process or in the render server as a result of your appâ€™s content and indicates areas of moderate and high system power usage that require optimization.": {
      "zh": "",
      "tips": ""
    },
    "Captures and displays Runloop execution details.": {
      "zh": "",
      "tips": ""
    },
    "Profiles running threads on all cores at regular intervals for all processes.": {
      "zh": "",
      "tips": ""
    },
    "Captures and displays periods of time when the main thread is unresponsive.": {
      "zh": "",
      "tips": ""
    },
    "Records Metal app events.": {
      "zh": "",
      "tips": ""
    },
    "Consider adding other instruments to your trace for specific investigations. For example, you can use the Thermal State instrument to record device thermal states to check if thermal pressures are throttling performance.": {
      "zh": "",
      "tips": ""
    },
    "Profile your workflows": {
      "zh": "",
      "tips": ""
    },
    "Click the record button at the top left of the window to start capturing profile data. Perform the actions in your app that you want to investigate. When you complete the actions, click the record button again to stop recording.": {
      "zh": "",
      "tips": ""
    },
    "To investigate performance issues or analyze system power impact, profile your app in isolation to understand your appâ€™s impact on system performance and ensure you get the most actionable information. For apps that run alongside other apps, profile your app again with those other apps running to understand how people experience your app in conjunction with other apps.": {
      "zh": "",
      "tips": ""
    },
    "Inspect frame rendering performance": {
      "zh": "",
      "tips": ""
    },
    "To maintain a smooth visual experience, the system tries to render new frames for the Apple Vision Pro at 90 frames per second (FPS). The system renders at other frame rates depending on the content it displays and the current surroundings. Each frame has a deadline for rendering based on the target frame rate. Not meeting these deadlines results in dropped frames. This creates a poor spatial experience overall. People tend to notice it in the visual performance of Persona and SharePlay experiences, video playback, and scrolling. The RealityKit Frames instrument displays the time spent rendering each frame in the Frames section of its timeline:": {
      "zh": "",
      "tips": ""
    },
    "When you zoom out, you can identify areas with a high number of frame drops or with frames running close to the rendering deadline. The timeline uses green to identify frames that complete rendering before the deadline, orange for frames that complete rendering close to the deadline, and red for frames that donâ€™t complete rendering that the renderer drops. Dropped frames contribute to a poor spatial experience, but frames that complete close to their rendering deadline indicate performance problems too. Hold the Option key and drag to zoom into a frame, or group of frames, to see their lifespan broken down in stages:": {
      "zh": "",
      "tips": ""
    },
    "This provides you with insight into which portion of the rendering pipeline to investigate further. This timeline also includes sections that visualize the Average CPU Frame Time and Average GPU Frame Time to indicate the type of processing that computes the frames. A region of the timeline without a frame block indicates a period of time without changes to a personâ€™s surroundings or app updates. The render server avoids computing new frames to send to the compositor during these periods which helps optimize power use.": {
      "zh": "",
      "tips": ""
    },
    "Monitor system power usage": {
      "zh": "",
      "tips": ""
    },
    "When thermal levels rise to levels that trigger thermal mitigations in the system, performance degrades and negatively impacts the responsiveness of your app. Optimize for power to avoid this negative impact. The timeline for the RealityKit Metrics instrument includes a System Power Impact section to identify areas of high power usage in your app:": {
      "zh": "",
      "tips": ""
    },
    "If the timeline displays green, the tool considers your appâ€™s impact on system power low enough to sustain. Regions that display orange or red indicate the system power usage could cause thermal levels to rise and trigger thermal mitigations. This decreases the availability of system resources, which can cause visual interruptions and responsiveness issues.": {
      "zh": "",
      "tips": ""
    },
    "If the render server canâ€™t maintain the target frame rate of 90 FPS due to thermal pressure, it might reduce its frame rate in half. When this occurs, all frames in the frames track show up as missing their rendering deadlines. Other factors can cause reduced frame rate, including the complexity and frequency of the content the system is processing. Use the Thermal State instrument to determine if thermal conditions are causing the rate limiting or if itâ€™s due to other factors.": {
      "zh": "",
      "tips": ""
    },
    "Identify bottlenecks": {
      "zh": "",
      "tips": ""
    },
    "The Bottlenecks section of the timeline for the RealityKit Metrics instrument contains markers that indicate high overhead in your app or the render server that contribute to dropped frames and high system power use. When you encounter either of these issues, check if the timeline identifies bottlenecks you can address. Double-click on any of the markers to display more information in the detail area at the bottom of the instruments window. If the detail area is hidden, choose View > Detail Area > Show Detail Area to reveal it. The render server encounters bottlenecks in either the CPU or GPU. The instrument categorizes bottlenecks by their severity and type.": {
      "zh": "",
      "tips": ""
    },
    "To filter the bottlenecks listed in the detail area to a particular time period, drag inside the timeline to select the region. To see an outline view of the bottlenecks organized by severity and type, select Summary: RealityKit Bottlenecks from the menu at the top left of the detail area. Click the arrow button to the right of the severity or type in the outline view to show the list of bottlenecks in that category.": {
      "zh": "",
      "tips": ""
    },
    "When you select a specific bottleneck, the extended detail provides recommendations for you to address the bottleneck â€“ choose View > Show Extended Detail to reveal the extended detail if itâ€™s hidden.": {
      "zh": "",
      "tips": ""
    },
    "Explore the metrics that relate to bottlenecks": {
      "zh": "",
      "tips": ""
    },
    "The trace provides additional information you can use to identify changes to make in your app to address these bottlenecks. Click the expansion arrow for the RealityKit Metrics instrument timeline to reveal graphs specific to each major category of work. Use the metrics associated with these graphs to determine which RealityKit feature has the biggest impact on high CPU frame times in the app process or in the render server. When interpreting these graphs, lower indicates better performance and power. The metrics represent values from all apps running, so profile with just your app running when trying to optimize for these metrics.": {
      "zh": "",
      "tips": ""
    },
    "Metrics related to the cost of 3D RealityKit rendering in the render server. This includes the number of draw calls, triangles, and vertices from all apps.": {
      "zh": "",
      "tips": ""
    },
    "Metrics related to UI content rendering costs in the render server. This includes the total number of render passes, offscreen render passes, and translucent UI meshes from all apps.": {
      "zh": "",
      "tips": ""
    },
    "Metrics related to the costs of entity commits in the app and the render server. This includes the number of RealityKit entities shared with the render server from all apps, as well as the number of updates received from all apps over certain intervals.": {
      "zh": "",
      "tips": ""
    },
    "Metrics related to the cost of RealityKit animations in the app and the render server. This includes the number of skeletal animations, across all apps.": {
      "zh": "",
      "tips": ""
    },
    "Metrics related to the cost of RealityKit physics simulations, collisions, and hit testing in the app process and render server. This includes the number of rigid body counts and colliders in use, as well as the type of physics shapes that the UI and other 3D content use, across all apps.": {
      "zh": "",
      "tips": ""
    },
    "Metrics related to the costs of spatial algorithms in the render server. This includes the number of custom anchors, across all apps.": {
      "zh": "",
      "tips": ""
    },
    "Tip": {
      "zh": "",
      "tips": ""
    },
    "The graphs for some sections combine several individual metrics. The heading indicates this by displaying a graph count. Click on the bottom of the timelineâ€™s heading and drag down to display individual graphs for each metric. For example, the 3D Render Timeline might display 13 Graphs in the heading; expanding that timeline exposes individual graphs for 3D Mesh Draw Calls, 3D Mesh Triangles, 3D Mesh Vertices, and the 10 additional metrics.": {
      "zh": "",
      "tips": ""
    },
    "The timeline for your appâ€™s process helps summarize information from the instruments about your process and the work the render server completes for your process.": {
      "zh": "",
      "tips": ""
    },
    "Choose an option from the pop-up in the timeline header to show different graphs in the timeline:": {
      "zh": "",
      "tips": ""
    },
    "Time each thread spends waiting or busy.": {
      "zh": "",
      "tips": ""
    },
    "Time the main thread is unresponsive.": {
      "zh": "",
      "tips": ""
    },
    "CPU usage and lifecycle status.": {
      "zh": "",
      "tips": ""
    },
    "Overhead attributed to RealityKit systems.": {
      "zh": "",
      "tips": ""
    },
    "When you select the timeline for your appâ€™s process, you can choose instrument summaries and profile data to display in the detail area from the popup-button at its top-left:": {
      "zh": "",
      "tips": ""
    },
    "To filter the information in the detail area by time, select periods of time in the timeline above.": {
      "zh": "",
      "tips": ""
    },
    "Detect delays on the main thread": {
      "zh": "",
      "tips": ""
    },
    "Select Hangs in your appâ€™s process timeline to identify times in the trace that might have interaction delays. Use the RealityKit Metrics and Time Profiler summaries to better understand the work your app is doing. Choose the following options from the detail area pop-up menu:": {
      "zh": "",
      "tips": ""
    },
    "Shows information from the Time Profiler instrument to determine what your app is doing during a hang.": {
      "zh": "",
      "tips": ""
    },
    "RealityKit System CPU times: Shows minimum, maximum, and average times the CPU spends on various RealityKit system operations.": {
      "zh": "",
      "tips": ""
    },
    "Optimize any 3D render updates, hit testing, and collision work you find. For more information about addressing hangs in your app, see Improving app responsiveness.": {
      "zh": "",
      "tips": ""
    },
    "Manage audio overhead": {
      "zh": "",
      "tips": ""
    },
    "Use the Audio Playback section of your processâ€™s timeline to identify areas of high audio overhead. The system defaults to using spatial audio for your app when running on visionOS. It processes information in real time about your position, surroundings, and the current location of audio sources to generate an immersive audio experience. If you include too many concurrent audio sources that require the system to adapt audio sources to their location within a large space, the increased demand on system resources can lead to delays in the audio output.": {
      "zh": "",
      "tips": ""
    },
    "To reduce the spatial audio work, limit:": {
      "zh": "",
      "tips": ""
    },
    "The number of concurrently playing audio sources": {
      "zh": "",
      "tips": ""
    },
    "The number of moving audio sources": {
      "zh": "",
      "tips": ""
    },
    "The size of the soundstage": {
      "zh": "",
      "tips": ""
    },
    "Consider creating a pool of audio players to limit the maximum number of players your app uses. Place players on stationary entities, instead of moving entities, when appropriate. Initializing several audio players at the same time causes a high overhead that affects other aspects of the system, such as rendering performance. Consider the other tasks the system completes during these allocations and space them out over time. For more information, see Create a great spatial playback experience.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/bringing-your-app-to-visionos": {
    "Bringing your existing apps to visionOS": {
      "zh": "å°†ç°æœ‰åº”ç”¨ç§»æ¤åˆ° visionOS",
      "tips": ""
    },
    "Build a version of your iPadOS or iOS app using the visionOS SDK, and update your code for platform differences.": {
      "zh": "ä½¿ç”¨ visionOS SDK ä¸ºä½ çš„ iPadOS æˆ– iOS åº”ç”¨æ„å»ºä¸€ä¸ªæ–°ç‰ˆæœ¬ï¼Œå¹¶æ›´æ–°ä»£ç ä»¥é€‚åº”å¹³å°å·®å¼‚ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "If you have an existing app that runs in iPadOS or iOS, you can build that app against the visionOS SDK to run it on the platform. Apps built specifically for visionOS adopt the standard system appearance, and they look more natural on the platform. Updating your app is also an opportunity to add elements that work well on the platform, such as 3D content and immersive experiences.": {
      "zh": "å¦‚æœä½ æœ‰ä¸€ä¸ªåœ¨ iPadOS æˆ– iOS ä¸Šè¿è¡Œçš„åº”ç”¨ï¼Œä½ å¯ä»¥ä½¿ç”¨ visionOS SDK æ„å»ºè¯¥åº”ç”¨ç¨‹åºï¼Œä»¥ä¾¿åœ¨è¯¥å¹³å°ä¸Šè¿è¡Œã€‚ä¸º visionOS ä¸“é—¨æ„å»ºçš„åº”ç”¨é‡‡ç”¨æ ‡å‡†ç³»ç»Ÿå¤–è§‚ï¼Œåœ¨è¯¥å¹³å°ä¸Šçœ‹èµ·æ¥æ›´è‡ªç„¶ã€‚åŒæ—¶ï¼Œæ›´æ–°åº”ç”¨ä¹Ÿæ˜¯æ·»åŠ åœ¨è¯¥å¹³å°ä¸Šå¸å¼•çœ¼çƒçš„å…ƒç´ ï¼ˆå¦‚ 3D å†…å®¹å’Œæ²‰æµ¸å¼ä½“éªŒï¼‰çš„å¥½æœºä¼šã€‚",
      "tips": ""
    },
    "In most cases, all you need to do to support visionOS is update your Xcode projectâ€™s settings and recompile your code. Depending on your app, you might need to make additional changes to account for features that are only found in the iOS SDK. While most of the same technologies are available on both platforms, some technologies donâ€™t make sense or require hardware that isnâ€™t present on visionOS devices. For example, people donâ€™t typically use a headset to make contactless payments, so apps that that use the ProximityReader framework must disable those features when running in visionOS.": {
      "zh": "åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä½ åªéœ€æ›´æ–° Xcode çš„é¡¹ç›®è®¾ç½®å¹¶é‡æ–°ç¼–è¯‘ä»£ç å³å¯æ”¯æŒ visionOSã€‚æ ¹æ®ä½ çš„åº”ç”¨ï¼Œä½ å¯èƒ½éœ€è¦è¿›è¡Œå…¶ä»–æ›´æ”¹ï¼Œä»¥è§£å†³é‚£äº›ä»…åœ¨ iOS SDK ä¸­æ”¯æŒçš„åŠŸèƒ½ã€‚è™½ç„¶åœ¨ä¸¤ä¸ªå¹³å°ä¸Šå¤šæ•°æŠ€æœ¯éƒ½æ˜¯é€šç”¨çš„ï¼Œæœ‰äº›æŠ€æœ¯åœ¨ visionOS è®¾å¤‡ä¸Šå¹¶ä¸åˆç†ï¼Œæˆ–è€…éœ€è¦çš„ç¡¬ä»¶å¹¶ä¸å­˜åœ¨ã€‚ä¾‹å¦‚ï¼Œç”¨æˆ·é€šå¸¸ä¸ä½¿ç”¨å¤´æˆ´å¼è®¾å¤‡è¿›è¡Œç”µå­æ”¯ä»˜ï¼Œå› æ­¤ä½¿ç”¨ ProximityReader æ¡†æ¶çš„åº”ç”¨åœ¨ visionOS ä¸­è¿è¡Œæ—¶å¿…é¡»ç¦ç”¨è¿™äº›åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "å¤‡æ³¨",
      "tips": ""
    },
    "If you use ARKit in your iOS app to create an augmented reality experience, you need to make additional changes to support ARKit in visionOS. For information on how to update this type of app, see Bringing your ARKit app to visionOS.": {
      "zh": "å¦‚æœä½ åœ¨ iOS åº”ç”¨ä¸­ä½¿ç”¨äº† ARKit æ¥å®ç°å¢å¼ºç°å®ä½“éªŒï¼Œåˆ™éœ€è¦è¿›è¡Œé¢å¤–çš„æ›´æ”¹æ‰èƒ½åœ¨ visionOS ä¸­æ”¯æŒ ARKitã€‚æœ‰å…³å¦‚ä½•æ›´æ–°æ­¤ç±»åº”ç”¨ï¼Œè¯·å‚é˜…å°† ARKit åº”ç”¨ç§»æ¤åˆ° visionOSã€‚",
      "tips": ""
    },
    "Add visionOS as a supported destination for your app": {
      "zh": "å°† visionOS æ·»åŠ ä¸ºåº”ç”¨çš„æ”¯æŒç»ˆç«¯ï¼ˆsupported destinationï¼‰",
      "tips": ""
    },
    "The first step to updating your app is to add visionOS as a supported destination. In your projectâ€™s settings, select your app target and navigate to the General tab. In Supported Destinations, click the Add (+) button to add a new destination and select the Apple Vision option. Adding this option lets you build your app specifically for the visionOS SDK.": {
      "zh": "æ›´æ–°åº”ç”¨çš„ç¬¬ä¸€æ­¥æ˜¯å°† visionOS æ·»åŠ ä¸ºæ”¯æŒç»ˆç«¯ã€‚åœ¨ä½ çš„é¡¹ç›®è®¾ç½®ä¸­ï¼Œé€‰æ‹©åº”ç”¨ç›®æ ‡å¹¶å¯¼èˆªåˆ° General é€‰é¡¹å¡ã€‚åœ¨ Supported Destinations é€‰é¡¹ä¸­ï¼Œå•å‡»æ·»åŠ  ï¼ˆ+ï¼‰ æŒ‰é’®ä»¥æ·»åŠ æ–°çš„ç»ˆç«¯ï¼Œå¹¶é€‰æ‹© Apple Vision é€‰é¡¹ã€‚æ·»åŠ è¯¥é€‰é¡¹åï¼Œä½ å°±å¯ä»¥ä¸“é—¨ä¸º visionOS SDK æ„å»ºåº”ç”¨äº†ã€‚",
      "tips": ""
    },
    "When you add Apple Vision as a destination, Xcode makes some one-time changes to your projectâ€™s build settings. After you add the destination, you can modify your projectâ€™s build settings and build phases to customize the build behavior specifically for visionOS. For example, you might remove dependencies for the visionOS version of your app, or change the set of source files you want to compile.": {
      "zh": "å½“ç¬¬ä¸€æ¬¡ Apple Vision æ·»åŠ ä¸ºç»ˆç«¯æ—¶ï¼ŒXcode ä¼šå¯¹é¡¹ç›®çš„æ„å»ºè®¾ç½®è¿›è¡Œä¸€äº›ä¸€æ¬¡æ€§æ›´æ”¹ã€‚æ·»åŠ ç»ˆç«¯åï¼Œä½ å¯ä»¥ä¿®æ”¹é¡¹ç›®çš„æ„å»ºè®¾ç½®å’Œæ„å»ºé˜¶æ®µï¼Œä»¥å®šåˆ¶é’ˆå¯¹ visionOS çš„æ„å»ºè¡Œä¸ºã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥ç§»é™¤ visionOS ç‰ˆåº”ç”¨çš„ä¾èµ–é¡¹ï¼Œæˆ–æ›´æ”¹è¦ç¼–è¯‘çš„æºæ–‡ä»¶é›†ã€‚",
      "tips": ""
    },
    "For more information about how to update a targetâ€™s configuration, see Customizing the build phases of a target.": {
      "zh": "æœ‰å…³å¦‚ä½•æ›´æ–°ç›®æ ‡é…ç½®çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…è‡ªå®šä¹‰ç›®æ ‡çš„æ„å»ºé˜¶æ®µã€‚",
      "tips": ""
    },
    "Clean up code that uses deprecated APIs": {
      "zh": "æ¸…ç†ä½¿ç”¨äº†åºŸå¼ƒ API çš„ä»£ç ",
      "tips": ""
    },
    "Fix any deprecation warnings in the iOS version of your code before you build for visionOS. Apple marks APIs as deprecated when they are no longer relevant or a suitable replacement exists. When you compile code that calls deprecated APIs, the compiler generates warnings and often suggests replacements for you to use instead. visionOS removed many deprecated symbols entirely, turning these deprecation warnings into missing-symbol errors on the platform. Make changes in the iOS version of your app to see the original deprecation warning and replacement details.": {
      "zh": "åœ¨ä¸º visionOS æ„å»ºä¹‹å‰ï¼Œä¿®å¤ iOS ç‰ˆæœ¬ä»£ç ä¸­çš„ä»»ä½•å¼ƒç”¨è­¦å‘Šã€‚å½“ API ä¸å†é€‚ç”¨æˆ–å­˜åœ¨åˆé€‚çš„æ›¿ä»£å“æ—¶ï¼ŒApple å°±ä¼šå°†å…¶æ ‡è®°ä¸ºåºŸå¼ƒã€‚å½“ä½ ç¼–è¯‘è°ƒç”¨å·²åºŸå¼ƒ API çš„ä»£ç æ—¶ï¼Œç¼–è¯‘å™¨ä¼šç”Ÿæˆè­¦å‘Šï¼Œå¹¶ç»å¸¸å»ºè®®ä½ ä½¿ç”¨æ›¿ä»£å“ã€‚visionOS å®Œå…¨åˆ é™¤äº†è®¸å¤šå·²åºŸå¼ƒçš„ç¬¦å·ï¼Œè¿™äº›åºŸå¼ƒè­¦å‘Šä¹Ÿå› æ­¤å˜æˆäº†è¯¥å¹³å°ä¸Šçš„ç¬¦å·ç¼ºå¤±é”™è¯¯ã€‚è¯·åœ¨ iOS ç‰ˆæœ¬çš„åº”ç”¨æŸ¥çœ‹åŸå§‹çš„å¼ƒç”¨è­¦å‘Šå’Œæ›¿æ¢è¯¦æƒ…ã€‚",
      "tips": ""
    },
    "In addition to individual symbols, the following frameworks are deprecated in their entirety in both iOS and visionOS. If your app still uses these frameworks, stop using them immediately. The reference documentation for each framework includes information about how to update your code.": {
      "zh": "é™¤ä¸ªåˆ«ç¬¦å·å¤–ï¼Œä»¥ä¸‹æ¡†æ¶åœ¨ iOS å’Œ visionOS ä¸­å‡å·²è¢«å®Œå…¨å¼ƒç”¨ã€‚å¦‚æœä½ çš„åº”ç”¨ä»åœ¨ä½¿ç”¨è¿™äº›æ¡†æ¶ï¼Œè¯·ç«‹å³åœæ­¢ä½¿ç”¨ã€‚æ¯ä¸ªæ¡†æ¶çš„å‚è€ƒæ–‡æ¡£éƒ½åŒ…å«æœ‰å…³å¦‚ä½•ä¿®æ”¹ä»£ç çš„è¯¦æƒ…ã€‚",
      "tips": ""
    },
    "Accounts": {
      "zh": "Accounts",
      "tips": ""
    },
    "Address Book": {
      "zh": "Address Book",
      "tips": ""
    },
    "Address Book UI": {
      "zh": "Address Book UI",
      "tips": ""
    },
    "Assets Library": {
      "zh": "Assets Library",
      "tips": ""
    },
    "GLKit": {
      "zh": "GLKit",
      "tips": ""
    },
    "iAd": {
      "zh": "iAd",
      "tips": ""
    },
    "Newsstand Kit": {
      "zh": "Newsstand Kit",
      "tips": ""
    },
    "NotificationCenter": {
      "zh": "NotificationCenter",
      "tips": ""
    },
    "OpenGL ES": {
      "zh": "OpenGL ES",
      "tips": ""
    },
    "Isolate features that are unavailable in visionOS": {
      "zh": "éš”ç¦» visionOS ä¸­ä¸å¯ç”¨çš„åŠŸèƒ½",
      "tips": ""
    },
    "The iOS SDK includes many frameworks that donâ€™t apply to visionOS, either because they use hardware that isnâ€™t available or their features donâ€™t apply to the platform. Move code that uses these frameworks to separate source files whenever possible, and include those files only in the iOS version of your app.": {
      "zh": "iOS SDK åŒ…å«è®¸å¤šä¸é€‚ç”¨äº visionOS çš„æ¡†æ¶ï¼Œè¿™å¯èƒ½æ˜¯å› ä¸ºæ¡†æ¶ä½¿ç”¨çš„ç¡¬ä»¶ä¸å¯ç”¨ï¼Œä¹Ÿå¯èƒ½æ˜¯å› ä¸ºæ¡†æ¶åŠŸèƒ½åŠŸèƒ½ä¸é€‚ç”¨äºè¯¥å¹³å°ã€‚å°½å¯èƒ½å°†ä½¿ç”¨è¿™äº›æ¡†æ¶çš„ä»£ç ç§»åˆ°ç‹¬ç«‹çš„æºæ–‡ä»¶ä¸­ï¼Œå¹¶åªåœ¨ iOS ç‰ˆæœ¬çš„åº”ç”¨ä¸­åŒ…å«è¿™äº›æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "When you canâ€™t isolate the code to separate source files, use conditional statements such as the ones below to offer a different code path for visionOS and iOS. The following example shows how to configure conditional statements to execute separate code paths in visionOS and iOS:": {
      "zh": "å¦‚æœæ— æ³•å°†ä»£ç éš”ç¦»åˆ°å•ç‹¬çš„æºæ–‡ä»¶ä¸­ï¼Œå¯ä½¿ç”¨æ¡ä»¶è¯­å¥ï¼ˆå¦‚ä¸‹é¢çš„è¯­å¥ï¼‰ä¸º visionOS å’Œ iOS æä¾›ä¸åŒçš„ä»£ç è·¯å¾„ã€‚ä¸‹é¢çš„ç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•é…ç½®æ¡ä»¶è¯­å¥ï¼Œä»¥ä¾¿åœ¨ visionOS å’Œ iOS ä¸­æ‰§è¡Œä¸åŒçš„ä»£ç è·¯å¾„ï¼š",
      "tips": ""
    },
    "The following frameworks are available in the iOS SDK but not in the visionOS SDK.": {
      "zh": "ä»¥ä¸‹æ¡†æ¶åœ¨ iOS SDK ä¸­å¯ç”¨ï¼Œä½†åœ¨ visionOS SDK ä¸­ä¸å¯ç”¨ã€‚",
      "tips": ""
    },
    "ActivityKit": {
      "zh": "ActivityKit",
      "tips": ""
    },
    "AdSupport": {
      "zh": "AdSupport",
      "tips": ""
    },
    "AppClip": {
      "zh": "AppClip",
      "tips": ""
    },
    "AutomatedDeviceEnrollment": {
      "zh": "AutomatedDeviceEnrollment",
      "tips": ""
    },
    "BusinessChat": {
      "zh": "BusinessChat",
      "tips": ""
    },
    "CarKey": {
      "zh": "CarKey",
      "tips": ""
    },
    "CarPlay": {
      "zh": "CarPlay",
      "tips": ""
    },
    "Cinematic": {
      "zh": "Cinematic",
      "tips": ""
    },
    "ClockKit": {
      "zh": "ClockKit",
      "tips": ""
    },
    "CoreLocationUI": {
      "zh": "CoreLocationUI",
      "tips": ""
    },
    "CoreMediaIO": {
      "zh": "CoreMediaIO",
      "tips": ""
    },
    "CoreNFC": {
      "zh": "CoreNFC",
      "tips": ""
    },
    "CoreTelephony": {
      "zh": "CoreTelephony",
      "tips": ""
    },
    "DeviceActivity": {
      "zh": "DeviceActivity",
      "tips": ""
    },
    "DockKit": {
      "zh": "DockKit",
      "tips": ""
    },
    "ExposureNotification": {
      "zh": "ExposureNotification",
      "tips": ""
    },
    "FamilyControls": {
      "zh": "FamilyControls",
      "tips": ""
    },
    "FinanceKit": {
      "zh": "FinanceKit",
      "tips": ""
    },
    "FinanceKitUI": {
      "zh": "FinanceKitUI",
      "tips": ""
    },
    "ManagedSettings": {
      "zh": "ManagedSettings",
      "tips": ""
    },
    "ManagedSettingsUI": {
      "zh": "ManagedSettingsUI",
      "tips": ""
    },
    "Messages": {
      "zh": "Messages",
      "tips": ""
    },
    "MLCompute": {
      "zh": "MLCompute",
      "tips": ""
    },
    "NearbyInteraction": {
      "zh": "NearbyInteraction",
      "tips": ""
    },
    "OpenAL": {
      "zh": "OpenAL",
      "tips": ""
    },
    "ProximityReader": {
      "zh": "ProximityReader",
      "tips": ""
    },
    "RoomPlan": {
      "zh": "RoomPlan",
      "tips": ""
    },
    "SafetyKit": {
      "zh": "SafetyKit",
      "tips": ""
    },
    "ScreenTime": {
      "zh": "ScreenTime",
      "tips": ""
    },
    "SensorKit": {
      "zh": "SensorKit",
      "tips": ""
    },
    "ServiceManagement": {
      "zh": "ServiceManagement",
      "tips": ""
    },
    "Social": {
      "zh": "Social",
      "tips": ""
    },
    "Twitter": {
      "zh": "Twitter",
      "tips": ""
    },
    "WidgetKit": {
      "zh": "WidgetKit",
      "tips": ""
    },
    "WorkoutKit": {
      "zh": "WorkoutKit",
      "tips": ""
    },
    "Some frameworks have behavioral changes that impact your app in visionOS, and some frameworks disable features when the required hardware is unavailable. To help you avoid using APIs for missing features, many frameworks offer APIs to check the availability of those features. Continue to use those APIs and take appropriate actions when the features arenâ€™t available. In other cases, be prepared for the framework code to do nothing or to generate errors when you use it.": {
      "zh": "æœ‰äº›æ¡†æ¶çš„è¡Œä¸ºå˜åŒ–ä¼šå½±å“ä½ çš„ visionOS åº”ç”¨ï¼Œæœ‰äº›æ¡†æ¶ä¼šåœ¨æ‰€éœ€ç¡¬ä»¶åœ¨å½“å‰å¹³å°ä¸å¯ç”¨æ—¶ç¦ç”¨åŠŸèƒ½ã€‚ä¸ºäº†å¸®åŠ©ä½ é¿å…ä½¿ç”¨ç¼ºå¤±åŠŸèƒ½çš„ APIï¼Œè®¸å¤šæ¡†æ¶éƒ½æä¾›äº†æ£€æŸ¥åŠŸèƒ½å¯ç”¨æ€§çš„ APIã€‚ç»§ç»­ä½¿ç”¨è¿™äº› APIï¼Œå¹¶åœ¨åŠŸèƒ½ä¸å¯ç”¨æ—¶é‡‡å–é€‚å½“çš„æªæ–½ã€‚è€Œåœ¨ä½¿ç”¨æ²¡æœ‰æ£€æŸ¥å¯ç”¨æ€§çš„æ¡†æ¶æ—¶ï¼Œè¯·åšå¥½æ¡†æ¶ä»£ç å¤±æ•ˆæˆ–æŠ¥é”™çš„å‡†å¤‡ã€‚",
      "tips": ""
    },
    "ARKit. This framework requires you to use different APIs for iOS and visionOS. For more information, see Bringing your ARKit app to visionOS.": {
      "zh": "ARKitã€‚æ­¤æ¡†æ¶è¦æ±‚ä½ ä¸º iOS å’Œ visionOS ä½¿ç”¨ä¸åŒçš„ APIã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…å°† ARKit åº”ç”¨ç§»æ¤åˆ° visionOSã€‚",
      "tips": ""
    },
    "AutomaticAssessmentConfiguration. The framework returns an error if you try to start a test in visionOS.": {
      "zh": "AutomaticAssessmentConfigurationã€‚å¦‚æœä½ å°è¯•åœ¨ visionOS ä¸­å¯åŠ¨æµ‹è¯•ï¼Œè¯¥æ¡†æ¶ä¼šè¿”å›é”™è¯¯ã€‚",
      "tips": ""
    },
    "AVFoundation. Capture interfaces arenâ€™t available in visionOS. Use availability checks to determine which services are present.": {
      "zh": "AVFoundationã€‚æˆªå±æ¥å£åœ¨ visionOS ä¸­ä¸å¯ç”¨ã€‚è¯·ä½¿ç”¨å¯ç”¨æ€§æ£€æŸ¥æ¥ç¡®å®šå“ªäº›æœåŠ¡å¯ç”¨ã€‚",
      "tips": ""
    },
    "CallKit. You may continue to offer Voice-over-IP (VoIP) services, but phone number verification, call-blocking, and other cellular-related services are unavailable.": {
      "zh": "CallKitã€‚ä½ å¯ä»¥ç»§ç»­æä¾› Voice-over-IP (VoIP) æœåŠ¡ï¼Œä½†ç”µè¯å·ç éªŒè¯ã€å‘¼å«é˜»æ–­å’Œå…¶ä»–èœ‚çªç›¸å…³æœåŠ¡ä¸å¯ç”¨ã€‚",
      "tips": ""
    },
    "ClockKit. The APIs of this framework do nothing in visionOS.": {
      "zh": "ClockKitã€‚è¯¥æ¡†æ¶çš„ API åœ¨ visionOS ä¸­ä¸èµ·ä½œç”¨ã€‚",
      "tips": ""
    },
    "CoreHaptics. visionOS plays audio feedback instead of haptic feedback.": {
      "zh": "CoreHapticsã€‚visionOS ä½¿ç”¨éŸ³é¢‘åé¦ˆè€Œéè§¦è§‰åé¦ˆã€‚",
      "tips": ""
    },
    "CoreLocation. You can request someoneâ€™s location using the standard location service, but most other services are unavailable. Use availability checks to determine which services are present. The Always authorization level is unavailable and automatically becomes When in Use authorization.": {
      "zh": "CoreLocationã€‚ ä½ å¯ä»¥ä½¿ç”¨æ ‡å‡†å®šä½æœåŠ¡è¯·æ±‚æŸäººçš„ä½ç½®ï¼Œä½†å¤§å¤šæ•°å…¶ä»–æœåŠ¡éƒ½ä¸å¯ç”¨ã€‚è¯·ä½¿ç”¨å¯ç”¨æ€§æ£€æŸ¥ç¡®è®¤å“ªäº›æœåŠ¡å¯ç”¨ã€‚â€œå§‹ç»ˆâ€æˆæƒçº§åˆ«ä¸å¯ç”¨ï¼Œä¼šè‡ªåŠ¨å˜ä¸ºâ€œä½¿ç”¨ä¸­â€æˆæƒã€‚",
      "tips": ""
    },
    "CoreMotion. Barometer data is unavailable, but most other sensors are available. Use availability checks to determine which sensors you can use.": {
      "zh": "CoreMotionã€‚ æ°”å‹è®¡æ•°æ®ä¸å¯ç”¨ï¼Œä½†å¤§å¤šæ•°å…¶ä»–ä¼ æ„Ÿå™¨å¯ç”¨ã€‚ä½¿ç”¨å¯ç”¨æ€§æ£€æŸ¥æ¥ç¡®è®¤å“ªäº›ä¼ æ„Ÿå™¨å¯ä»¥ä½¿ç”¨ã€‚",
      "tips": ""
    },
    "HealthKit and HealthKitUI. Health data is unavailable. Use availability checks to determine when information is available.": {
      "zh": "HealthKit å’Œ HealthKitUIã€‚å¥åº·æ•°æ®ä¸å¯ç”¨ã€‚ä½¿ç”¨å¯ç”¨æ€§æ£€æŸ¥ç¡®è®¤ä¿¡æ¯ä½•æ—¶å¯ç”¨ã€‚",
      "tips": ""
    },
    "MapKit. User-tracking features that involve heading information arenâ€™t available.": {
      "zh": "MapKitã€‚æ¶‰åŠèˆªå‘ä¿¡æ¯çš„ç”¨æˆ·è·Ÿè¸ªåŠŸèƒ½ä¸å¯ç”¨ã€‚",
      "tips": ""
    },
    "MediaPlayer. Some APIs are unavailable in visionOS.": {
      "zh": "MediaPlayerã€‚æŸäº› API åœ¨ visionOS ä¸­ä¸å¯ç”¨ã€‚",
      "tips": ""
    },
    "MetricKit. You can gather on-device diagnostic logs and generate reports, but you canâ€™t gather metrics.": {
      "zh": "MetricKitã€‚ä½ å¯ä»¥æ”¶é›†è®¾å¤‡ä¸Šçš„è¯Šæ–­æ—¥å¿—å¹¶ç”ŸæˆæŠ¥å‘Šï¼Œä½†æ— æ³•æ”¶é›†æŒ‡æ ‡ã€‚",
      "tips": ""
    },
    "MusicKit. Some APIs are unavailable in visionOS.": {
      "zh": "MusicKitã€‚æŸäº› API åœ¨ visionOS ä¸­ä¸å¯ç”¨ã€‚",
      "tips": ""
    },
    "NearbyInteraction. The framework does nothing in visionOS. Use availability checks to determine when services are present.": {
      "zh": "NearbyInteractionã€‚è¯¥æ¡†æ¶åœ¨ visionOS ä¸­ä¸èµ·ä½œç”¨ã€‚ä½¿ç”¨å¯ç”¨æ€§æ£€æŸ¥æ¥ç¡®è®¤æœåŠ¡æ˜¯å¦å­˜åœ¨ã€‚",
      "tips": ""
    },
    "PushToTalk. Push to Talk services are unavailable. Check for errors when creating a PTChannelManager.": {
      "zh": "PushToTalkã€‚ä¸€é”®é€šè¯æœåŠ¡ä¸å¯ç”¨ã€‚è¯·æ£€æŸ¥åˆ›å»º PTChannelManager æ—¶çš„é”™è¯¯ã€‚",
      "tips": ""
    },
    "SafariServices. A link that presents a SFSafariViewController now opens a new scene in the Safari app.": {
      "zh": "SafariServicesã€‚æ˜¾ç¤º SFSafariViewController çš„é“¾æ¥ä¼šåœ¨ Safari åº”ç”¨ç¨‹åºä¸­æ‰“å¼€ä¸€ä¸ªæ–°åœºæ™¯ã€‚",
      "tips": ""
    },
    "UIKit. The system reports a maximum of two simultaneous touch inputs â€”Â one for each of the personâ€™s hands. All system gesture recognizers handle these inputs correctly, including for zoom and rotation gestures that require multiple fingers. If you have custom gesture recognizers that require more than two fingers, update them to support only one or two touches in visionOS.": {
      "zh": "UIKitã€‚ ç³»ç»Ÿæœ€å¤šå¯åŒæ—¶åé¦ˆä¸¤ä¸ªè§¦æ§è¾“å…¥ - åŒæ‰‹å„ä¸€ä¸ªã€‚æ‰€æœ‰ç³»ç»Ÿæ‰‹åŠ¿è¯†åˆ«å™¨éƒ½èƒ½æ­£ç¡®å¤„ç†è¿™äº›è¾“å…¥ï¼ŒåŒ…æ‹¬éœ€è¦å¤šæ‰‹æŒ‡æ“ä½œçš„ç¼©æ”¾å’Œæ—‹è½¬æ‰‹åŠ¿ã€‚å¦‚æœä½ æœ‰éœ€è¦ä¸¤ä¸ªæ‰‹æŒ‡ä»¥ä¸Šçš„è‡ªå®šä¹‰æ‰‹åŠ¿ï¼Œè¯·åœ¨ visionOS ä¸­å°†å…¶æ›´æ–°ä¸ºåªæœ‰ä¸€ä¸ªæˆ–ä¸¤ä¸ªè§¦æ§çš„æ‰‹åŠ¿ã€‚",
      "tips": ""
    },
    "VisionKit. The DataScannerViewController APIs are unavailable, but other features are still available.": {
      "zh": "VisionKitã€‚ DataScannerViewController API ä¸å¯ç”¨ï¼Œä½†å…¶ä»–åŠŸèƒ½ä»ç„¶å¯ç”¨ã€‚",
      "tips": ""
    },
    "WatchConnectivity. The framework supports connections only between an iPhone and Apple Watch. Use availability checks to determine when services are available.": {
      "zh": "WatchConnectivityã€‚è¯¥æ¡†æ¶ä»…æ”¯æŒ iPhone ä¸ Apple Watch ä¹‹é—´çš„è¿æ¥ã€‚ä½¿ç”¨å¯ç”¨æ€§æ£€æŸ¥ç¡®è®¤æœåŠ¡ä½•æ—¶å¯ç”¨ã€‚",
      "tips": ""
    },
    "For additional information about how to isolate code to the iOS version of your app, see Running code on a specific platform or OS version.": {
      "zh": "æœ‰å…³å¦‚ä½•å°†ä»£ç éš”ç¦»åˆ° iOS åº”ç”¨ç‰ˆæœ¬çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…åœ¨ç‰¹å®šå¹³å°æˆ–æ“ä½œç³»ç»Ÿç‰ˆæœ¬ä¸Šè¿è¡Œä»£ç ã€‚",
      "tips": ""
    },
    "Update your interface to take advantage of visionOS features": {
      "zh": "æ›´æ–°ç•Œé¢ä»¥æ›´å¥½åœ°åˆ©ç”¨ visionOS åŠŸèƒ½",
      "tips": ""
    },
    "After your existing code runs correctly in visionOS, look for ways to improve the experience you offer on the platform. In visionOS, you can display content using more than just windows. Think about ways to incorporate the following elements into your interface:": {
      "zh": "å½“ä½ çš„ç°æœ‰ä»£ç åœ¨ visionOS ä¸­æ­£å¸¸è¿è¡Œåï¼Œè¯·è®¾æ³•æ”¹å–„ä½ åœ¨è¯¥å¹³å°ä¸Šæä¾›çš„ä½“éªŒã€‚åœ¨ visionOS ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨çª—å£ä¹‹å¤–çš„æ–¹å¼æ¥æ˜¾ç¤ºå†…å®¹ã€‚è¯·è€ƒè™‘å¦‚ä½•å°†ä»¥ä¸‹å…ƒç´ èå…¥ä½ çš„ç•Œé¢ï¼š",
      "tips": ""
    },
    "Depth. Many SwiftUI and UIKit views use visual effects to add depth. Look for similar ways to incorporate depth into your own custom views.": {
      "zh": "æ·±åº¦ã€‚è®¸å¤š SwiftUI å’Œ UIKit è§†å›¾éƒ½ä½¿ç”¨è§†è§‰æ•ˆæœæ¥å¢åŠ æ·±åº¦ã€‚è¯·å¯»æ‰¾ç±»ä¼¼çš„æ–¹æ³•ï¼Œå°†æ·±åº¦å…ƒç´ èå…¥è¿›ä½ çš„è‡ªå®šä¹‰è§†å›¾ä¸­ã€‚",
      "tips": ""
    },
    "3D content. Think about where you might incorporate 3D models and shapes into your content. Use RealityKit to implement your content, and a RealityView to present that content from your app. See Adding 3D content to your app.": {
      "zh": "3D å†…å®¹ã€‚æƒ³æƒ³åœ¨å“ªäº›å†…å®¹ä¸­å¯ä»¥åŠ å…¥ 3D æ¨¡å‹å’Œå½¢çŠ¶ã€‚ä½¿ç”¨ RealityKit å®ç°ä½ çš„å†…å®¹ï¼Œå¹¶ä½¿ç”¨ RealityView ä»ä½ çš„åº”ç”¨ä¸­å±•ç¤ºè¿™äº›å†…å®¹ã€‚è¯·å‚é˜…åœ¨åº”ç”¨ä¸­æ·»åŠ  3D å†…å®¹ã€‚",
      "tips": ""
    },
    "Immersive experiences. Present a space to immerse someone in your appâ€™s content. Spaces let you place content anywhere in a personâ€™s surroundings. You can also create fully immersive experiences that display only your appâ€™s content. See Creating fully immersive experiences in your app.": {
      "zh": "æ²‰æµ¸å¼ä½“éªŒã€‚æ˜¾ç¤ºä¸€ä¸ªç©ºé—´ï¼Œè®©ç”¨æˆ·æ²‰æµ¸åœ¨ä½ çš„åº”ç”¨å†…å®¹ä¸­ã€‚ç©ºé—´å¯ä»¥è®©ä½ å°†å†…å®¹å‘ˆç°åœ¨ç”¨æˆ·å‘¨å›´çš„ä»»ä½•åœ°æ–¹ã€‚ä½ è¿˜å¯ä»¥åˆ›å»ºåªæ˜¾ç¤ºå½“å‰åº”ç”¨å†…å®¹çš„å®Œå…¨æ²‰æµ¸å¼ä½“éªŒã€‚è¯·å‚é˜…åœ¨åº”ç”¨ä¸­åˆ›å»ºå®Œå…¨æ²‰æµ¸å¼ä½“éªŒã€‚",
      "tips": ""
    },
    "Interactions with someoneâ€™s surroundings. Use ARKit to facilitate interactions between your content and the surroundings. For example, detect planar surfaces to use as anchor points for your content. See ARKit.": {
      "zh": "ä¸å‘¨å›´ç¯å¢ƒçš„äº’åŠ¨ã€‚ä½¿ç”¨ ARKit å¯ä¿ƒè¿›ä½ çš„å†…å®¹ä¸å‘¨å›´ç¯å¢ƒä¹‹é—´çš„äº’åŠ¨ã€‚ä¾‹å¦‚ï¼Œæ£€æµ‹å¹³é¢ä»¥ç”¨ä½œå†…å®¹çš„é”šç‚¹ã€‚è¯·å‚é˜… ARKitã€‚",
      "tips": ""
    },
    "If you built your interface using UIKit, you can still load iOS storyboards into your app, but you canâ€™t customize your interface for visionOS or include 3D content. To include visionOS content in your app, programmatically add your SwiftUI views using UIHostingController or UIViewRepresentable. Alternatively, migrate the relevant parts of your interface to SwiftUI. Moving your interface to SwiftUI gives you less code to maintain and makes it easier to validate that your interface does what you want.": {
      "zh": "å¦‚æœä½ ä½¿ç”¨ UIKit æ„å»ºäº†ç•Œé¢ï¼Œä½ ä»å¯å°† iOS æ•…äº‹æ¿åŠ è½½åˆ°ä½ çš„åº”ç”¨ä¸­ï¼Œä½†æ— æ³•ä¸º visionOS å®šåˆ¶ç•Œé¢æˆ–åŒ…å« 3D å†…å®¹ã€‚è¦åœ¨åº”ç”¨ä¸­åŒ…å« visionOS å†…å®¹ï¼Œè¯·ä½¿ç”¨ UIHostingController æˆ– UIViewRepresentable ä»¥ç¼–ç¨‹æ–¹å¼æ·»åŠ  SwiftUI è§†å›¾ã€‚åˆæˆ–è€…ï¼Œå°†ç•Œé¢çš„ç›¸å…³éƒ¨åˆ†è¿ç§»åˆ° SwiftUIã€‚å°†ç•Œé¢è¿ç§»åˆ° SwiftUI ä¼šå‡å°‘éœ€è¦ç»´æŠ¤çš„ä»£ç ï¼Œå¹¶æ›´å®¹æ˜“éªŒè¯ä½ çš„ç•Œé¢æ˜¯å¦æŒ‰ä½ çš„éœ€æ±‚è¿è¡Œã€‚",
      "tips": ""
    },
    "For information about mixing SwiftUI and UIKit content, see UIKit integration in SwiftUI. For guidance on how best to incorporate depth and 3D elements in your interface, see Human Interface Guidelines.": {
      "zh": "å…³äºåŒæ—¶ä½¿ç”¨ SwiftUI å’Œ UIKit å†…å®¹çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… SwiftUI ä¸­çš„ UIKit é›†æˆã€‚æœ‰å…³å¦‚ä½•æœ€å¥½åœ°åœ¨ç•Œé¢ä¸­èå…¥æ·±åº¦å’Œ 3D å…ƒç´ çš„æŒ‡å—ï¼Œè¯·å‚é˜…äººæœºç•Œé¢æŒ‡å—ã€‚",
      "tips": ""
    },
    "Update your appâ€™s assets": {
      "zh": "æ›´æ–°åº”ç”¨çš„ç´ æèµ„æº",
      "tips": ""
    },
    "Add vector-based or high-resolution images to your project specifically to support visionOS. In visionOS, people can view your appâ€™s content at different angles and different distances, so image pixels rarely line up with screen pixels. Vector-based images work best because they maintain their detail and crispness at any size. For bitmap-based images, use high-resolution images (@2x or better) to ensure your images retain detail at different sizes.": {
      "zh": "åœ¨ä½ çš„é¡¹ç›®ä¸­æ·»åŠ åŸºäºçŸ¢é‡æˆ–é«˜åˆ†è¾¨ç‡çš„å›¾åƒï¼Œä»¥ä¸“é—¨æ”¯æŒ visionOSã€‚åœ¨ visionOS ä¸­ï¼Œç”¨æˆ·å¯ä»¥ä»ä¸åŒè§’åº¦å’Œä¸åŒè·ç¦»è§‚çœ‹åº”ç”¨çš„å†…å®¹ï¼Œå› æ­¤å›¾åƒåƒç´ å¾ˆå°‘ä¸å±å¹•åƒç´ å¯¹é½ã€‚åŸºäºçŸ¢é‡çš„å›¾åƒæ•ˆæœæœ€ä½³ï¼Œå› ä¸ºå®ƒä»¬åœ¨ä»»ä½•å°ºå¯¸ä¸‹éƒ½èƒ½ä¿æŒç»†èŠ‚å’Œæ¸…æ™°åº¦ã€‚å¯¹äºä½å›¾å›¾åƒï¼Œè¯·ä½¿ç”¨é«˜åˆ†è¾¨ç‡å›¾åƒï¼ˆ@2x æˆ–æ›´é«˜ï¼‰ï¼Œä»¥ç¡®ä¿å›¾åƒåœ¨ä¸åŒå°ºå¯¸ä¸‹éƒ½èƒ½ä¿æŒç»†èŠ‚ã€‚",
      "tips": ""
    },
    "For more information about designing images for your app, see Images in Human Interface Guidelines.": {
      "zh": "æœ‰å…³ä¸ºåº”ç”¨è®¾è®¡å›¾åƒçš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…äººæœºç•Œé¢æŒ‡å—ä¸­çš„å›¾åƒç« èŠ‚ã€‚",
      "tips": ""
    },
    "Decide whether to port your app at all": {
      "zh": "å†³å®šæ˜¯å¦ç§»æ¤åº”ç”¨",
      "tips": ""
    },
    "In some cases, it might not make sense to port your app for visionOS. For example, donâ€™t port the following types of apps:": {
      "zh": "åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå°†åº”ç”¨ç§»æ¤åˆ° visionOS å¯èƒ½å¹¶ä¸åˆç†ã€‚ä¾‹å¦‚ï¼Œè¯·å‹¿ç§»æ¤ä»¥ä¸‹ç±»å‹çš„åº”ç”¨ï¼š",
      "tips": ""
    },
    "Apps that act as containers for app extensions. This includes apps where the primary purpose is to deliver custom keyboard extensions, device drivers, sticker packs, SMS and MMS message filtering extensions, call directory extensions, or widgets.": {
      "zh": "ä½œä¸ºåº”ç”¨æ‰©å±•ä¿¡æ¯å®¹å™¨çš„åº”ç”¨ã€‚è¿™åŒ…æ‹¬äº†ä¸»è¦ç›®çš„æ˜¯æä¾›è‡ªå®šä¹‰é”®ç›˜æ‰©å±•ã€è®¾å¤‡é©±åŠ¨ç¨‹åºã€è´´çº¸åŒ…ã€çŸ­ä¿¡å’Œå½©ä¿¡è¿‡æ»¤æ‰©å±•ã€é€šè¯ç›®å½•æ‰©å±•æˆ–å°ç»„ä»¶çš„åº”ç”¨ã€‚",
      "tips": ""
    },
    "Movement-based apps. This includes apps that follow a personâ€™s location changes, such as apps that offer turn-by-turn directions or navigation. It also includes apps that track body movements.": {
      "zh": "åŸºäºè¿åŠ¨çš„åº”ç”¨ã€‚è¿™åŒ…æ‹¬äº†è¿½è¸ªç”¨æˆ·ä½ç½®å˜åŒ–çš„åº”ç”¨ç¨‹åºï¼Œå¦‚æä¾›è½¬å¼¯æŒ‡ç¤ºæˆ–å¯¼èˆªçš„åº”ç”¨ç¨‹åºã€‚ä¹ŸåŒ…æ‹¬äº†è¿½è¸ªèº«ä½“è¿åŠ¨çš„åº”ç”¨ç¨‹åºã€‚",
      "tips": ""
    },
    "Selfie or photography apps. This includes apps where the primary purpose is to capture images or video from the deviceâ€™s cameras.": {
      "zh": "è‡ªæ‹æˆ–æ‘„å½±ç±»åº”ç”¨ã€‚è¿™åŒ…æ‹¬ä»¥é€šè¿‡è®¾å¤‡æ‘„åƒå¤´æ•æ‰å›¾åƒæˆ–è§†é¢‘ä¸ºä¸»è¦ç›®çš„çš„åº”ç”¨ç¨‹åºã€‚",
      "tips": ""
    },
    "If your app uses an unsupported feature but can function without it, you can still bring your app to visionOS. Remove features that arenâ€™t available and focus on bringing the rest of your content to the platform. For example, if you have an app that lets people write down notes and take pictures to include with those notes, disable the picture-taking ability in visionOS but let people add text and incorporate images they already have.": {
      "zh": "å¦‚æœä½ çš„åº”ç”¨ä½¿ç”¨äº†ä¸æ”¯æŒçš„åŠŸèƒ½ï¼Œä½†åœ¨æ²¡æœ‰è¯¥åŠŸèƒ½çš„æƒ…å†µä¸‹ä¹Ÿèƒ½æ­£å¸¸è¿è¡Œï¼Œä½ ä»ç„¶å¯ä»¥å°†åº”ç”¨ç§»æ¤åˆ° visionOS ä¸­ã€‚ç§»é™¤ä¸æ”¯æŒçš„åŠŸèƒ½ï¼Œå¹¶ä¸“æ³¨äºå°†å…¶ä»–å†…å®¹ç§»æ¤åˆ°è¯¥å¹³å°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ æœ‰ä¸€æ¬¾åº”ç”¨å¯ä»¥è®©ç”¨æˆ·å†™ä¸‹ç¬”è®°å¹¶æ‹ç…§æ”¾åœ¨ç¬”è®°ä¸­ï¼Œé‚£ä¹ˆä½ å¯ä»¥åœ¨ visionOS ä¸­ç¦ç”¨æ‹ç…§åŠŸèƒ½ï¼Œä½†å…è®¸ç”¨æˆ·æ·»åŠ æ–‡å­—å¹¶æ•´åˆå·²æœ‰çš„å›¾ç‰‡ã€‚",
      "tips": ""
    }
  },
  "visionos/bringing-your-arkit-app-to-visionos": {
    "Bringing your ARKit app to visionOS": {
      "zh": "å°† ARKit åº”ç”¨ç§»æ¤åˆ° visionOS",
      "tips": ""
    },
    "Update an iPadOS or iOS app that uses ARKit, and provide an equivalent experience in visionOS.": {
      "zh": "æ›´æ–°ä½¿ç”¨äº† ARKit çš„ iPadOS æˆ– iOS åº”ç”¨ï¼Œå¹¶åœ¨ visionOS ä¸­æä¾›ç›¸åŒçš„ä½“éªŒã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "If you use ARKit to create an augmented reality experience on iPhone or iPad, you need to rethink your use of that technology when bringing your app to visionOS. ARKit plays a crucial role in delivering your content to the display in iPadOS and iOS. In visionOS, you use ARKit only to acquire data about the personâ€™s surroundings, and you do so using a different set of APIs.": {
      "zh": "å¦‚æœä½ ä½¿ç”¨ ARKit åœ¨ iPhone æˆ– iPad ä¸Šåˆ›å»ºå¢å¼ºç°å®ä½“éªŒï¼Œé‚£ä¹ˆåœ¨å°†ä½ çš„åº”ç”¨ç§»æ¤åˆ° visionOS æ—¶ï¼Œä½ éœ€è¦é‡æ–°è€ƒè™‘å¯¹è¯¥æŠ€æœ¯çš„ä½¿ç”¨ã€‚åœ¨ iPadOS å’Œ iOS ä¸­ï¼ŒARKit åœ¨å‘æ˜¾ç¤ºå±äº¤ä»˜å†…å®¹æ–¹é¢å‘æŒ¥ç€è‡³å…³é‡è¦çš„ä½œç”¨ã€‚è€Œåœ¨ visionOS ä¸­ï¼Œä½ åªèƒ½ä½¿ç”¨ ARKit æ¥è·å–æœ‰å…³ç”¨æˆ·å‘¨å›´ç¯å¢ƒçš„æ•°æ®ï¼Œè€Œä¸”ä½¿ç”¨çš„æ˜¯ä¸€å¥—ä¸åŒçš„ APIã€‚",
      "tips": ""
    },
    "In visionOS, you donâ€™t need a special view to display an augmented reality interface. Build windows with your appâ€™s content using SwiftUI or UIKit. When you display those windows, visionOS places them in the personâ€™s surroundings for you. If you want to control the placement of any 2D or 3D content in the personâ€™s surroundings, build your content using SwiftUI and RealityKit.": {
      "zh": "åœ¨ visionOS ä¸­ï¼Œä½ ä¸éœ€è¦ä¸€ä¸ªç‰¹æ®Šçš„è§†å›¾æ¥æ˜¾ç¤ºå¢å¼ºç°å®ç•Œé¢ã€‚ä½ åªéœ€ä½¿ç”¨ SwiftUI æˆ– UIKit æ„å»ºåŒ…å«åº”ç”¨å†…å®¹çš„çª—å£ã€‚å½“ä½ æ˜¾ç¤ºè¿™äº›çª—å£æ—¶ï¼ŒvisionOS ä¼šä¸ºä½ å°†å®ƒä»¬æ”¾ç½®åœ¨ç”¨æˆ·çš„å‘¨å›´ç¯å¢ƒä¸­ã€‚å¦‚æœä½ æƒ³æ§åˆ¶ç”¨æˆ·çš„å‘¨å›´ç¯å¢ƒä¸­ä»»æ„ 2D æˆ– 3D å†…å®¹çš„ä½ç½®ï¼Œè¯·ä½¿ç”¨ SwiftUI å’Œ RealityKit æ„å»ºä½ çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "When migrating your app to visionOS, reuse as much of your appâ€™s existing content as you can. visionOS supports most of the same technologies as iOS, so you can reuse project assets, 3D models, and most custom views. Donâ€™t reuse your appâ€™s ARKit code or any code that relies on technologies visionOS doesnâ€™t support.": {
      "zh": "åœ¨å°†åº”ç”¨è¿ç§»åˆ° visionOS æ—¶ï¼Œè¯·å°½å¯èƒ½å¤šåœ°å¤ç”¨åº”ç”¨çš„å½“å‰å†…å®¹ã€‚visionOS æ”¯æŒä¸ iOS ç›¸åŒçš„å¤§å¤šæ•°æŠ€æœ¯ï¼Œå› æ­¤ä½ å¯ä»¥é‡å¤ä½¿ç”¨é¡¹ç›®ç´ æã€3D æ¨¡å‹å’Œå¤§å¤šæ•°è‡ªå®šä¹‰è§†å›¾ã€‚ä½†ä¸è¦å¤ç”¨åº”ç”¨çš„ ARKit ä»£ç æˆ–ä»»ä½•ä¾èµ–äº visionOS å¹³å°ä¸æ”¯æŒæŠ€æœ¯çš„ä»£ç ã€‚",
      "tips": ""
    },
    "For general guidance on how to port apps to visionOS, see Bringing your existing apps to visionOS.": {
      "zh": "æœ‰å…³å¦‚ä½•å°†åº”ç”¨ç§»æ¤åˆ° visionOS çš„ä¸€èˆ¬æŒ‡å¯¼ï¼Œè¯·å‚é˜…å°†ç°æœ‰åº”ç”¨ç§»æ¤åˆ° visionOSã€‚",
      "tips": ""
    },
    "Adopt technologies available in both iOS and visionOS": {
      "zh": "é‡‡ç”¨ iOS å’Œ visionOS å…¼å®¹çš„æŠ€æœ¯",
      "tips": ""
    },
    "To create a single app that runs in both iOS and visionOS, use technologies that are available on both platforms. While ARKit in iOS lets you create your interface using several different technologies, the preferred technologies in visionOS are SwiftUI and RealityKit. If youâ€™re not currently using RealityKit for 3D content, consider switching to it before you start adding visionOS support. If you retain code that uses older technologies in your iOS app, you might need to re-create much of that code using RealityKit when migrating to visionOS.": {
      "zh": "è¦åˆ›å»ºä¸€ä¸ªæ—¢å¯åœ¨ iOS åˆå¯ä»¥åœ¨ visionOS ä¸­è¿è¡Œçš„åº”ç”¨ï¼Œè¯·ä½¿ç”¨ä¸¤ä¸ªå¹³å°ä¸Šå…¼å®¹çš„æŠ€æœ¯ã€‚iOS ä¸­çš„ ARKit å¯è®©ä½ ä½¿ç”¨å¤šç§ä¸åŒçš„æŠ€æœ¯åˆ›å»ºç•Œé¢ï¼Œè€Œ visionOS ä¸­çš„é¦–é€‰æŠ€æœ¯æ˜¯ SwiftUI å’Œ RealityKitã€‚å¦‚æœä½ ç›®å‰æ²¡æœ‰ä½¿ç”¨ RealityKit æ¥åˆ¶ä½œ 3D å†…å®¹ï¼Œè¯·è€ƒè™‘åœ¨å¼€å§‹æ·»åŠ  visionOS æ”¯æŒä¹‹å‰åˆ‡æ¢åˆ° RealityKitã€‚å¦‚æœä½ çš„ iOS åº”ç”¨ä¸­ä¿ç•™äº†ä½¿ç”¨æ—§æŠ€æœ¯çš„ä»£ç ï¼Œé‚£ä¹ˆåœ¨è¿ç§»åˆ° visionOS æ—¶ï¼Œä½ å¯èƒ½éœ€è¦ä½¿ç”¨ RealityKit é‡æ–°åˆ›å»ºå…¶ä¸­çš„å¤§éƒ¨åˆ†ä»£ç ã€‚",
      "tips": ""
    },
    "If you use Metal to draw your appâ€™s content, you can bring your code to visionOS to create content for 2D views or to create fully immersive experiences. You canâ€™t use Metal to create 3D content that integrates with the personâ€™s surroundings. This restriction prevents apps from sampling pixels of the personâ€™s surroundings, which might contain sensitive information. For information on how to create a fully immersive experience with Metal, see Drawing fully immersive content using Metal.": {
      "zh": "å¦‚æœä½ ä½¿ç”¨ Metal ç»˜åˆ¶åº”ç”¨çš„å†…å®¹ï¼Œä½ å¯ä»¥å°†ä»£ç ç§»æ¤åˆ° visionOSï¼Œä¸º 2D è§†å›¾åˆ›å»ºå†…å®¹æˆ–åˆ›å»ºå®Œå…¨æ²‰æµ¸å¼ä½“éªŒã€‚ä½ ä¸èƒ½ä½¿ç”¨ Metal åˆ›å»ºä¸ç”¨æˆ·å‘¨å›´ç¯å¢ƒç›¸èåˆçš„ 3D å†…å®¹ã€‚è¿™ä¸€é™åˆ¶å¯é˜²æ­¢åº”ç”¨å¯¹ç”¨æˆ·å‘¨å›´ç¯å¢ƒçš„åƒç´ è¿›è¡Œé‡‡æ ·ï¼Œå› ä¸ºè¿™äº›åƒç´ å¯èƒ½åŒ…å«æ•æ„Ÿä¿¡æ¯ã€‚æœ‰å…³å¦‚ä½•ä½¿ç”¨ Metal åˆ›å»ºå®Œå…¨æ²‰æµ¸å¼ä½“éªŒçš„ä¿¡æ¯ï¼Œè¯·å‚é˜…ä½¿ç”¨ Metal ç»˜åˆ¶å®Œå…¨æ²‰æµ¸å¼å†…å®¹ã€‚",
      "tips": ""
    },
    "Convert 3D assets to the USDZ format": {
      "zh": "å°† 3D ç´ æè½¬æ¢ä¸º USDZ æ ¼å¼",
      "tips": ""
    },
    "The recommended format for 3D assets in iOS and visionOS is USDZ. This format offers a compact single file for everything, including your models, textures, behaviors, physics, anchoring, and more. If you have assets that donâ€™t use this format, use the Reality Converter tool that comes with Xcode to convert them for your project.": {
      "zh": "iOS å’Œ visionOS ä¸­ 3D ç´ æçš„æ¨èæ ¼å¼æ˜¯ USDZã€‚è¿™ç§æ ¼å¼ä¸ºæ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬æ¨¡å‹ã€çº¹ç†ã€è¡Œä¸ºã€ç‰©ç†ã€é”šç‚¹ç­‰ï¼‰æä¾›äº†ä¸€ä¸ªç´§å‡‘çš„å•ä¸€æ–‡ä»¶ã€‚å¦‚æœä½ çš„ç´ æä¸ä½¿ç”¨è¿™ç§æ ¼å¼ï¼Œè¯·ä½¿ç”¨ Xcode è‡ªå¸¦çš„ Reality Converter å·¥å…·ä¸ºä½ çš„é¡¹ç›®è¿›è¡Œè½¬æ¢ã€‚",
      "tips": ""
    },
    "When building 3D scenes for visionOS, use Reality Composer Pro to create your scenes that incorporate your USDZ assets. With Reality Composer Pro, you can import your USD files and edit them in place, nondestructively. If your iOS app applies custom materials to your assets, convert those materials to shader graphs in the app.": {
      "zh": "åœ¨ä¸º visionOS æ„å»º 3D åœºæ™¯æ—¶ï¼Œè¯·ä½¿ç”¨ Reality Composer Pro åˆ›å»ºåŒ…å« USDZ ç´ æçš„åœºæ™¯ã€‚ä½¿ç”¨ Reality Composer Proï¼Œä½ å¯ä»¥å¯¼å…¥ä½ çš„ USD æ–‡ä»¶ï¼Œå¹¶è¿›è¡Œæ— æŸçš„åŸè£…ç¼–è¾‘ã€‚å¦‚æœä½ çš„ iOS åº”ç”¨ä¸ºä½ çš„ç´ ææ·»åŠ äº†è‡ªå®šä¹‰æè´¨ï¼Œè¯·åœ¨åº”ç”¨ä¸­å°†è¿™äº›æè´¨è½¬æ¢ä¸ºç€è‰²å™¨å›¾å½¢ã€‚",
      "tips": ""
    },
    "Although you can bring models and materials to your project using USDZ files, you canâ€™t bring custom shaders you wrote using Metal. Replace any custom shader code with MaterialX shaders. Many digital content creation tools support the MaterialX standard, and let you create dynamic shaders and save them with your USDZ files. Reality Composer Pro and RealityKit support MaterialX shaders, and incorporate them with your other USDZ asset content. For more information about MaterialX, see https://materialx.org.": {
      "zh": "è™½ç„¶ä½ å¯ä»¥ä½¿ç”¨ USDZ æ–‡ä»¶å°†æ¨¡å‹å’Œæè´¨ç§»æ¤åˆ°é¡¹ç›®ï¼Œä½†ä½ æ— æ³•ç§»æ¤ä½¿ç”¨äº† Metal ç¼–å†™çš„è‡ªå®šä¹‰ç€è‰²å™¨ã€‚è¯·ä½¿ç”¨ MaterialX ç€è‰²å™¨æ›¿æ¢ä»»ä½•è‡ªå®šä¹‰ç€è‰²å™¨ä»£ç ã€‚è®¸å¤šæ•°å­—å†…å®¹åˆ›å»ºå·¥å…·éƒ½æ”¯æŒ MaterialX æ ‡å‡†ï¼Œå¯è®©ä½ åˆ›å»ºåŠ¨æ€ç€è‰²å™¨å¹¶å°†å…¶ä¸ USDZ æ–‡ä»¶ä¸€èµ·ä¿å­˜ã€‚Reality Composer Pro å’Œ RealityKit å‡æ”¯æŒ MaterialX ç€è‰²å™¨ï¼Œå¹¶å°†å®ƒä»¬ä¸å…¶ä»– USDZ ç´ æå†…å®¹ç»“åˆåœ¨ä¸€èµ·ã€‚æœ‰å…³ MaterialX çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… https://materialx.orgã€‚",
      "tips": ""
    },
    "Update your interface to support visionOS": {
      "zh": "æ›´æ–°ç•Œé¢ä»¥æ”¯æŒ visionOS",
      "tips": ""
    },
    "In visionOS, you manage your appâ€™s content, and the system handles the integration of that content with the personâ€™s surroundings. This approach differs from iOS, where you use a special ARKit view to blend your content and the live camera content. Bringing your interface to visionOS therefore means you need to remove this special ARKit view and focus only on your content.": {
      "zh": "åœ¨ visionOS ä¸­ï¼Œä½ è´Ÿè´£ç®¡ç†åº”ç”¨çš„å†…å®¹ï¼Œè€Œç³»ç»Ÿä¼šè´Ÿè´£å¤„ç†è¿™äº›å†…å®¹ä¸ç”¨æˆ·å‘¨å›´ç¯å¢ƒçš„æ•´åˆã€‚è¿™æ˜¯ä¸ iOS ä¸åŒçš„ä¸€ç‚¹ï¼šåœ¨ iOS ä¸­ï¼Œä½ ä½¿ç”¨ç‰¹æ®Šçš„ ARKit è§†å›¾å°†ä½ çš„å†…å®¹ä¸å®æ—¶æ‘„åƒå¤´å†…å®¹èåˆåœ¨ä¸€èµ·ã€‚å› æ­¤ï¼Œå°†ä½ çš„ç•Œé¢ç§»æ¤åˆ° visionOS æ„å‘³ç€ä½ éœ€è¦ç§»é™¤è¿™ä¸ªç‰¹æ®Šçš„ ARKit è§†å›¾ï¼Œå¹¶åªä¸“æ³¨äºä½ çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "If you can display your appâ€™s content using SwiftUI or UIKit views, build a window with those views and present it from your visionOS app. If you use other technologies to incorporate 2D or 3D content into the personâ€™s surroundings, make the following substitutions in the visionOS version of your app.": {
      "zh": "å¦‚æœä½ å¯ä»¥ä½¿ç”¨ SwiftUI æˆ– UIKit è§†å›¾æ¥æ˜¾ç¤ºåº”ç”¨çš„å†…å®¹ï¼Œé‚£ä¹ˆå°±ç”¨è¿™äº›è§†å›¾æ„å»ºä¸€ä¸ªçª—å£ï¼Œå¹¶ä»ä½ çš„ visionOS åº”ç”¨ä¸­å°†å…¶å‘ˆç°å‡ºæ¥ã€‚å¦‚æœä½ ä½¿ç”¨å…¶ä»–æŠ€æœ¯å°† 2D æˆ– 3D å†…å®¹èå…¥ç”¨æˆ·å‘¨å›´çš„ç¯å¢ƒï¼Œè¯·åœ¨ä½ çš„åº”ç”¨çš„ visionOS ç‰ˆæœ¬ä¸­è¿›è¡Œä»¥ä¸‹æ›¿æ¢ã€‚",
      "tips": ""
    },
    "If you create your AR experience using:": {
      "zh": "å¦‚æœä½ ä½¿ç”¨äº†ä»¥ä¸‹æ¡†æ¶åˆ›å»º AR ä½“éªŒï¼š",
      "tips": ""
    },
    "Update to:": {
      "zh": "æ›´æ–°ä¸ºï¼š",
      "tips": ""
    },
    "RealityKit and ARView": {
      "zh": "RealityKit å’Œ ARView",
      "tips": ""
    },
    "RealityKit and RealityView": {
      "zh": "RealityKit å’Œ RealityView",
      "tips": ""
    },
    "SceneKit and ARSCNView": {
      "zh": "SceneKit å’Œ ARSCNView",
      "tips": ""
    },
    "SpriteKit and ARSKView": {
      "zh": "SpriteKit å’Œ ARSKView",
      "tips": ""
    },
    "RealityKit or SwiftUI": {
      "zh": "RealityKit æˆ– SwiftUI",
      "tips": ""
    },
    "A RealityView is a SwiftUI view that manages the content and animations you create using RealityKit and Reality Composer Pro. You can add a RealityView to any of your appâ€™s windows to display 2D or 3D content. You can also add the view to an ImmersiveSpace scene, which you use to integrate your RealityKit content into the personâ€™s surroundings.": {
      "zh": "RealityView æ˜¯ä¸€ç§ SwiftUI è§†å›¾ï¼Œç”¨äºç®¡ç†ä½¿ç”¨ RealityKit å’Œ Reality Composer Pro åˆ›å»ºçš„å†…å®¹å’ŒåŠ¨ç”»ã€‚ä½ å¯ä»¥å°† RealityView æ·»åŠ åˆ°åº”ç”¨çš„ä»»ä½•çª—å£ä¸­ï¼Œä»¥æ˜¾ç¤º 2D æˆ– 3D å†…å®¹ã€‚ä½ è¿˜å¯ä»¥å°†è§†å›¾æ·»åŠ åˆ° ImmersiveSpace åœºæ™¯ä¸­ï¼Œç”¨æ¥å°† RealityKit å†…å®¹æ•´åˆåˆ°ç”¨æˆ·çš„å‘¨å›´ç¯å¢ƒä¸­ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨æ„",
      "tips": ""
    },
    "You can load iOS storyboards into a visionOS app, but you canâ€™t customize your interface for visionOS or include 3D content. If you want to share interface files between iOS and visionOS, adopt SwiftUI views or create your interface programmatically.": {
      "zh": "ä½ å¯ä»¥å°† iOS æ•…äº‹æ¿åŠ è½½åˆ° visionOS åº”ç”¨ä¸­ï¼Œä½†ä¸èƒ½ä¸º visionOS å®šåˆ¶ç•Œé¢æˆ–åŠ å…¥ 3D å†…å®¹ã€‚å¦‚æœä½ æƒ³åœ¨ iOS å’Œ visionOS ä¹‹é—´å…±äº«ç•Œé¢æ–‡ä»¶ï¼Œè¯·é‡‡ç”¨ SwiftUI è§†å›¾æˆ–ä»¥ç¼–ç¨‹æ–¹å¼åˆ›å»ºç•Œé¢ã€‚",
      "tips": ""
    },
    "For more information about how to use RealityView and respond to interactions with your content, see Adding 3D content to your app.": {
      "zh": "æœ‰å…³å¦‚ä½•ä½¿ç”¨ RealityView ä»¥åŠå¦‚ä½•å“åº”ä¸å†…å®¹äº¤äº’çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…åœ¨åº”ç”¨ä¸­æ·»åŠ  3D å†…å®¹ã€‚",
      "tips": ""
    },
    "Replace your ARKit code": {
      "zh": "æ›¿æ¢ ARKit ä»£ç ",
      "tips": ""
    },
    "ARKit provides different APIs for iOS and visionOS, and the way you use ARKit services on the platforms is also different. In iOS, you must use ARKit to put your content onscreen, and you can also use it to manage interactions between your content and a personâ€™s surroundings. In visionOS, the system puts your content onscreen, so you only use ARKit to manage interactions with the surroundings. Because of this more limited usage, some apps donâ€™t need ARKit at all in visionOS.": {
      "zh": "ARKit ä¸º iOS å’Œ visionOS æä¾›äº†ä¸åŒçš„ APIï¼Œåœ¨è¿™ä¸¤ä¸ªå¹³å°ä¸Šä½¿ç”¨ ARKit æœåŠ¡çš„æ–¹å¼ä¹Ÿæœ‰æ‰€ä¸åŒã€‚åœ¨ iOS ä¸­ï¼Œä½ éœ€è¦ä½¿ç”¨ ARKit å°†å†…å®¹æŠ•è‡³å±å¹•ä¸Šï¼Œä¹Ÿå¯ä»¥ç”¨å®ƒæ¥ç®¡ç†å†…å®¹ä¸ç”¨æˆ·å‘¨å›´ç¯å¢ƒä¹‹é—´çš„äº¤äº’ã€‚è€Œåœ¨ visionOS ä¸­ï¼Œç³»ç»Ÿä¼šå°†å†…å®¹æŠ•è‡³å±å¹•ï¼Œå› æ­¤ä½ ä»…ä½¿ç”¨ ARKit ç®¡ç†ä¸å‘¨å›´ç¯å¢ƒçš„äº¤äº’ã€‚ç”±äºè¿™ç§ä½¿ç”¨æ–¹å¼æ¯”è¾ƒæœ‰é™ï¼Œæœ‰äº›åº”ç”¨åœ¨ visionOS ä¸­å®Œå…¨ä¸éœ€è¦ ARKitã€‚",
      "tips": ""
    },
    "The only time you use ARKit in visionOS is when you need one of the following services:": {
      "zh": "åªæœ‰åœ¨éœ€è¦ä»¥ä¸‹æœåŠ¡æ—¶ï¼Œä½ æ‰ä¼šåœ¨ visionOS ä¸­ä½¿ç”¨ ARKitï¼š",
      "tips": ""
    },
    "Plane detection": {
      "zh": "å¹³é¢æ£€æµ‹",
      "tips": ""
    },
    "Image tracking": {
      "zh": "å›¾åƒè¿½è¸ª",
      "tips": ""
    },
    "Scene reconstruction": {
      "zh": "åœºæ™¯é‡å»º",
      "tips": ""
    },
    "Hand tracking": {
      "zh": "æ‰‹éƒ¨è¿½è¸ª",
      "tips": ""
    },
    "World tracking and device-pose prediction": {
      "zh": "ä¸–ç•Œè¿½è¸ªå’Œè®¾å¤‡å§¿æ€é¢„æµ‹",
      "tips": ""
    },
    "Use plane detection, image tracking, and scene reconstruction to facilitate interactions between your appâ€™s virtual content and real-world items. For example, use plane detection to detect a tabletop on which to place your content. Use world tracking to record anchors that you want to persist between launches of your app. Use hand tracking if your app requires custom hands-based input.": {
      "zh": "ä½¿ç”¨å¹³é¢æ£€æµ‹ã€å›¾åƒè¿½è¸ªå’Œåœºæ™¯é‡å»ºæ¥ä¿ƒè¿›åº”ç”¨çš„è™šæ‹Ÿå†…å®¹ä¸ç°å®ä¸–ç•Œç‰©å“ä¹‹é—´çš„äº¤äº’ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨å¹³é¢æ£€æµ‹æ¥æ£€æµ‹æ”¾ç½®å†…å®¹çš„æ¡Œé¢ã€‚ä½¿ç”¨ä¸–ç•Œè¿½è¸ªæ¥è®°å½•åœ¨åº”ç”¨é‡å¯æ—¶éœ€è¦ä¿å­˜çš„é”šç‚¹ã€‚å¦‚æœä½ çš„åº”ç”¨éœ€è¦åŸºäºæ‰‹çš„è‡ªå®šä¹‰è¾“å…¥ï¼Œä½¿ç”¨æ‰‹éƒ¨è¿½è¸ªã€‚",
      "tips": ""
    },
    "To start ARKit services in your app, create an ARKitSession object and run it with the data providers for each service. Unlike ARKit in iOS, services in visionOS are independent of one another, and you can start and stop each one at any time. The following example shows how to detect horizontal and vertical planes. Data providers deliver new information using an asynchronous sequence.": {
      "zh": "è¦åœ¨åº”ç”¨ä¸­å¯åŠ¨ ARKit æœåŠ¡ï¼Œè¯·åˆ›å»ºä¸€ä¸ª ARKitSession å¯¹è±¡ï¼Œå¹¶ä¸æ¯ä¸ªæœåŠ¡çš„æ•°æ®æä¾›æºä¸€èµ·è¿è¡Œã€‚ä¸ iOS ä¸­çš„ ARKit ä¸åŒï¼ŒvisionOS ä¸­çš„æœåŠ¡å½¼æ­¤ç‹¬ç«‹ï¼Œä½ å¯ä»¥éšæ—¶å¯åŠ¨æˆ–åœæ­¢å•ä¸ªæœåŠ¡ã€‚ä¸‹é¢çš„ç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•æ£€æµ‹æ°´å¹³å’Œå‚ç›´å¹³é¢ã€‚æ•°æ®æä¾›æºä½¿ç”¨å¼‚æ­¥åºåˆ—ä¼ é€’æ–°çš„ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "If you use the world-tracking data provider in visionOS, ARKit automatically persists the anchors you add to your appâ€™s content. You donâ€™t need to persist these anchors yourself.": {
      "zh": "å¦‚æœä½ ä½¿ç”¨äº† visionOS ä¸­çš„ä¸–ç•Œè¿½è¸ªæ•°æ®æä¾›æºï¼ŒARKit ä¼šè‡ªåŠ¨ä¿å­˜ä½ æ·»åŠ åˆ°åº”ç”¨å†…å®¹ä¸­çš„é”šç‚¹ã€‚ä½ æ— éœ€è‡ªå·±ä¿å­˜è¿™äº›é”šç‚¹ã€‚",
      "tips": ""
    },
    "For more information about how to use ARKit, see ARKit.": {
      "zh": "æœ‰å…³å¦‚ä½•ä½¿ç”¨ ARKit çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… ARKitã€‚",
      "tips": ""
    },
    "Isolate ARKit features not available in visionOS": {
      "zh": "éš”ç¦»åœ¨ visionOS ä¸­ä¸å¯ç”¨çš„ ARKit åŠŸèƒ½",
      "tips": ""
    },
    "If your app uses ARKit features that arenâ€™t present in visionOS, isolate that code to the iOS version of your app. The following features are available in iOS, but donâ€™t have an equivalent in visionOS:": {
      "zh": "å¦‚æœä½ çš„åº”ç”¨ä½¿ç”¨äº† visionOS ä¸­æ²¡æœ‰çš„ ARKit åŠŸèƒ½ï¼Œè¯·å°†è¯¥ä»£ç éš”ç¦»åˆ° iOS ç‰ˆæœ¬çš„åº”ç”¨ä¸­ã€‚ä»¥ä¸‹åŠŸèƒ½åœ¨ iOS ä¸­å¯ç”¨ï¼Œä½†åœ¨ visionOS ä¸­æ²¡æœ‰ç›¸åº”çš„åŠŸèƒ½ï¼š",
      "tips": ""
    },
    "Face tracking": {
      "zh": "é¢éƒ¨è¿½è¸ª",
      "tips": ""
    },
    "Body tracking": {
      "zh": "èº«ä½“è¿½è¸ª",
      "tips": ""
    },
    "Geotracking and placing anchors using a latitude and longitude": {
      "zh": "åœ°ç†è¿½è¸ªå’Œä½¿ç”¨ç»çº¬åº¦æ”¾ç½®é”šç‚¹",
      "tips": ""
    },
    "Object detection": {
      "zh": "ç‰©ä½“æ£€æµ‹",
      "tips": ""
    },
    "App Clip Code detection": {
      "zh": "åº”ç”¨å‰ªè¾‘ä»£ç æ£€æµ‹",
      "tips": ""
    },
    "Video frame post-processing": {
      "zh": "è§†é¢‘å¸§åå¤„ç†",
      "tips": ""
    },
    "Although whole body tracking isnâ€™t available in visionOS, you can track the hands of the person wearing the device. Hand gestures are an important way of interacting with content in visionOS. SwiftUI handles common types of interactions like taps and drags, but you can use custom hand tracking for more complex gestures your app supports.": {
      "zh": "è™½ç„¶ visionOS ä¸­ä¸æä¾›å…¨èº«è¿½è¸ªåŠŸèƒ½ï¼Œä½†å¯ä»¥è¿½è¸ªä½©æˆ´è®¾å¤‡ç”¨æˆ·çš„åŒæ‰‹ã€‚åœ¨ visionOS ä¸­ï¼Œæ‰‹åŠ¿æ˜¯ä¸å†…å®¹äº¤äº’çš„é‡è¦æ–¹å¼ã€‚SwiftUI å¯å¤„ç†å¸¸è§ç±»å‹çš„äº¤äº’ï¼Œå¦‚ç‚¹å‡»å’Œæ‹–åŠ¨ï¼Œä½†ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨è‡ªå®šä¹‰æ‰‹åŠ¿è¿½è¸ªæ¥å®ç°åº”ç”¨æ”¯æŒçš„å¤æ‚æ‰‹åŠ¿ã€‚",
      "tips": ""
    },
    "If you use ARKit raycasting in iOS to detect interactions with objects in the personâ€™s surroundings, you might not need that code in visionOS. SwiftUI and RealityKit handle both direct and indirect interactions with your appâ€™s content in 3D space, eliminating the need for raycasting in many situations. In other situations, you can use the features of ARKit and RealityKit to manage interactions with your content. For example, you might use ARKit hand tracking to determine where someone is pointing in the scene, and use scene reconstruction to build a mesh you can integrate into your RealityKit content.": {
      "zh": "å¦‚æœä½ åœ¨ iOS ä¸­ä½¿ç”¨ ARKit å°„çº¿æ¥æ£€æµ‹ä¸ç”¨æˆ·å‘¨å›´ç¯å¢ƒä¸­çš„ç‰©ä½“çš„äº¤äº’ï¼Œé‚£ä¹ˆä½ å¯èƒ½ä¸éœ€è¦åœ¨ visionOS ä¸­ä½¿ç”¨è¯¥ä»£ç ã€‚SwiftUI å’Œ RealityKit å¯åœ¨ 3D ç©ºé—´ä¸­å¤„ç†ä¸åº”ç”¨å†…å®¹çš„ç›´æ¥å’Œé—´æ¥äº¤äº’ï¼Œå› æ­¤åœ¨å¾ˆå¤šæƒ…å†µä¸‹éƒ½æ— éœ€è¿›è¡Œå°„çº¿æ£€æµ‹ã€‚åœ¨å…¶ä»–æƒ…å†µä¸‹ï¼Œä½ å¯ä»¥ä½¿ç”¨ ARKit å’Œ RealityKit çš„åŠŸèƒ½æ¥ç®¡ç†ä¸å†…å®¹çš„äº¤äº’ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥ä½¿ç”¨ ARKit çš„æ‰‹éƒ¨è¿½è¸ªåŠŸèƒ½æ¥ç¡®å®šç”¨æˆ·åœ¨åœºæ™¯ä¸­çš„æŒ‡å‘ï¼Œç„¶åä½¿ç”¨åœºæ™¯é‡å»ºåŠŸèƒ½æ¥æ„å»ºä¸€ä¸ªç½‘æ ¼ï¼Œå¹¶å°†å…¶é›†æˆåˆ° RealityKit å†…å®¹ä¸­ã€‚",
      "tips": ""
    }
  },
  "visionos/capturing-video-from-your-visionos-device": {
    "Capturing video from Apple Vision Pro for 2D viewing": {
      "zh": "",
      "tips": ""
    },
    "Record high-quality video of your visionOS app and its surroundings for app previews.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Use short videos and screenshots of your visionOS app to showcase your user interface, highlight functionality, and demonstrate usage. Help people understand what to expect from an immersive experience by recording content from the device that includes your app and its surroundings.": {
      "zh": "",
      "tips": ""
    },
    "The system renders content with spacial effects and optimizations for viewing during immersive experiences. To produce high-resolution content for people to view on 2D displays, the system needs to render without these effects and drop some optimizations. Use Developer Capture in Reality Composer Pro to notify the system to reconfigure rendering, and capture up to 60 seconds of high-resolution video, including sound, from Apple Vision Pro.": {
      "zh": "",
      "tips": ""
    },
    "Pair your Apple Vision Pro to Xcode": {
      "zh": "",
      "tips": ""
    },
    "Before capturing video from your device, pair it to a Mac that has Xcode and the visionOS SDK installed. For instructions on pairing your device, see Running your app in Simulator or on a device.": {
      "zh": "",
      "tips": ""
    },
    "Prepare to capture your app and its surroundings": {
      "zh": "",
      "tips": ""
    },
    "Select a well-lit location that is free from clutter. Avoid including objects that might get in the way of your appâ€˜s windows and 3D content or distract the audience. Include enough detail in the scene to provide context and anchoring points. Consider your surroundings and avoid material that you donâ€™t have permission to capture. This can include people, screens, branded products, logos, artwork, and other intellectual property.": {
      "zh": "",
      "tips": ""
    },
    "Use the version of your app that you intend to share with your audience. Build and install your app using a release configuration. This configuration enables code optimizations for better runtime performance and disables the generation of debugging information. Debug configurations typically disable code optimizations and might include UI you donÊ¼t intend to share. Donâ€™t use them to record video for previews you intend to share. Build schemes manage the build configuration Xcode uses during build actions, for more information see Customizing the build schemes for a project.": {
      "zh": "",
      "tips": ""
    },
    "Plan the tasks you intend to capture ahead of time and keep them short and focused. Launch the app and get the app into the state you need before you begin the capture. Reduce unnecessary processing overhead on the visionOS device by quiting other apps and avoiding background tasks.": {
      "zh": "",
      "tips": ""
    },
    "Record your capture": {
      "zh": "",
      "tips": ""
    },
    "To begin capturing video from the device:": {
      "zh": "",
      "tips": ""
    },
    "Launch Reality Composer Pro. Choose Open Developer Tool > Reality Composer Pro from the Xcode menu.": {
      "zh": "",
      "tips": ""
    },
    "Choose File > Developer Capture to bring up the Developer Capture dialog.": {
      "zh": "",
      "tips": ""
    },
    "Select the device to capture from the pop-up menu.": {
      "zh": "",
      "tips": ""
    },
    "If you see the message â€œPreparing, wait for the device to be readyâ€. You can click the info button that appears to the right of the popup menu for more information.": {
      "zh": "",
      "tips": ""
    },
    "Click the record button to begin the countdown timer.": {
      "zh": "",
      "tips": ""
    },
    "Clicking the record button starts a countdown. When the countdown reaches 0, the capture session begins. As the capture process happens, the video changes because the system reconfigures to render content for viewing in 2D. You might notice reduced responsiveness from the device during the session as it devotes more processing to render and capture the video.": {
      "zh": "",
      "tips": ""
    },
    "Perform the interactions you want to record on the device. Keep relevant content centered and in frame. The aspect ratio of the video you capture crops content that appears at the sides of an experience. Keep your head stable, and use slow, steady movement to transition the focus of the device when necessary. Small movements get amplified and might be jarring to the audience.": {
      "zh": "",
      "tips": ""
    },
    "Click the record button again from your Mac to end the capture session. The session ends on its own if the elapsed time exceeds 60 seconds.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "To begin a capture, the device must have a stable connection to your Mac and start at low power and thermal levels to stay below thresholds necessary to achieve consistent frame rates. When capturing multiple sessions, you might need to wait between each session.": {
      "zh": "",
      "tips": ""
    },
    "Review the captured video file": {
      "zh": "",
      "tips": ""
    },
    "Each recording session creates a QuickTime Movie file (.mov) and saves it to the desktop of your Mac. The file includes video captured at 30 FPS using 10-bit HEVC in HDTV Rec. 709 color space with system audio recorded in 32-bit floating-point linear PCM.": {
      "zh": "",
      "tips": ""
    },
    "Review the video to make sure that it includes all the content you planned and it doesnâ€™t include any unexpected elements. Ensure that the transitions and animations are smooth and frame rates are consistent.": {
      "zh": "",
      "tips": ""
    },
    "You might want to use additional video-editing tools to trim, edit, and apply post-processing, such as stabilization, to the video to create a high-quality preview. Select frames from the video you capture to use as screenshots.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/checking-whether-your-app-is-compatible-with-visionos": {
    "Checking whether your existing app is compatible with visionOS": {
      "zh": "æ£€æŸ¥ç°æœ‰åº”ç”¨æ˜¯å¦ä¸ visionOS å…¼å®¹",
      "tips": ""
    },
    "Determine whether your existing iOS or iPadOS app runs as is in visionOS or requires modifications to handle platform differences.": {
      "zh": "ç¡®è®¤ä½ ç°æœ‰çš„ iOS æˆ– iPadOS åº”ç”¨èƒ½å¦åŸå°ä¸åŠ¨åœ°åœ¨ visionOS ä¸­æ­£å¸¸è¿è¡Œï¼Œè¿˜æ˜¯éœ€è¦è¿›è¡Œä¿®æ”¹ä»¥å¤„ç†å¹³å°å·®å¼‚ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "visionOS runs compatible iPad and iPhone apps to provide continuous access to existing content right away. visionOS supports most of the same technologies as iOS, so many apps built to run on iPad or iPhone can run unmodified on visionOS devices. When a compatible app runs in visionOS, it retains the same appearance it had in iPadOS or iOS, and its content appears in a window in the personâ€™s surroundings.": {
      "zh": "visionOS æ”¯æŒå¤§å¤šæ•°ä¸ iOS ç›¸åŒçš„æŠ€æœ¯ï¼Œå› æ­¤è®¸å¤šä¸“ä¸ºåœ¨ iPad æˆ– iPhone ä¸Šè¿è¡Œè€Œå¼€å‘çš„åº”ç”¨éƒ½å¯ä»¥ä¸ç»ä¿®æ”¹åœ°åœ¨ visionOS è®¾å¤‡ä¸Šè¿è¡Œã€‚å½“å…¼å®¹çš„åº”ç”¨åœ¨ visionOS ä¸­è¿è¡Œæ—¶ï¼Œå®ƒå°†ä¿ç•™åœ¨ iPadOS æˆ– iOS ä¸­çš„å¤–è§‚ï¼Œå¹¶ä¸”å…¶å†…å®¹ä¼šæ˜¾ç¤ºåœ¨ç”¨æˆ·å‘¨å›´ç¯å¢ƒçš„çª—å£ä¸­ã€‚",
      "tips": ""
    },
    "If you have an app in the iOS App Store, try downloading it and running it on Apple Vision Pro. If you run into issues, use Xcode to identify and fix them. If you built your app using the iOS SDK, Xcode 15 and later automatically adds a Designed for iPad runtime destination to your project. Use this destination to run your app and test its compatibility in visionOS. You can test most of your appâ€™s core functionality in Simulator, but some features are available only on a device.": {
      "zh": "å¦‚æœä½ åœ¨ iOS App Store ä¸Šå‘å¸ƒäº†ä¸€æ¬¾åº”ç”¨ï¼Œè¯·å°è¯•ä¸‹è½½å¹¶åœ¨ Apple Vision Pro ä¸Šè¿è¡Œã€‚å¦‚æœé‡åˆ°é—®é¢˜ï¼Œè¯·ä½¿ç”¨ Xcode è¿›è¡Œè¯†åˆ«å’Œä¿®å¤ã€‚å¦‚æœä½ ä½¿ç”¨ iOS SDK æ„å»ºäº†åº”ç”¨ï¼ŒXcode 15 åŠæ›´é«˜ç‰ˆæœ¬ä¼šè‡ªåŠ¨å°†â€œä¸“ä¸º iPad è®¾è®¡â€è¿è¡Œæ—¶ç›®æ ‡æ·»åŠ åˆ°æ‚¨çš„é¡¹ç›®ä¸­ã€‚ä½¿ç”¨æ­¤ç›®æ ‡è¿è¡Œä½ çš„åº”ç”¨å¹¶æµ‹è¯•å…¶åœ¨ visionOS ä¸­çš„å…¼å®¹æ€§ã€‚ä½ å¯ä»¥åœ¨æ¨¡æ‹Ÿå™¨ä¸­æµ‹è¯•åº”ç”¨çš„å¤§éƒ¨åˆ†æ ¸å¿ƒåŠŸèƒ½ï¼Œä½†æœ‰äº›åŠŸèƒ½ä»…åœ¨è®¾å¤‡ä¸Šå¯ç”¨ã€‚",
      "tips": ""
    },
    "Determine whether a missing feature impacts your app": {
      "zh": "ç¡®è®¤ç¼ºå¤±çš„åŠŸèƒ½æ˜¯å¦ä¼šå½±å“ä½ çš„åº”ç”¨",
      "tips": ""
    },
    "visionOS contains most of the same technologies as iPadOS and iOS, but there are some differences. In some cases, a feature you use in your app might not be available because of hardware differences or because of differences in how people use a visionOS device. As part of your testing, consider the impact of any missing features on your appâ€™s overall experience. Whenever possible, work around missing features by disabling them or providing alternate ways to access the same content.": {
      "zh": "visionOS åŒ…å«ä¸ iPadOS å’Œ iOS ç›¸åŒçš„å¤§éƒ¨åˆ†æŠ€æœ¯ï¼Œä½†ä¹Ÿå­˜åœ¨ä¸€äº›å·®å¼‚ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç”±äºç¡¬ä»¶å·®å¼‚æˆ–äººä»¬ä½¿ç”¨ visionOS è®¾å¤‡çš„æ–¹å¼ä¸åŒï¼Œä½ åœ¨åº”ç”¨ä¸­ä½¿ç”¨çš„æŸé¡¹åŠŸèƒ½å¯èƒ½æ— æ³•ä½¿ç”¨ã€‚åœ¨æµ‹è¯•çš„è¿‡ç¨‹ä¸­ï¼Œè¯·è€ƒè™‘ä»»ä½•ç¼ºå¤±åŠŸèƒ½å¯¹æ•´ä½“åº”ç”¨ä½“éªŒçš„å½±å“ã€‚å°½å¯èƒ½é€šè¿‡ç¦ç”¨ç¼ºå¤±åŠŸèƒ½æˆ–æä¾›è®¿é—®ç›¸åŒå†…å®¹çš„æ–¹æ³•æ¥æ›¿ä»£ç¼ºå¤±çš„åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "The following features arenâ€™t available in compatible iPad and iPhone apps in visionOS. Use framework APIs to determine when the features are available.": {
      "zh": "ä»¥ä¸‹åŠŸèƒ½åœ¨å…¼å®¹ visionOS çš„ iPad å’Œ iPhone åº”ç”¨ä¸­ä¸å¯ç”¨ã€‚è¯·ä½¿ç”¨æ¡†æ¶ API æ¥ç¡®è®¤è¿™äº›åŠŸèƒ½ä½•æ—¶å¯ç”¨ã€‚",
      "tips": ""
    },
    "Core Motion services": {
      "zh": "æ ¸å¿ƒè¿åŠ¨æœåŠ¡",
      "tips": ""
    },
    "Barometer and magnetometer data": {
      "zh": "æ°”å‹è®¡å’Œç£åŠ›è®¡æ•°æ®",
      "tips": ""
    },
    "All location services except the standard service": {
      "zh": "é™¤æ ‡å‡†æœåŠ¡å¤–çš„æ‰€æœ‰å®šä½æœåŠ¡",
      "tips": ""
    },
    "HealthKit data": {
      "zh": "HealthKit æ•°æ®",
      "tips": ""
    },
    "Video or still-photo capture": {
      "zh": "è§†é¢‘æˆ–é™æ€ç…§ç‰‡æ•è·",
      "tips": ""
    },
    "Camera features like auto-focus or flash": {
      "zh": "è‡ªåŠ¨å¯¹ç„¦æˆ–é—ªå…‰ç¯ç­‰ç›¸æœºåŠŸèƒ½",
      "tips": ""
    },
    "Rear-facing (selfie) cameras": {
      "zh": "å‰ç½®ï¼ˆè‡ªæ‹ï¼‰æ‘„åƒå¤´",
      "tips": ""
    },
    "In some cases, a framework or feature behaves differently when your app runs in visionOS. Be prepared to handle these differences when your app runs in visionOS.": {
      "zh": "åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå½“ä½ çš„åº”ç”¨åœ¨ visionOS ä¸­è¿è¡Œæ—¶ï¼Œæ¡†æ¶æˆ–åŠŸèƒ½çš„è¡Œä¸ºä¼šæœ‰æ‰€ä¸åŒã€‚å½“ä½ çš„åº”ç”¨åœ¨ visionOS ä¸­è¿è¡Œæ—¶ï¼Œè¯·å‡†å¤‡å¥½å¤„ç†è¿™äº›å·®å¼‚ã€‚",
      "tips": ""
    },
    "AirPlay. visionOS hides AirPlay sharing buttons in system interfaces, and you canâ€™t use AirPlay features from compatible apps.": {
      "zh": "AirPlayã€‚visionOS éšè—äº†ç³»ç»Ÿç•Œé¢ä¸­çš„ AirPlay å…±äº«æŒ‰é’®ï¼Œå¹¶ä¸”ä½ æ— æ³•ä½¿ç”¨å…¼å®¹åº”ç”¨ä¸­çš„ AirPlay åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "App extensions. visionOS doesnâ€™t load App Clips, device drivers, device activity monitors, keyboard extensions, Messages app extensions, photo-editing app extensions, SMS and call-reporting extensions, or widgets.": {
      "zh": "åº”ç”¨æ‰©å±•ã€‚VisionOS ä¸ä¼šåŠ è½½ App Clipsã€è®¾å¤‡é©±åŠ¨ç¨‹åºã€è®¾å¤‡æ´»åŠ¨ç›‘è§†å™¨ã€é”®ç›˜æ‰©å±•ã€ä¿¡æ¯åº”ç”¨æ‰©å±•ã€ç…§ç‰‡ç¼–è¾‘åº”ç”¨æ‰©å±•ã€çŸ­ä¿¡å’Œé€šè¯æŠ¥å‘Šæ‰©å±•æˆ–å°ç»„ä»¶ã€‚",
      "tips": ""
    },
    "Apple Watch features. visionOS ignores watchOS apps and WatchKit extensions in your iOS or iPadOS app. The Watch Connectivity framework is unavailable. Face sharing in ClockKit does nothing in visionOS.": {
      "zh": "Apple Watch åŠŸèƒ½ã€‚VisionOS ä¼šå¿½ç•¥ iOS æˆ– iPadOS åº”ç”¨ä¸­çš„ watchOS åº”ç”¨å’Œ WatchKit æ‰©å±•ã€‚Watch Connectivity æ¡†æ¶ä¸å¯ç”¨ã€‚ClockKit ä¸­çš„é¢éƒ¨å…±äº«åœ¨ visionOS ä¸­ä¸èµ·ä½œç”¨ã€‚",
      "tips": ""
    },
    "Audio and video. visionOS doesnâ€™t support Picture in Picture or AV routing features. Check the availability of video features before using them. Be prepared for audio playback to stop automatically when your app moves to the background.": {
      "zh": "éŸ³é¢‘å’Œè§†é¢‘ã€‚visionOS ä¸æ”¯æŒç”»ä¸­ç”»æˆ– AV è·¯ç”±åŠŸèƒ½ã€‚åœ¨ä½¿ç”¨è§†é¢‘åŠŸèƒ½å‰ï¼Œè¯·æ£€æŸ¥å…¶å¯ç”¨æ€§ã€‚è¯·å‡†å¤‡å¥½åœ¨åº”ç”¨ç§»è‡³åå°æ—¶ä¼šè‡ªåŠ¨åœæ­¢éŸ³é¢‘æ’­æ”¾ã€‚",
      "tips": ""
    },
    "Classroom features. Starting a test with Automatic Assessment Configuration reports an error.": {
      "zh": "è¯¾å ‚åŠŸèƒ½ã€‚ä½¿ç”¨è‡ªåŠ¨è¯„ä¼°é…ç½®å¯åŠ¨æµ‹è¯•æ—¶ä¼šæŠ¥é”™ã€‚",
      "tips": ""
    },
    "Cellular telephony. Cellular services are unavailable. You can still implement Voice-over-IP (VoIP) services using CallKit and Core Telephony.": {
      "zh": "èœ‚çªç”µè¯ã€‚èœ‚çªç½‘ç»œæœåŠ¡ä¸å¯ç”¨ã€‚ä½ ä»å¯ä½¿ç”¨ CallKit å’Œ Core Telephony å®æ–½ IPè¯­éŸ³ï¼ˆVoIPï¼‰æœåŠ¡ã€‚",
      "tips": ""
    },
    "Device management. Calls to the ManagedSettings and ManagedSettingsUI frameworks do nothing.": {
      "zh": "è®¾å¤‡ç®¡ç†ã€‚è°ƒç”¨ ManagedSettings å’Œ ManagedSettingsUI æ¡†æ¶æ²¡æœ‰æ•ˆæœã€‚",
      "tips": ""
    },
    "Game controllers. visionOS delivers game controller events only when someone is looking at the app. To require a game controller as an input device for your app, add the GCRequiresControllerUserInteraction key with the visionOS value to your appâ€™s Info.plist.": {
      "zh": "æ¸¸æˆæ§åˆ¶å™¨ã€‚visionOS åªæœ‰åœ¨æœ‰äººæ­£åœ¨æŸ¥çœ‹åº”ç”¨æ—¶æ‰ä¼šå‘é€æ¸¸æˆæ§åˆ¶å™¨äº‹ä»¶ã€‚å¦‚è¦å°†æ¸¸æˆæ§åˆ¶å™¨ä½œä¸ºåº”ç”¨çš„è¾“å…¥è®¾å¤‡ï¼Œè¯·å°†å¸¦æœ‰ visionOS å€¼çš„ GCRequiresControllerUserInteraction é”®æ·»åŠ åˆ°åº”ç”¨çš„ Info.plist ä¸­ã€‚",
      "tips": ""
    },
    "Handoff. visionOS doesnâ€™t attempt to hand off user activities to other devices.": {
      "zh": "æ¥åŠ›ã€‚visionOS ä¸ä¼šå°è¯•å°†ç”¨æˆ·æ´»åŠ¨ç§»äº¤ç»™å…¶ä»–è®¾å¤‡ã€‚",
      "tips": ""
    },
    "Haptics. visionOS plays sounds instead of haptics.": {
      "zh": "è§¦æ„Ÿåé¦ˆã€‚visionOS æ’­æ”¾å£°éŸ³è€Œéè§¦è§‰ã€‚",
      "tips": ""
    },
    "HomeKit. You canâ€™t add accessories using a QR code from a visionOS device.": {
      "zh": "HomeKitã€‚ä½ æ— æ³•ä½¿ç”¨äºŒç»´ç ä» visionOS è®¾å¤‡æ·»åŠ é…ä»¶ã€‚",
      "tips": ""
    },
    "Metrics. You can use MetricKit to gather on-device diagnostic logs and generate reports, but you canâ€™t gather metrics.": {
      "zh": "æŒ‡æ ‡ã€‚ä½ å¯ä»¥ä½¿ç”¨ MetricKit æ”¶é›†è®¾å¤‡ä¸Šçš„è¯Šæ–­æ—¥å¿—å¹¶ç”ŸæˆæŠ¥å‘Šï¼Œä½†æ— æ³•æ”¶é›†æŒ‡æ ‡ã€‚",
      "tips": ""
    },
    "Multi-Touch. The system reports a maximum of two simultaneous touch inputs â€”Â one for each of the personâ€™s hands. All system gesture recognizers handle these inputs correctly, including for zoom and rotation gestures that require multiple fingers. If you have custom gesture recognizers that require more than two points of interaction, update them to support only one or two touches in visionOS.": {
      "zh": "å¤šç‚¹è§¦æ§ã€‚ç³»ç»Ÿæœ€å¤šå¯åŒæ—¶æŠ¥å‘Šä¸¤ä¸ªè§¦æ‘¸è¾“å…¥--ç”¨æˆ·çš„åŒæ‰‹ã€‚æ‰€æœ‰ç³»ç»Ÿæ‰‹åŠ¿è¯†åˆ«å™¨éƒ½èƒ½æ­£ç¡®å¤„ç†è¿™äº›è¾“å…¥ï¼ŒåŒ…æ‹¬éœ€è¦å¤šä¸ªæ‰‹æŒ‡çš„ç¼©æ”¾å’Œæ—‹è½¬æ‰‹åŠ¿ã€‚å¦‚æœä½ çš„è‡ªå®šä¹‰æ‰‹åŠ¿è¯†åˆ«å™¨éœ€è¦ä¸¤ä¸ªä»¥ä¸Šçš„äº¤äº’ç‚¹ï¼Œè¯·å°†å…¶æ›´æ–°ä¸ºåœ¨ visionOS ä¸­ä»…æ”¯æŒä¸€æˆ–ä¸¤ä¸ªè§¦æ§ã€‚",
      "tips": ""
    },
    "Parental controls. Calls to the FamilyControls framework do nothing.": {
      "zh": "å®¶é•¿æ§åˆ¶ã€‚è°ƒç”¨ FamilyControls æ¡†æ¶ä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚",
      "tips": ""
    },
    "PencilKit. visionOS doesnâ€™t report touches of type UITouch.TouchType.pencil, but it does report other types of touches.": {
      "zh": "PencilKitã€‚visionOS ä¸ä¼šæŠ¥å‘Š UITouch.TouchType.pencil ç±»å‹çš„è§¦æ‘¸ï¼Œä½†ä¼šæŠ¥å‘Šå…¶ä»–ç±»å‹çš„è§¦æ‘¸ã€‚",
      "tips": ""
    },
    "Push to Talk. Calls to the Push to Talk framework do nothing.": {
      "zh": "ä¸€é”®é€šè¯ã€‚è°ƒç”¨ Push to Talk æ¡†æ¶ä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚",
      "tips": ""
    },
    "Safari Services. Links that present an SFSafariViewController open a Safari scene instead.": {
      "zh": "Safari æœåŠ¡ã€‚æ˜¾ç¤º SFSafariViewController çš„é“¾æ¥ä¼šæ‰“å¼€ Safari åœºæ™¯ã€‚",
      "tips": ""
    },
    "ScreenTime. Calls to the Screen Time framework do nothing.": {
      "zh": "å±å¹•æ—¶é—´ã€‚è°ƒç”¨ Screen Time æ¡†æ¶ä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚",
      "tips": ""
    },
    "Sensor-related features. Calls to the SensorKit framework do nothing.": {
      "zh": "ä¼ æ„Ÿå™¨ç›¸å…³åŠŸèƒ½ã€‚è°ƒç”¨ SensorKit æ¡†æ¶ä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚",
      "tips": ""
    },
    "Social media. Calls to the Social framework do nothing.": {
      "zh": "ç¤¾äº¤åª’ä½“ã€‚è°ƒç”¨ Social æ¡†æ¶æ—¶ä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚",
      "tips": ""
    },
    "System interfaces. Authorization prompts, Sign in with Apple prompts, and other system-provided interfaces run asynchronously outside of your appâ€™s process. Because these interfaces donâ€™t run modally in your app, your app might not receive immediate responses.": {
      "zh": "ç³»ç»Ÿç•Œé¢ã€‚æˆæƒæç¤ºã€â€œä½¿ç”¨ Apple ç™»å½•â€æç¤ºå’Œå…¶ä»–ç³»ç»Ÿæä¾›çš„ç•Œé¢ä¼šåœ¨åº”ç”¨è¿›ç¨‹ä¹‹å¤–å¼‚æ­¥è¿è¡Œã€‚ç”±äºè¿™äº›ç•Œé¢ä¸åœ¨ä½ çš„åº”ç”¨ä¸­ä»¥å¼ºåˆ¶æ¨¡å¼è¿è¡Œï¼Œå› æ­¤ä½ çš„åº”ç”¨å¯èƒ½æ— æ³•æ”¶åˆ°å³æ—¶å“åº”ã€‚",
      "tips": ""
    },
    "Vehicle features. The system doesnâ€™t call your appâ€™s CarPlay code. Calls you make using CarKey do nothing.": {
      "zh": "è½¦è¾†åŠŸèƒ½ã€‚ç³»ç»Ÿä¸ä¼šè°ƒç”¨ä½ åº”ç”¨çš„ CarPlay ä»£ç ã€‚ä½ çš„ CarKey è°ƒç”¨ä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚",
      "tips": ""
    },
    "Vision. Data scanners do nothing in VisionKit.": {
      "zh": "è§†è§‰ã€‚æ•°æ®æ‰«æä»ªåœ¨ VisionKit ä¸­ä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚",
      "tips": ""
    },
    "The version of ARKit in iOS is incompatible with the one in visionOS and visionOS canâ€™t display windows that contain ARKit views. For information about how to bring an ARKit app to visionOS, see Bringing your ARKit app to visionOS.": {
      "zh": "iOS ä¸­çš„ ARKit ç‰ˆæœ¬ä¸ visionOS ä¸­çš„ç‰ˆæœ¬ä¸å…¼å®¹ï¼Œå› æ­¤ visionOS æ— æ³•æ˜¾ç¤ºåŒ…å« ARKit è§†å›¾çš„çª—å£ã€‚æœ‰å…³å¦‚ä½•å°† ARKit åº”ç”¨ç§»æ¤åˆ° visionOS çš„ä¿¡æ¯ï¼Œè¯·å‚é˜…å°† ARKit åº”ç”¨ç§»æ¤åˆ° visionOSã€‚",
      "tips": ""
    },
    "For details about how to handle missing features in your code, see Making your existing app compatible with visionOS.": {
      "zh": "æœ‰å…³å¦‚ä½•å¤„ç†ä»£ç ä¸­ç¼ºå¤±åŠŸèƒ½çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…ä½¿ç°æœ‰åº”ç”¨ä¸ visionOS å…¼å®¹ã€‚",
      "tips": ""
    },
    "Test specific scenarios before uploading your app": {
      "zh": "åœ¨ä¸Šä¼ åº”ç”¨ä¹‹å‰æµ‹è¯•ç‰¹å®šåœºæ™¯",
      "tips": ""
    },
    "The following App Store features for iOS continue to work when your app runs in visionOS:": {
      "zh": "å½“ä½ çš„åº”ç”¨åœ¨ visionOS ä¸­è¿è¡Œæ—¶ï¼Œä»¥ä¸‹é€‚ç”¨äº iOS çš„ App Store åŠŸèƒ½å°†ç»§ç»­æœ‰æ•ˆï¼š",
      "tips": ""
    },
    "In-app purchases and subscriptions": {
      "zh": "åº”ç”¨å†…è´­ä¹°å’Œè®¢é˜…",
      "tips": ""
    },
    "App capabilities and entitlements": {
      "zh": "åº”ç”¨æƒé™å’Œæˆæƒ",
      "tips": ""
    },
    "On-demand resources": {
      "zh": "æŒ‰éœ€èµ„æº",
      "tips": ""
    },
    "App thinning": {
      "zh": "åº”ç”¨ç²¾ç®€",
      "tips": ""
    },
    "When you use app thinning to optimize your app for different devices and operating systems, the App Store selects the resources and content that offer the best fit for visionOS devices. It then removes any other resources to create a streamlined installation of your app. When you export your app from Xcode 15 or later, you can test the thinning support using the visionOS virtual thinning target.": {
      "zh": "å½“ä½ ä½¿ç”¨åº”ç”¨ç²¾ç®€åŠŸèƒ½ä¸ºä¸åŒçš„è®¾å¤‡å’Œæ“ä½œç³»ç»Ÿä¼˜åŒ–ä½ çš„åº”ç”¨æ—¶ï¼ŒApp Store ä¼šé€‰æ‹©æœ€é€‚åˆ visionOS è®¾å¤‡çš„èµ„æºå’Œå†…å®¹ã€‚ç„¶åï¼Œå®ƒä¼šç§»é™¤ä»»ä½•å…¶ä»–èµ„æºï¼Œä»¥åˆ›å»ºä¸€ä¸ªç²¾ç®€çš„åº”ç”¨å®‰è£…åŒ…ã€‚å½“ä½ ä» Xcode 15 æˆ–æ›´é«˜ç‰ˆæœ¬å¯¼å‡ºåº”ç”¨æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ visionOS è™šæ‹Ÿç²¾ç®€ç›®æ ‡æ¥æµ‹è¯•åº”ç”¨ç²¾ç®€åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "When youâ€™re ready to distribute your app, create an archive and export it using the Ad-Hoc or Development distribution method. During the export process, Xcode creates an appropriately signed app for you to distribute to your testers. For more information, see Distributing your app to registered devices.": {
      "zh": "å½“ä½ å‡†å¤‡åˆ†å‘åº”ç”¨æ—¶ï¼Œè¯·åˆ›å»ºä¸€ä¸ªå­˜æ¡£ï¼Œç„¶åä½¿ç”¨â€œAd-Hocâ€æˆ–â€œDevelopmentâ€åˆ†å‘æ–¹æ³•å¯¼å‡ºã€‚åœ¨å¯¼å‡ºè¿‡ç¨‹ä¸­ï¼ŒXcode ä¼šåˆ›å»ºä¸€ä¸ªç»è¿‡é€‚å½“ç­¾åçš„åº”ç”¨ï¼Œä¾›ä½ åˆ†å‘ç»™æµ‹è¯•äººå‘˜ã€‚è¯¦ç»†ä¿¡æ¯è¯·å‚é˜…å°†åº”ç”¨åˆ†å‘åˆ°å·²æ³¨å†Œè®¾å¤‡ã€‚",
      "tips": ""
    },
    "Update your app information in App Store Connect": {
      "zh": "åœ¨ App Store Connect ä¸­æ›´æ–°åº”ç”¨ä¿¡æ¯",
      "tips": ""
    },
    "The App Store makes compatible iPad and iPhone apps available in visionOS automatically after you sign the updated Apple Developer Program License Agreement. If you donâ€™t want your app to run on Apple Vision Pro, change your appâ€™s availability in App Store Connect.": {
      "zh": "åœ¨ä½ ç­¾ç½²æ›´æ–°çš„ Apple Developer Program License Agreement åï¼ŒApp Store ä¼šè‡ªåŠ¨åœ¨ visionOS ä¸­æä¾›å…¼å®¹çš„ iPad å’Œ iPhone åº”ç”¨ã€‚å¦‚æœä½ ä¸æƒ³è®©ä½ çš„åº”ç”¨åœ¨ Apple Vision Pro ä¸Šè¿è¡Œï¼Œè¯·åœ¨ App Store Connect ä¸­æ›´æ”¹åº”ç”¨çš„å¯ç”¨æ€§ã€‚",
      "tips": ""
    },
    "Select your app in App Store Connect.": {
      "zh": "åœ¨ App Store Connect ä¸­é€‰æ‹©ä½ çš„åº”ç”¨ã€‚",
      "tips": ""
    },
    "Navigate to the Pricing and Availability information.": {
      "zh": "å¯¼èˆªè‡³å®šä»·å’Œå¯ç”¨æ€§ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Disable the â€œMake this app available on Apple Vision Proâ€ option.": {
      "zh": "ç¦ç”¨â€œåœ¨ Apple Vision Pro ä¸Šæä¾›æ­¤åº”ç”¨â€é€‰é¡¹ã€‚",
      "tips": ""
    },
    "When you remove your appâ€™s availability for Apple Vision Pro, the App Store stops making your iOS app available for visionOS. People who already downloaded your iOS app can still run it in visionOS, but they canâ€™t download it again. This setting doesnâ€™t affect the version of your app built using the visionOS SDK.": {
      "zh": "å½“ä½ ç§»é™¤åº”ç”¨åœ¨ Apple Vision Pro ä¸Šçš„å¯ç”¨æ€§åï¼ŒApp Store å°±ä¼šåœæ­¢æä¾›é€‚ç”¨äº visionOS çš„ iOS åº”ç”¨ã€‚å·²ç»ä¸‹è½½è¿‡ä½ çš„ iOS åº”ç”¨çš„ç”¨æˆ·ä»ç„¶å¯ä»¥åœ¨ visionOS ä¸­è¿è¡Œå®ƒï¼Œä½†ä»–ä»¬æ— æ³•å†æ¬¡ä¸‹è½½ã€‚æ­¤è®¾ç½®ä¸ä¼šå½±å“ä½¿ç”¨ visionOS SDK æ„å»ºçš„åº”ç”¨ç‰ˆæœ¬ã€‚",
      "tips": ""
    }
  },
  "visionos/configuring-your-app-icon": {
    "Configuring your app icon": {
      "zh": "",
      "tips": ""
    },
    "Add app icon variations to represent your app in places such as Settings, search results, and the App Store.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Every app has a distinct app icon that communicates the appâ€™s purpose and makes it easy to recognize throughout the system. Apps require multiple variations of the app icon to look great in different contexts. Xcode can help generate these variations for you using a single high-resolution image, or you can configure your app icon variations by using an app iconâ€™s image set in your projectâ€™s asset catalog. visionOS and tvOS app icons are made up of multiple stacked image layers you configure in your projectâ€™s asset catalog.": {
      "zh": "",
      "tips": ""
    },
    "Create an app icon": {
      "zh": "",
      "tips": ""
    },
    "When you create your project from a template, it automatically includes a default asset catalog (Assets.xcassets) that contains the AppIcon. If you donâ€™t have a default asset catalog or existing AppIcon or you want to provide an alternate, you can add an app icon to an asset catalog manually:": {
      "zh": "",
      "tips": ""
    },
    "In the Project navigator, select an asset catalog.": {
      "zh": "",
      "tips": ""
    },
    "Click the Add button (+) at the bottom of the outline view.": {
      "zh": "",
      "tips": ""
    },
    "In the pop-up menu, choose OS variant > OS variant App Icon. Xcode creates a new app icon set or image stack with the name AppIcon.": {
      "zh": "",
      "tips": ""
    },
    "Specify app icon variations": {
      "zh": "",
      "tips": ""
    },
    "Variations of your app icon appear throughout the system in places like the Home View, Settings, and search results. In Xcode 14 and later, for iOS, macOS or watchOS apps, you can generate all variations of your icon using a single 1024Ã—1024 pixel image or provide variations for all sizes. Although using a single size is the default behavior for new apps or new icons in the asset catalog, you might need all sizes in order to include detail in larger variants and simplify as app size decreases. If you have an existing project that provides multiple variants, consider providing a single size when that is all your icon requires.": {
      "zh": "",
      "tips": ""
    },
    "For each platform your app supports, choose between using a single size and providing all sizes in the Asset Catalog:": {
      "zh": "",
      "tips": ""
    },
    "In the Asset Catalog, select the icon.": {
      "zh": "",
      "tips": ""
    },
    "To view and edit attributes, select Inspectors > Attributes from Xcodeâ€™s View menu.": {
      "zh": "",
      "tips": ""
    },
    "Select Single Size or All Sizes from the pop-up menu for the platform you want to change.": {
      "zh": "",
      "tips": ""
    },
    "For each platform your app supports, add a single image that Xcode can use to generate your icon variations, or add an image for each icon variation of an icon set in the Asset Catalog:": {
      "zh": "",
      "tips": ""
    },
    "From the Finder, drag image variations of the app icon to the image wells in the detail area of the Asset Catalog in Xcode that match their resolutions and use cases. visionOS and tvOS app icons combine a stack of multiple image layers to create a sense of depth. For tvOS apps, the asset catalog contains an App Icon & Top Shelf Image folder with the different app icon and launch image sets.": {
      "zh": "",
      "tips": ""
    },
    "For general design guidance, see App icons. For platform-specific design guidance:": {
      "zh": "",
      "tips": ""
    },
    "visionOS": {
      "zh": "",
      "tips": ""
    },
    "iOS": {
      "zh": "",
      "tips": ""
    },
    "macOS": {
      "zh": "",
      "tips": ""
    },
    "tvOS": {
      "zh": "",
      "tips": ""
    },
    "watchOS": {
      "zh": "",
      "tips": ""
    },
    "Configure the layers of an image stack": {
      "zh": "",
      "tips": ""
    },
    "By default, visionOS and tvOS app icons are constructed with three layers. This is the maximum number of layers visionOS icons support but you can use up to five layers when constructing tvOS icons. To add a layer, Click the Add button (+), choose OS variant > OS variant App Icon Layer. To remove a layer, select the layer and click the Remove button (-).": {
      "zh": "",
      "tips": ""
    },
    "Add images to each layer by dragging them from the Finder into the image wells in the detail area of the Asset Catalog in Xcode. For information on the use of layers, see App icons visionOS and tvOS.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "You can use Parallax Previewer app or Parallax Exporter plug-in to create and preview Layer Source Representation (.lsr and .xlsr) files that you can import into your Asset Catalog in Xcode. Save your file in the LSR file format to import a tvOS icon into Xcode, and save in the XLSR file format to import a visionOS icon. Download these from the Apple Design Resources site.": {
      "zh": "",
      "tips": ""
    },
    "Specify an App Store icon": {
      "zh": "",
      "tips": ""
    },
    "If you distribute your app through the App Store, you must provide app icon imagery to use in the App Store. In the Project navigator, select an asset catalog and add icon images to the appropriate image wells in an app icon set or image stack. The App Store image well location varies by platform.": {
      "zh": "",
      "tips": ""
    },
    "Platform": {
      "zh": "",
      "tips": ""
    },
    "App Store icon location": {
      "zh": "",
      "tips": ""
    },
    "Drag an icon image to the iOS 1,024pt image well.": {
      "zh": "",
      "tips": ""
    },
    "iMessage": {
      "zh": "",
      "tips": ""
    },
    "For the iOS target, drag an icon image to the iOS 1,024pt image well in the AppIcon set. For the iMessage Extension target, drag an icon to the Messages App Store image well in the iMessage App Icon set.": {
      "zh": "",
      "tips": ""
    },
    "Sticker Pack": {
      "zh": "",
      "tips": ""
    },
    "Drag an icon image to the iOS 1,024pt image well and the Messages App Store image well.": {
      "zh": "",
      "tips": ""
    },
    "Drag an icon image to the App Store - 2x image well.": {
      "zh": "",
      "tips": ""
    },
    "Drag images to the image wells for the layers of your App Icon - App Store stack in the App Icon & Top Shelf Image folder. The App Store generates an icon from the layers of the image stack.": {
      "zh": "",
      "tips": ""
    },
    "Drag images to the image wells for the layers of your visionOS App Icon stack. The App Store generates an icon from the layers of the image stack.": {
      "zh": "",
      "tips": ""
    },
    "For the iOS target, drag an icon image to the iOS 1,024pt image well. For the WatchKit App target, drag an icon image to the watchOS image well.": {
      "zh": "",
      "tips": ""
    },
    "Change the default app icon set": {
      "zh": "",
      "tips": ""
    },
    "If you donâ€™t create your project from a template, or you want to change your default app icon set, specify which one to use in your targetâ€™s build settings.": {
      "zh": "",
      "tips": ""
    },
    "In the Project navigator, select the project and in the project editor, select the target.": {
      "zh": "",
      "tips": ""
    },
    "In the App Icons and Launch Images section of the General pane, choose the app icon set from the App Icons Source pop-up menu.": {
      "zh": "",
      "tips": ""
    },
    "If you donâ€™t select the Include all app icon assets option, Xcode only includes the app icon set you specify in the App Icons Source pop-up menu when it builds your app. You might leave this option unselected if you want to use a different icon for the Debug and Release builds of your app without including the Debug icon in your Release app bundle. You can specialize the app icon for the Debug and Release configurations by modifying the Primary App Icon Set Name build setting in the Build Settings tab.": {
      "zh": "",
      "tips": ""
    },
    "Xcode also includes any additional app icon sets you specify under the Alternate App Icon Sets build setting. Include any icon sets your app can select using setAlternateIconName(_:completionHandler:) or use in App Store product pages.": {
      "zh": "",
      "tips": ""
    },
    "For information on configuring tests that use icons in App Store Connect, see Product Page Optimization.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/configuring_your_app_for_media_playback": {
    "Configuring your app for media playback": {
      "zh": "",
      "tips": ""
    },
    "Configure apps to enable standard media playback behavior.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "When you build media playback apps for iOS, tvOS, and visionOS, you need to do additional configuration to enable the expected playback behavior. Configuring the audio experience and background operations helps ensure that your appâ€™s audio works as intended. It also enables advanced features like AirPlay streaming and Picture in Picture playback on supported platforms.": {
      "zh": "",
      "tips": ""
    },
    "Configure the audio session": {
      "zh": "",
      "tips": ""
    },
    "Apple platforms, other than macOS which primarily leaves control to an app, provide an audio experience that the operating system manages. This enables the OS to provide a seamless audio experience to people as they switch between apps and receive high-priority audio requests such as phone or FaceTime calls.": {
      "zh": "",
      "tips": ""
    },
    "Your app uses an AVAudioSession to configure its audio behavior semantically, for example to have a primary purpose of playback or recording. You delegate the management of those details to the audio session, which ensures that the operating system can best manage a personâ€™s audio experience.": {
      "zh": "",
      "tips": ""
    },
    "Your app automatically has an audio session that the system configures with this default behavior:": {
      "zh": "",
      "tips": ""
    },
    "Audio playback in your app silences other background audio": {
      "zh": "",
      "tips": ""
    },
    "Support for audio playback but not audio recording": {
      "zh": "",
      "tips": ""
    },
    "Ring/Silent switch set to silent mode in iOS silences app audio": {
      "zh": "",
      "tips": ""
    },
    "Locked device in iOS silences app audio": {
      "zh": "",
      "tips": ""
    },
    "The default audio session provides useful behavior, but typically doesnâ€™t provide the experience and features you need when building a playback app. To add the required behavior, configure your appâ€™s audio session category.": {
      "zh": "",
      "tips": ""
    },
    "An audio session category defines the general audio behavior your app requires. AVFoundation defines several audio session categories you can use, but the one most relevant for media playback apps is playback. This category indicates that media playback is a central feature of your app. When you specify this category, the system doesnâ€™t silence your appâ€™s audio when someone sets the Ring/Silent switch to silent mode in iOS only. Enabling this category means your app can play background audio if youâ€™re using the Audio, AirPlay, and Picture in Picture background mode as explained in the section below.": {
      "zh": "",
      "tips": ""
    },
    "Use an AVAudioSession object to configure your appâ€™s audio session. An audio session is a singleton object you use to set the audio session category, mode, and other settings. To configure the audio session for optimized playback of movies:": {
      "zh": "",
      "tips": ""
    },
    "To enable this category, activate the audio session using the setActive(_:options:) method.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "You can activate the audio session at any time after setting its category, but itâ€™s recommended to defer this call until your app begins audio playback. Deferring the call ensures that you donâ€™t prematurely interrupt any other background audio that may be in progress.": {
      "zh": "",
      "tips": ""
    },
    "Setting the category is the minimal interaction with an audio session, but other configuration options and features are available. For example, in visionOS, you customize a userâ€™s spatial audio experience by configuring the audio session. For more information, see AVAudioSession.": {
      "zh": "",
      "tips": ""
    },
    "Configure the background modes": {
      "zh": "",
      "tips": ""
    },
    "The system requires you to enable certain capabilities to perform some background operations. A common capability that playback apps require is playing background audio. With this capability enabled, your appâ€™s audio continues when people switch to another app or lock their iOS device. Your app also needs this capability to enable advanced playback features like AirPlay streaming and Picture in Picture playback on supported platforms.": {
      "zh": "",
      "tips": ""
    },
    "Use Xcode to configure this capability:": {
      "zh": "",
      "tips": ""
    },
    "Select your appâ€™s target in Xcode and select the Signing & Capabilities tab.": {
      "zh": "",
      "tips": ""
    },
    "Click the + Capability button and add the Background Modes capability to the project.": {
      "zh": "",
      "tips": ""
    },
    "In the Background Modes interface, select the Audio, AirPlay, and Picture in Picture option under its list of background modes.": {
      "zh": "",
      "tips": ""
    },
    "With this mode enabled and your audio session configured, your app is ready to play background audio. In iOS, when you enable this option, your app can stream its content over AirPlay, and in iOS and tvOS it can use Picture in Picture playback.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/controlling_the_transport_behavior_of_a_player": {
    "Controlling the transport behavior of a player": {
      "zh": "",
      "tips": ""
    },
    "Play, pause, and seek through a media presentation.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "AVFoundation provides comprehensive support for playing media assets, including local and remote file-based media and also media streamed with HTTP Live Streaming. The framework models its media assets using the AVAsset class, which provides a consistent interface to load and inspect your media, regardless of its type or location. Use an AVPlayer object to play media assets in the form of AVPlayerItem objects, which model the dynamic state of an asset such as its currentTime().": {
      "zh": "",
      "tips": ""
    },
    "Understanding how to effectively use AVPlayer is essential for anyone building a custom player UI or otherwise requiring programmatic control of playback.": {
      "zh": "",
      "tips": ""
    },
    "Observe playback readiness": {
      "zh": "",
      "tips": ""
    },
    "When you create a player item, it starts with a status of AVPlayerItem.Status.unknown, which means the system hasnâ€™t attempted to load its media for playback. Only when you associate the item with an AVPlayer object does the system begin loading an assetâ€™s media.": {
      "zh": "",
      "tips": ""
    },
    "To know when the player item is ready for playback, observe the value of its status property. Add this observation before you call the playerâ€™s replaceCurrentItem(with:) method, because associating the player item with a player is the systemâ€™s cue to load the itemâ€™s media:": {
      "zh": "",
      "tips": ""
    },
    "When the player item reaches a AVPlayerItem.Status.readyToPlay state, present or enable your playback UI. Alternatively, if a failure occurs, show the appropriate status in the player.": {
      "zh": "",
      "tips": ""
    },
    "Control the playback rate": {
      "zh": "",
      "tips": ""
    },
    "A player provides the play() and pause() methods as its primary means of controlling its playback rate. When a player item is ready for playback, call the playerâ€™s play() method to request that playback begins at the defaultRate, which has an initial value of 1.0 (the natural rate). By default, a player automatically waits to start playback until it has sufficient media data available to minimize stalling. You can determine whether a player is in a paused, waiting to play, or playing state by observing its timeControlStatus value:": {
      "zh": "",
      "tips": ""
    },
    "Observe changes to the rate property by observing notifications of type rateDidChangeNotification. Observing this notification is similar to key-value observing the rate property, but provides additional information about the reason for the rate change. Retrieve the reason from the notificationâ€™s userInfo dictionary using the rateDidChangeReasonKey constant:": {
      "zh": "",
      "tips": ""
    },
    "Seek through the media timeline": {
      "zh": "",
      "tips": ""
    },
    "You can seek through a media timeline in several ways using the methods of AVPlayer and AVPlayerItem. The most common way is to use the playerâ€™s seek(to:) method, passing it a destination CMTime value. Call this method in an asynchronous context:": {
      "zh": "",
      "tips": ""
    },
    "You can call this method a single time to seek to the location, but you can also call it continuously such as when you use a Slider view.": {
      "zh": "",
      "tips": ""
    },
    "The seek(to:) method is a convenient way to quickly seek through your presentation, but itâ€™s tuned for speed rather than precision. This means the actual time to which the player seeks may differ slightly from the time you request. If you need to implement precise seeking behavior, use the seek(to:toleranceBefore:toleranceAfter:) method, which lets you indicate the tolerated amount of deviation from your target time (before and after). For example, if you need to provide sample-accurate seeking behavior, specify tolerance values of zero:": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/creating-a-performance-plan-for-visionos-app": {
    "Creating a performance plan for your visionOS app": {
      "zh": "",
      "tips": ""
    },
    "Identify your appâ€™s performance and power goals and create a plan to measure and assess them.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Performance tuning is an important part of the development process, regardless of platform. Performance tuning means making your app run as efficiently as possible, so it does more work in less time and with fewer system resources. Efficiency is especially important on devices that can support multiple apps in an immersive experience. Apps that consume too many resources, can push the device beyond thermal limits. When this occurs, the system takes steps to cool down to a more acceptable level. This can have a noticeable visual impact and be disorienting for the wearer.": {
      "zh": "",
      "tips": ""
    },
    "As you start development, set aggressive goals and evaluate progress throughout the development cycle. Automate the collection of performance metrics as much as possible and look at data over time to see if performance is improving or declining. When you detect a significant decrease in performance, take immediate steps to correct it. When you start fine-tuning early in development, you have more time to make needed changes to algorithms and approaches.": {
      "zh": "",
      "tips": ""
    },
    "For more information on performance tuning, see Improving your appâ€™s performance.": {
      "zh": "",
      "tips": ""
    },
    "Set performance and power targets": {
      "zh": "",
      "tips": ""
    },
    "Performance isnâ€™t a single metric that you measure and improve. Typically, you choose several metrics and set goals for each of them. For example, consider:": {
      "zh": "",
      "tips": ""
    },
    "Make sure your app launches quickly; this is your first chance to make a good impression.": {
      "zh": "",
      "tips": ""
    },
    "Your interface needs to respond quickly to interactions, even while doing other work. Minimize the time it takes to start tasks. For example, make sure audio and video start without noticeable delays.": {
      "zh": "",
      "tips": ""
    },
    "For an immersive experience with realtime rendering, itâ€™s important to maintain consistently high frame rates. Help maintain these rates by avoiding unnecessary changes that result in more frequent updates to the shared render server. Measure things like update rates, stalls, and hangs in both the render server and your app. Only render the content you need, and optimize the textures and other resources you use during drawing.": {
      "zh": "",
      "tips": ""
    },
    "When the device begins to reach thermal limits, the system reduces CPU or GPU usage and performance degrades over time. Avoid this thermal ceiling by prioritizing and spreading out work, limiting the number of simultaneous threads your app maintains, and turning off hardware-related features like Core Location when you donâ€™t need them.": {
      "zh": "",
      "tips": ""
    },
    "Make the app do as much as possible using the smallest amount of hardware resources. Minimize task-based overhead.": {
      "zh": "",
      "tips": ""
    },
    "Use as little free memory as possible. Donâ€™t allocate or deallocate memory during critical operations, which might make your app appear slow.": {
      "zh": "",
      "tips": ""
    },
    "After you choose the metrics you want, set realistic goals and prioritize them, so you know which ones matter the most. Performance tuning often involves making tradeoffs between competing goals. For example, if you reduce CPU usage by caching computed data or pre-load assets to improve responsiveness, you increase your appâ€™s memory usage. Make these kinds of tradeoffs carefully, and always measure the results of any changes to learn whether they were successful. In some cases, you might find the sacrifice isnâ€™t worthwhile.": {
      "zh": "",
      "tips": ""
    },
    "Consider how people will use your app. If your app runs in the Shared Space, consider more conservative targets and goals for system resources. If you expect people to use your app for longer periods of time, factor this extended use into your targets and goals when choosing metrics.": {
      "zh": "",
      "tips": ""
    },
    "Identify the code flows and user scenarios to test": {
      "zh": "",
      "tips": ""
    },
    "After you choose the metrics to collect, decide which portions of your app to test. Choose features that are repeatable, measurable, and reliable to test. Repeatable automated tests allow you to compare the results and know the comparisons represent the exact same task. Focus on places where your app executes code, but donâ€™t ignore places where your app hands off data to the system and waits. If your app spends a significant amount of time waiting for information, consider eliminating the requests altogether or batching them to achieve better performance.": {
      "zh": "",
      "tips": ""
    },
    "Focus your tuning efforts on the parts of your app that people use the most, or that have the most impact on overall system performance, including:": {
      "zh": "",
      "tips": ""
    },
    "User-facing workflows": {
      "zh": "",
      "tips": ""
    },
    "Key algorithms": {
      "zh": "",
      "tips": ""
    },
    "Task that allocate or deallocate memory": {
      "zh": "",
      "tips": ""
    },
    "Background and network-based tasks": {
      "zh": "",
      "tips": ""
    },
    "Custom Metal shaders": {
      "zh": "",
      "tips": ""
    },
    "Choose actions that people perform frequently or that correspond to important features. For example, if your app lets someone add a new contact, test the workflow for creating the contact, editing the contact, and saving the results. Test your app with a particular feature enabled and disabled to determine whether the feature is solely responsible for any performance impacts. Choose lightweight workflows such as how your app performs at idle time, and also heavyweight workflows, for example, ones that involve user interactions and your appâ€™s responses. For launch times, gather metrics for both hot and cold launches â€” that is, when the app is already resident in memory and when it is not.": {
      "zh": "",
      "tips": ""
    },
    "Consider thermal and environmental factors": {
      "zh": "",
      "tips": ""
    },
    "Consider how environmental factors impact your app. The characteristics of your physical environment can affect system load and thermals of the device. Consider the effect that ambient room temperature, the presence of other people, and the number and type of real-world objects can have on the your appâ€˜s algorithms. Try to test in different settings to get an idea of whether you need to optimize for these scenarios or not.": {
      "zh": "",
      "tips": ""
    },
    "Use Xcodeâ€™s thermal inducers to mimic the device hitting its thermal limits and consider how your app responds to fair, serious, and critical thermal notifications. You might need to have different performance goals when under thermal pressure, and prioritize optimizing for power or find ways to dynamically lower your appâ€˜s complexity in response to thermal pressure to give a smoother experience, even if latency is a bit higher.": {
      "zh": "",
      "tips": ""
    },
    "Choose tools to collect performance data": {
      "zh": "",
      "tips": ""
    },
    "There are many tools and APIs you can use to collect performance-related data for your visionOS app. Use a variety of tools to make sure you have the data you need:": {
      "zh": "",
      "tips": ""
    },
    "Monitor the CPU, memory, disk and network gauges in the Debug navigator to track system resources utilization.": {
      "zh": "",
      "tips": ""
    },
    "Profile your app to gather performance data on most metrics. Instruments lets you profile your appâ€™s code execution, find memory leaks, track memory allocations, analyze file-system or graphics performance, SwiftUI performance, and much more. Use the RealityKit Trace template to monitoring and investigate render server stalls and bottlenecks on visionOS.": {
      "zh": "",
      "tips": ""
    },
    "Use XCTest APIs to collect performance data.": {
      "zh": "",
      "tips": ""
    },
    "Use MetricKit to gather on-device app diagnostics and generate reports.": {
      "zh": "",
      "tips": ""
    },
    "Review diagnostic logs for hangs, disk and energy usage, and crashes in the Xcode Organizer.": {
      "zh": "",
      "tips": ""
    },
    "Review statistics on the contents of your RealityKit scenes. Use this information to optimize your 3D models and textures.": {
      "zh": "",
      "tips": ""
    },
    "Add signposts to your code to generate timing information you can view in Instruments. For more information, see Recording performance data.": {
      "zh": "",
      "tips": ""
    },
    "Include log messages to report significant events and relevant data for those events. For more information, see Generating log messages from your code.": {
      "zh": "",
      "tips": ""
    },
    "Get feedback from testers about their experiences with beta versions of your app. Fill out the Test Information page for your beta version, and request that testers provide feedback about the performance of your app.": {
      "zh": "",
      "tips": ""
    },
    "Profile on a physical device": {
      "zh": "",
      "tips": ""
    },
    "In general, profile and analyze performance on a physical device rather than in Simulator. Even if something works well in Simulator, it might not perform as well on devices for all use cases. Simulator doesnâ€™t support some hardware features and APIs. There are differences in the rendering pipeline for Simulator running on macOS, so rendering performance characteristics will be different. Other pipelines such as input delivery and audio or video playback are also different. There are, however, some insights you can gain profiling in Simulator, such as CPU stalls, that help you spot areas to investigate and address.": {
      "zh": "",
      "tips": ""
    },
    "Build automated test cases and run them regularly": {
      "zh": "",
      "tips": ""
    },
    "Xcode comes with tools to help you automate the collection of performance data:": {
      "zh": "",
      "tips": ""
    },
    "Use the XCTest framework to build test cases to collect performance metrics. XCTest lets you gather several different metrics, including the time it takes to perform operations, the amount of CPU activity that occurs during the test, details about memory or storage use, and more.": {
      "zh": "",
      "tips": ""
    },
    "Use Instruments to collect metrics for specific interactions with your app. Record those interactions and play them back later to collect a new set of metrics.": {
      "zh": "",
      "tips": ""
    },
    "Write custom scripts to gather performance-related data using system command-line tools. Integrate these scripts into your projectâ€™s build process to automate their execution.": {
      "zh": "",
      "tips": ""
    },
    "Configure Xcode to run test cases each time you build your app, or create a separate target to run test cases or custom scripts on demand. Integrate your performance tests into your Xcode Cloud workflows, or your own custom continuous integration solution.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "Collect performance data using a production version of your app to obtain more accurate results. Debug builds contain additional code to support debugging operations and logging. You can collect data from debug builds too, but keep those metrics separate from production-build metrics.": {
      "zh": "",
      "tips": ""
    },
    "For information about how to write test cases for your app, see Testing your apps in Xcode. For information about how to automate testing with Xcode Cloud, see Xcode Cloud.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/creating-fully-immersive-experiences": {
    "Creating fully immersive experiences in your app": {
      "zh": "åœ¨åº”ç”¨ä¸­æ„å»ºå®Œå…¨æ²‰æµ¸å¼çš„ä½“éªŒ",
      "tips": ""
    },
    "Build fully immersive experiences by combining spaces with content you create using RealityKit or Metal.": {
      "zh": "å°† RealityKit æˆ– Metal åˆ›å»ºçš„å†…å®¹ä¸ç©ºé—´ç»“åˆï¼Œæ„å»ºå®Œå…¨æ²‰æµ¸å¼çš„ä½“éªŒã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "A fully immersive experience replaces everything the person sees with custom content you create. You might use this type of experience to:": {
      "zh": "å®Œå…¨æ²‰æµ¸å¼çš„ä½“éªŒä¼šç”¨ä½ åˆ›å»ºçš„è‡ªå®šä¹‰å†…å®¹æ›¿ä»£ç”¨æˆ·çœ‹åˆ°çš„ä¸€åˆ‡ã€‚ä½ å¯ä»¥ä½¿ç”¨è¿™ç§ç±»å‹çš„ä½“éªŒæ¥ï¼š",
      "tips": ""
    },
    "Offer a temporary transitional experience": {
      "zh": "æä¾›ä¸€ç§ä¸´æ—¶çš„è¿‡æ¸¡æ€§ä½“éªŒ",
      "tips": ""
    },
    "Create a distraction-free space for your content": {
      "zh": "ä¸ºä½ çš„å†…å®¹åˆ›å»ºä¸€ä¸ªä¸å—å¹²æ‰°çš„ç©ºé—´",
      "tips": ""
    },
    "Implement a virtual reality (VR) game": {
      "zh": "å®ç°è™šæ‹Ÿç°å®(VR)æ¸¸æˆ",
      "tips": ""
    },
    "Present a virtual world to explore": {
      "zh": "å‘ˆç°ä¸€ä¸ªå¯ä»¥æ¢ç´¢çš„è™šæ‹Ÿä¸–ç•Œ",
      "tips": ""
    },
    "With a fully immersive experience, youâ€™re responsible for everything that appears onscreen. The system hides passthrough video and displays the content you provide, showing the personâ€™s hands only when they come into view. To achieve the best performance, use RealityKit or Metal to create and animate your content.": {
      "zh": "åœ¨å®Œå…¨æ²‰æµ¸å¼çš„ä½“éªŒä¸­ï¼Œä½ è¦è´Ÿè´£å±å¹•ä¸Šæ˜¾ç¤ºçš„æ‰€æœ‰å†…å®¹ã€‚ç³»ç»Ÿéšè—æ‘„åƒå¤´æ•æ‰åˆ°çš„å®æ—¶è§†é¢‘ï¼Œæ˜¾ç¤ºä½ æä¾›çš„å†…å®¹ï¼Œåªæœ‰å½“äººå‡ºç°åœ¨è§†é‡é‡Œæ—¶ä¼šæ˜¾ç¤ºäººçš„æ‰‹éƒ¨ã€‚ä¸ºäº†è·å¾—æœ€ä½³æ€§èƒ½ï¼Œè¯·ä½¿ç”¨ RealityKit æˆ– Metal æ¥åˆ›å»ºå†…å®¹å¹¶ä¸ºå…¶åˆ¶ä½œåŠ¨ç”»ã€‚",
      "tips": ""
    },
    "Typically, you combine a fully immersive experience with other types of experiences and provide transitions between them. When you display a window first and then offer controls to enter your immersive experience, you give people time to prepare for the transition. It also gives them the option to skip the experience if they prefer to use your appâ€™s windows instead.": {
      "zh": "é€šå¸¸æ¥è®²ï¼Œä½ å°†å®Œå…¨æ²‰æµ¸å¼çš„ä½“éªŒä¸å…¶ä»–ç±»å‹çš„ä½“éªŒç»“åˆèµ·æ¥ï¼Œå¹¶åœ¨å®ƒä»¬ä¹‹é—´æä¾›è¿‡æ¸¡ã€‚å½“ä½ å…ˆæ˜¾ç¤ºä¸€ä¸ªçª—å£ï¼Œç„¶åæä¾›æ§ä»¶ä»¥è¿›å…¥ä½ çš„æ²‰æµ¸å¼ä½“éªŒæ—¶ï¼Œä½ ä¸ºç”¨æˆ·å‡†å¤‡è¿‡æ¸¡æä¾›äº†æ—¶é—´ã€‚è¿™ä¹Ÿä¸ºç”¨æˆ·æä¾›äº†é€‰æ‹©ï¼Œå¦‚æœç”¨æˆ·æ›´æ„¿æ„ä½¿ç”¨ä½ çš„åº”ç”¨ç¨‹åºçš„çª—å£ï¼Œå¯ä»¥è·³è¿‡è¯¥ä½“éªŒã€‚",
      "tips": ""
    },
    "Prepare someone for your appâ€™s transitions": {
      "zh": "åº”ç”¨ç¨‹åºçš„è¿‡æ¸¡ä½¿ç”¨æˆ·åšå¥½å‡†å¤‡",
      "tips": ""
    },
    "Give people control over when they enter or exit fully immersive experiences, and provide clear transitions to and from those experiences. Clear visual transitions make it easier to adjust to such a large change. Sudden transitions might be disorienting, unpleasant, or make the person think something went wrong.": {
      "zh": "è®©ç”¨æˆ·æœ‰æƒæ§åˆ¶ä½•æ—¶è¿›å…¥æˆ–é€€å‡ºæ²‰æµ¸å¼çš„ä½“éªŒï¼Œå¹¶ä¸ºè¿™äº›ä½“éªŒæä¾›æ˜ç¡®çš„è¿‡æ¸¡ã€‚æ¸…æ™°çš„è§†è§‰è¿‡æ¸¡è®©ç”¨æˆ·æ›´å®¹æ˜“é€‚åº”å¦‚æ­¤å·¨å¤§çš„å˜åŒ–ã€‚çªç„¶çš„è¿‡æ¸¡å¯èƒ½ä¼šè®©äººæ„Ÿåˆ°è¿·å¤±ã€ä¸æ„‰å¿«ï¼Œæˆ–è®©äººè®¤ä¸ºå‡ºç°äº†é—®é¢˜ã€‚",
      "tips": ""
    },
    "At launch time, display windows or other content that allows the person to see their surroundings. Add controls to that content to initiate the transition to the fully immersive experience, and provide a clear indication of what the controls do. Inside your experience, provide clear controls and instructions on how to exit the experience.": {
      "zh": "åœ¨å¯åŠ¨æ—¶ï¼Œæ˜¾ç¤ºçª—å£æˆ–å…¶ä»–å†…å®¹ï¼Œè®©ç”¨æˆ·èƒ½å¤Ÿçœ‹åˆ°å‘¨å›´ç¯å¢ƒã€‚å‘è¯¥å†…å®¹æ·»åŠ æ§ä»¶ï¼Œä»¥å¯åŠ¨è¿›å…¥å®Œå…¨æ²‰æµ¸å¼ä½“éªŒçš„è¿‡æ¸¡ï¼Œå¹¶æ¸…æ™°æŒ‡å‡ºæ§ä»¶çš„åŠŸèƒ½ã€‚åœ¨ç”¨æˆ·çš„ä½“éªŒä¸­ï¼Œæä¾›æ¸…æ™°çš„å…³äºå¦‚ä½•é€€å‡ºä½“éªŒçš„æ§ä»¶å’Œè¯´æ˜ã€‚",
      "tips": ""
    },
    "Warning": {
      "zh": "è­¦å‘Š",
      "tips": ""
    },
    "When you start a fully immersive experience, visionOS defines a system boundary that extends 1.5 meters from the initial position of the personâ€™s head. If their head moves outside of that zone, the system automatically stops the immersive experience and turns on the external video again. This feature is an assistant to help prevent someone from colliding with objects.": {
      "zh": "å½“ä½ å¯åŠ¨å®Œå…¨æ²‰æµ¸å¼ä½“éªŒæ—¶ï¼ŒvisionOS å®šä¹‰äº†ä¸€ä¸ªç³»ç»Ÿè¾¹ç•Œï¼Œå…¶èŒƒå›´ä»ç”¨æˆ·å¤´éƒ¨çš„åˆå§‹ä½ç½®å»¶ä¼¸ 1.5 ç±³ã€‚å¦‚æœç”¨æˆ·çš„å¤´éƒ¨ç§»åŠ¨åˆ°è¯¥åŒºåŸŸä¹‹å¤–ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åœæ­¢æ²‰æµ¸å¼ä½“éªŒå¹¶é‡æ–°æ‰“å¼€å¤–éƒ¨è§†é¢‘ã€‚è¿™ä¸ªåŠŸèƒ½æœ‰åŠ©äºé˜²æ­¢ç”¨æˆ·æ’åˆ°ç‰©ä½“ã€‚",
      "tips": ""
    },
    "For guidelines on how to design fully immersive experiences, see Human Interface Guidelines.": {
      "zh": "æœ‰å…³å¦‚ä½•è®¾è®¡å®Œå…¨æ²‰æµ¸å¼ä½“éªŒçš„æŒ‡å—ï¼Œè¯·é˜…è¯» [äººæœºç•Œé¢æŒ‡å—](https://developer.apple.com/design/human-interface-guidelines)ã€‚",
      "tips": ""
    },
    "Open an immersive space": {
      "zh": "æ‰“å¼€ä¸€ä¸ªæ²‰æµ¸å¼ç©ºé—´",
      "tips": ""
    },
    "To create a fully immersive experience, open an ImmersiveSpace and set its style to full. An immersive space is a type of SwiftUI scene that lets you place content anywhere in the personâ€™s surroundings. Applying the full style to the scene tells the system to hide passthrough video and display only your appâ€™s content.": {
      "zh": "è¦åˆ›å»ºå®Œå…¨æ²‰æµ¸å¼çš„ä½“éªŒï¼Œè¯·æ‰“å¼€ä¸€ä¸ª [ImmersiveSpace](https://developer.apple.com/documentation/SwiftUI/ImmersiveSpace) å¹¶å°†å…¶æ ·å¼è®¾ç½®ä¸º [å…¨å±](https://developer.apple.com/documentation/SwiftUI/ImmersionStyle/full)ã€‚æ²‰æµ¸å¼ç©ºé—´æ˜¯ä¸€ç§ SwiftUI sceneï¼Œå…è®¸ä½ å°†å†…å®¹æ”¾ç½®åœ¨ä¸ªä½“å‘¨å›´çš„ä»»ä½•åœ°æ–¹ã€‚å°† [å…¨å±](https://developer.apple.com/documentation/SwiftUI/ImmersionStyle/full) æ ·å¼åº”ç”¨äºåœºæ™¯ä¼šå‘ŠçŸ¥ç³»ç»Ÿéšè—æ‘„åƒå¤´æ•æ‰åˆ°çš„å®æ—¶è§†é¢‘ï¼Œå¹¶ä»…æ˜¾ç¤ºä½ åº”ç”¨ç¨‹åºçš„å†…å®¹ã€‚",
      "tips": ""
    },
    "Declare spaces in the body property of your app object, or anywhere you manage SwiftUI scenes. The following example shows an app with a main window and a fully immersive space. At launch time, the app displays the window.": {
      "zh": "åœ¨ä½ çš„åº”ç”¨ç¨‹åºå¯¹è±¡çš„ [body](https://developer.apple.com/documentation/SwiftUI/App/body-swift.property) å±æ€§ä¸­å£°æ˜ç©ºé—´ï¼Œæˆ–è€…åœ¨ä½ ç®¡ç† SwiftUI scenes çš„ä»»ä½•åœ°æ–¹å£°æ˜ã€‚ä»¥ä¸‹ç¤ºä¾‹æ˜¾ç¤ºäº†ä¸€ä¸ªå…·æœ‰ä¸»çª—å£å’Œä¸€ä¸ªå®Œå…¨æ²‰æµ¸å¼ç©ºé—´çš„åº”ç”¨ç¨‹åºã€‚åœ¨å¯åŠ¨æ—¶ï¼Œåº”ç”¨ç¨‹åºæ˜¾ç¤ºä¸»çª—å£ã€‚",
      "tips": ""
    },
    "To display an ImmersiveSpace, open it using the openImmersiveSpace action, which you obtain from the SwiftUI environment. This action runs asynchronously and uses the provided information to find and initialize your scene. The following example shows a button that opens the space with the solarSystem identifier:": {
      "zh": "è¦æ˜¾ç¤º [ImmersiveSpace](https://developer.apple.com/documentation/SwiftUI/ImmersiveSpace)ï¼Œè¯·ä½¿ç”¨ä» SwiftUI ç¯å¢ƒè·å–çš„ [openImmersiveSpace](https://developer.apple.com/documentation/SwiftUI/EnvironmentValues/openImmersiveSpace) æ–¹æ³•ã€‚æ­¤æ“ä½œä»¥å¼‚æ­¥æ–¹å¼è¿è¡Œï¼Œå¹¶ä½¿ç”¨æä¾›çš„ä¿¡æ¯æŸ¥æ‰¾å¹¶åˆå§‹åŒ–ä½ çš„ sceneã€‚ä¸‹é¢çš„ç¤ºä¾‹æ˜¾ç¤ºä¸€ä¸ªæŒ‰é’®ï¼Œè¯¥æŒ‰é’®ä½¿ç”¨ solarSystem æ ‡è¯†ç¬¦æ‰“å¼€ç©ºé—´ï¼š",
      "tips": ""
    },
    "An app can display only one space at a time, and itâ€™s an error for you to try to open a space while another space is visible. To dismiss an open space, use the dismissImmersiveSpace action.": {
      "zh": "ä¸€ä¸ªåº”ç”¨åŒæ—¶åªèƒ½æ˜¾ç¤ºä¸€ä¸ªç©ºé—´ï¼Œå¦‚æœä½ å°è¯•åœ¨å­˜åœ¨å¦ä¸€ä¸ªç©ºé—´æ—¶æ‰“å¼€ä¸€ä¸ªæ–°ç©ºé—´ï¼Œå°†ä¼šæŠ¥é”™ã€‚è¦å…³é—­å·²æ‰“å¼€çš„ç©ºé—´ï¼Œè¯·ä½¿ç”¨ [dismissImmersiveSpace](https://developer.apple.com/documentation/SwiftUI/EnvironmentValues/dismissImmersiveSpace) æ–¹æ³•ã€‚",
      "tips": ""
    },
    "For more information about displaying spaces, see the ImmersiveSpace type.": {
      "zh": "æœ‰å…³æ˜¾ç¤ºç©ºé—´çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… [ImmersiveSpace](https://developer.apple.com/documentation/SwiftUI/ImmersiveSpace) ç±»å‹ã€‚",
      "tips": ""
    },
    "Draw your content using RealityKit": {
      "zh": "ä½¿ç”¨ RealityKit ç»˜åˆ¶ä½ çš„å†…å®¹",
      "tips": ""
    },
    "RealityKit works well when your content consists of primitive shapes or existing content in USD files. Organize the contents of your scene using RealityKit entities, and animate that content using components and systems. Use Reality Composer Pro to assemble your content visually, and to attach dynamic shaders, animations, audio, and other behaviors to your content. Display the contents of your RealityKit scene in a RealityView in your scene.": {
      "zh": "å½“ä½ çš„å†…å®¹ç”±åŸºæœ¬å½¢çŠ¶æˆ–å­˜åœ¨äº USD æ–‡ä»¶ä¸­çš„å†…å®¹ç»„æˆçš„æ—¶ï¼ŒRealityKit æ•ˆæœå¾ˆå¥½ã€‚ä½¿ç”¨ RealityKit entities æ¥ç®¡ç†åº”ç”¨é‡Œ scene çš„å†…å®¹ï¼Œå¹¶ä½¿ç”¨ç»„ä»¶å’Œç³»ç»Ÿå¯¹è¯¥å†…å®¹åšåŠ¨ç”»æ•ˆæœã€‚ä½¿ç”¨ Reality Composer Pro åœ¨è§†è§‰ä¸Šç»„ç»‡ä½ çš„å†…å®¹ï¼Œå¹¶åœ¨ä½ çš„å†…å®¹ä¸Šæ·»åŠ åŠ¨æ€ç€è‰²å™¨ã€åŠ¨ç”»ã€éŸ³é¢‘å’Œå…¶ä»–æ“ä½œã€‚åœ¨ä½ çš„ scene ä¸­ä½¿ç”¨ [RealityView](https://developer.apple.com/documentation/RealityKit/RealityView) æ¥æ˜¾ç¤º RealityKit åœºæ™¯çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "To load a Reality Composer Pro scene at runtime, fetch the URL of your Reality Composer Pro package file, and load the root entity of your scene. The following example shows how to create the entity for a package located in the appâ€™s bundle:": {
      "zh": "è¦åœ¨è¿è¡Œæ—¶åŠ è½½ Reality Composer Pro sceneï¼Œè¯·è·å– Reality Composer Pro åŒ…æ–‡ä»¶çš„ URLï¼Œå¹¶åŠ è½½ scene çš„æ ¹å®ä½“ã€‚ä»¥ä¸‹ç¤ºä¾‹æ˜¾ç¤ºå¦‚ä½•ä¸ºåº”ç”¨ç¨‹åºä¸­çš„åŒ…åˆ›å»ºå®ä½“ï¼š",
      "tips": ""
    },
    "For more information about how to display content in a RealityView and manage interactions with your content, see Adding 3D content to your app.": {
      "zh": "æœ‰å…³å¦‚ä½•åœ¨ [RealityView](https://developer.apple.com/documentation/RealityKit/RealityView) ä¸­æ˜¾ç¤ºå†…å®¹å¹¶ç®¡ç†ä¸å†…å®¹çš„äº¤äº’çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… [å‘ä½ çš„åº”ç”¨æ·»åŠ  3D å†…å®¹](https://developer.apple.com/documentation/visionos/adding-3d-content-to-your-app)ã€‚",
      "tips": ""
    },
    "Draw your content using Metal": {
      "zh": "ä½¿ç”¨ Metal ç»˜åˆ¶ä½ çš„å†…å®¹",
      "tips": ""
    },
    "Another option for creating fully immersive scenes is to draw everything yourself using Metal. When using Metal to draw your content, use the Compositor Services framework to place that content onscreen. Compositor Services provides the code you need to set up your Metal rendering engine and start drawing.": {
      "zh": "å¦ä¸€ç§åˆ›å»ºå®Œå…¨æ²‰æµ¸å¼åœºæ™¯çš„é€‰é¡¹æ˜¯ä½¿ç”¨ Metal è‡ªå·±ç»˜åˆ¶æ‰€æœ‰å†…å®¹ã€‚åœ¨ç”¨ Metal ç»˜åˆ¶å†…å®¹æ—¶ï¼Œä½¿ç”¨ Compositor Services æ¡†æ¶å°†è¯¥å†…å®¹æ”¾ç½®åœ¨å±å¹•ä¸Šã€‚Compositor Services ä¸ºä½ æä¾›äº†è®¾ç½® Metal æ¸²æŸ“å¼•æ“å¹¶å¼€å§‹ç»˜åˆ¶çš„ä»£ç ã€‚",
      "tips": ""
    },
    "For details on how to render content using Metal and Compositor Services, and manage interactions with your content, see Drawing fully immersive content using Metal.": {
      "zh": "æœ‰å…³å¦‚ä½•ä½¿ç”¨ Metal å’Œ Compositor Services æ¸²æŸ“å†…å®¹ä»¥åŠç®¡ç†ä¸å†…å®¹äº¤äº’çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… [ä½¿ç”¨ Metal ç»˜åˆ¶å®Œå…¨æ²‰æµ¸å¼å†…å®¹](https://developer.apple.com/documentation/compositorservices/drawing_fully_immersive_content_using_metal)ã€‚",
      "tips": ""
    }
  },
  "visionos/creating-your-first-visionos-app": {
    "Creating your first visionOS app": {
      "zh": "åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ª visionOS åº”ç”¨",
      "tips": ""
    },
    "Build a new visionOS app using SwiftUI and add platform-specific features.": {
      "zh": "ä½¿ç”¨ SwiftUI æ„å»ºæ–°çš„ visionOS åº”ç”¨ï¼Œå¹¶æ·»åŠ å¹³å°ç‰¹æœ‰çš„åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "If youâ€™re new to visionOS, start with a new Xcode project to learn about the platform features, and to familiarize yourself with visionOS content and techniques. When you build an app for visionOS, SwiftUI is an excellent choice because it gives you full access to visionOS features. Although you can also use UIKit to build portions of your app, you need to use SwiftUI for many features that are unique to the platform.": {
      "zh": "å¦‚æœä½ æ˜¯ visionOS çš„æ–°æ‰‹ï¼Œè¯·ä»ä¸€ä¸ªæ–°çš„ Xcode é¡¹ç›®å¼€å§‹ï¼Œäº†è§£å¹³å°åŠŸèƒ½ï¼Œå¹¶ç†Ÿæ‚‰ visionOS çš„å†…å®¹å’ŒæŠ€æœ¯ã€‚å½“ä½ ä¸º visionOS æ„å»ºåº”ç”¨æ—¶ï¼ŒSwiftUI æ˜¯ä¸€ä¸ªç»ä½³çš„é€‰æ‹©ï¼Œå› ä¸ºå®ƒèƒ½è®©ä½ å®Œå…¨å‘æŒ¥ visionOS çš„åŠŸèƒ½ã€‚è™½ç„¶ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ UIKit æ„å»ºéƒ¨åˆ†åº”ç”¨ï¼Œä½†ä½ éœ€è¦ä½¿ç”¨ SwiftUI æ¥å®ç°è®¸å¤šè¯¥å¹³å°çš„ç‰¹æœ‰åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "å¤‡æ³¨",
      "tips": ""
    },
    "Developing for visionOS requires a Mac with Apple silicon.": {
      "zh": "ä¸º visionOS å¼€å‘éœ€è¦é…å¤‡ Apple èŠ¯ç‰‡çš„ Macã€‚",
      "tips": ""
    },
    "In any SwiftUI app, you place content onscreen using scenes. A scene contains the views and controls to display onscreen. Scenes also define the appearance of those views and controls when they appear onscreen. In visionOS, you can include both 2D and 3D views in the same scene, and you can present those views in a window or as part of the personâ€™s surroundings.": {
      "zh": "åœ¨ä»»ä½• SwiftUI åº”ç”¨ä¸­ï¼Œä½ éƒ½å¯ä»¥ä½¿ç”¨åœºæ™¯åœ¨å±å¹•ä¸Šæ”¾ç½®å†…å®¹ã€‚åœºæ™¯åŒ…å«äº†è¦åœ¨å±å¹•ä¸Šæ˜¾ç¤ºçš„è§†å›¾å’Œæ§ä»¶ã€‚åœºæ™¯è¿˜å®šä¹‰äº†è¿™äº›è§†å›¾å’Œæ§ä»¶åœ¨å±å¹•ä¸Šæ˜¾ç¤ºæ—¶çš„å¤–è§‚ã€‚åœ¨ visionOS ä¸­ï¼Œä½ å¯ä»¥åœ¨åŒä¸€åœºæ™¯ä¸­åŒ…å«äºŒç»´å’Œä¸‰ç»´è§†å›¾ï¼Œä¹Ÿå¯ä»¥å°†è¿™äº›è§†å›¾å‘ˆç°åœ¨çª—å£æˆ–åœ¨ç”¨æˆ·å‘¨å›´ç¯å¢ƒä¸­ã€‚",
      "tips": ""
    },
    "Start with a new Xcode project and add features to familiarize yourself with visionOS content and techniques. Run your app in Simulator to verify your content looks like you expect, and run it on device to see your 3D content come to life.": {
      "zh": "ä»ä¸€ä¸ªæ–°çš„ Xcode é¡¹ç›®å¼€å§‹ï¼Œæ·»åŠ åŠŸèƒ½ä»¥ç†Ÿæ‚‰ visionOS çš„å†…å®¹å’ŒæŠ€æœ¯ã€‚åœ¨æ¨¡æ‹Ÿå™¨ä¸­è¿è¡Œåº”ç”¨ï¼ŒéªŒè¯å†…å®¹æ˜¯å¦ç¬¦åˆä½ çš„é¢„æœŸï¼Œç„¶ååœ¨è®¾å¤‡ä¸Šè¿è¡Œä»¥è§è¯æ ©æ ©å¦‚ç”Ÿçš„ä¸‰ç»´å†…å®¹ã€‚",
      "tips": ""
    },
    "Organize your content around one or more scenes, which manage your appâ€™s interface. Each scene contains the views and controls you want to display, and the scene type determines whether your content adopts a 2D or 3D appearance. SwiftUI adds 3D scene types specifically for visionOS, and also adds 3D elements and layout options for all scene types.": {
      "zh": "å›´ç»•ä¸€ä¸ªæˆ–å¤šä¸ªåœºæ™¯ç»„ç»‡å†…å®¹ï¼Œåœºæ™¯å†³å®šäº†åº”ç”¨çš„ç•Œé¢ã€‚æ¯ä¸ªåœºæ™¯éƒ½åŒ…å«äº†ä½ è¦æ˜¾ç¤ºçš„è§†å›¾å’Œæ§ä»¶ï¼Œè€Œåœºæ™¯ç±»å‹åˆ™å†³å®šä½ çš„å†…å®¹é‡‡ç”¨äºŒç»´è¿˜æ˜¯ä¸‰ç»´å¤–è§‚ã€‚SwiftUI ä¸“é—¨ä¸º visionOS æ·»åŠ äº†ä¸‰ç»´åœºæ™¯ç±»å‹ï¼Œè¿˜ä¸ºæ‰€æœ‰åœºæ™¯ç±»å‹æ·»åŠ äº†ä¸‰ç»´å…ƒç´ å’Œå¸ƒå±€é€‰é¡¹ã€‚",
      "tips": ""
    },
    "Create your Xcode project": {
      "zh": "åˆ›å»º Xcode é¡¹ç›®",
      "tips": ""
    },
    "Create a new project in Xcode by choosing File > New > Project. Navigate to the visionOS section of the template chooser, and choose the App template. When prompted, specify a name for your project along with other options.": {
      "zh": "åœ¨ Xcode ä¸­é€‰æ‹© \"æ–‡ä»¶\">\"æ–°å»º\">\"é¡¹ç›®\"ï¼Œåˆ›å»ºä¸€ä¸ªæ–°é¡¹ç›®ã€‚å¯¼èˆªè‡³æ¨¡æ¿é€‰æ‹©å™¨çš„ visionOS éƒ¨åˆ†ï¼Œç„¶åé€‰æ‹©åº”ç”¨æ¨¡æ¿ã€‚å‡ºç°æç¤ºæ—¶ï¼Œä¸ºé¡¹ç›®æŒ‡å®šåç§°å’Œå…¶ä»–é€‰é¡¹ã€‚",
      "tips": ""
    },
    "When creating a new visionOS app, you can configure your appâ€™s initial scene types from the configuration dialog. To display primarily 2D content in your initial scene, choose a Window as your initial scene type. For primarily 3D content, choose a Volume. You can also add an immersive scene to place your content in the personâ€™s surroundings.": {
      "zh": "åˆ›å»ºæ–°çš„ visionOS åº”ç”¨æ—¶ï¼Œä½ å¯ä»¥åœ¨é…ç½®å¯¹è¯æ¡†ä¸­é…ç½®åº”ç”¨çš„åˆå§‹åœºæ™¯ç±»å‹ã€‚å¦‚æœè¦åœ¨åˆå§‹åœºæ™¯ä¸­ä¸»è¦æ˜¾ç¤ºäºŒç»´å†…å®¹ï¼Œè¯·é€‰æ‹© \"çª—å£ \"ä½œä¸ºåˆå§‹åœºæ™¯ç±»å‹ã€‚å¦‚æœä¸»è¦æ˜¾ç¤ºä¸‰ç»´å†…å®¹ï¼Œåˆ™é€‰æ‹© \"ä½“é‡\"ã€‚ä½ è¿˜å¯ä»¥æ·»åŠ ä¸€ä¸ªæ²‰æµ¸å¼åœºæ™¯ï¼Œå°†å†…å®¹ç½®äºç”¨æˆ·çš„å‘¨å›´ç¯å¢ƒä¸­ã€‚",
      "tips": ""
    },
    "Include a Reality Composer Pro project file when you want to create 3D assets or scenes to display from your app. Use this project file to build content from primitive shapes and existing USDZ assets. You can also use it to build and test custom RealityKit animations and behaviors for your content.": {
      "zh": "å½“ä½ æƒ³åˆ›å»ºæ˜¾ç¤ºåœ¨åº”ç”¨ä¸­çš„ä¸‰ç»´ç´ ææˆ–åœºæ™¯æ—¶ï¼Œè¯·åŒ…å«ä¸€ä¸ª Reality Composer Pro é¡¹ç›®æ–‡ä»¶ã€‚ä½¿ç”¨æ­¤é¡¹ç›®æ–‡ä»¶å¯ä»åŸå§‹å½¢çŠ¶å’Œç°æœ‰çš„ USDZ ç´ æåˆ›å»ºå†…å®¹ã€‚ä½ è¿˜å¯ä»¥ç”¨å®ƒä¸ºä½ çš„å†…å®¹æ„å»ºå¹¶æµ‹è¯•è‡ªå®šä¹‰çš„ RealityKit åŠ¨ç”»å’Œè¡Œä¸ºã€‚",
      "tips": ""
    },
    "Modify the existing window": {
      "zh": "ä¿®æ”¹ç°æœ‰çª—å£",
      "tips": ""
    },
    "Build your initial interface using standard SwiftUI views. Views provide the basic content for your interface, and you customize the appearance and behavior of them using SwiftUI modifiers. For example, the .background modifier adds a partially transparent tint color behind your content:": {
      "zh": "ä½¿ç”¨æ ‡å‡† SwiftUI è§†å›¾æ„å»ºåˆå§‹ç•Œé¢ã€‚è§†å›¾ä¸ºç•Œé¢æä¾›äº†åŸºæœ¬å†…å®¹ï¼Œä½ å¯ä»¥ä½¿ç”¨ SwiftUI ä¿®é¥°ç¬¦è‡ªå®šä¹‰è§†å›¾çš„å¤–è§‚å’Œè¡Œä¸ºã€‚ä¾‹å¦‚ï¼Œ.background ä¿®é¥°ç¬¦å¯åœ¨å†…å®¹åæ–¹æ·»åŠ åŠé€æ˜çš„è‰²è°ƒï¼š",
      "tips": ""
    },
    "To learn more about how to create and configure interfaces using SwiftUI, see SwiftUI Essentials.": {
      "zh": "è¦è¿›ä¸€æ­¥äº†è§£å¦‚ä½•ä½¿ç”¨ SwiftUI åˆ›å»ºå’Œé…ç½®ç•Œé¢ï¼Œè¯·å‚é˜… SwiftUI Essentialsã€‚",
      "tips": ""
    },
    "Handle events in your views": {
      "zh": "å¤„ç†è§†å›¾ä¸­çš„äº‹ä»¶",
      "tips": ""
    },
    "Many SwiftUI views handle interactions automatically â€” all you do is provide code to run when the interactions occur. You can also add SwiftUI gesture recognizers to a view to handle tap, long-press, drag, rotate, and zoom gestures. The system automatically maps the following types of input to your SwiftUI event-handling code:": {
      "zh": "è®¸å¤š SwiftUI è§†å›¾ä¼šè‡ªåŠ¨å¤„ç†äº¤äº’ï¼Œä½ åªéœ€åœ¨äº¤äº’å‘ç”Ÿæ—¶æä¾›è¦è¿è¡Œçš„ä»£ç å³å¯ã€‚ä½ è¿˜å¯ä»¥åœ¨è§†å›¾ä¸­æ·»åŠ  SwiftUI æ‰‹åŠ¿è¯†åˆ«å™¨ï¼Œä»¥å¤„ç†è½»ç‚¹ã€é•¿æŒ‰ã€æ‹–åŠ¨ã€æ—‹è½¬å’Œç¼©æ”¾æ‰‹åŠ¿ã€‚ç³»ç»Ÿä¼šè‡ªåŠ¨å°†ä»¥ä¸‹ç±»å‹çš„è¾“å…¥æ˜ å°„åˆ°ä½ çš„ SwiftUI äº‹ä»¶å¤„ç†ä»£ç ä¸­ï¼š",
      "tips": ""
    },
    "Indirect input. The personâ€™s eyes indicate the target of an interaction. To start the interaction, the person touches their thumb and forefinger together on one or both hands. Additional finger and hand movements define the gesture type.": {
      "zh": "é—´æ¥è¾“å…¥ã€‚ç”¨æˆ·çœ¼ç›æŒ‡ç¤ºå‡ºäº†äº’åŠ¨ç›®æ ‡ã€‚è¦å¼€å§‹äº’åŠ¨ï¼Œç”¨æˆ·ä¼šå°†ä¸€åªæˆ–ä¸¤åªæ‰‹çš„æ‹‡æŒ‡å’Œé£ŸæŒ‡å¹¶æ‹¢ã€‚å…¶ä»–çš„æ‰‹æŒ‡å’Œæ‰‹æŒåŠ¨ä½œå†³å®šäº†æ‰‹åŠ¿çš„ç±»å‹ã€‚",
      "tips": ""
    },
    "Direct input. When a personâ€™s finger occupies the same space as an onscreen item, the system reports an interaction. Additional finger and hand movements define the gesture type.": {
      "zh": "ç›´æ¥è¾“å…¥ã€‚å½“ç”¨æˆ·æ‰‹æŒ‡ä¸å±å¹•ä¸Šçš„é¡¹ç›®å æ®ç›¸åŒç©ºé—´æ—¶ï¼Œç³»ç»Ÿä¼šæŠ¥å‘Šä¸€æ¬¡äº¤äº’ã€‚å…¶ä»–çš„æ‰‹æŒ‡å’Œæ‰‹æŒåŠ¨ä½œå†³å®šäº†æ‰‹åŠ¿çš„ç±»å‹ã€‚",
      "tips": ""
    },
    "Keyboard input. People can use a connected mouse, trackpad, or keyboard to interact with items, trigger menu commands, and perform gestures.": {
      "zh": "é”®ç›˜è¾“å…¥ã€‚ç”¨æˆ·å¯ä»¥ä½¿ç”¨è¿æ¥çš„é¼ æ ‡ã€è§¦æ§æ¿æˆ–é”®ç›˜ä¸é¡¹ç›®äº’åŠ¨ï¼Œè§¦å‘èœå•å‘½ä»¤å¹¶æ‰§è¡Œæ‰‹åŠ¿ã€‚",
      "tips": ""
    },
    "For more information about handling interactions in SwiftUI views, see Handling User Input in the SwiftUI Essentials tutorial.": {
      "zh": "æœ‰å…³åœ¨ SwiftUI è§†å›¾ä¸­å¤„ç†äº¤äº’çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… SwiftUI Essentials æ•™ç¨‹ä¸­çš„å¤„ç†ç”¨æˆ·è¾“å…¥ã€‚",
      "tips": ""
    },
    "Build and run your app": {
      "zh": "æ„å»ºå¹¶è¿è¡Œåº”ç”¨",
      "tips": ""
    },
    "Build and run your app in Simulator to see how it looks. Simulator for visionOS has a virtual background as the backdrop for your appâ€™s content. Use your keyboard and your mouse or trackpad to navigate around the environment and interact with your app.": {
      "zh": "åœ¨æ¨¡æ‹Ÿå™¨ä¸­æ„å»ºå¹¶è¿è¡Œåº”ç”¨æ¥æŸ¥çœ‹å¤–è§‚ã€‚visionOS æ¨¡æ‹Ÿå™¨æœ‰ä¸€ä¸ªè™šæ‹ŸèƒŒæ™¯ï¼Œä½œä¸ºåº”ç”¨å†…å®¹çš„èƒŒæ™¯ã€‚ä½¿ç”¨é”®ç›˜ï¼Œé¼ æ ‡æˆ–è§¦æ§æ¿åœ¨ç¯å¢ƒä¸­å¯¼èˆªï¼Œå¹¶ä¸åº”ç”¨è¿›è¡Œäº¤äº’ã€‚",
      "tips": ""
    },
    "Tap and drag the window bar below your appâ€™s content to reposition the window in the environment. Move the pointer over the circle next to the window bar to reveal the windowâ€™s close button. Move the cursor to one of the windowâ€™s corners to turn the window bar into a resizing control.": {
      "zh": "è½»ç‚¹å¹¶æ‹–åŠ¨åº”ç”¨å†…å®¹ä¸‹æ–¹çš„çª—å£æ ï¼Œå¯è°ƒæ•´çª—å£åœ¨ç¯å¢ƒä¸­çš„ä½ç½®ã€‚å°†æŒ‡é’ˆç§»è‡³çª—å£æ æ—è¾¹çš„åœ†åœˆä¸Šï¼Œæ˜¾ç¤ºçª—å£çš„å…³é—­æŒ‰é’®ã€‚å°†å…‰æ ‡ç§»è‡³çª—å£çš„æŸä¸ªè§’è½ï¼Œå¯å°†çª—å£æ å˜æˆä¸€ä¸ªè°ƒæ•´å¤§å°çš„æ§ä»¶ã€‚",
      "tips": ""
    },
    "Apps donâ€™t control the placement of windows in the space. The system places each window in its initial position, and updates that position based on further interactions with the app.": {
      "zh": "åº”ç”¨æ— æ³•æ§åˆ¶çª—å£åœ¨ç©ºé—´ä¸­çš„ä½ç½®ã€‚ç³»ç»Ÿä¼šå°†æ¯ä¸ªçª—å£æ”¾ç½®åœ¨å…¶åˆå§‹ä½ç½®ï¼Œå¹¶æ ¹æ®ä¸åº”ç”¨çš„è¿›ä¸€æ­¥äº¤äº’æ›´æ–°è¯¥ä½ç½®ã€‚",
      "tips": ""
    },
    "For additional information about how to interact with your app in Simulator, see Interacting with your app in the visionOS simulator.": {
      "zh": "æœ‰å…³å¦‚ä½•åœ¨æ¨¡æ‹Ÿå™¨ä¸­ä¸åº”ç”¨äº¤äº’çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…åœ¨ visionOS æ¨¡æ‹Ÿå™¨ä¸­ä¸åº”ç”¨äº¤äº’ã€‚",
      "tips": ""
    }
  },
  "visionos/designing-realitykit-content-with-reality-composer-pro": {
    "Designing RealityKit content with Reality Composer Pro": {
      "zh": "ä½¿ç”¨ Reality Composer Pro è®¾è®¡ RealityKit å†…å®¹",
      "tips": ""
    },
    "Design RealityKit scenes for your visionOS app.": {
      "zh": "ä¸ºä½ çš„ visionOS åº”ç”¨è®¾è®¡ RealityKit åœºæ™¯ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è§ˆ",
      "tips": ""
    },
    "Use Reality Composer Pro to visually design, edit, and preview RealityKit content. In Reality Composer Pro, you can create one or more scenes, which act as a container for RealityKit content. Scenes contain hierarchies of entities, which are virtual objects such as 3D models.": {
      "zh": "Reality Composer Pro èƒ½ç”¨äºå¯è§†åŒ–è®¾è®¡ã€ç¼–è¾‘å’Œé¢„è§ˆ RealityKit å†…å®¹ã€‚åœ¨ Reality Composer Pro ä¸­ï¼Œä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªæˆ–å¤šä¸ªåœºæ™¯ï¼Œå°†å…¶å½“ä½œ RealityKit å†…å®¹çš„å®¹å™¨ã€‚åœºæ™¯åŒ…å«å®ä½“å±‚çº§ï¼Œè€Œè¿™äº›å®ä½“åˆ™æ˜¯ä¾‹å¦‚ 3D æ¨¡å‹ç­‰çš„è™šæ‹Ÿå¯¹è±¡ã€‚",
      "tips": ""
    },
    "In addition to helping you compose scenes, Reality Composer Pro also gives you the ability to add and configure components â€” even custom components that youâ€™ve written â€” to the entities in your scenes and also lets you create complex materials and effects using a node-based material editor called Shader Graph.": {
      "zh": "é™¤äº†å¯ä»¥å¸®åŠ©ä½ ç¼–æ’åœºæ™¯ï¼ŒReality Composer Pro è¿˜èƒ½è®©ä½ æ·»åŠ å’Œé…ç½®ç»„ä»¶â€”â€”åŒ…æ‹¬ä½ è‡ªå·±ç¼–å†™çš„è‡ªå®šä¹‰ç»„ä»¶â€”â€”åˆ°ä½ åœºæ™¯ä¸­çš„å®ä½“ã€‚å¹¶ä¸”å…è®¸ä½ ä½¿ç”¨ä¸€ä¸ªåŸºäºèŠ‚ç‚¹çš„æè´¨ç¼–è¾‘å™¨ï¼ˆç§°ä¹‹ä¸º Shader Graphï¼‰æ¥åˆ›å»ºå¤æ‚çš„æè´¨å’Œæ•ˆæœã€‚",
      "tips": ""
    },
    "Launch Reality Composer Pro": {
      "zh": "å¯åŠ¨ Reality Composer Pro",
      "tips": ""
    },
    "When you create a visionOS project in Xcode, it also contains a default Reality Composer Pro project named RealityKitContent within the Packages folder, which is a Swift package. The RealityKitContent package can include images, 3D models, and other assets like audio and video files. The assets you add to your project go in the RealityKitContent.rkassets bundle, while your source code goes into its Sources directory. The package also contains a file called Package.realitycomposerpro, which is the actual Reality Composer Pro project.": {
      "zh": "å½“ä½ åœ¨ Xcode ä¸­åˆ›å»ºä¸€ä¸ª visionOS é¡¹ç›®æ—¶ï¼Œå®ƒè¿˜ä¼šåœ¨ Packages æ–‡ä»¶å¤¹ä¸­åŒ…å«ä¸€ä¸ªåä¸º RealityKitContent çš„é»˜è®¤çš„ Reality Composer Pro é¡¹ç›®ï¼Œå®ƒæ˜¯ä¸€ä¸ª Swift packageã€‚RealityKitContent åŒ…å¯ä»¥åŒ…æ‹¬å›¾åƒã€3D æ¨¡å‹ä»¥åŠå…¶ä»–éŸ³è§†é¢‘æ–‡ä»¶èµ„æºã€‚ä½ æ·»åŠ åˆ°é¡¹ç›®ä¸­çš„èµ„æºä¼šæ”¾åˆ° RealityKitContent.rkassets åŒ…ä¸­ï¼Œè€Œæºä»£ç åˆ™ä¼šæ”¾åœ¨ Sources ç›®å½•ä¸‹ã€‚è¿™ä¸ªåŒ…è¿˜å¸¦æœ‰ä¸€ä¸ªåä¸º Package.realitycomposerpro çš„æ–‡ä»¶ï¼Œè¿™å°±æ˜¯å®é™…çš„ Reality Composer Pro é¡¹ç›®ã€‚",
      "tips": ""
    },
    "To launch Reality Composer Pro, double-click the Package.realitycomposerpro file in the Project navigator, or click the Open in Reality Composer Pro button. If your project doesnâ€™t already have a Reality Composer Pro project, you can launch Reality Composer Pro directly by choosing Xcode > Open Developer Tool > Reality Composer Pro.": {
      "zh": "è¦å¯åŠ¨ Reality Composer Proï¼Œå¯ä»¥åœ¨é¡¹ç›®å¯¼èˆªæ ï¼ˆProject navigatorï¼‰ä¸­åŒå‡» Package.realitycomposerpro æ–‡ä»¶ï¼Œæˆ–è€…ç‚¹å‡»â€œOpen in Reality Composer Proâ€æŒ‰é’®ã€‚å¦‚æœä½ çš„é¡¹ç›®è¿˜æ²¡æœ‰ Reality Composer Pro é¡¹ç›®ï¼Œä½ å¯ä»¥é€šè¿‡é€‰æ‹© Xcode > Open Developer Tool > Reality Composer Pro çš„æ–¹å¼ç›´æ¥å¯åŠ¨ Reality Composer Proã€‚",
      "tips": ""
    },
    "For efficiency, store all of your RealityKit assets in Reality Composer Pro projects. Xcode compiles Reality Composer Pro projects into a more efficient format when you build your app.": {
      "zh": "è¦æƒ³æé«˜æ•ˆç‡ï¼Œå¯ä»¥å°†ä½ æ‰€æœ‰çš„ RealityKit èµ„æºä¿å­˜åˆ° Reality Composer Pro é¡¹ç›®ä¸­ã€‚Xcode ä¼šåœ¨ä½ æ„å»ºé¡¹ç›®æ—¶å°† Reality Composer Pro é¡¹ç›®ç¼–è¯‘æˆæ›´é«˜æ•ˆçš„æ ¼å¼ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨æ„",
      "tips": ""
    },
    "Loading assets from a .reality file is considerably faster and more resource efficient than loading individual asset files.": {
      "zh": "ä» .reality æ–‡ä»¶åŠ è½½èµ„æºï¼Œä¼šæ¯”åŠ è½½å•ä¸ªèµ„æºæ–‡ä»¶è¦å¿«å¾—å¤šï¼Œè€Œä¸”æ›´æœ‰æ•ˆç‡ã€‚",
      "tips": ""
    },
    "Orient yourself in Reality Composer Pro": {
      "zh": "ç†Ÿæ‚‰ Reality Composer Pro çš„æ“ä½œç•Œé¢",
      "tips": ""
    },
    "The Reality Composer Pro window has several sections. The top-half displays the active scene. If you have multiple scenes, the window shows a tab bar at the top with one tab for each open scene. A scene in Reality Composer Pro is an entity hierarchy stored in a .usda file.": {
      "zh": "Reality Composer Pro çª—å£åŒ…å«å¤šä¸ªéƒ¨åˆ†ã€‚åœ¨ä¸ŠåŠéƒ¨åˆ†æ˜¾ç¤ºå¤„äºæ´»è·ƒçŠ¶æ€çš„åœºæ™¯ã€‚å¦‚æœä½ æœ‰å¤šä¸ªåœºæ™¯ï¼Œåœ¨çª—å£é¡¶éƒ¨ä¼šæœ‰æ ‡ç­¾æ ï¼Œæ¯ä¸€ä¸ªæ‰“å¼€çš„åœºæ™¯å¯¹åº”ä¸€ä¸ªæ ‡ç­¾é¡µã€‚åœ¨ Reality Composer Pro ä¸­çš„åœºæ™¯æ˜¯ä¸€ä¸ªä¿å­˜åœ¨ .usda æ–‡ä»¶ä¸­çš„å®ä½“å±‚çº§ã€‚",
      "tips": ""
    },
    "The left side of the top pane contains the hierarchy browser, which shows a tree representation of the entities in the active scene. You can toggle it using the top-left toolbar button to reveal errors and warnings. The middle pane is the 3D View, which shows a 3D representation of the active scene. The top-right is the inspector, which shows configurable values for the item selected in the 3D view, hierarchy view, or Shader Graph, depending on which has focus.": {
      "zh": "ä¸ŠåŠéƒ¨åˆ†é¢æ¿çš„å·¦ä¾§æ˜¯å±‚çº§ç»“æ„æµè§ˆå·¥å…·ï¼Œä»¥æ ‘çŠ¶ç»“æ„æ˜¾ç¤ºå½“å‰æ´»è·ƒçŠ¶æ€åœºæ™¯ä¸­çš„å®ä½“ã€‚ä½ å¯ä»¥ä½¿ç”¨å·¦ä¸Šè§’çš„å·¥å…·æ æŒ‰é’®æ¥è¿›è¡Œé”™è¯¯ã€è­¦å‘Šå’Œå±‚çº§è§†å›¾ç»“æ„çš„æ˜¾ç¤ºåˆ‡æ¢ã€‚ä¸­é—´çš„é¢æ¿æ˜¯ 3D è§†å›¾ï¼Œå±•ç¤ºæ´»è·ƒåœºæ™¯çš„ 3D å†…å®¹ã€‚åœ¨å³ä¸Šè§’æ˜¯æ£€æŸ¥å™¨ï¼Œåˆ†åˆ«æ˜¾ç¤ºåœ¨ 3D è§†å›¾æ¨¡å¼ã€å±‚çº§è§†å›¾æ¨¡å¼æˆ–è€… Shader Graph ä¸‹é€‰ä¸­çš„å†…å®¹çš„å¯é…ç½®å€¼ï¼Œå…·ä½“å–å†³äºå½“å‰é€‰ä¸­çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "Tip": {
      "zh": "å»ºè®®",
      "tips": ""
    },
    "A Reality Composer Pro scene can represent an entire RealityKit scene, and you can have multiple scenes in your Reality Composer Pro project, each driving a different RealityView in the same app. A scene can also contain a collection of entities to use as a building block. For example, if you had an airplane model, you might build a scene for it that contains its 3D model, a particle effect to make smoke come out its engine, and audio entities or components that represent the various sounds a plane makes. Your app could then load those combined assets and use them together anywhere it needs.": {
      "zh": "ä¸€ä¸ª Reality Composer Pro åœºæ™¯å¯ä»¥è¡¨ç¤ºæ•´ä¸ª RealityKit åœºæ™¯ï¼Œå¹¶ä¸”ä½ å¯ä»¥åœ¨ Reality Composer Pro é¡¹ç›®ä¸­æ‹¥æœ‰å¤šä¸ªåœºæ™¯ï¼Œåœ¨åŒä¸€ä¸ªåº”ç”¨ä¸­ï¼Œæ¯ä¸€ä¸ªåœºæ™¯è´Ÿè´£é©±åŠ¨ä¸åŒçš„ RealityViewã€‚ä¸€ä¸ªåœºæ™¯è¿˜å¯ä»¥åŒ…å«ä¸€ç³»åˆ—ä½œä¸ºæ„å»ºæ¨¡å—çš„å®ä½“ã€‚ä¸¾ä¸ªä¾‹å­æ¥è¯´ï¼Œå¦‚æœä½ æœ‰ä¸€æ¶é£æœºæ¨¡å‹ï¼Œä½ å¯èƒ½ä¼šä¸ºå®ƒæ„å»ºä¸€ä¸ªåŒ…å« 3D æ¨¡å‹çš„åœºæ™¯ï¼Œä»å¼•æ“ä¸­ç”ŸæˆçƒŸé›¾æ•ˆæœçš„ç²’å­æ¨¡å‹ï¼Œä»¥åŠå±•ç°é£æœºäº§ç”Ÿçš„å„ç§å£°éŸ³çš„éŸ³é¢‘å®ä½“æˆ–ç»„ä»¶ã€‚ä½ çš„åº”ç”¨å¯ä»¥åŠ è½½è¿™äº›åˆå¹¶åçš„èµ„æºï¼Œå¹¶åœ¨ä»»ä½•éœ€è¦çš„åœ°æ–¹ä½¿ç”¨ã€‚",
      "tips": ""
    },
    "The bottom half of Reality Composer Pro contains the following four tabs:": {
      "zh": "Reality Composer Pro çš„ä¸‹åŠéƒ¨åˆ†åŒ…å«ä»¥ä¸‹å››ä¸ªæ ‡ç­¾é¡µï¼š",
      "tips": ""
    },
    "Displays all of the assets in your project.": {
      "zh": "æ˜¾ç¤ºä½ çš„é¡¹ç›®ä¸­çš„æ‰€æœ‰èµ„æºã€‚",
      "tips": ""
    },
    "An advanced, node-based material editor.": {
      "zh": "ä¸€ç§å…ˆè¿›çš„ã€åŸºäºèŠ‚ç‚¹çš„æè´¨ç¼–è¾‘å™¨ã€‚",
      "tips": ""
    },
    "A tool for combining sound assets.": {
      "zh": "ä¸€ä¸ªç”¨äºåˆæˆå£°éŸ³èµ„æºçš„å·¥å…·ã€‚",
      "tips": ""
    },
    "Information about the currently open scene, such as the number of entities, vertices, and animations it contains.": {
      "zh": "å½“å‰æ‰“å¼€çš„åœºæ™¯ä¿¡æ¯ï¼Œæ¯”å¦‚å®ƒåŒ…å«çš„å®ä½“ã€é¡¶ç‚¹å’ŒåŠ¨ç”»çš„æ•°é‡ã€‚",
      "tips": ""
    },
    "Reality Composer Pro projects start with a single empty scene called Scene which is stored in a file called Scene.usda. You can create as many additional scenes as you need by choosing File > New > Scene. New scenes open as tabs along the top of the window, and they also appear in the Project Browser as .usda files.": {
      "zh": "Reality Composer Pro é¡¹ç›®åœ¨å¼€å§‹æ—¶ä¼šæœ‰ä¸€ä¸ªåä¸º Scene çš„ç©ºç™½åœºæ™¯ï¼Œä¿å­˜åœ¨ Scene.usda æ–‡ä»¶ä¸­ã€‚ä½ å¯ä»¥é€šè¿‡é€‰æ‹© File > New > Scene æ¥åˆ›å»ºä½ æ‰€éœ€çš„ä»»æ„æ•°é‡çš„æ–°åœºæ™¯ã€‚æ–°åœºæ™¯ä¼šä½œä¸ºçª—å£é¡¶éƒ¨çš„æ ‡ç­¾é¡µæ‰“å¼€ï¼Œè€Œä¸”å®ƒä»¬ä¹Ÿä¼šä»¥ .usda æ–‡ä»¶çš„å½¢å¼å‡ºç°åœ¨é¡¹ç›®æµè§ˆå™¨ï¼ˆProject Browserï¼‰ä¸­ã€‚",
      "tips": ""
    },
    "If you close a sceneâ€™s tab and need to re-open it, double-click on the sceneâ€™s .usda file in the Project Browser. If you no longer need a scene, delete its .usda file from the Project Browser or remove it from your projectâ€™s .rkassets bundle in Xcode.": {
      "zh": "å¦‚æœä½ å…³é—­äº†ä¸€ä¸ªåœºæ™¯çš„æ ‡ç­¾é¡µä¸”éœ€è¦é‡æ–°æ‰“å¼€å®ƒï¼Œé‚£ä¹ˆä½ å¯ä»¥åœ¨é¡¹ç›®æµè§ˆå™¨ä¸ŠåŒå‡»åœºæ™¯çš„ .usda æ–‡ä»¶ã€‚å¦‚æœä½ ä¸å†éœ€è¦ä¸€ä¸ªåœºæ™¯ï¼Œå¯ä»¥ä»é¡¹ç›®æµè§ˆå™¨ä¸­åˆ é™¤å®ƒçš„ .usda æ–‡ä»¶ï¼Œæˆ–è€…ä» Xcode ä¸­çš„é¡¹ç›®çš„ .rkassets åŒ…ä¸­åˆ é™¤å®ƒã€‚",
      "tips": ""
    },
    "To delete a scene:": {
      "zh": "è¦åˆ é™¤ä¸€ä¸ªåœºæ™¯ï¼š",
      "tips": ""
    },
    "Close the scene tab by selecting File > Close Tab": {
      "zh": "é€šè¿‡é€‰æ‹© File > Close Tab æ¥å…³é—­åœºæ™¯æ ‡ç­¾é¡µ",
      "tips": ""
    },
    "Select the sceneâ€™s .usda file in the Project Browser": {
      "zh": "åœ¨é¡¹ç›®æµè§ˆå™¨ä¸­é€‰æ‹©åœºæ™¯çš„ .usda æ–‡ä»¶",
      "tips": ""
    },
    "Control-click the sceneâ€™s .usda file the Project Browser.": {
      "zh": "åœ¨é¡¹ç›®æµè§ˆå™¨ä¸­å¯¹åœºæ™¯çš„ .usda æ–‡ä»¶æŒ‰ä½ Control çš„åŒæ—¶è¿›è¡Œç‚¹å‡»",
      "tips": ""
    },
    "Choose Delete from the contextual menu.": {
      "zh": "åœ¨èœå•ä¸­é€‰æ‹©åˆ é™¤",
      "tips": ""
    },
    "Click Move to Trash.": {
      "zh": "é€‰æ‹©ç§»åŠ¨åˆ°åºŸçº¸ç¯“",
      "tips": ""
    },
    "This removes the sceneâ€™s .usda and the scene tab at the top of the window.": {
      "zh": "è¿™å°†ç§»é™¤çª—å£ä¸Šæ–¹çš„åœºæ™¯æ ‡ç­¾é¡µå’Œåœºæ™¯çš„ .usda æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "Add assets to your project": {
      "zh": "ä¸ºä½ çš„é¡¹ç›®æ·»åŠ èµ„æº",
      "tips": ""
    },
    "In Reality Composer Pro, you design scenes by first importing assets into your project. Then add assets to scenes and move, rotate, and scale them. The Project Browser tab displays all of the asset files in your project. You can add new assets by dragging them to the Project Browser or by choosing File > Import and select the assets to add to your project. To add an asset from the Project Browser to the current scene, drag it to the 3D view in the center of the window, or to the hierarchy view in the top-left of the window.": {
      "zh": "åœ¨ Reality Composer Pro ä¸­ï¼Œä½ é¦–å…ˆé€šè¿‡å°†èµ„æºå¯¼å…¥åˆ°é¡¹ç›®ä¸­æ¥è®¾è®¡åœºæ™¯ã€‚ç„¶åå°†èµ„æºæ·»åŠ åˆ°åœºæ™¯ä¸­å¹¶å¯¹å®ƒä»¬è¿›è¡Œç§»åŠ¨ã€æ—‹è½¬å’Œç¼©æ”¾æ“ä½œã€‚é¡¹ç›®æµè§ˆå™¨æ ‡ç­¾é¡µä¼šæ˜¾ç¤ºé¡¹ç›®ä¸­çš„æ‰€æœ‰èµ„æºæ–‡ä»¶ã€‚ä½ å¯ä»¥å°†å®ƒä»¬æ‹–åˆ°é¡¹ç›®æµè§ˆå™¨æˆ–é€šè¿‡é€‰æ‹© File > Import å¹¶é€‰æ‹©è¦æ·»åŠ åˆ°é¡¹ç›®ä¸­çš„èµ„æºæ¥æ·»åŠ æ–°çš„èµ„æºã€‚è¦å°†é¡¹ç›®æµè§ˆå™¨ä¸­çš„ä¸€ä¸ªèµ„æºæ·»åŠ åˆ°å½“å‰åœºæ™¯ï¼Œä½ å¯ä»¥å°†å®ƒæ‹–åˆ°çª—å£ä¸­å¿ƒçš„ 3D è§†å›¾ä¸Šï¼Œæˆ–è€…æ‹–åŠ¨åˆ°çª—å£å·¦ä¸Šè§’çš„å±‚çº§è§†å›¾å¤„ã€‚",
      "tips": ""
    },
    "Reality Composer Pro projects can contain assets not used in any scene. Such assets are still compiled into your app and can be loaded at runtime and take full advantage of the efficient loading process for .reality files.": {
      "zh": "Reality Composer Pro é¡¹ç›®å¯ä»¥åŒ…å«æœªåœ¨ä»»ä½•åœºæ™¯ä¸­ä½¿ç”¨çš„èµ„æºã€‚è¿™äº›èµ„æºä¾æ—§ä¼šè¢«ç¼–è¯‘åˆ°ä½ çš„åº”ç”¨ä¸­ï¼Œå¹¶ä¸”åœ¨è¿è¡Œæ—¶åŠ è½½ï¼Œå¹¶èƒ½å……åˆ†åˆ©ç”¨ .reality æ–‡ä»¶é«˜æ•ˆçš„åŠ è½½è¿‡ç¨‹ã€‚",
      "tips": ""
    },
    "Reality Composer Pro can represent many assets as entities, but it canâ€™t represent all assets that way; for example:": {
      "zh": "Reality Composer Pro å¯ä»¥å°†è®¸å¤šèµ„æºè¡¨ç¤ºä¸ºå®ä½“ï¼Œä½†å¹¶ä¸é€‚ç”¨äºæ‰€æœ‰èµ„æºã€‚ä¾‹å¦‚ï¼š",
      "tips": ""
    },
    "USDZ models do become an entity or entity hierarchy when you add them to a scene.": {
      "zh": "å½“ä½ å°† USDC æ¨¡å‹æ·»åŠ åˆ°åœºæ™¯ä¸­æ—¶ï¼Œå®ƒä»¬ä¼šå˜æˆä¸€ä¸ªå®ä½“æˆ–è€…å®ä½“å±‚çº§ç»“æ„ã€‚",
      "tips": ""
    },
    "Image files do not become an entity. Reality Composer Pro only uses image assets indirectly, such as being the source texture for materials you build in Shader Graph. If you drag assets that Reality Composer Pro canâ€™t turn into an entity, nothing happens.": {
      "zh": "å›¾åƒæ–‡ä»¶ä¸ä¼šå˜æˆå®ä½“ã€‚Reality Composer Pro åªä¼šé—´æ¥ä½¿ç”¨å›¾åƒèµ„æºï¼Œæ¯”å¦‚ä½œä¸ºä½ åœ¨ Shader Graph ä¸­æ„å»ºçš„æè´¨çš„åŸå§‹çº¹ç†ã€‚å¦‚æœä½ æ‹–åŠ¨ Reality Composer Pro æ— æ³•è½¬åŒ–æˆå®ä½“çš„èµ„æºï¼Œå°†ä¸ä¼šé€ æˆä»»ä½•å½±å“ã€‚",
      "tips": ""
    },
    "Add any 3D models, animations, sounds, and image files you need to your project. You can organize your assets into subfolders to make the Project Browser more manageable as your project grows in size.": {
      "zh": "å°†ä½ æ‰€éœ€çš„ä»»ä½• 3D æ¨¡å‹ã€åŠ¨ç”»ã€å£°éŸ³å’Œå›¾åƒæ–‡ä»¶æ·»åŠ åˆ°é¡¹ç›®ä¸­ã€‚éšç€ä½ é¡¹ç›®è§„æ¨¡çš„å¢é•¿ï¼Œä¸ºä½¿é¡¹ç›®æµè§ˆå™¨æ›´æ–¹ä¾¿ç®¡ç†èµ„æºï¼Œå¯ä»¥å°†å®ƒä»¬æ•´ç†åˆ°å„ä¸ªå­æ–‡ä»¶å¤¹ä¸­ã€‚",
      "tips": ""
    },
    "Reality Composer Pro has a library of assets that you can use in your own apps. You can access the library by clicking the Add button (+) in the toolbar. Click the icon of the down-arrow inside a circle next to an asset to download the asset to Reality Composer Pro. When the download finishes, you can double-click or drag the asset into your project.": {
      "zh": "Reality Composer Pro æœ‰ä¸€ä¸ªå¯ä»¥åœ¨è‡ªå·±çš„åº”ç”¨ä¸­ä½¿ç”¨çš„èµ„æºåº“ã€‚ä½ å¯ä»¥é€šè¿‡ç‚¹å‡»å·¥å…·æ ä¸­çš„æ·»åŠ æŒ‰é’®ï¼ˆ+ï¼‰æ¥è®¿é—®åº“ã€‚ç‚¹å‡»èµ„æºæ—è¾¹å¸¦æœ‰å‘ä¸‹ç®­å¤´çš„åœ†ç¯å›¾æ ‡ï¼Œå°†èµ„æºä¸‹è½½åˆ° Reality Composer Proã€‚å½“ä¸‹è½½å®Œæˆåï¼Œä½ å¯ä»¥åŒå‡»æˆ–è€…æ‹–åŠ¨èµ„æºåˆ°ä½ çš„é¡¹ç›®ä¸­ã€‚",
      "tips": ""
    },
    "Important": {
      "zh": "é‡è¦",
      "tips": ""
    },
    "Reality Composer Pro treats your imported assets as read-only.": {
      "zh": "Reality Composer Pro å°†å·²å¯¼å…¥çš„èµ„æºè§†ä½œåªè¯»èµ„æºã€‚",
      "tips": ""
    },
    "Changes you make to assets in a scene only affect that sceneâ€™s copy of the asset. The changes you make are stored in the sceneâ€™s .usda file, not in the original asset. That means you can work without fear of inadvertently changing other scenes. If you plan to make significant changes to an imported 3D model, such as by replacing its materials with dynamic Shader Graph materials, import the model as a.usdc file instead of as a .usdz file, and then separately import just the supporting assets you need to avoid Xcode compiling assets that you donâ€™t need into your app.": {
      "zh": "ä½ åœ¨åœºæ™¯ä¸­å¯¹èµ„æºçš„ä¿®æ”¹åªä¼šå½±å“è¯¥åœºæ™¯çš„èµ„æºå‰¯æœ¬ã€‚ä½ æ‰€åšå‡ºçš„æ›´æ”¹ä¼šä¿å­˜åœ¨åœºæ™¯çš„ .usda æ–‡ä»¶ä¸­ï¼Œè€Œä¸æ˜¯åœ¨åŸå§‹èµ„æºä¸­ã€‚è¿™æ„å‘³ç€ä½ å¯ä»¥æ”¾å¿ƒå·¥ä½œï¼Œæ— éœ€æ‹…å¿ƒå¯¹å…¶ä»–åœºæ™¯è¿›è¡Œä¸å¿…è¦çš„æ”¹åŠ¨ã€‚å¦‚æœä½ è®¡åˆ’å¯¹å·²å¯¼å…¥çš„ 3D æ¨¡å‹ä½œå‡ºé‡å¤§ä¿®æ”¹ï¼Œä¾‹å¦‚ä½¿ç”¨åŠ¨æ€çš„ Shader Graph æè´¨æ›¿æ¢å…¶ç°æœ‰æè´¨ï¼Œé‚£ä¹ˆéœ€è¦å°†æ¨¡å‹ä½œä¸º .usdc æ–‡ä»¶è€Œä¸æ˜¯ .usdz æ–‡ä»¶å¯¼å…¥ï¼Œç„¶ååˆ†åˆ«å¯¼å…¥ä½ éœ€è¦çš„æ”¯æŒèµ„æºï¼Œä»¥é¿å… Xcode å°†ä½ ä¸éœ€è¦çš„èµ„æºç¼–è¯‘è¿›ä½ çš„åº”ç”¨ã€‚",
      "tips": ""
    },
    "Compose scenes from assets": {
      "zh": "ä½¿ç”¨èµ„æºæ¥åˆæˆåœºæ™¯",
      "tips": ""
    },
    "All RealityKit entities in a scene exist at a specific position, orientation, and scale, even if that entity has no visual representation. When you click to select an entity in the 3D view or hierarchy view, Reality Composer Pro displays:": {
      "zh": "åœºæ™¯ä¸­æ‰€æœ‰ RealityKit çš„å®ä½“éƒ½æœ‰ä¸€ä¸ªæ˜ç¡®çš„ä½ç½®ã€æ–¹å‘å’Œæ¯”ä¾‹ï¼Œå³ä½¿è¯¥å®ä½“å¹¶ä¸å¯è§ã€‚å½“ä½ åœ¨ 3D è§†å›¾æˆ–è€…å±‚çº§è§†å›¾ä¸­é€‰æ‹©ä¸€ä¸ªå®ä½“æ—¶ï¼ŒReality Composer Pro ä¼šæ˜¾ç¤ºï¼š",
      "tips": ""
    },
    "A manipulator over the entity in the 3D view.": {
      "zh": "åœ¨ 3D è§†å›¾ä¸­çš„å®ä½“ä¸Šå±•ç¤ºä¸€ä¸ªæ“çºµå™¨",
      "tips": ""
    },
    "Any configurable values from the entityâ€™s components in the inspector on the right.": {
      "zh": "åœ¨å³ä¾§æ£€æŸ¥å™¨ä¸­æ˜¾ç¤ºå®ä½“ç»„ä»¶çš„ä»»ä½•å¯ä»¥é…ç½®çš„å€¼ã€‚",
      "tips": ""
    },
    "You can use the manipulator to move, rotate, and scale the selected entity.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨æ“çºµå™¨æ¥ç§»åŠ¨ã€æ—‹è½¬å’Œç¼©æ”¾æ‰€é€‰çš„å®ä½“ã€‚",
      "tips": ""
    },
    "To move the selected entity around the 3D scene, drag the small colored cone that corresponds to the axis you want to move it along. Alternatively, you can drag the entity itself to move it freely relative to your viewing angle.": {
      "zh": "è¦åœ¨ 3D åœºæ™¯ä¸­ç§»åŠ¨æ‰€é€‰å®ä½“ï¼Œæ‹–åŠ¨ä¸ä½ æƒ³æ²¿å…¶ç§»åŠ¨çš„è½´å¯¹åº”çš„å°è‰²é”¥ã€‚æˆ–è€…ï¼Œä½ å¯ä»¥æ‹–åŠ¨å®ä½“æœ¬èº«ï¼Œç›¸å¯¹äºä½ çš„è§‚å¯Ÿè§’åº¦æ¥è‡ªç”±ç§»åŠ¨å®ƒã€‚",
      "tips": ""
    },
    "To rotate the selected entity, click on the manipulatorâ€™s rotation control, which looks like a circle, and drag in a circular motion.": {
      "zh": "è¦æ—‹è½¬æ‰€é€‰å®ä½“ï¼Œç‚¹å‡»æ“çºµå™¨çš„æ—‹è½¬æ§ä»¶ï¼ˆå®ƒçœ‹èµ·æ¥åƒä¸€ä¸ªåœ†ï¼‰å¹¶ä»¥åœ†çš„åŠ¨ä½œæ‹–åŠ¨ã€‚",
      "tips": ""
    },
    "Reality Composer Proâ€™s manipulator only shows one rotation control at a time.": {
      "zh": "Reality Composer Pro çš„æ“çºµå™¨åœ¨åŒä¸€æ—¶é—´åªæ˜¾ç¤ºä¸€ä¸ªæ—‹è½¬æ§ä»¶ã€‚",
      "tips": ""
    },
    "To rotate an entity on one of the other axes, click the cone corresponding to the axis you want to rotate. For example, if you want to rotate the entity on the X axis, tap the red cone to bring up the red rotation handle for that axis.": {
      "zh": "è¦åœ¨å…¶ä»–è½´ä¸Šæ—‹è½¬å®ä½“ï¼Œç‚¹å‡»ä½ æƒ³è¦æ—‹è½¬çš„è½´å¯¹åº”çš„åœ†é”¥ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ æƒ³åœ¨ X è½´ä¸Šæ—‹è½¬å®ä½“ï¼Œç‚¹å‡»çº¢è‰²åœ†é”¥ï¼Œä½¿å…¶ä¸ºè¯¥è½´å¸¦å‡ºçº¢è‰²çš„æ—‹è½¬æ‰‹æŸ„ã€‚",
      "tips": ""
    },
    "To scale the selected entity uniformly, click the rotation circle and drag away from the entity origin to scale it up, or toward the entity origin to scale it down. Because it scales uniformly, it doesnâ€™t matter which rotation handle Reality Composer Pro is showing.": {
      "zh": "è¦ç»Ÿä¸€ç¼©æ”¾æ‰€é€‰å®ä½“ï¼Œç‚¹å‡»æ—‹è½¬åœˆå¹¶ä»å®ä½“åŸç‚¹å‘å¤–æ‹–åŠ¨ä»¥æ”¾å¤§å®ƒï¼Œæˆ–è€…å‘å®ä½“åŸç‚¹æ–¹å‘æ‹–åŠ¨ä»¥ç¼©å°å®ƒã€‚ç”±äºå®ƒæ˜¯ç­‰æ¯”ä¾‹ç¼©æ”¾ï¼Œæ— è®º Reality Composer Pro æ­£åœ¨æ˜¾ç¤ºå“ªä¸ªæ—‹è½¬æ‰‹æŸ„éƒ½æ²¡æœ‰å…³ç³»ã€‚",
      "tips": ""
    },
    "In the manipulator, Red indicates the X axis, Green indicates the Y axis, and Blue indicates the Z axis.": {
      "zh": "åœ¨æ“çºµå™¨ä¸­ï¼Œçº¢è‰²ä»£è¡¨ X è½´ï¼Œç»¿è‰²ä»£è¡¨ Y è½´ï¼Œè“è‰²ä»£è¡¨ Z è½´ã€‚",
      "tips": ""
    },
    "Alternatively, you can make the same changes to the selected entity by typing new values into the transform component of the inspector. The transform component stores the position, rotation, and scale for an entity. The manipulator is just a visual way to change the values on this component.": {
      "zh": "å¦å¤–ï¼Œä½ ä¹Ÿå¯ä»¥é€šè¿‡åœ¨æ£€æŸ¥å™¨çš„è½¬æ¢ç»„ä»¶ä¸­è¾“å…¥æ–°çš„å€¼ï¼Œæ¥å¯¹é€‰ä¸­çš„å®ä½“åº”ç”¨åŒæ ·çš„æ›´æ”¹æ“ä½œã€‚è½¬æ¢ç»„ä»¶ä¿å­˜å®ä½“çš„ä½ç½®ã€æ—‹è½¬å’Œç¼©æ”¾æ•°å€¼ã€‚æ“çºµå™¨åªæ˜¯é€šè¿‡å¯è§†åŒ–æ¥æ”¹å˜æ­¤ç»„ä»¶å€¼çš„ä¸€ç§æ–¹å¼ã€‚",
      "tips": ""
    },
    "Activate and deactivate scene entities": {
      "zh": "æ¿€æ´»å’Œåœç”¨åœºæ™¯ä¸­çš„å®ä½“",
      "tips": ""
    },
    "Reality Composer Pro scenes can get quite complex and sometimes contain overlapping entities, which can be difficult to work with. To simplify a scene, you can deactivate entities to remove them from the 3D view. Deactivate entities by Control-clicking them and selecting Deactivate from the contextual menu. The entity still exists in your project and is shown in the hierarchy view, albeit grayed out and without any child entities. It wonâ€™t, however, appear in the 3D view. Xcode doesnâ€™t compile deactivated entities into your appâ€™s bundle, so itâ€™s important to re-activate any entities your app needs before saving your project. To reactivate an entity, Control-click the entity in the hierarchy view and select Activate from the contextual menu.": {
      "zh": "Reality Composer Pro çš„åœºæ™¯å¯èƒ½ä¼šéå¸¸å¤æ‚ï¼Œæœ‰æ—¶å€™ä¼šåŒ…å«éš¾ä»¥å¤„ç†çš„ã€é‡å çš„å®ä½“ã€‚ä¸ºäº†ç®€åŒ–åœºæ™¯ï¼Œä½ å¯ä»¥åœç”¨å®ä½“ä»è€Œå°†å®ƒä»¬ä» 3D è§†å›¾ä¸­ç§»é™¤ã€‚é€šè¿‡æŒ‰ä½ Control çš„åŒæ—¶åœ¨å®ä½“ä¸Šç‚¹å‡»ï¼Œå¹¶åœ¨ä¸Šä¸‹æ–‡èœå•ä¸­é€‰æ‹©åœç”¨æ¥åœç”¨è¿™ä¸ªå®ä½“ã€‚å°½ç®¡å®ƒå·²ç»å˜æˆç°è‰²è€Œä¸”æ²¡æœ‰äº†ä»»ä½•çš„å­å®ä½“ï¼Œä½†å®ƒä»ç„¶å­˜åœ¨äºä½ çš„é¡¹ç›®ä¸­ï¼Œå¹¶åœ¨å±‚çº§è§†å›¾ä¸­å±•ç¤ºã€‚ç„¶è€Œï¼Œå®ƒä¸ä¼šå±•ç°åœ¨ 3D è§†å›¾ä¸­ã€‚Xcode ä¸ä¼šå°†åœç”¨çš„å®ä½“ç¼–è¯‘è¿›åº”ç”¨çš„åŒ…ä¸­ï¼Œæ‰€ä»¥ï¼Œåœ¨ä¿å­˜é¡¹ç›®ä¹‹å‰é‡æ–°æ¿€æ´»åº”ç”¨éœ€è¦çš„å®ä½“æ˜¯éå¸¸é‡è¦çš„ã€‚è¦é‡æ–°æ¿€æ´»å®ä½“ï¼Œå¯ä»¥åœ¨å±‚çº§è§†å›¾ä¸­æŒ‰ä½ Control çš„åŒæ—¶ç‚¹å‡»å®ä½“ï¼Œå¹¶ä»ä¸Šä¸‹æ–‡èœå•ä¸­é€‰æ‹©æ¿€æ´»ã€‚",
      "tips": ""
    },
    "Add components to entities": {
      "zh": "ä¸ºå®ä½“æ·»åŠ ç»„ä»¶",
      "tips": ""
    },
    "RealityKit follows a design pattern called Entity-Component-System (ECS). In ECS, you store data on an entity using components and then implement entity behavior by writing systems that use the data from those components. You can add and configure components to entities in Reality Composer Pro, including both built-in components like ParticleEmitterComponent, and custom components that you write and place in the Sources folder of your Reality Composer Pro Swift package. You can also create new components in Reality Composer Pro and edit them in Xcode.": {
      "zh": "RealityKit éµå¾ªåä¸º ECSï¼ˆEntity-Component-Systemï¼‰çš„è®¾è®¡æ¨¡å¼ã€‚åœ¨ ECS ä¸­ï¼Œä½ é€šè¿‡ä½¿ç”¨ç»„ä»¶æ¥ä¿å­˜å®ä½“ä¸Šçš„æ•°æ®ï¼Œç„¶åé€šè¿‡ç¼–å†™å„ä¸ªç³»ç»Ÿæ¥å®ç°å®ä½“çš„è¡Œä¸ºï¼Œè¿™äº›ç³»ç»Ÿåˆ™ä½¿ç”¨ä¿å­˜åœ¨ç»„ä»¶çš„æ•°æ®ã€‚ä½ å¯ä»¥åœ¨ Reality Composer Pro ä¸­ä¸ºå®ä½“æ·»åŠ å’Œé…ç½®ç»„ä»¶ï¼ŒåŒ…æ‹¬åƒå†…ç½®çš„ ParticleEmitterComponent è¿™æ ·çš„ç»„ä»¶ï¼Œä»¥åŠä½ ç¼–å†™å¹¶æ”¾ç½®åœ¨ä½ çš„ Reality Composer Pro Swift åŒ…çš„ Sources æ–‡ä»¶å¤¹ä¸­çš„è‡ªå®šä¹‰ç»„ä»¶ã€‚ä½ è¿˜å¯ä»¥åœ¨ Reality Composer Pro ä¸­åˆ›å»ºæ–°çš„ç»„ä»¶ï¼Œå¹¶åœ¨ Xcode ä¸­å¯¹å®ƒä»¬è¿›è¡Œç¼–è¾‘ã€‚",
      "tips": ""
    },
    "For more information about ECS, see Understanding RealityKitâ€™s modular architecture.": {
      "zh": "æ›´å¤šæœ‰å…³ ECS çš„å†…å®¹ï¼Œè¯¦è§â€œç†è§£ RealityKit çš„æ¨¡å—åŒ–ç»“æ„â€ä¸€æ–‡ã€‚",
      "tips": ""
    },
    "To add a component to an entity, select that entity in the hierarchy view or 3D view. At the bottom-right of the inspector window, click Add Component. A list of available components appears with New Component at the top. If you select the first item, Reality Composer Pro creates a new component class in the Sources folder, and optionally a new system class. It also adds the component to the selected entity. If you select any other item in the list, it adds that component to the selected entity if it doesnâ€™t already have that component.": {
      "zh": "è¦å°†ç»„ä»¶æ·»åŠ åˆ°å®ä½“ï¼Œå¯ä»¥ä»å±‚çº§è§†å›¾æˆ–è€… 3D è§†å›¾ä¸­é€‰æ‹©å®ä½“ã€‚åœ¨æ£€æŸ¥å™¨çª—å£çš„å³ä¸‹è§’ï¼Œç‚¹å‡» â€œAdd Componentâ€ã€‚ä¼šåœ¨çª—å£é¡¶éƒ¨å‡ºç°ä¸€ä¸ªåä¸ºâ€œNew Componentâ€çš„å¯ç”¨ç»„ä»¶åˆ—è¡¨ã€‚å¦‚æœä½ é€‰æ‹©åˆ—è¡¨ä¸­çš„ç¬¬ä¸€é¡¹ï¼ŒReality Composer Pro ä¼šåœ¨ Sources æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„ç»„ä»¶ç±»ï¼Œå’Œä¸€ä¸ªå¯é€‰çš„æ–°çš„ç³»ç»Ÿç±»ã€‚å®ƒè¿˜ä¼šå°†è¯¥ç»„ä»¶æ·»åŠ åˆ°æ‰€é€‰çš„å®ä½“ã€‚å¦‚æœä½ é€‰æ‹©åˆ—è¡¨ä¸­çš„ä»»ä½•å…¶ä»–é¡¹ï¼Œå¦‚æœè¯¥å®ä½“å°šæœªæ‹¥æœ‰è¯¥ç»„ä»¶ï¼Œå®ƒå°†å°†è¯¥ç»„ä»¶æ·»åŠ åˆ°æ‰€é€‰å®ä½“ã€‚",
      "tips": ""
    },
    "Create or modify entity hierarchies": {
      "zh": "åˆ›å»ºæˆ–ä¿®æ”¹å®ä½“å±‚çº§ç»“æ„",
      "tips": ""
    },
    "Reality Composer Pro scenes are hierarchies of RealityKit entities. You can change the relationship between entities in the hierarchy browser except for parts of the hierarchy imported from a .usdz file, which Reality Composer Pro treats as a read-only file.": {
      "zh": "Reality Composer Pro çš„åœºæ™¯æ˜¯ RealityKit å®ä½“çš„å±‚çº§ç»“æ„ã€‚ä½ å¯ä»¥åœ¨å±‚çº§ç»“æ„æµè§ˆå™¨ä¸­æ›´æ”¹å®ä½“ä¹‹é—´çš„å…³ç³»ï¼Œé™¤äº†ä» .usdz æ–‡ä»¶å¯¼å…¥çš„å±‚çº§ç»“æ„é‚£éƒ¨åˆ†ä»¥å¤–ï¼Œå› ä¸º Reality Composer Pro å°†å…¶è§†ä½œåªè¯»æ–‡ä»¶ã€‚",
      "tips": ""
    },
    "To change the relationship between entities, or to create a relationship between two currently unrelated entities, use the hierarchy view and drag an entity onto the entity that you want it to be part of. If you want an entity to become a root entity, drag it to the Root transform at the top of the hierarchy view.": {
      "zh": "è¦æ›´æ”¹å®ä½“ä¹‹é—´çš„å…³ç³»ï¼Œæˆ–æ˜¯åœ¨å½“å‰æ— å…³çš„ä¸¤ä¸ªå®ä½“ä¹‹é—´å»ºç«‹æ–°è”ç³»ï¼Œä½¿ç”¨å±‚çº§ç»“æ„è§†å›¾å¹¶å°†å®ä½“æ‹–æ”¾åˆ°ä½ å¸Œæœ›äº§ç”Ÿè”ç³»çš„å¦ä¸€ä¸ªå®ä½“ä¹‹ä¸Šã€‚å¦‚æœä½ æƒ³è®©å®ä½“æˆä¸ºæ ¹å®ä½“ï¼Œé‚£å°±å°†å®ƒæ‹–åˆ°å±‚çº§è§†å›¾é¡¶éƒ¨çš„ Root transform ä¸Šã€‚",
      "tips": ""
    },
    "Modify or create new materials": {
      "zh": "ä¿®æ”¹æˆ–åˆ›å»ºæ–°æè´¨",
      "tips": ""
    },
    "When you import a USDZ model into Reality Composer Pro, it creates a RealityKit material for every physically-based rendering (PBR) material the asset contains. Reality Composer Pro displays materials in the hierarchy view just like it displays entities, except it uses a paintbrush icon. Reality Composer Pro doesnâ€™t display materials in the 3D view.": {
      "zh": "å½“ä½ å°† USDZ æ¨¡å‹å¯¼å…¥åˆ° Reality Composer Pro æ—¶ï¼Œå®ƒä¼šä¸ºèµ„æºåŒ…å«çš„æ‰€æœ‰åŸºäºç‰©ç†æ¸²æŸ“çš„æè´¨ï¼ˆPBRï¼‰åˆ›å»ºä¸€ä¸ªå¯¹åº”çš„ RealityKit æè´¨ã€‚RealityKit Composer Pro å°±å¯ä»¥åƒåœ¨å±•ç¤ºå®ä½“ä¸€æ ·åœ¨å±‚çº§è§†å›¾ä¸­å±•ç¤ºæè´¨ï¼Œå”¯ä¸€åŒºåˆ«æ˜¯å®ƒä½¿ç”¨äº†ç”»ç¬”å›¾æ ‡ã€‚Reality Composer Pro ä¸ä¼šåœ¨ 3D è§†å›¾ä¸­å±•ç¤ºæè´¨ã€‚",
      "tips": ""
    },
    "The library in Reality Composer Pro contains materials for several common real-world surfaces like metal, wood, and denim that you can import into your project.": {
      "zh": "Reality Composer Pro çš„èµ„æºåº“ä¸­åŒ…å«äº†ä¸€äº›çœŸå®ä¸–ç•Œå¸¸è§çš„æè´¨ï¼Œè¯¸å¦‚é‡‘å±ã€æœ¨æå’Œç‰›ä»”å¸ƒï¼Œä½ å¯ä»¥å°†å®ƒä»¬å¯¼å…¥åˆ°ä½ çš„é¡¹ç›®ä¸­ã€‚",
      "tips": ""
    },
    "If you select a PBR material in the hierarchy view, you can edit it using the inspector. You can replace images, colors, or values for any of the PBR attributes with another image, color, or value of your choosing. Any changes you make to a material affects any entity thatâ€™s bound to that material. You can also create new materials from scratch by clicking the Add button (+) at the bottom of the scene hierarchy and choosing Material.": {
      "zh": "å¦‚æœä½ åœ¨å±‚çº§è§†å›¾ä¸­é€‰æ‹©äº†ä¸€ä¸ª PBR æè´¨ï¼Œä½ å¯ä»¥ä½¿ç”¨æ£€æŸ¥å™¨æ¥è¿›è¡Œç¼–è¾‘ã€‚ä½ å¯ä»¥ç”¨ä½ é€‰æ‹©çš„å…¶ä»–å›¾åƒã€é¢œè‰²æˆ–å€¼æ¥æ›¿æ¢ PBR å±æ€§ä¸­çš„ä»»ä½•å›¾åƒã€é¢œè‰²æˆ–å€¼ã€‚ä½ å¯¹æè´¨çš„è¿›è¡Œçš„ä»»ä½•ä¿®æ”¹éƒ½ä¼šå½±å“åˆ°ç»‘å®šåˆ°è¯¥æè´¨çš„æ‰€æœ‰å®ä½“ã€‚ä½ ä¹Ÿèƒ½å¤Ÿé€šè¿‡åœ¨åœºæ™¯å±‚çº§çš„åº•éƒ¨ç‚¹å‡»æ·»åŠ æŒ‰é’®ï¼ˆ+ï¼‰å¹¶é€‰æ‹© Material æ¥åˆ›å»ºå…¨æ–°çš„æè´¨ã€‚",
      "tips": ""
    },
    "Build materials in Shader Graph": {
      "zh": "åœ¨ Shader Graph ä¸­æ„å»ºæè´¨",
      "tips": ""
    },
    "PBR materials are great at reproducing real-world surfaces. However, they canâ€™t represent nonrealistic materials like cartoon shaders, and they canâ€™t contain logic. This means that you canâ€™t animate a PBR material or have it react to input from your app.": {
      "zh": "PBR æè´¨æ“…é•¿å†ç°çœŸå®ä¸–ç•Œçš„è¡¨é¢ã€‚ç„¶è€Œï¼Œå®ƒä»¬ä¸èƒ½è¡¨ç¤ºåƒå¡é€šç€è‰²å™¨è¿™æ ·çš„éç°å®æè´¨ï¼Œä¹Ÿä¸èƒ½åŒ…å«é€»è¾‘ã€‚è¿™æ„å‘³ç€ä½ ä¸èƒ½å¯¹ PBR æè´¨è¿›è¡ŒåŠ¨ç”»å¤„ç†ï¼Œä¹Ÿä¸èƒ½è®©å®ƒå¯¹ä½ çš„åº”ç”¨è¾“å…¥ä½œå‡ºååº”ã€‚",
      "tips": ""
    },
    "Reality Composer Pro offers a second type of material called a custom material. You can build and edit custom materials using the Shader Graph tab. Shader Graph provides a tremendous amount of control over materials and allows you to do things that would otherwise require writing Metal shaders. For more information on writing Metal shaders, see Metal.": {
      "zh": "Reality Composer Pro æä¾›äº†ç¬¬äºŒç§ç±»å‹çš„æè´¨ï¼Œç§°ä¸ºè‡ªå®šä¹‰æè´¨ã€‚ä½ å¯ä»¥ä½¿ç”¨ Shader Graph æ ‡ç­¾æ¥æ„å»ºå’Œç¼–è¾‘è‡ªå®šä¹‰æè´¨ã€‚Shader Graph æä¾›äº†å¯¹æè´¨çš„é«˜åº¦æ§åˆ¶èƒ½åŠ›ï¼Œå¹¶ä½¿ä½ èƒ½å¤Ÿå®ç°é€šå¸¸éœ€è¦ç¼–å†™ Metal ç€è‰²å™¨æ‰èƒ½å®Œæˆçš„æ“ä½œã€‚æœ‰å…³ç¼–å†™ Metal ç€è‰²å™¨çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ Metalã€‚",
      "tips": ""
    },
    "RealityKit doesnâ€™t represent Reality Composer Pro custom materials as an instance of CustomMaterial, as you might expect. Instead, RealityKit represents these materials as ShaderGraphMaterial instances.": {
      "zh": "RealityKit ä¸ä¼šåƒä½ å¯èƒ½é¢„æœŸçš„é‚£æ ·ï¼Œå°† Reality Composer Pro çš„è‡ªå®šä¹‰æè´¨è¡¨ç¤ºä¸º CustomMaterial çš„å®ä¾‹ã€‚ç›¸åï¼ŒRealityKit ä¼šå°†è¿™äº›æè´¨è¡¨ç¤ºä¸º ShaderGraphMaterial å®ä¾‹ã€‚",
      "tips": ""
    },
    "The materials you build in the editor can affect both the look of an entity and its shape. If you build a node graph and connect it to the Custom Surface pin on the output node, that node graph controls the surface appearance of the model and roughly equates to writing Metal code in a fragment shader. If you build a node graph and connect it to the Custom Geometry Modifier output pin, those nodes control the shape of the entity, which equates to Metal code running in a vertex shader.": {
      "zh": "åœ¨ç¼–è¾‘å™¨ä¸­ä½ æ‰€æ„å»ºçš„æè´¨èƒ½å¤Ÿå½±å“å®ä½“çš„å¤–è§‚å’Œå½¢çŠ¶ã€‚å¦‚æœä½ æ„å»ºäº†ä¸€ä¸ªèŠ‚ç‚¹å›¾å¹¶å°†å…¶è¿æ¥åˆ°è¾“å‡ºèŠ‚ç‚¹ä¸Šçš„ Custom Surface å¼•è„šï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹å›¾å°±ä¼šæ§åˆ¶æ¨¡å‹çš„è¡¨é¢å¤–è§‚ï¼Œè¿™åŸºæœ¬ä¸Šç­‰åŒäºåœ¨ç‰‡æ®µç€è‰²å™¨ä¸­ç¼–å†™ Metal ä»£ç ã€‚å¦‚æœä½ æ„å»ºäº†ä¸€ä¸ªèŠ‚ç‚¹å›¾å¹¶å°†å…¶è¿æ¥åˆ° Custom Geometry Modifier è¾“å‡ºå¼•è„šï¼Œé‚£ä¹ˆè¿™äº›èŠ‚ç‚¹å°±ä¼šæ§åˆ¶å®ä½“çš„å½¢çŠ¶ï¼Œè¿™ç­‰åŒäºåœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­è¿è¡Œ Metal ä»£ç ã€‚",
      "tips": ""
    },
    "Nodes represent values and operations and serve the same purpose as either a variable or constant, or a function in Metal. If you need the sine of a value, for example, connect the valueâ€™s output node to the input pin of a Sin node. Add new nodes to the graph by double-clicking the background of the Shader Graph view or click the New Node button on the right side of the screen.": {
      "zh": "èŠ‚ç‚¹ä»£è¡¨å€¼å’Œæ“ä½œï¼Œå…¶ä½œç”¨ä¸ Metal ä¸­çš„å˜é‡æˆ–å¸¸æ•°ï¼Œæˆ–å‡½æ•°ç›¸åŒã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ éœ€è¦ä¸€ä¸ªå€¼çš„æ­£å¼¦ï¼Œå°†å€¼çš„è¾“å‡ºèŠ‚ç‚¹è¿æ¥åˆ° Sin èŠ‚ç‚¹çš„è¾“å…¥å¼•è„šã€‚é€šè¿‡åŒå‡» Shader Graph è§†å›¾çš„èƒŒæ™¯æˆ–ç‚¹å‡»å±å¹•å³ä¾§çš„â€œNew Nodeâ€æŒ‰é’®ï¼Œå¯ä»¥å‘å›¾ä¸­æ·»åŠ æ–°çš„èŠ‚ç‚¹ã€‚",
      "tips": ""
    },
    "Some nodes, like Sin, are universal and can be used with either output pin. Other nodes are specific to either the Custom Surface or Geometry Modifier outputs. If a node name starts with Geometry Modifier, you can only connect it to the Geometry Modifier output pin. If the nodeâ€™s name starts with â€œSurfaceâ€, you can only connect it to the Custom Surface output pin.": {
      "zh": "ä¸€äº›èŠ‚ç‚¹ï¼Œæ¯”å¦‚ Sinï¼Œæ˜¯é€šç”¨çš„ï¼Œå¯ä»¥ç”¨äºä»»æ„è¾“å‡ºå¼•è„šã€‚å…¶ä»–èŠ‚ç‚¹åˆ™ç‰¹å®šäº Custom Surface æˆ– Geometry Modifier è¾“å‡ºã€‚å¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„åç§°ä»¥ Geometry Modifier å¼€å¤´ï¼Œé‚£ä¹ˆä½ åªèƒ½å°†å®ƒè¿æ¥åˆ° Geometry Modifier è¾“å‡ºå¼•è„šã€‚å¦‚æœèŠ‚ç‚¹çš„åç§°ä»¥â€œSurfaceâ€å¼€å¤´ï¼Œä½ åªèƒ½å°†å®ƒè¿æ¥åˆ° Custom Surface è¾“å‡ºå¼•è„šã€‚",
      "tips": ""
    },
    "To unlock the real power of Shader Graph, you need to be able to change values on the material from Swift code. Shader Graph allows you to do this by creating promoted inputs, which are parameters you can set and read from Swift to change your material at runtime. If you have a feature that you want to turn on and off, you might create a Boolean input parameter and have conditional logic based on its value. If you want to smoothly interpolate between two colors, you might create a Float input parameter and use it to control how to interpolate between the two colors. You can Control-click on a constant node and select Promote to turn it into a promoted input. You can also turn a promoted input back into a constant by Control-clicking it and selecting Demote.": {
      "zh": "è¦è§£é” Shader Graph çš„çœŸæ­£èƒ½åŠ›ï¼Œä½ éœ€è¦é€šè¿‡ Swift ä»£ç æ¥æ›´æ”¹æè´¨ä¸Šçš„å€¼ã€‚Shader Graph å…è®¸ä½ é€šè¿‡åˆ›å»ºæå‡è¾“å…¥ï¼ˆpromoted inputï¼‰æ¥è¾¾åˆ°è¿™ä¸€ç‚¹ï¼Œè¿™äº›è¾“å…¥æ˜¯ä½ å¯ä»¥åœ¨ Swift ä¸­è®¾ç½®å’Œè¯»å–çš„å‚æ•°ï¼Œç”¨äºæ”¹å˜åœ¨è¿è¡Œæ—¶çš„æè´¨ã€‚å¦‚æœä½ æœ‰ä¸€ä¸ªæƒ³è¦å¼€å¯å’Œå…³é—­çš„åŠŸèƒ½ï¼Œä½ å¯èƒ½ä¼šåˆ›å»ºä¸€ä¸ª Boolean è¾“å…¥å‚æ•°ï¼Œå¹¶æ ¹æ®å…¶å€¼æ‰§è¡Œæ¡ä»¶é€»è¾‘ã€‚å¦‚æœä½ æƒ³åœ¨ä¸¤ç§é¢œè‰²ä¹‹é—´å¹³æ»‘æ’å€¼ï¼Œä½ å¯èƒ½ä¼šåˆ›å»ºä¸€ä¸ª Float è¾“å…¥å‚æ•°ï¼Œå¹¶ä½¿ç”¨å®ƒæ¥æ§åˆ¶å¦‚ä½•åœ¨ä¸¤ç§é¢œè‰²ä¹‹é—´æ’å€¼ã€‚ä½ å¯ä»¥æŒ‰ä½ Control å¹¶ç‚¹å‡»ä¸€ä¸ªå¸¸é‡èŠ‚ç‚¹å¹¶é€‰æ‹© Promote æ¥å°†å…¶è½¬æ¢ä¸ºæå‡è¾“å…¥ã€‚ä½ ä¹Ÿå¯ä»¥é€šè¿‡æŒ‰ä½ Control å¹¶ç‚¹å‡»å®ƒå¹¶é€‰æ‹© Demote æ¥å°†æå‡è¾“å…¥è½¬æ¢å›å¸¸é‡ã€‚",
      "tips": ""
    },
    "If you donâ€™t have an existing constant to promote, you can create new promoted inputs using the inspector. The New Input button only shows up in the inspector when you select a material in the hierarchy view but have no nodes selected in the Shader Graph tab.": {
      "zh": "å¦‚æœä½ æ²¡æœ‰è¦æå‡çš„ç°æœ‰å¸¸é‡ï¼Œä½ å¯ä»¥ä½¿ç”¨æ£€æŸ¥å™¨åˆ›å»ºæ–°çš„æå‡è¾“å…¥ã€‚åªæœ‰å½“åœ¨ä½ åœ¨å±‚çº§è§†å›¾ä¸­é€‰æ‹©äº†æè´¨ï¼Œä½†åœ¨ Shader Graph æ ‡ç­¾ä¸­æœªé€‰æ‹©ä»»ä½•èŠ‚ç‚¹æ—¶ï¼Œâ€œNew Inputâ€æŒ‰é’®æ‰ä¼šåœ¨æ£€æŸ¥å™¨ä¸­æ˜¾ç¤ºã€‚",
      "tips": ""
    },
    "To change the value of an input parameter from Swift code, use setParameter(name:value:), passing the name of the parameter and the new value. Note that parameter names are case sensitive, so your name string must exactly match what you called the parameter in Shader Graph.": {
      "zh": "è¦ä» Swift ä»£ç ä¸­æ›´æ”¹è¾“å…¥å‚æ•°çš„å€¼ï¼Œä½¿ç”¨ setParameter(name:value:) æ–¹æ³•ï¼Œä¼ å…¥å‚æ•°åå’Œæ–°å€¼ã€‚è¯·æ³¨æ„ï¼Œå‚æ•°åç§°æ˜¯åŒºåˆ†å¤§å°å†™çš„ï¼Œå› æ­¤ä½ çš„åç§°å­—ç¬¦ä¸²å¿…é¡»ä¸ä½ åœ¨ Shader Graph ä¸­ä¸ºå‚æ•°æ‰€å–çš„åç§°å®Œå…¨åŒ¹é…ã€‚",
      "tips": ""
    },
    "For examples of Shader Graph use, see Diorama and Happy Beam.": {
      "zh": "è¦æŸ¥çœ‹ Shader Graph çš„ä½¿ç”¨ç¤ºä¾‹ï¼Œå¯å‚çœ‹ Diorama å’Œ Happy Beamã€‚",
      "tips": ""
    },
    "Use references to reuse assets": {
      "zh": "ä½¿ç”¨å¼•ç”¨æ¥å¤ç”¨èµ„æº",
      "tips": ""
    },
    "If your project has multiple scenes that share assets, you can use references to avoid creating duplicate assets. A reference acts like an alias in Finder â€” it points to the original asset and functions just as if it were another copy of that asset.": {
      "zh": "å¦‚æœä½ çš„é¡¹ç›®åŒ…å«å¤šä¸ªå…±äº«èµ„æºçš„åœºæ™¯ï¼Œä½ å¯ä»¥ä½¿ç”¨å¼•ç”¨æ¥é¿å…åˆ›å»ºé‡å¤çš„èµ„æºã€‚å¼•ç”¨å°±åƒ Finder ä¸­çš„åˆ«åâ€”â€”å®ƒæŒ‡å‘åŸå§‹èµ„æºï¼Œå¹¶ä¸”åŠŸèƒ½ä¸Šå°±åƒæ˜¯è¯¥èµ„æºçš„å¦ä¸€ä»½å‰¯æœ¬ã€‚",
      "tips": ""
    },
    "Create references using the inspector. By default, the references section is hidden for entities and materials that donâ€™t have any references. To add a new reference to an asset or material that doesnâ€™t have one, choose Reality Composer Pro > Settings and uncheck Hide Empty References.": {
      "zh": "ä½¿ç”¨æ£€æŸ¥å™¨æ¥åˆ›å»ºå¼•ç”¨ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå¯¹äºæ²¡æœ‰ä»»ä½•å¼•ç”¨çš„å®ä½“å’Œæè´¨ï¼Œå¼•ç”¨éƒ¨åˆ†æ˜¯éšè—çš„ã€‚è¦ä¸ºæ²¡æœ‰å¼•ç”¨çš„èµ„æºæˆ–æè´¨æ·»åŠ æ–°å¼•ç”¨ï¼Œéœ€è¦é€‰æ‹© Reality Composer Pro > Settingsï¼Œç„¶åå–æ¶ˆé€‰ä¸­â€œHide Empty Referencesâ€ã€‚",
      "tips": ""
    },
    "To add a reference, click the Add button (+) at the bottom of the references section in the inspector, choose the .usda file for the scene that contains the asset, then choose the asset you want to link to. After you do that, the selected entity or material becomes a copy of the one you linked to.": {
      "zh": "è¦æ·»åŠ å¼•ç”¨ï¼Œå•å‡»æ£€æŸ¥å™¨ä¸­å¼•ç”¨éƒ¨åˆ†åº•éƒ¨çš„æ·»åŠ æŒ‰é’®ï¼ˆ+ï¼‰ï¼Œé€‰æ‹©åŒ…å«è¯¥èµ„æºçš„åœºæ™¯çš„ .usda æ–‡ä»¶ï¼Œç„¶åé€‰æ‹©ä½ æƒ³è¦é“¾æ¥çš„èµ„æºã€‚å®Œæˆåï¼Œæ‰€é€‰çš„å®ä½“æˆ–æè´¨å°†æˆä¸ºä½ é“¾æ¥çš„é‚£ä¸ªçš„å‰¯æœ¬ã€‚",
      "tips": ""
    },
    "If you make changes to a linked asset, those changes will affect every linked reference.": {
      "zh": "å¦‚æœä½ å¯¹é“¾æ¥çš„èµ„æºè¿›è¡Œäº†æ›´æ”¹ï¼Œé‚£ä¹ˆè¿™äº›æ›´æ”¹å°†å½±å“æ¯ä¸ªé“¾æ¥çš„å¼•ç”¨ã€‚",
      "tips": ""
    },
    "Preview scenes on device": {
      "zh": "åœ¨è®¾å¤‡ä¸Šé¢„è§ˆåœºæ™¯",
      "tips": ""
    },
    "If you have an Apple Vision Pro connected to your Mac, choose Preview > Play or click the preview button in the Reality Composer Pro toolbar to view your scene on device. The Preview button is the left-most button on the right side of the toolbar â€” the one with an Apple Vision Pro icon. If you have multiple Apple Vision Pro devices connected, choose which device to use by clicking the pull-down menu next to the Preview button.": {
      "zh": "å¦‚æœä½ çš„ Mac ä¸Šè¿æ¥äº†ä¸€å° Apple Vision Proï¼Œé€‰æ‹© Preview > Play æˆ–ç‚¹å‡» Reality Composer Pro å·¥å…·æ ä¸­çš„é¢„è§ˆæŒ‰é’®ï¼Œå°±å¯ä»¥åœ¨è®¾å¤‡ä¸ŠæŸ¥çœ‹ä½ çš„åœºæ™¯ã€‚é¢„è§ˆæŒ‰é’®æ˜¯å·¥å…·æ å³ä¾§æœ€å·¦è¾¹çš„æŒ‰é’®â€”â€”å¸¦æœ‰ Apple Vision Pro å›¾æ ‡çš„æŒ‰é’®ã€‚å¦‚æœä½ è¿äº†å¤šå° Apple Vision Pro è®¾å¤‡ï¼Œé€šè¿‡ç‚¹å‡»é¢„è§ˆæŒ‰é’®æ—è¾¹çš„ä¸‹æ‹‰èœå•é€‰æ‹©è¦ä½¿ç”¨çš„è®¾å¤‡ã€‚",
      "tips": ""
    },
    "Load Reality Composer Pro scenes in RealityKit": {
      "zh": "åœ¨ RealityKit ä¸­åŠ è½½ Reality Composer Pro åœºæ™¯",
      "tips": ""
    },
    "Loading a Reality Composer Pro scene is nearly identical to loading a USDZ asset from your app bundle, except you have to specify the Reality Composer Pro package bundle instead. You typically do this in the make closure of a RealityView initializer. Reality Composer Pro packages define a global constant that points to its bundle, which is named after the project with â€œBundleâ€ appended to it. In the default Xcode visionOS template, the Reality Composer Pro project is called RealityKitContent, so the global bundle variable is called realityKitContentBundle:": {
      "zh": "åŠ è½½ Reality Composer Pro åœºæ™¯ä¸ä»ä½ çš„åº”ç”¨åŒ…ä¸­åŠ è½½ USDZ èµ„æºå‡ ä¹ç›¸åŒï¼Œåªæ˜¯ä½ éœ€è¦æŒ‡å®š Reality Composer Pro çš„åŒ…å†…å®¹ã€‚ä½ é€šå¸¸ä¼šåœ¨ RealityView åˆå§‹åŒ–æ–¹æ³•çš„é—­åŒ…ä¸­å®Œæˆè¿™ä¸€æ“ä½œã€‚Reality Composer Pro åŒ…å®šä¹‰äº†ä¸€ä¸ªå…¨å±€å¸¸é‡ï¼Œè¯¥å¸¸é‡æŒ‡å‘å…¶è‡ªèº«çš„ bundleï¼Œå¹¶ä¸”å®ƒçš„åç§°æ˜¯åœ¨é¡¹ç›®åç§°åæ·»åŠ â€œBundle\"ã€‚åœ¨é»˜è®¤çš„ Xcode visionOS æ¨¡æ¿ä¸­ï¼ŒReality Composer Pro é¡¹ç›®è¢«ç§°ä¸º RealityKitContentï¼Œå› æ­¤å…¨å±€ bundle å˜é‡è¢«ç§°ä¸º realityKitContentBundleï¼š",
      "tips": ""
    },
    "The code above saves a reference to the root node. This isnâ€™t required, but with RealityView, unlike ARView on iOS and macOS, you donâ€™t have ready access to the scene content, so itâ€™s often handy to maintain your own reference to the root entity of your scene in your appâ€™s data model.": {
      "zh": "ä¸Šè¿°ä»£ç ä¿å­˜äº†å¯¹æ ¹èŠ‚ç‚¹çš„å¼•ç”¨ã€‚è™½ç„¶è¿™ä¸æ˜¯å¿…éœ€çš„ï¼Œä½†ä¸ iOS å’Œ macOS ä¸Šçš„ ARView ä¸åŒï¼Œä½ åœ¨ RealityView ä¸­ä¸èƒ½ç›´æ¥è·å–åˆ°åœºæ™¯å†…å®¹ï¼Œå› æ­¤åœ¨åº”ç”¨çš„æ•°æ®æ¨¡å‹ä¸­ä¿æŒå¯¹ä½ åœºæ™¯çš„æ ¹å®ä½“çš„å¼•ç”¨é€šå¸¸ä¼šå¾ˆæ–¹ä¾¿ã€‚",
      "tips": ""
    },
    "When RealityKit finishes loading the scene, the scene variable contains the root entity of the scene you specified. Add it to content and RealityKit displays it to the user.": {
      "zh": "å½“ RealityKit å®Œæˆåœºæ™¯åŠ è½½åï¼Œscene å˜é‡ä¼šåŒ…å«ä½ æŒ‡å®šçš„åœºæ™¯çš„æ ¹å®ä½“ã€‚å°†å®ƒæ·»åŠ åˆ° content ä¸­ï¼ŒRealityKit å°±ä¼šå°†å®ƒæ˜¾ç¤ºç»™ç”¨æˆ·ã€‚",
      "tips": ""
    }
  },
  "visionos/destination-video": {
    "Destination Video": {
      "zh": "ç›®çš„åœ°è§†é¢‘",
      "tips": ""
    },
    "Leverage 3D video and Spatial Audio to deliver an immersive experience.": {
      "zh": "åˆ©ç”¨ 3D è§†é¢‘å’Œç©ºé—´éŸ³é¢‘æä¾›èº«ä¸´å…¶å¢ƒçš„ä½“éªŒã€‚",
      "tips": "Spatial Audio è¯‘ä¸ºâ€œç©ºé—´éŸ³é¢‘â€"
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "Destination Video is a multiplatform video-playback app for visionOS, iOS, and tvOS. People get a familiar media-browsing experience navigating the libraryÊ¼s content and playing videos they find interesting. The app provides a similar experience on supported platforms, but leverages unique features of visionOS to create a novel, immersive playback experience.": {
      "zh": "Destination Video æ˜¯ä¸€æ¬¾é€‚ç”¨äº visionOSã€iOS å’Œ tvOS çš„å¤šå¹³å°è§†é¢‘æ’­æ”¾åº”ç”¨ã€‚åº”ç”¨ä¸ºç”¨æˆ·æä¾›äº†ç†Ÿæ‚‰çš„åª’ä½“æµè§ˆä½“éªŒï¼šåœ¨å›¾ä¹¦é¦†ä¸­æµè§ˆå†…å®¹å¹¶å¯ä»¥æ’­æ”¾æ„Ÿå…´è¶£çš„è§†é¢‘ã€‚è¯¥åº”ç”¨åœ¨æ‰€æœ‰æ”¯æŒçš„å¹³å°ä¸Šæä¾›äº†ç›¸è¿‘çš„ä½“éªŒï¼Œä½†åŒæ—¶ä¹Ÿåˆ©ç”¨äº† visionOS çš„ç‰¹æœ‰åŠŸèƒ½æ¥åˆ›å»ºæ–°é¢–ã€èº«ä¸´å…¶å¢ƒçš„è§†å¬ä½“éªŒã€‚",
      "tips": ""
    },
    "Play video in an inline player": {
      "zh": "åœ¨å†…è”æ’­æ”¾å™¨ä¸­æ’­æ”¾è§†é¢‘",
      "tips": "inline player è¯‘ä¸ºå†…è”æ’­æ”¾å™¨"
    },
    "When you select a video in the library, Destination Video presents a view that displays additional details about the item. The view presents controls to play the video and specify whether to include it in your Up Next list. In visionOS, it also displays a video poster along its leading edge. Tapping the viewâ€™s Preview button displays an inline preview of the video.": {
      "zh": "å½“æ‚¨åœ¨èµ„æºåº“ä¸­é€‰æ‹©è§†é¢‘æ—¶ï¼Œâ€œç›®çš„åœ°è§†é¢‘â€ä¼šæ˜¾ç¤ºä¸€ä¸ªæœ‰å…³è¯¥é¡¹ç›®è¯¦æƒ…çš„è§†å›¾ã€‚è¯¥è§†å›¾æ˜¾ç¤ºæ’­æ”¾è§†é¢‘çš„æ§ä»¶ï¼Œå¹¶å…è®¸ç”¨æˆ·æŒ‡å®šæ˜¯å¦å°†å…¶åŒ…å«åœ¨â€œå¾…æ’­æ¸…å•â€åˆ—è¡¨ä¸­ã€‚åœ¨visionOSä¸­ï¼Œå®ƒè¿˜ä¼šé å·¦æ˜¾ç¤ºä¸€å¼ è§†é¢‘æµ·æŠ¥ã€‚ç‚¹å‡»è§†å›¾ä¸­çš„â€œé¢„è§ˆâ€æŒ‰é’®å¯åœ¨è¡Œä¸­æ˜¾ç¤ºè§†é¢‘çš„é¢„è§ˆã€‚",
      "tips": ""
    },
    "When you present an AVPlayerViewController objectâ€™s interface as a child of another view, inline controls display, for example, pause, skip, and seek. Showing standard playback controls in your app provides a familiar UI that automatically adapts its appearance to fit each platform, and is the recommended choice in most cases.": {
      "zh": "å½“æ‚¨å°† AVPlayerViewController çš„ç•Œé¢ä½œä¸ºä¸€ä¸ªå­è§†å›¾æ˜¾ç¤ºæ—¶ï¼Œæš‚åœã€è·³è¿‡å’ŒæŸ¥æ‰¾ç­‰å†…è”æ§ä»¶å°†æ˜¾ç¤ºã€‚åœ¨åº”ç”¨ä¸­æ˜¾ç¤ºæ ‡å‡†æ’­æ”¾æ§ä»¶å¯æä¾›å¯è‡ªåŠ¨è°ƒæ•´å…¶å¤–è§‚ä»¥é€‚åº”å¹³å°çš„ç†Ÿæ‚‰ UIï¼Œè¿™åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹æ˜¯æ¨èçš„é€‰æ‹©ã€‚",
      "tips": ""
    },
    "Destination Video uses a simple UI for the inline player view: a single button that toggles state of playback. AVPlayerViewController doesnâ€™t provide this controls style, but the app uses it to display the video content without controls by setting the value of its showsPlaybackControls property to false. It then overlays the custom playback controls it requires. See Destination Videoâ€™s InlinePlayerView type for details on how you can implement this.": {
      "zh": "ç›®çš„åœ°è§†é¢‘ä½¿ç”¨ç®€å•çš„ UI ä½œä¸ºå†…è”æ’­æ”¾å™¨è§†å›¾ï¼šä¸€ä¸ªç”¨äºåˆ‡æ¢æ’­æ”¾çŠ¶æ€çš„æŒ‰é’®ã€‚ AVPlayerViewController ä¸æä¾›æ­¤æ§ä»¶æ ·å¼ï¼Œä½†æœ¬åº”ç”¨ä»…ä»…ä½¿ç”¨å®ƒæ¥æ˜¾ç¤ºè§†é¢‘å†…å®¹ï¼Œè€Œä¸æ˜¾ç¤ºæ§ä»¶ï¼Œå…¶å®ç°æ–¹æ³•æ˜¯å°† showsPlaybackControls å±æ€§çš„å€¼è®¾ç½®ä¸º falseã€‚ç„¶ååº”ç”¨ä¼šç”¨æ‰€éœ€çš„è‡ªå®šä¹‰æ’­æ”¾æ§ä»¶è¦†ç›–åœ¨ä¸Šã€‚å¦‚æƒ³äº†è§£æ­¤åŠŸèƒ½çš„è¯¦æƒ…ï¼Œè¯·å‚é˜…ç›®çš„åœ°è§†é¢‘ä¸­çš„ InlinePlayerView ç±»å‹ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨æ„",
      "tips": ""
    },
    "AVPlayerViewController only supports displaying 2D content when embedded inline.": {
      "zh": "",
      "tips": "æ³¨æ„ AVPlayerViewController åœ¨å†…è”åµŒå…¥æ—¶ä»…æ”¯æŒæ˜¾ç¤º 2D å†…å®¹ã€‚"
    },
    "Play video in a full-window player": {
      "zh": "åœ¨å…¨å±æ’­æ”¾å™¨ä¸­æ’­æ”¾è§†é¢‘",
      "tips": ""
    },
    "One of the most exciting features of visionOS is its ability to play 3D video along with Spatial Audio, which adds a deeper level of immersion to the viewing experience. Playing 3D content in your app requires that you display AVPlayerViewController full window. When you present the player this way, the system automatically docks it into the ideal viewing position, and presents streamlined playback controls that keep the personâ€™s focus on the content.": {
      "zh": "visionOS æœ€ä»¤äººå…´å¥‹çš„åŠŸèƒ½ä¹‹ä¸€æ˜¯å®ƒèƒ½å¤Ÿæ’­æ”¾ 3D è§†é¢‘å’Œç©ºé—´éŸ³é¢‘ï¼Œè¿™ä¸ºè§‚çœ‹ä½“éªŒå¢åŠ äº†æ›´æ·±å±‚çš„æ²‰æµ¸æ„Ÿã€‚åœ¨åº”ç”¨ä¸­æ’­æ”¾ 3D å†…å®¹éœ€è¦åœ¨å…¨å±æ¨¡å¼ä¸‹æ˜¾ç¤º AVPlayerViewControllerã€‚å½“æ‚¨ä»¥è¿™ç§æ–¹å¼å‘ˆç°æ’­æ”¾å™¨æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å°†å…¶åœé åœ¨ç†æƒ³çš„è§‚çœ‹ä½ç½®ï¼Œå¹¶æä¾›ç®€åŒ–çš„æ’­æ”¾æ§ä»¶ï¼Œä½¿ç”¨æˆ·ä¸“æ³¨äºå†…å®¹ã€‚",
      "tips": ""
    },
    "In iOS or tvOS, you typically present video in a full-screen presentation using the fullScreenCover(isPresented:onDismiss:content:) modifier. This API is available in visionOS; however, the recommended way to present the player for full-window playback is to set it as the root view of your appâ€™s window group.": {
      "zh": "åœ¨ iOS æˆ– Apple tvOS ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨ fullScreenCover(isPresented:onDismiss:content:) ä¿®é¥°ç¬¦åœ¨å…¨å±æ¨¡å¼ä¸‹æ¼”ç¤ºè§†é¢‘ã€‚æ­¤ API åœ¨ visionOS äº¦å¯ç”¨ï¼›ç„¶è€Œï¼Œæ¨èçš„å…¨å±æ¨¡å¼æ’­æ”¾è§†é¢‘æ–¹æ³•æ˜¯å°†è§†å›¾è®¾ç½®ä¸ºåº”ç”¨çª—å£ç»„çš„æ ¹è§†å›¾ã€‚",
      "tips": ""
    },
    "Destination Videoâ€™s ContentView displays the appâ€™s library by default. It observes changes to the player modelâ€™s presentation property, which indicates whether the app requests inline or full-window playback. When the presentation state changes to fullWindow, the view redraws the UI to display the player view in place of the library.": {
      "zh": "é»˜è®¤æƒ…å†µä¸‹ï¼Œç›®çš„åœ°è§†é¢‘çš„ ContentView ä¼šæ˜¾ç¤ºåº”ç”¨çš„èµ„æºåº“ã€‚å®ƒè§‚å¯Ÿå¯¹æ’­æ”¾å™¨æ¨¡å‹ä¸­ presentationï¼ˆæ¼”ç¤ºçŠ¶æ€ï¼‰ å±æ€§çš„æ›´æ”¹ï¼Œå±æ€§çš„å˜åŒ–æ„å‘³ç€åº”ç”¨è¯·æ±‚å†…è”æ’­æ”¾æˆ–å…¨å±æ’­æ”¾ã€‚å½“æ¼”ç¤ºçŠ¶æ€å˜ä¸º fullWindow æ—¶ï¼Œè§†å›¾å°†é‡æ–°ç»˜åˆ¶ UIï¼Œç”¨æ’­æ”¾å™¨è§†å›¾æ¥ä»£æ›¿åŸæœ¬çš„èµ„æºåº“è§†å›¾ã€‚",
      "tips": "Player model è¯‘ä¸ºæ’­æ”¾å™¨æ¨¡å‹ã€‚presentation è¯‘ä¸ºæ¼”ç¤ºçŠ¶æ€ã€‚"
    },
    "When someone selects the Play Video button on the detail view, the app calls the player modelâ€™s loadVideo(_: presentation:) method requesting the fullWindow presentation option.": {
      "zh": "å½“ç”¨æˆ·åœ¨è¯¦ç»†ä¿¡æ¯è§†å›¾ä¸Šé€‰æ‹©äº†â€œæ’­æ”¾è§†é¢‘â€æŒ‰é’®æ—¶ï¼Œåº”ç”¨ä¼šè°ƒç”¨æ’­æ”¾å™¨æ¨¡å‹çš„ loadVideo(_: presentation:) æ–¹æ³•ï¼Œè¯·æ±‚fullWindow æ¼”ç¤ºé€‰é¡¹ã€‚",
      "tips": "presentation option è¯‘ä¸ºæ¼”ç¤ºé€‰é¡¹"
    },
    "After the player model successfully loads the video content for playback, it updates its presentation value to fullWindow, which causes the app to replace the library with PlayerView.": {
      "zh": "å½“æ’­æ”¾å™¨æ¨¡å‹æˆåŠŸåŠ è½½è§†é¢‘å†…å®¹å¹¶æ’­æ”¾åï¼Œä¼šå°†å…¶ presentation å€¼æ›´æ–°ä¸º fullWindow ï¼Œè¿™ä¼šè®©åº”ç”¨å°†èµ„æºåº“æ›¿æ¢ä¸º PlayerView ã€‚",
      "tips": ""
    },
    "To dismiss the full-window player in visionOS, people tap the Back button in the player UI. To handle this action, the appâ€™s PlayerViewControllerDelegate type defines an AVPlayerViewControllerDelegate object that handles the dismissal.": {
      "zh": "è¦åœ¨ visionOS ä¸­å…³é—­å…¨å±æ’­æ”¾å™¨ï¼Œç”¨æˆ·å¯ä»¥ç‚¹å‡»æ’­æ”¾å™¨ UI ä¸­çš„â€œåé€€â€æŒ‰é’®ã€‚ä¸ºäº†å¤„ç†æ­¤æ“ä½œï¼Œåº”ç”¨çš„ PlayerViewControllerDelegate ç±»å‹å®šä¹‰äº†ä¸€ä¸ª AVPlayerViewControllerDelegate å¯¹è±¡ï¼Œç”¨äºå…³é—­ç•Œé¢ã€‚",
      "tips": ""
    },
    "When the delegate receives this call, it clears the media from the player model and resets the presentation state back to its default value, which results in the Destination Video app redisplaying the library view.": {
      "zh": "å½“å§”æ‰˜ï¼ˆdelegateï¼‰æ”¶åˆ°æ­¤è°ƒç”¨æ—¶ï¼Œå®ƒä¼šä»æ’­æ”¾å™¨æ¨¡å‹ä¸­æ¸…é™¤åª’ä½“ï¼Œå¹¶å°†æ¼”ç¤ºçŠ¶æ€é‡ç½®å›å…¶é»˜è®¤å€¼ï¼Œè¿™ä¼šè®©ç›®çš„åœ°è§†é¢‘åº”ç”¨é‡æ–°æ˜¾ç¤ºèµ„æºåº“è§†å›¾",
      "tips": ""
    },
    "Configure the Spatial Audio experience": {
      "zh": "é…ç½®ç©ºé—´éŸ³é¢‘ä½“éªŒ",
      "tips": ""
    },
    "Media playback apps require common configuration of their capabilities and audio session. In addition to performing the steps outlined in Configuring your app for media playback, Destination Video also adopts new AVAudioSession API to customize a personâ€™s Spatial Audio experience.": {
      "zh": "åª’ä½“æ’­æ”¾åº”ç”¨éœ€è¦å¯¹å…¶åŠŸèƒ½å’ŒéŸ³é¢‘ä¼šè¯è¿›è¡Œé€šç”¨é…ç½®ã€‚é™¤äº†æ‰§è¡Œé…ç½®åº”ç”¨ä»¥è¿›è¡Œåª’ä½“æ’­æ”¾ä¸­åˆ—ä¸¾çš„æ­¥éª¤ä¹‹å¤–ï¼ŒDestination Video è¿˜é‡‡ç”¨æ–°çš„ AVAudioSession API æ¥è‡ªå®šä¹‰ç”¨æˆ·çš„ç©ºé—´éŸ³é¢‘ä½“éªŒã€‚",
      "tips": ""
    },
    "After the app successfully loads a video for playback, it configures the Spatial Audio experience for the current presentation. For the inline player view, it sets the experience to a small, focused sound stage where the audio originates from the location of the view. When displaying a video full window, it sets the experience to a large, fully immersive sound stage.": {
      "zh": "åº”ç”¨æˆåŠŸåŠ è½½è§†é¢‘è¿›è¡Œæ’­æ”¾åï¼Œä¼šä¸ºå½“å‰çš„æ¼”ç¤ºå†…å®¹é…ç½®ç©ºé—´éŸ³é¢‘ä½“éªŒã€‚å¯¹äºå†…è”æ’­æ”¾å™¨è§†å›¾ï¼Œå®ƒå°†ä½“éªŒè®¾ç½®ä¸ºä¸€ä¸ªå°å‹çš„ã€é›†ä¸­çš„å£°åœºï¼Œå…¶ä¸­éŸ³æºæ¥è‡ªè§†å›¾çš„ä½ç½®ã€‚å½“æ˜¾ç¤ºå…¨å±è§†é¢‘æ—¶ï¼Œå®ƒä¼šå°†ä½“éªŒè®¾ç½®ä¸ºå¤§å‹ã€å®Œå…¨æ²‰æµ¸å¼çš„å£°åœºã€‚",
      "tips": ""
    },
    "Present an immersive space": {
      "zh": "å‘ˆç°æ²‰æµ¸å¼ç©ºé—´",
      "tips": ""
    },
    "Building video playback apps for visionOS provides new opportunities to enhance the viewing experience beyond the bounds of the player window. To add a greater level of immersion, the sample presents an immersive space that displays a scene around a person as they watch the video. It defines the immersive space in the DestinationVideo app structure.": {
      "zh": "åœ¨ visionOS ä¸Šåˆ¶ä½œè§†é¢‘æ’­æ”¾åº”ç”¨æä¾›äº†æ–°çš„æœºä¼šï¼Œå› ä¸ºå¼€å‘è€…å¯ä»¥å°†è§‚çœ‹ä½“éªŒæ‰©å±•åˆ°æ’­æ”¾å™¨çª—å£ä¹‹å¤–ã€‚ä¸ºäº†æä¾›æ›´å¼ºçš„æ²‰æµ¸æ„Ÿï¼Œè¯¥ç¤ºä¾‹æä¾›äº†ä¸€ä¸ªåœ¨ç”¨æˆ·è§‚çœ‹è§†é¢‘æ—¶åœ¨å…¶å‘¨å›´æ˜¾ç¤ºé£æ™¯çš„æ²‰æµ¸å¼ç©ºé—´ã€‚åº”ç”¨ç»“æ„ä½“ DestinationVideo ä¸­å®šä¹‰äº†æ²‰æµ¸å¼ç©ºé—´ã€‚",
      "tips": ""
    },
    "The immersive space presents an instance of DestinationView, which maps a texture to the inside of a sphere that it displays around a person. The app presents it using the .progressive immersion style, which lets someone change their amount of immersion by turning the Digital Crown on the device.": {
      "zh": "æ²‰æµ¸å¼ç©ºé—´å‘ˆç°äº†ä¸€ä¸ª DestinationView çš„å®ä¾‹ï¼Œå®ƒå°†çº¹ç†æ˜ å°„åˆ°å›´ç»•ç”¨æˆ·è€Œæ˜¾ç¤ºçš„çƒä½“å†…éƒ¨ã€‚åº”ç”¨ä½¿ç”¨ .progressive é£æ ¼å‘ˆç°å®ƒï¼Œè¯¥é£æ ¼å…è®¸ç”¨æˆ·é€šè¿‡è½¬åŠ¨è®¾å¤‡ä¸Šçš„â€œæ•°ç è¡¨å† â€æ¥ä¿®æ”¹æ²‰æµ¸åº¦ã€‚",
      "tips": ""
    },
    "The Destination Video app automatically presents the immersive space when a person navigates to a videoâ€™s detail view, and dismisses it when they return to the library. To monitor these events, the app observes its navigation path to determine when a navigation event occurs so it can show or dismiss the space.": {
      "zh": "åº”ç”¨ä¼šåœ¨ç”¨æˆ·è¿›å…¥è§†é¢‘è¯¦æƒ…è§†å›¾æ—¶è‡ªåŠ¨æ˜¾ç¤ºæ²‰æµ¸å¼ç©ºé—´ï¼Œå¹¶åœ¨è¿”å›èµ„æºåº“æ—¶å°†å…¶å…³é—­ã€‚ä¸ºäº†ç›‘è§†è¿™äº›äº‹ä»¶ï¼Œåº”ç”¨ä¼šè§‚å¯Ÿå…¶å¯¼èˆªè·¯å¾„ä»¥ç¡®å®šå¯¼èˆªäº‹ä»¶å‘ç”Ÿçš„æ—¶æœºï¼Œå¹¶æ˜¾ç¤ºæˆ–å…³é—­ç©ºé—´ã€‚",
      "tips": ""
    },
    "Provide a shared viewing experience": {
      "zh": "æä¾›å…±äº«çš„è§‚çœ‹ä½“éªŒ",
      "tips": ""
    },
    "One of the best ways to enhance your appâ€™s playback experience is to make that experience shareable with others. You can use the AVFoundation and the GroupActivities frameworks to build SharePlay experiences that bring people together even when they canâ€™t be in the same location.": {
      "zh": "å¢å¼ºåº”ç”¨æ’­æ”¾ä½“éªŒçš„æœ€ä½³æ–¹æ³•ä¹‹ä¸€æ˜¯ä½¿ä½“éªŒå¯ä¸ä»–äººå…±äº«ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ AVFoundation å’Œ Group Activities æ¡†æ¶æ¥æ„å»ºåŒæ’­å…±äº«ä½“éªŒï¼Œå³ä½¿ç”¨æˆ·ä»¬ä¸åœ¨åŒä¸€ä¸ªåœ°æ–¹ï¼ŒåŒæ’­ä½“éªŒä¹Ÿèƒ½å¤Ÿæ‹‰è¿‘ä»–ä»¬çš„è·ç¦»ã€‚",
      "tips": ""
    },
    "The Destination Video app creates an experience where people can watch videos with others across devices and platforms. It defines a group activity called VideoWatchingActivity that adopts the GroupActivity protocol. When people have a FaceTime call active and they play a video in the full-window player, it becomes eligible for playback for everyone on the call.": {
      "zh": "ç›®çš„åœ°è§†é¢‘åˆ›é€ äº†ä¸€ç§ç”¨æˆ·å¯ä»¥è·¨è®¾å¤‡å’Œå¹³å°ä¸ä»–äººä¸€èµ·è§‚çœ‹è§†é¢‘çš„ä½“éªŒã€‚å®ƒå®šä¹‰äº†ä¸€ä¸ªåä¸º VideoWatchingActivity ä¸”éµå¾ª GroupActivity åè®®çš„ç»„æ´»åŠ¨ã€‚å½“ç”¨æˆ·ä»¬æ¿€æ´»äº† FaceTime é€šè¯å¹¶åœ¨å…¨å±æ’­æ”¾å™¨ä¸­æ’­æ”¾è§†é¢‘æ—¶ï¼Œé€šè¯ä¸­çš„æ¯ä¸ªäººéƒ½æœ‰æƒé™æ’­æ”¾è¯¥è§†é¢‘ã€‚",
      "tips": ""
    },
    "The appâ€™s VideoWatchingCoordinator actor manages Destination Videoâ€™s SharePlay functionality. It observes the activation of new VideoWatchingActivity sessions and when one starts, it sets the GroupSession instance on the player objectâ€™s AVPlaybackCoordinator.": {
      "zh": "åº”ç”¨çš„ VideoWatchingCoordinator actor ç®¡ç†ç›®çš„åœ°è§†é¢‘çš„åŒæ’­å…±äº«åŠŸèƒ½ã€‚å®ƒè§‚å¯Ÿæ–° VideoWatchingActivity ä¼šè¯çš„æ¿€æ´»ï¼Œå½“ä¸€ä¸ªä¼šè¯å¯åŠ¨æ—¶ï¼Œå®ƒå°† GroupSession å¯¹è±¡è®¾ç½®ä¸ºæ’­æ”¾å™¨å¯¹è±¡çš„ AVPlaybackCoordinatorã€‚",
      "tips": ""
    },
    "With the player configured to use the group session, when the app loads new videos, they become eligible to share with people in the FaceTime call.": {
      "zh": "å°†æ’­æ”¾å™¨é…ç½®ä½¿ç”¨ç¾¤ç»„ä¼šè¯åï¼Œæ¯å½“åº”ç”¨åŠ è½½äº†æ–°è§†é¢‘ï¼Œå®ƒä»¬éƒ½å¯ä»¥åœ¨ FaceTime é€šè¯ä¸­ä¸ä»–äººå…±äº«ã€‚",
      "tips": ""
    }
  },
  "visionos/diagnosing-and-resolving-bugs-in-your-running-app": {
    "Diagnosing and resolving bugs in your running app": {
      "zh": "",
      "tips": ""
    },
    "Inspect your app to isolate bugs, locate crashes, identify excess system-resource usage, visualize memory bugs, and investigate problems in its appearance.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Unit testing determines whether your code delivers results that meet your expectations, but it doesnâ€™t explain the cause when it doesnâ€™t. To diagnose an error, attach the debugger, reproduce the error, and then narrow down its root cause by inspecting your variables at key points in your code while the app is running with breakpoints. If you configure a schemeâ€™s run action for debugging by using the Debug executable checkbox in Info settings, the app will attach to the debugger automatically when the app uses the scheme. To attach the debugger to a process that is already running, choose Debug â†’ Attach to Process, and select your appâ€™s process from the list. Follow this same process to diagnose and resolve errors in your code, crashes, memory leaks, and layout problems.": {
      "zh": "",
      "tips": ""
    },
    "Pause the app to inspect variables and isolate bugs": {
      "zh": "",
      "tips": ""
    },
    "To fix a bug, you first need to understand what is causing it. To narrow down the cause of a bug, develop a set of steps to reliably reproduce it:": {
      "zh": "",
      "tips": ""
    },
    "Determine where the bug happens in your source code.": {
      "zh": "",
      "tips": ""
    },
    "Pause your app with a breakpoint in your source code before the point at which you believe the bug occurs.": {
      "zh": "",
      "tips": ""
    },
    "Look at your variables and confirm they have the values you expect. If they donâ€™t, begin again with step 1.": {
      "zh": "",
      "tips": ""
    },
    "Step through your code and watch your variables change. Note where your variables have unexpected values.": {
      "zh": "",
      "tips": ""
    },
    "Analyze your code to determine a fix.": {
      "zh": "",
      "tips": ""
    },
    "After determining a potential fix for the bug, confirm the diagnosis by changing your code and retesting to reproduce it. If the change addresses the problem, youâ€™ve resolved the bug. If your change doesnâ€™t resolve it, reconsider where the bug might be occurring, and repeat the steps to isolate and fix it.": {
      "zh": "",
      "tips": ""
    },
    "For more information on setting breakpoints and inspecting variables, see Setting breakpoints to pause your running app and Stepping through code and inspecting variables to isolate bugs.": {
      "zh": "",
      "tips": ""
    },
    "Locate crashes, exceptions, and runtime issues": {
      "zh": "",
      "tips": ""
    },
    "When your app experiences a crash, exception, or runtime issue, it can be challenging to pinpoint the code causing the problem because the stack trace for the crash doesnâ€™t always point to the line of code that causes the crash. Use the rubric below to identify the problem characteristics and then set the correct type of breakpoint:": {
      "zh": "",
      "tips": ""
    },
    "A crash that stops at main or highlights AppDelegate is frequently an Objective-C exception.": {
      "zh": "",
      "tips": ""
    },
    "A crash that is the result of a runtime issue also stops at main or highlights AppDelegate, and may have a message similar to: â€œThread 8: EXC_BAD_INSTRUCTION (code=â€¦)â€.": {
      "zh": "",
      "tips": ""
    },
    "A crash that stops at an uncaught or unhandled Swift error displays a fatal error message and indicates a Swift error.": {
      "zh": "",
      "tips": ""
    },
    "Add a breakpoint to your code in a location based on problem characteristics, then when your app stops at the breakpoint, check the state of the code execution. For more information on setting breakpoints and identifying crashes, see Setting breakpoints to pause your running app and Identifying the cause of common crashes.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "Your Swift code can receive an Objective-C exception when it uses code from a module that uses Objective-C.": {
      "zh": "",
      "tips": ""
    },
    "Inspect variables and execution sequence without pausing": {
      "zh": "",
      "tips": ""
    },
    "When you develop code, itâ€™s helpful to log actions and variable values so you understand how your code runs and what values your variables have at different points in your app. This is especially true when you develop concurrent code, or code that executes simultaneously across multiple queues or threads, because bugs can be intermittent and difficult to reproduce. Often, you reproduce a bug in normal execution, but not when stepping through the debugger, because the timing is different between normal execution and debugging. The debugger provides tools to inspect variables without pausing and disturbing the timing of your concurrent code.": {
      "zh": "",
      "tips": ""
    },
    "Developers commonly add print or NSLog statements to see variable values. While this technique works, it adds extra code that isnâ€™t useful after you finish development, and leaves your app with a noisy console that makes diagnosing subsequent bugs more difficult. Instead, use breakpoint actions to know when events in your app take place, and inspect variable values without pausing.": {
      "zh": "",
      "tips": ""
    },
    "To determine whether your code executes with minimal effect to timing, use a breakpoint action to play a sound and continue executing. If the debugger reaches the breakpoint when you run the app, it plays the sound and confirms execution.": {
      "zh": "",
      "tips": ""
    },
    "To log a variable value to the console without pausing, add a breakpoint with a Debugger Command action using po to print out the evaluation of an object, or v to print the value of a variable to the console. Select the Automatically continue after evaluating actions option for the breakpoint to prevent pausing.": {
      "zh": "",
      "tips": ""
    },
    "To log custom text to the console and add context to variable values, add a breakpoint with a Log Message action. Specify your custom text, and include expressions, the breakpoint name, or the breakpoint hit count to provide more information.": {
      "zh": "",
      "tips": ""
    },
    "Because po compiles code dynamically to evaluate expressions, it takes more time to evaluate your variable and log it to the console. To reduce timing issues, use v to log variable values instead.": {
      "zh": "",
      "tips": ""
    },
    "Use other breakpoint actions to execute an AppleScript or a shell script, or to capture a GPU frame.": {
      "zh": "",
      "tips": ""
    },
    "For more information on inspecting variables, see Setting breakpoints to pause your running app and Stepping through code and inspecting variables to isolate bugs.": {
      "zh": "",
      "tips": ""
    },
    "Identify potential overuse of CPU and memory": {
      "zh": "",
      "tips": ""
    },
    "An easily overlooked and common problem in development and testing is the overuse of CPU and memory. Xcodeâ€™s debugger provides gauges in the Debug navigator to help investigate potential problems. Monitor the gauges while youâ€™re testing your app to uncover unusual usage. Click a gauge for a more detailed view.": {
      "zh": "",
      "tips": ""
    },
    "The CPU gauge shows the amount of CPU the app requires to process instructions over time. When your app is drawing the user interface, processing data it retrieves from the network, or performing calculations, itâ€˜s normal to see CPU usage increase to fairly high numbers for a short period of time. When those tasks are complete and your app is idle and waiting for the user to perform an action, CPU usage should be zero or very low. Do additional analysis if CPU usage is:": {
      "zh": "",
      "tips": ""
    },
    "Persistent at a level above zero when the app appears to be idle.": {
      "zh": "",
      "tips": ""
    },
    "Over 100% for more than very short periods of time.": {
      "zh": "",
      "tips": ""
    },
    "Very high and you see hitches in your user interface.": {
      "zh": "",
      "tips": ""
    },
    "For more information on improving performance, see Improving your appâ€™s performance.": {
      "zh": "",
      "tips": ""
    },
    "The Memory gauge shows how much memory your app uses over time. It starts at a fairly small number, less than 10 MB, when you first launch your app, and then increases as people navigate through your user interface. It may also increase if you fetch, process, and store data from the network, or perform complex calculations. It then decreases when processing is complete. Watch the gauge as you navigate through your app, and note when memory usage goes up and down. Memory usage increases when you present modal views or add a view to a navigation controller, and decreases when you dismiss or navigate away from those views. If your usage continues to increase and doesnâ€™t ever decrease, investigate whether you have a memory leak or abandoned memory. For more information on reducing memory use and resolving memory leaks, see the section below Visualize and diagnose increasing memory usage and Reducing your appâ€™s memory use.": {
      "zh": "",
      "tips": ""
    },
    "Detect high disk access and network use": {
      "zh": "",
      "tips": ""
    },
    "Be aware of issues resulting from frequent access to resources on disk and over the network. You can monitor these resources using the gauges in Xcodeâ€™s debugger as well. The Disk I/O gauge shows how much data your app reads and writes from disk over time. The gauge shows if you:": {
      "zh": "",
      "tips": ""
    },
    "Store data that the user generates in your app.": {
      "zh": "",
      "tips": ""
    },
    "Store data in user preferences.": {
      "zh": "",
      "tips": ""
    },
    "Fetch data from the network and store it.": {
      "zh": "",
      "tips": ""
    },
    "Read data from your app bundle or the appâ€™s directories.": {
      "zh": "",
      "tips": ""
    },
    "Storing and reading data frequently from disk uses more power than doing so from memory, and it adds wear and tear to the userâ€™s device. To know whether disk usage is unusual, you need to understand the size of data youâ€™re storing and reading, and compare that to what you observe in the gauge. For example, if you download and store a 5 MB graphic file for display in a view that you use frequently and it writes over 50 MB of data, investigate whether the remote image changes frequently, or whether you need to configure networking to prevent redownloading the same image. If youâ€™re reading more data from disk than you expect, investigate whether a memory-caching solution might help, or whether youâ€™re initiating a data read from the wrong point in your app or view life cycle, and reading it too often. For more information on reducing disk writes, see Reducing disk writes.": {
      "zh": "",
      "tips": ""
    },
    "The Network I/O gauge shows how much data your app reads from and writes to the network over time. If your app only uses local resources, your app may not read or write any data from the network. Communicating data over the network uses energy and reduces the deviceâ€™s battery life, so minimize data transfer wherever possible. To understand your appâ€™s network usage, watch the Network I/O gauge when your app is sending or receiving data from the network. For example, if you implement a cache system for downloaded images and your network usage increases when accessing them, confirm that your cache settings are correct in the app and on the server. If youâ€™re uploading user-generated content and frequent upload failures during poor networking conditions lead to high network usage, implement a system to recover and restart failed uploads at the point of failure, rather than reuploading the entire file.": {
      "zh": "",
      "tips": ""
    },
    "Visualize and diagnose increasing memory usage": {
      "zh": "",
      "tips": ""
    },
    "Diagnose the cause of memory leaks and abandoned memory with the memory graph. The observable symptom of a memory leak is memory usage that continues to increase over time, even when conditions in the app indicate that memory usage is decreasing. A memory leak can occur in a retain cycle, which is when objects maintain strong references to each other, but the app no longer references them. These objects remain in memory and the app canâ€™t remove them. Abandoned memory occurs when you create objects and your code still references them, but your app no longer needs them or uses them.": {
      "zh": "",
      "tips": ""
    },
    "To see the memory graph in the debugger, pause your app at a breakpoint and click the Debug Memory Graph button in the debug bar. Alternatively, click the Debug Memory Graph button when the app is running to pause the app and show the memory graph.": {
      "zh": "",
      "tips": ""
    },
    "The memory graph view replaces the stack trace in the Debug navigator with a list of types, organized by library, each with a list of instances called nodes. Select a node to view its memory graph.": {
      "zh": "",
      "tips": ""
    },
    "A nodeâ€™s memory graph shows all the memory references to that node, and highlights strong references. Control-click any node in the graph to perform more actions, such as accessing Quick Look or printing the description to the console. Choose Focus on Node to show the graph for the selected node. Click a reference to see its details, including the name of the variable, the type of reference, and the source and destination objects in memory.": {
      "zh": "",
      "tips": ""
    },
    "To resolve a memory leak for a retain cycle:": {
      "zh": "",
      "tips": ""
    },
    "Observe the Memory gauge while you navigate the app.": {
      "zh": "",
      "tips": ""
    },
    "Note when memory usage increases when your app instantiates an object, but doesnâ€™t decrease when you expect the system to deallocate the object.": {
      "zh": "",
      "tips": ""
    },
    "Examine the memory graph to see if there are an unexpected number of instances of the object or inappropriate strong references to it.": {
      "zh": "",
      "tips": ""
    },
    "If there is a strong reference to the object, Control-click the node with the strong reference and choose Focus on Node to view its graph. If the node also has a strong reference from the object, this is a retain cycle.": {
      "zh": "",
      "tips": ""
    },
    "Resolve the retain cycle by changing one side of the relationship to use a weak declaration for the reference to the other object, or remove the reference altogether by removing any dependencies on the other object. Retest to confirm that the change fixes the issue.": {
      "zh": "",
      "tips": ""
    },
    "To resolve abandoned memory issues, identify the time in your appâ€™s life cycle that it no longer needs the abandoned object and remove any references to it.": {
      "zh": "",
      "tips": ""
    },
    "Inspect and resolve appearance and layout issues": {
      "zh": "",
      "tips": ""
    },
    "Some issues in the appearance or layout of your app only appear when you configure the system with a particular interface style, dynamic text size or when your app uses particular accessibility features. Use environmental overrides when targeting iOS, macOS, and tvOS apps to test your interface in these environments. To understand issues that involve the position or size of your view, you might need to inspect them within the context of views in other layers. Use the view debugger when targeting iOS, macOS, tvOS, and watchOS apps, which displays a 3D representation of the view hierarchy in layers, to help diagnose these issue. Entities within a visionOS app and their surroundings sometimes interact with each other in ways you donâ€™t expect. Enable visualizations to represent coordinate axes, bounding boxes, and other information that is normally invisible, to help understand these interactions.": {
      "zh": "",
      "tips": ""
    },
    "For information on using these features to debug the appearance of your app, see Diagnosing issues in the appearance of a running app.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/diagnosing-issues-in-the-appearance-of-your-running-app": {
    "Diagnosing issues in the appearance of a running app": {
      "zh": "",
      "tips": ""
    },
    "Inspect your running app to investigate issues in the appearance and placement of the content it displays.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "At times your appâ€™s content may appear to be missing, out of place, or have an appearance that is incorrect. To identify and diagnose the cause of these issues, attach the debugger, reproduce the error, and then narrow down its root cause by inspecting changes in your interface, the code that is executing, and the state of variables. If you configure a schemeâ€™s run action for debugging by using the Debug executable checkbox in Info settings, the app will attach to the debugger automatically when the app uses the scheme. To attach the debugger to a process that is already running, choose Debug â†’ Attach to Process, and select your appâ€™s process from the list.": {
      "zh": "",
      "tips": ""
    },
    "Temporarily override system settings to control your appâ€™s appearance and reveal problems that only occur when these settings are in effect, understand layout issues by visualize your views in stacked layers, and debug content in immersive space by adding visual overlays.": {
      "zh": "",
      "tips": ""
    },
    "Adjust system configurations to identify their impact on your views": {
      "zh": "",
      "tips": ""
    },
    "Some visual issues only arise when you configure the system using specific environmental settings. Xcode provides environmental overrides when targeting iOS, macOS, and tvOS apps to help you debug these issue. Use these environmental overrides to change the interface style, dynamic text size, and to induce the effects of other accessibility options, so you can understand the effect of these changes on the layout and visual appearance of your views.": {
      "zh": "",
      "tips": ""
    },
    "To enable one or more of these overrides, click the Enable Overrides button on Xcodeâ€™s debugging toolbar, toggle the switch next to the override category, and configure the controls under the category heading.": {
      "zh": "",
      "tips": ""
    },
    "View your appâ€™s content with a light or dark appearance. Select between light and dark appearances using the radio button.": {
      "zh": "",
      "tips": ""
    },
    "View your appâ€™s content using different dynamic type sizes. Select the size using the slider. For more information on dynamic types, see DynamicTypeSize.": {
      "zh": "",
      "tips": ""
    },
    "View the effects various accessibility features have on your appâ€™s content. Click the checkboxes to enable or disable the accessibility features.": {
      "zh": "",
      "tips": ""
    },
    "Resolve issues in the layout of your UIKit and SwiftUI views": {
      "zh": "",
      "tips": ""
    },
    "Use the View debugger, available when targeting iOS, macOS, tvOS, and watchOS apps, to diagnose the reasons an item in your user interface is in the wrong position or is the wrong size. Set a breakpoint in your app after it presents the view, for example, in a viewDidAppear: method, then click the View Debugger button in the debug bar when the debugger pauses on your breakpoint. Alternatively, just click the View Debugger button after your app presents the view.": {
      "zh": "",
      "tips": ""
    },
    "The debugger displays a 3D rendering of the current view on the canvas in the center, with a representation of the view hierarchy in the Debug navigator. Drag the view in any direction to see a 3D representation of the current view stack, and use the controls at the bottom of the canvas to adjust the views and the spacing between them.": {
      "zh": "",
      "tips": ""
    },
    "Click to select a view in either the visual rendering or the view hierarchy in the Debug navigator, then inspect details in the Object inspector or Size inspector. Resolve your layout issue according to the type of layout:": {
      "zh": "",
      "tips": ""
    },
    "The view debugger shows the frames you specify in the Size inspector. If the size isnâ€™t what you expect, step through your code to diagnose issues with your frame calculations. Then fix and retest.": {
      "zh": "",
      "tips": ""
    },
    "The Size inspector shows constraints. Click a constraint to highlight it in the view debugger. Analyze the constraints that affect the misplaced or mis-sized view to diagnose the issue. Adjust your constraints, either in your code or in Interface Builder, and retest.": {
      "zh": "",
      "tips": ""
    },
    "The Size inspector shows how SwiftUI resolves the size and placement of your view. With that information, analyze and adjust your SwiftUI code and retest.": {
      "zh": "",
      "tips": ""
    },
    "Understand the relationships between objects in a immersive space": {
      "zh": "",
      "tips": ""
    },
    "For visionOS apps with content in an immersive space, itâ€™s often helpful to see a visual representation of coordinate axes, bounding boxes, and other information that is normally invisible. Xcodeâ€™s debugging tools include options to display this information in Simulator or on a device. Use them to ensure that your entities are located where you expect, and interacting with each other and the surroundings the way you anticipate. For example, if an entity isnâ€™t responding to events, enable Collision Shapes to confirm the presence of one, required for event handling, and indicate its boundary.": {
      "zh": "",
      "tips": ""
    },
    "To annotate your content with an overlay, click the Enable Visualizations button on Xcodeâ€™s debugging toolbar and select one or more of the options:": {
      "zh": "",
      "tips": ""
    },
    "Red, green and blue arrows indicating the x, y, and z axes of each object in the space. Use this to understand the orientation of each object.": {
      "zh": "",
      "tips": ""
    },
    "Green lines that indicate the bounding edge of each entity.": {
      "zh": "",
      "tips": ""
    },
    "A dot marking the the origin of each object.": {
      "zh": "",
      "tips": ""
    },
    "Red, green and blue arrows indicating the x, y, and z axes of each anchor point and a yellow line betwen entities and their anchors. Use this to understand the placement of entities in relation to other real-world objects in the space.": {
      "zh": "",
      "tips": ""
    },
    "A white outline around the collision shape of an entity. Use this to understand issues in event detection.": {
      "zh": "",
      "tips": ""
    },
    "A multi-colored wireframe around real objects in the space. Use this to identify areas where virtual objects are correctly or incorrectly being hidden behind real objects.": {
      "zh": "",
      "tips": ""
    },
    "White border lines and diagonals marking each surface. Use this to understand the borders of surfaces that the system detects.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/diorama": {
    "Diorama": {
      "zh": "è¥¿æ´‹é•œ",
      "tips": ""
    },
    "Design scenes for your visionOS app using Reality Composer Pro.": {
      "zh": "ä½¿ç”¨ Reality Composer Pro è®¾è®¡ visionOS åº”ç”¨ä¸­çš„åœºæ™¯ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è§ˆ",
      "tips": ""
    },
    "Use Reality Composer Pro to compose, edit, and preview RealityKit content for your visionOS app. In your Reality Composer Pro project, you can create one or more scenes, each of which contains a hierarchy of virtual objects called entities that your app can efficiently load and display.": {
      "zh": "VisionOS åº”ç”¨ç¨‹åºä½¿ç”¨ RealityKit å±•ç¤ºçš„è™šæ‹Ÿç°å®å†…å®¹ï¼Œå¯ä»¥é€šè¿‡ Reality Composer Pro æ¥æ„å»ºï¼Œç¼–è¾‘ï¼Œé¢„è§ˆã€‚åœ¨ Reality Composer Pro é¡¹ç›®ä¸­ï¼Œå¯ä»¥åˆ›å»ºå¤šä¸ªåœºæ™¯ï¼Œæ¯ä¸ªåœºæ™¯é€šè¿‡å±‚æ¬¡ç»“æ„ç»„ç»‡è™šæ‹Ÿå¯¹è±¡ï¼ˆä¹Ÿå°±æ˜¯å®ä½“ï¼‰ï¼Œè¿™æ ·ä½ çš„åº”ç”¨ç¨‹åºå¯ä»¥é«˜æ•ˆç‡åœ°åŠ è½½æ˜¾ç¤ºè™šæ‹Ÿç°å®å†…å®¹ã€‚",
      "tips": ""
    },
    "In addition to helping you compose entity hierarchies, Reality Composer Pro also gives you the ability to add and configure components â€” even custom components that youâ€™ve written â€” to the entities in your scenes.": {
      "zh": "å¦å¤–ï¼Œåœ¨ Reality Composer Pro ä¸­ä¹Ÿå¯ä»¥ä¸ºåœºæ™¯ä¸­çš„å®ä½“ï¼ˆ Entity ï¼‰å¢åŠ å’Œé…ç½®ç»„ä»¶ï¼ˆ Component ï¼‰â€”â€” ä¹ŸåŒ…æ‹¬è‡ªå®šä¹‰çš„ç»„ä»¶ï¼Œè¿™æ ·å¯ä»¥å¸®åŠ©ä½ æ„å»ºå®ä½“çš„å±‚æ¬¡ç»“æ„ã€‚",
      "tips": ""
    },
    "You can also design the visual appearance of entities using Shader Graph, a node-based visual tool for creating RealityKit materials. Shader Graph gives you a tremendous amount of control over the surface details and shape of entities. You can even create animated materials and dynamic materials that change based on the state of your app or user input.": {
      "zh": "ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ Shader Graph è®¾è®¡å®ä½“çš„è™šæ‹Ÿå¤–è§‚ï¼ŒShader Graph ä¹Ÿæ˜¯ä¸€ä¸ªåŸºäºèŠ‚ç‚¹çš„è§†è§‰å·¥å…·ï¼Œç”¨æ¥åˆ›é€  RealityKit å¯ä»¥ä½¿ç”¨çš„ç´ æï¼ˆMaterialsï¼‰ã€‚Shader Graph æä¾›äº†ä¸°å¯Œçš„è¡¨é¢ç»†èŠ‚å’Œå½¢çŠ¶å¯ä»¥æ“ä½œçš„å®ä½“ã€‚ä½ ä¹Ÿå¯ä»¥åˆ›å»ºæœ‰åŠ¨ç”»æ•ˆæœçš„æè´¨( animated materials )å’ŒåŠ¨æ€çš„æè´¨ï¼ˆ dynamic materials ï¼‰ï¼Œè¿™äº›ç´ æå¯ä»¥æ ¹æ®åº”ç”¨ç¨‹åºçš„çŠ¶æ€æˆ–ç”¨æˆ·çš„è¾“å…¥è€Œæ”¹å˜ã€‚",
      "tips": ""
    },
    "Diorama demonstrates many of RealityKit and Reality Composer Proâ€™s features. It displays an interactive, virtual topographical trail map, much like the real-world dioramas you find at trailheads and ranger stations in national parks. This virtual map has points of interest you can tap to bring up more detailed information. You can also smoothly transition between two trail maps: Yosemite and Catalina Island.": {
      "zh": "Diorama é¡¹ç›®å±•ç¤ºäº† RealityKit å’Œ Reality Composer Pro è®¸å¤šç‰¹æ€§ã€‚è¿™ä¸ªé¡¹ç›®å±•ç¤ºäº†ä¸€ä¸ªå¯äº¤äº’çš„è™šæ‹Ÿå¾’æ­¥åœ°å½¢å›¾ï¼Œæ¨¡æ‹Ÿäº†ç°å®ä¸–ç•Œä¸­å›½å®¶å…¬å›­çš„ç™»å±±è·¯å¾„å’ŒæŠ¤æ—å‘˜ç«™ç‚¹çš„åœ°å½¢å›¾ã€‚è™šæ‹Ÿåœ°å›¾ä¸Šæœ‰æ ‡å¿—æ€§æ™¯ç‚¹ï¼Œå¯ä»¥ç‚¹å‡»è·å–è¯¦ç»†ä¿¡æ¯ã€‚ä¹Ÿå¯ä»¥åœ¨ Yosemite å’Œ Catalina Island è¿™ä¸¤ä¸ªè™šæ‹Ÿå¾’æ­¥åœ°å›¾ä¹‹é—´ä¸æ»‘çš„åˆ‡æ¢ã€‚",
      "tips": ""
    },
    "Import assets for building the scene": {
      "zh": "å¯¼å…¥ Asset æ¥æ„å»ºåœºæ™¯",
      "tips": ""
    },
    "Your Reality Composer Pro project must contain assets, which you use to compose scenes for your app. Dioramaâ€™s project has several assets, including 3D models like the diorama table, trail map, some birds and clouds that fly over the map, and a number of sounds and images. Reality Composer Pro provides a library of 3D models you can use. Access the library by clicking the Add (+) button on the right side of the toolbar. Selecting objects from the library imports them into your project.": {
      "zh": "Reality Composer Pro é¡¹ç›®åŒ…å«äº†åº”ç”¨ç¨‹åºç”¨æ¥æ„å»ºåœºæ™¯çš„å„ç§æ•°å­—èµ„æºï¼ˆ Asset ï¼‰ã€‚Diorama é¡¹ç›®ä¸­æœ‰å¤šä¸ª Asset ï¼ŒåŒ…æ‹¬è®¸å¤š 3D æ¨¡å‹ï¼Œæ¯”å¦‚ä»¿çœŸæ¡Œå­ï¼Œæ¨¡æ‹Ÿçš„å¾’æ­¥åœ°å½¢å›¾ï¼Œå‡ åªé¸Ÿå„¿å’Œäº‘æœµï¼Œä»¥åŠç¯å¢ƒéŸ³å’Œä¸€äº›å›¾åƒã€‚Reality Composer Pro æä¾›äº†ä¸€ç³»åˆ—å†…ç½® 3D æ¨¡å‹ã€‚å¯ä»¥ç‚¹å‡»çª—å£å³ä¸Šè§’çš„â€œ Add (+) â€æŒ‰é’®ï¼Œåœ¨å³è¾¹å¼¹å‡ºçš„å·¥å…·æ ä¸­å¯ä»¥çœ‹åˆ°è¿™äº› 3D æ¨¡å‹ã€‚é€‰æ‹©ç›¸åº”çš„å¯¹è±¡å°±å°†å®ƒä»¬å¯¼å…¥åˆ°é¡¹ç›®ä¸­ã€‚",
      "tips": ""
    },
    "Diorama uses custom assets instead of the available library assets. To use custom assets in your own Reality Composer Pro scenes, import them into your project in one of three ways: by dragging them to Reality Composer Proâ€™s project browser, using File > Import from the File menu, or copying the assets into the .rkassets bundle inside your projectâ€™s Swift package.": {
      "zh": "Diorama ä½¿ç”¨çš„æ˜¯è‡ªå®šä¹‰çš„ Assetã€‚ä¸ºäº†åœ¨ Reality Composer Pro çš„åœºæ™¯ä¸­ä½¿ç”¨è‡ªå®šä¹‰çš„ Asset ï¼Œæœ‰ä¸‰ç§æ–¹å¼å°† Asset å¯¼å…¥åˆ°é¡¹ç›®ä¸­ï¼šç›´æ¥å°†å®ƒä»¬æ‹–æ‹½åˆ° Reality Composer Pro é¡¹ç›®çš„ Project Browser çª—å£ä¸­ï¼›ç‚¹å‡»èœå•æ ä¸­â€œ File > Import â€é€‰æ‹©ç›¸åº”çš„èµ„æºæ–‡ä»¶( Asset )å¯¼å…¥ï¼›å°†èµ„æºæ–‡ä»¶( Asset ) æ‹·è´åˆ°é¡¹ç›®å…³è”çš„ Swift package çš„ .rkassets Bundleä¸­ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨æ„",
      "tips": ""
    },
    "Although you can still load USDZ files and other assets directly in visionOS, RealityKit compiles assets in your Reality Composer Pro project into a binary format that loads considerably faster than loading from individual files.": {
      "zh": "å³ä½¿å¯ä»¥åœ¨ VisionOS ç³»ç»Ÿä¸­ç›´æ¥åŠ è½½ USDZ æ–‡ä»¶ï¼Œä»¥åŠå…¶ä»–çš„èµ„æºæ–‡ä»¶( Asset )ï¼Œä½†æ˜¯ RealityKit ä¼šå°† Reality Composer Pro é¡¹ç›®ä¸­çš„èµ„æºæ–‡ä»¶( Asset )ç¼–è¯‘ä¸ºäºŒè¿›åˆ¶æ ¼å¼ï¼Œè¿™æ¯”åŠ è½½å•ç‹¬çš„æ–‡ä»¶è¦å¿«å¾—å¾ˆå¤šã€‚",
      "tips": ""
    },
    "Create scenes containing the appâ€™s entities": {
      "zh": "åˆ›å»ºåŒ…å«åº”ç”¨ç¨‹åºå®ä½“çš„åœºæ™¯",
      "tips": ""
    },
    "A single Reality Composer Pro project can have multiple scenes. A scene is an entity hierarchy stored in the project as a .usda file that you can load and display in a RealityView. You can use Reality Composerâ€™s scenes to build an entire RealityKit scene, or to store reusable entity hierarchies that you can use as building block for composing scenes at runtime â€” the approach Diorama uses. You can add as many different scenes to your project as you need by selecting File > New > Scene, or pressing âŒ˜N.": {
      "zh": "å•ç‹¬çš„ Reality Composer Pro é¡¹ç›®ä¸­å¯ä»¥æœ‰å¾ˆå¤šä¸ªåœºæ™¯ã€‚åœºæ™¯æ˜¯å®ä½“çš„å±‚æ¬¡ç»“æ„ï¼Œåœ¨é¡¹ç›®ä¸­ä»¥ .usda ç±»å‹çš„æ–‡ä»¶å­˜å‚¨åœºæ™¯ï¼Œå¯ä»¥é€šè¿‡ RealityView åŠ è½½æ˜¾ç¤ºã€‚ä½ å¯ä»¥ä½¿ç”¨ Reality Composer çš„â€œ Scenes â€å¯ä»¥æ„å»ºå®Œæ•´çš„ RealityKit åœºæ™¯ï¼Œä¹Ÿå¯ä»¥ç”¨äºå­˜å‚¨å¯é‡ç”¨çš„å®ä½“å±‚æ¬¡ç»“æ„â€”â€”åœ¨è¿è¡Œæ—¶ä½œä¸ºæ„å»ºå—åˆ›å»ºå…¶ä»–åœºæ™¯â€”â€”ç±»ä¼¼äº Diorama é¡¹ç›®ä¸­é‚£æ ·ä½¿ç”¨ã€‚å¯ä»¥æ ¹æ®éœ€è¦ï¼Œåœ¨èœå•æ ä¸­é€‰æ‹©â€œ File > New > Scene â€ï¼Œæˆ–è€…ç‚¹å‡»â€œ âŒ˜N â€ï¼Œåœ¨é¡¹ç›®ä¸­æ·»åŠ ä¸åŒåœºæ™¯ã€‚",
      "tips": ""
    },
    "At the top of the Reality Composer Pro window, thereâ€™s a separate tab for every scene thatâ€™s currently open. To open a scene, double-click the sceneâ€™s .usda file in the project browser. To edit a scene, select its tab, and make changes using the hierarchy viewer, the 3D view, and the inspector.": {
      "zh": "åœ¨ Reality Composer Pro çª—å£çš„é¡¶ç«¯æ˜¾ç¤ºå½“å‰æ‰€æœ‰æ‰“å¼€åœºæ™¯çš„æ ‡ç­¾ Tab ã€‚ Project Browser çª—å£ä¸­åŒå‡» .usda æ–‡ä»¶æ¥æ‰“å¼€åœºæ™¯ã€‚é€‰ä¸­åœºæ™¯çš„æ ‡ç­¾ tab ï¼Œè¿™æ ·å°±å¯ä»¥ç¼–è¾‘åœºæ™¯â€”â€”åœ¨ Hierarchy Viewer çª—å£ï¼ˆåœ¨å·¦ä¾§ï¼‰ï¼Œ3D å†…å®¹å±•ç¤ºï¼ˆä¸­é—´ï¼‰ï¼ŒInspector å±æ€§çª—å£ï¼ˆåœ¨å³ä¾§ï¼‰å¯ä»¥å¯¹åœºæ™¯åšä¿®æ”¹ã€‚",
      "tips": ""
    },
    "Add assets to your scenes": {
      "zh": "åœ¨åœºæ™¯ä¸­æ·»åŠ èµ„æº Asset",
      "tips": ""
    },
    "RealityKit can only include entities in a scene, but it canâ€™t use every type of asset that Reality Composer Pro supports as an entity. Reality Composer Pro automatically turns some assets, like 3D models, into an entity when you place them in a scene. It uses other assets indirectly. It uses image files, for example, primarily to define the surface details of model entities.": {
      "zh": "RealityKit åªæ”¯æŒåœºæ™¯ä¸­åŒ…å«å®ä½“ï¼Œä½†å®ƒæ— æ³•å°† Reality Composer Pro æ”¯æŒçš„æ‰€æœ‰ç±»å‹çš„èµ„æº Asset è½¬åŒ–ä¸ºå®ä½“ä½¿ç”¨ã€‚å½“ä½ å°†æŸäº› Assetâ€”â€”ä¾‹å¦‚3Dæ¨¡å‹ï¼Œç½®äºåœºæ™¯ä¸­æ—¶ï¼ŒReality Composer Pro ä¼šè‡ªåŠ¨å°† Asset è½¬åŒ–ä¸ºä¸€ä¸ªå®ä½“ã€‚Reality Composer Pro åˆ™ä¼šé—´æ¥ä½¿ç”¨å…¶ä»–ç±»å‹çš„èµ„æº Assetã€‚ä¾‹å¦‚ï¼Œå®ƒä¸»è¦ä½¿ç”¨å›¾åƒæ–‡ä»¶æç»˜æ¨¡å‹å®ä½“çš„è¡¨é¢ç»†èŠ‚ã€‚",
      "tips": ""
    },
    "Diorama uses multiple scenes to group assets together and then, at runtime, combines those scenes into a single immersive experience. For example, the diorama table has its own scene that includes the table, the map surface, and the trail lines. There are separate scenes for the birds that flock over the table, and for the clouds that float above it.": {
      "zh": "Diorama ä½¿ç”¨å¤šä¸ªåœºæ™¯å°†èµ„æº Asset æ•´åˆåœ¨ä¸€èµ·ï¼Œè¿™æ ·è¿è¡Œæ—¶å¯ä»¥å°†è¿™äº›åœºæ™¯æ•´åˆä¸ºä¸€ä¸ªå®Œæ•´çš„æ²‰æµ¸å¼ä½“éªŒç¯å¢ƒã€‚ä¾‹å¦‚ï¼ŒDioramaAssembled åœºæ™¯ä¸­åŒ…å«äº†æ¡Œå­ï¼Œå¾’æ­¥åœ°å½¢å›¾ä½œä¸ºæ¡Œé¢ï¼Œä»¥åŠåœ°å½¢å›¾ä¸Šçš„è·¯çº¿ã€‚åœ¨åœ°å½¢å›¾ä¸Šé£ç¿”çš„é¸Ÿç¾¤å’Œæ¼‚æµ®çš„äº‘æœµä¹Ÿåˆ†ä½œç‹¬ç«‹çš„åœºæ™¯ã€‚",
      "tips": ""
    },
    "To add entities to a scene, drag assets from the project browser to the sceneâ€™s hierarchy view or 3D view. If the asset you drag is a type that can be represented as an entity, Reality Composer Pro adds it to your scene. You can select any asset in the scene hierarchy or the 3D view and change its location, rotation, and scale using the inspector on the right side of the window or the manipulator in the 3D view.": {
      "zh": "å°† Asset ä» Project Browser çª—å£æ‹–æ‹½åˆ°åœºæ™¯å±‚æ¬¡ç»“æ„ä¸­æˆ– 3D å†…å®¹å±•ç¤ºåŒºåŸŸä¸­ï¼Œè¿™æ ·å°±åœ¨åœºæ™¯ä¸­æ·»åŠ äº†å®ä½“ã€‚å¦‚æœä½ æ‹–æ‹½çš„ Asset å¯ä»¥ä½œä¸ºå®ä½“çš„ç±»å‹ï¼ŒReality Composer Pro å°±ä¼šå°†å®ƒæ·»åŠ åˆ°åœºæ™¯ä¸­ã€‚åœ¨åœºæ™¯å±‚æ¬¡ç»“æ„ æˆ–è€… 3D å†…å®¹å±•ç¤ºåŒºåŸŸä¸­é€‰ä¸­ä»»ä½•ä¸€ä¸ª Asset ï¼Œå¯ä»¥åœ¨å³ä¾§çš„ Inspector å±æ€§çª—å£ä¸­ï¼Œæˆ–è€…3D å†…å®¹å±•ç¤ºåŒºåŸŸä½¿ç”¨æ“çºµå™¨ Manipulator ï¼Œè°ƒæ•´ Asset çš„ä½ç½®ï¼Œæ—‹è½¬è§’åº¦ï¼Œæˆ–è€…ç¼©æ”¾æ“ä½œã€‚",
      "tips": ""
    },
    "Add components to entities": {
      "zh": "ç»™å®ä½“æ·»åŠ ç»„ä»¶",
      "tips": ""
    },
    "RealityKit follows a design pattern called Entity Component System (ECS). In an ECS app, you store additional data on an entity using components and can implement entity behavior by writing systems that use the data from those components. You can add and configure components to entities in Reality Composer Pro, including both shipped components like PhysicsBodyComponent, and custom components that you write and place in the Sources folder of your Reality Composer Pro Swift package. You can even create new components in Reality Composer Pro and then edit them in Xcode. For more information about ECS, see Understanding RealityKitâ€™s modular architecture.": {
      "zh": "RealityKit éµå¾ªâ€œå®ä½“-ç»„ä»¶-ç³»ç»Ÿâ€ï¼ˆ ECS ï¼‰çš„è®¾è®¡åŸåˆ™ã€‚åœ¨ ECS æ¶æ„çš„åº”ç”¨ç¨‹åºä¸­ï¼Œä½ å°±å¯ä»¥ä½¿ç”¨ç»„ä»¶å­˜å‚¨å®ä½“é¢å¤–çš„æ•°æ®ï¼Œä½¿ç”¨ç»„ä»¶ä¸­çš„æ•°æ®ç¼–å†™ç³»ç»Ÿé€»è¾‘å®ç°å®ä½“çš„è¡Œä¸ºã€‚Reality Composer Pro ä¸­å¯ä»¥ä¸ºå®ä½“æ·»åŠ å’Œè®¾ç½®ç»„ä»¶ï¼Œç»„ä»¶ç±»å‹åŒ…æ‹¬åƒ PhysicsBodyComponent è¿™æ ·è‡ªå¸¦çš„ç»„ä»¶ï¼Œä¹Ÿå¯ä»¥è‡ªå®šä¹‰çš„ç»„ä»¶â€”â€”ä½äº Reality Composer Pro é¡¹ç›®çš„ Swift Package åŒ…ä¸­çš„ Sources æ–‡å¤¹ä»¶ä¸‹ã€‚ä½ ä¹Ÿå¯ä»¥åœ¨ Reality Composer Pro ä¸­åˆ›å»ºæ–°çš„ç»„ä»¶ï¼Œå¹¶ä¸”å¯ä»¥åœ¨ Xcode ä¸­ä¿®æ”¹å®ƒä»¬ã€‚æ›´å¤šå…³äº ECS çš„ä¿¡æ¯ï¼Œè¯·æŸ¥é˜… Understanding RealityKitâ€™s modular architecture ã€‚",
      "tips": ""
    },
    "Diorama uses custom components to identify which transforms are points of interest, to mark the birds so the app can make sure they flock together, and to control the opacity of entities that are specific to just one of the two maps.": {
      "zh": "Diorama ä½¿ç”¨è‡ªå®šä¹‰ç»„ä»¶è¾¨è®¤é‚£äº›æ ‡å¿—æ€§æ™¯ç‚¹çš„å˜æ¢æ“ä½œ transform ï¼Œæ ‡è®°é¸Ÿå„¿è®©å®ƒä»¬æˆç¾¤ç»“é˜Ÿçš„é£ç¿”ï¼Œæˆ–è€…æŒ‡å®šä¸¤å¼ åœ°å›¾ä¸­çš„ä¸€ä¸ªçš„ç»„ä»¶ä»¥æ§åˆ¶å®ä½“çš„é€æ˜åº¦ã€‚",
      "tips": ""
    },
    "To add a component to an entity, select that entity in the hierarchy view or 3D view. At the bottom right of the inspector window, click on the Add Component button. A list of available components appears and the first item in that list is New Component. This item creates a new component class, and optionally a new system class, and adds the component to the selected entity.": {
      "zh": "åœ¨å±‚æ¬¡ç»“æ„æˆ– 3D å†…å®¹å±•ç¤ºåŒºåŸŸä¸­é€‰æ‹©å…¶ä¸­çš„å®ä½“ï¼Œè¿™æ—¶å±•ç¤ºåœ¨å³ä¾§ Inspector å±æ€§çª—å£ç§ï¼Œç‚¹å‡»æœ€ä¸‹é¢çš„ Add Component æŒ‰é’®æ¥ä¸ºé€‰ä¸­çš„å®ä½“æ·»åŠ ç»„ä»¶ã€‚è¿™æ—¶ï¼Œå±å¹•ä¸­é—´ä¼šå‡ºç°ä¸€ä¸ªå¯ç”¨çš„ç»„ä»¶åˆ—è¡¨ï¼Œåˆ—è¡¨çš„ç¬¬ä¸€è¡Œæ˜¯â€œ New Component â€ã€‚è¿™ä¸ªé€‰é¡¹æ˜¯åˆ›å»ºä¸€ä¸ªæ–°çš„ç»„ä»¶ç±»åˆ«ï¼Œä¹Ÿå¯ä»¥é€‰æ‹©åˆ›å»ºä¸€ä¸ªæ–°çš„ç³»ç»Ÿç±»åˆ«ï¼ŒåŒæ—¶æŠŠè¿™ä¸ªæ–°åˆ›å»ºçš„ç»„ä»¶æ·»åŠ åˆ°äº†é€‰ä¸­çš„å®ä½“ä¸­ã€‚",
      "tips": ""
    },
    "If you look at the list of components, you see the PointOfInterestComponent that Diorama uses to indicate which transforms are points of interest. If the selected entity doesnâ€™t already contain a PointOfInterestComponent, selecting that adds it to the selected entity. Each entity can only have one component of a specific type. You can edit the values of the existing component in the inspector, which changes what shows up when you tap that point of interest in the app.": {
      "zh": "åœ¨ç»„ä»¶åˆ—è¡¨ä¸­ï¼Œå¯ä»¥çœ‹åˆ° Diorama é¡¹ç›®ä¸­ç”¨æ¥è¾¨è®¤æ ‡å¿—æ€§æ™¯ç‚¹çš„å˜æ¢æ“ä½œ Transform çš„ PointOfInterestComponent ç»„ä»¶ã€‚å¦‚æœé€‰ä¸­å®ä½“æ²¡æœ‰åŒ…å« PointOfInterestComponent ç»„ä»¶ï¼Œé€‰æ‹©æŠŠè¿™ä¸ªç»„ä»¶æ·»åŠ åˆ°é€‰ä¸­çš„å®ä½“ä¸­ã€‚æ¯ä¸ªå®ä½“æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªæŸç§ç±»å‹ç»„ä»¶çš„å®ä¾‹ã€‚ä½ å¯ä»¥åœ¨ Inspector å±æ€§çª—å£ç¼–è¾‘ç°å­˜ç»„ä»¶çš„æ•°å€¼ï¼Œè¿™äº›ä¼šæ”¹å˜æ ‡å¿—æ€§æ™¯ç‚¹è¢«ç‚¹å‡»æ—¶çš„æ˜¾ç¤ºã€‚",
      "tips": ""
    },
    "Use transforms to mark locations": {
      "zh": "ä½¿ç”¨ Transform å»åšæ ‡æ³¨ç‚¹",
      "tips": ""
    },
    "In Reality Composer Pro, a transform is an empty entity that marks a point in space. A transform contains a location, rotation, and scale, and its child entities inherit those. But, transforms have no visual representation and do nothing by themselves. Use transforms to mark locations in your scene or organize your entity hierarchy. For example, you might make several entities that need to move together into child entities of the same transform, so you can move them together by moving the parent transform.": {
      "zh": "åœ¨ Reality Composer Pro ä¸­ï¼ŒTransform æ˜¯æ ‡è®°ç©ºé—´çš„ç‚¹çš„è™šå®ä½“ã€‚Transform åŒ…å«ä½ç½®ä¿¡æ¯ Positionï¼Œæ—‹è½¬ä¿¡æ¯ Rotationï¼Œç¼©æ”¾ä¿¡æ¯ Scaleï¼ŒåŒæ—¶ä»–çš„å­ç±»å®ä½“ä¼šç»§æ‰¿è¿™äº›ä¿¡æ¯ã€‚ä½†æ˜¯ï¼ŒTransform æ²¡æœ‰è§†è§‰è¡¨è¿°ï¼Œå®ƒä»¬æœ¬èº«æ²¡æœ‰ç‹¬ç«‹çš„åŠŸèƒ½ã€‚Transform æ˜¯ç”¨æ¥æ ‡è®°åœºæ™¯ä¸­ä½ç½®ï¼Œæˆ–è€…ç”¨æ¥ç»„ç»‡å®ä½“å±‚æ¬¡ç»“æ„ã€‚æ¯”å¦‚ï¼Œä½ ä¼šå°†éœ€è¦ä¸€èµ·ç§»åŠ¨çš„å®ä½“è®¾ç½®ä¸ºæœ‰ç›¸åŒ Transform çš„å­å®ä½“ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡ç§»åŠ¨çˆ¶å®ä½“çš„ Transform çš„åŒæ—¶å°†å­å®ä½“ä»¬ä¸€èµ·ç§»åŠ¨ã€‚",
      "tips": ""
    },
    "Diorama uses transforms with a PointOfInterestComponent to indicate points of interest on the map. When the app runs, those transforms mark the location of the floating placards with the name of the location. Tapping on a placard expands it to show more detailed information. To turn transforms into an interactive view, the app looks for a specific component on transforms called a PointOfInterestComponent. Because a transform contains no data other than location, orientation, and scale, it uses this component to hold the data the app needs to display on the placards. If you open the DioramaAssembled scene in Reality Composer Pro and click on the transform called Cathedral_Rocks, you see the PointOfInterestComponent in the inspector.": {
      "zh": "Diorama ä½¿ç”¨ PointOfInterestComponent ç»„ä»¶å’Œ Transform ä¸€èµ·æ ‡ç¤ºåœ°å›¾ä¸Šçš„æ ‡å¿—æ€§æ™¯ç‚¹ã€‚åœ¨åº”ç”¨ç¨‹åºè¿è¡Œæ—¶ï¼ŒTransform ä¼šæ ‡è®°å±•ç¤ºåœ°ç†ä½ç½®åç§°çš„æ‚¬æµ®æ ‡ç‰Œçš„ä½ç½®ã€‚ç‚¹å‡»æ ‡ç‰Œä½¿å…¶å±•å¼€æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ã€‚å°† PointOfInterestComponent ç»„ä»¶æ·»åŠ åˆ° Transform è™šå®ä½“ä¸­ï¼Œåº”ç”¨ç¨‹åºæŸ¥æ‰¾æœ‰ PointOfInterestComponent ç±»å‹ç»„ä»¶çš„ Transform è™šå®ä½“ï¼Œå°†å…¶è½¬åŒ–ä¸ºå¯äº¤äº’çš„è§†å›¾ã€‚å› ä¸º Transform é™¤äº†åŒ…å«ä½ç½®æ•°æ® Positionï¼Œæ–¹å‘æ•°æ® Rotationï¼Œç¼©æ”¾æ•°æ® Scale ä¹‹å¤–æ²¡æœ‰å…¶ä»–çš„æ•°æ®ï¼Œæ‰€ä»¥ Transform ä½¿ç”¨ PointOfInterestComponent ç»„ä»¶æ¥å­˜å‚¨æ ‡ç‰Œæ˜¾ç¤ºæ‰€éœ€è¦çš„æ•°æ®ã€‚åœ¨ Reality Composer Pro æ‰“å¼€åä¸º DioramaAssembled åœºæ™¯ï¼Œç‚¹å‡»åä¸º Cathedral_Rocks çš„ Transformï¼Œè¿™æ—¶åœ¨ Inspector å±æ€§çª—å£å°±èƒ½çœ‹åˆ° PointOfInterestComponent ç»„ä»¶ã€‚",
      "tips": ""
    },
    "Load a scene at runtime": {
      "zh": "ç¨‹åºè¿è¡Œæ—¶åŠ è½½åœºæ™¯",
      "tips": ""
    },
    "To load a Reality Composer Pro scene, use load(named:in:), passing the name of the scene you want to load and the projectâ€™s bundle. Reality Composer Pro Swift packages define a constant that provides ready access to its bundle. The constant is the name of the Reality Composer Pro project with â€œBundleâ€ appended to the end. In this case, the project is called RealityKitContent, so the constant is called RealityKitContentBundle. Hereâ€™s how Diorama loads the map table in the RealityView initializer:": {
      "zh": "ä¸ºäº†æ›´æ–¹ä¾¿å¿«æ·åœ°åŠ è½½ Reality Composer Pro åœºæ™¯ï¼ŒReality Composer Pro Swift package å®šä¹‰äº†ä¸€ä¸ªå¸¸é‡ï¼Œè¿™ä¸ªå¸¸é‡å°±æ˜¯ Reality Composer Pro é¡¹ç›®åç§°åé¢è¿½åŠ  â€œBundleâ€ å­—ç¬¦ã€‚åœ¨è°ƒç”¨ load(named:in:)ï¼Œå°†åœºæ™¯çš„åç§°å­—ç¬¦ä¸²ä½œä¸º named å‚æ•°ï¼Œâ€œ {{ProjectName}}Bundle â€å¸¸é‡ä½œä¸º in å‚æ•°ï¼Œå°±å¯ä»¥åŠ è½½ Reality Composer Pro é¡¹ç›® Bundle ä¸­çš„åœºæ™¯ã€‚ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œé¡¹ç›®åæ˜¯ RealityKitContent ï¼Œæ‰€ä»¥å¸¸é‡å°±æ˜¯ RealityKitContentBundle ã€‚ä¸‹é¢ä»£ç å°±æ˜¯åœ¨ Diorama é¡¹ç›®ä¸­é€šè¿‡ RealityView åˆå§‹åŒ–æ–¹æ³•åŠ è½½åœ°å›¾æ¡Œé¢åœºæ™¯ï¼š",
      "tips": ""
    },
    "The load(named:in:) function is asynchronous when called from an asynchronous context. Because the content closure of the RealityView initializer is asynchronous, it automatically uses the async version to load the scene. Note that when using it asynchronously, you must call it using the await keyword.": {
      "zh": "å½“ä»ä¸€ä¸ªå¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­è°ƒç”¨æ—¶ load(named:in:) æ–¹æ³•æ—¶ï¼Œè¿™ä¸ªæ–¹æ³•å°±ä¼šè¢«å¼‚æ­¥æ‰§è¡Œçš„ã€‚å› ä¸º RealityView åˆå§‹åŒ–æ–¹æ³•ä¸­çš„ content é—­åŒ…æ—¶å¼‚æ­¥æ‰§è¡Œï¼Œé‚£ä¹ˆåœ¨é—­åŒ…ä¸­åŠ è½½åœºæ™¯ä¹Ÿæ˜¯å¼‚æ­¥çš„ã€‚æ³¨æ„å¼‚æ­¥è°ƒç”¨ load(named:in:) é¡»è¦ä½¿ç”¨ await å…³é”®å­—ã€‚",
      "tips": ""
    },
    "Create the floating view": {
      "zh": "åˆ›å»ºæ‚¬æµ®è§†å›¾",
      "tips": ""
    },
    "Diorama adds a PointOfInterestComponent to a transform to display details about interesting places. Every point of interestâ€™s name appears in a view that floats above its location on the map. When you tap the floating view, it expands to show detailed information, which the app pulls from the PointOfInterestComponent. The app shows these details by creating a SwiftUI view for each point of interest and querying for all entities that have a PointOfInterestComponent using this query declared in ImmersiveView.swift:": {
      "zh": "Diorama å°† PointOfInterestComponent ç»„ä»¶æ·»åŠ åˆ° Transform ç”¨ä»¥æ˜¾ç¤ºæ™¯ç‚¹çš„è¯¦ç»†ä¿¡æ¯ã€‚åœ°å›¾ä¸Šæ¯ä¸ªæ™¯ç‚¹çš„ä½ç½®ä¸Šé¢éƒ½æ‚¬æµ®ç€æ˜¾ç¤ºæ™¯ç‚¹åå­—çš„è§†å›¾ã€‚ç‚¹å‡»æ‚¬æµ®è§†å›¾æ—¶ï¼Œä¾¿ä¼šå±•å¼€æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ï¼Œè¿™äº›ä¿¡æ¯å°±æ˜¯æ¥è‡ª PointOfInterestComponent ç»„ä»¶å­˜å‚¨çš„æ•°æ®ã€‚åˆ›å»º SwiftUI è§†å›¾å±•ç¤ºæ™¯ç‚¹çš„è¯¦ç»†ä¿¡æ¯ï¼Œé€šè¿‡ PointOfInterestComponent ç»„ä»¶æŸ¥è¯¢ç›¸åº”çš„å®ä½“ï¼Œä½¿ç”¨ ImmersiveView.swift ä¸­å£°æ˜çš„æŸ¥è¯¢ï¼š",
      "tips": ""
    },
    "In the RealityView initializer, Diorama queries to retrieve the points of interest entities and passes them to a function called createLearnMoreView(for:), which creates the view and saves it for display when itâ€™s tapped.": {
      "zh": "Diorama é¡¹ç›®ä¸­ï¼Œåœ¨ RealityView åˆå§‹åŒ–æ–¹æ³•ä¸­æŸ¥è¯¢è·å–é‚£äº›æ ‡å¿—æ€§æ™¯ç‚¹å®ä½“ï¼Œå¹¶å°†å®ƒä»¬ä¼ é€’ç»™ createLearnMoreView(for:) å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°åˆ›å»ºè¯¦æƒ…è§†å›¾ï¼Œå¹¶å°†å®ƒå­˜å‚¨ä¸‹æ¥ï¼Œåœ¨ç‚¹å‡»çš„æ—¶å€™åœ¨å±•ç¤ºå®ƒã€‚",
      "tips": ""
    },
    "Create attachments for points of interest": {
      "zh": "ä¸ºæ ‡å¿—æ€§æ™¯ç‚¹åˆ›å»ºé™„å±è§†å›¾",
      "tips": ""
    },
    "Diorama displays the information added to a PointOfInterestComponent in a LearnMoreView, which it stores as an attachment. Attachments are SwiftUI views that are also RealityKit entities and that you can place into a RealityKit scene at a specific location. Diorama uses attachments to position the view that floats above each point of interest.": {
      "zh": "Diorama ç”¨ LearnMoreView è§†å›¾å±•ç¤º PointOfInterestComponent ç»„ä»¶ä¸­å‚¨å­˜çš„è¯¦ç»†ä¿¡æ¯ï¼Œé¦–å…ˆå°† LearnMoreView å­˜å‚¨ä¸ºé™„å±è§†å›¾ã€‚é™„å±è§†å›¾æ˜¯ SwiftUI è§†å›¾ï¼Œä¹Ÿæ˜¯ RealityKit å®ä½“ï¼Œè€Œåœ¨ RealityKit åœºæ™¯ä¸­ä½¿ç”¨çš„æ˜¯é™„å±è§†å›¾ä½œä¸ºå®ä½“å¹¶è®¾å®šä½ç½®ã€‚ä¾‹å¦‚ï¼ŒDiorama è®¾ç½®çš„æ˜¯é™„å±è§†å›¾ï¼ˆ Attachment ï¼‰çš„ä½ç½®ï¼Œè®©å®ƒä»¬æ‚¬æµ®åœ¨æ¯ä¸ªæ ‡å¿—æ™¯ç‚¹çš„ä¸Šæ–¹ã€‚",
      "tips": "è¯‘è€…æ³¨ï¼šå°† Attachment è¯‘ä½œâ€œé™„å±è§†å›¾â€ï¼Œattachment å°±åƒæ˜¯é“¾æ¥ SwiftUI ç¯å¢ƒ å’Œ RealityKit ç¯å¢ƒ çš„ä¸€ä¸ªä¸­é—´ä»¶ã€‚"
    },
    "The app first checks to see if the entity has a component called PointOfInterestRuntimeComponent. If it doesnâ€™t, it creates a new one and adds it to the entity. This new component contains a value you only use at runtime that you donâ€™t need to edit in Reality Composer Pro.": {
      "zh": "åº”ç”¨ç¨‹åºé¦–å…ˆä¼šæ£€æŸ¥å®ä½“æ˜¯å¦æœ‰ PointOfInterestRuntimeComponent ç»„ä»¶ã€‚å¦‚æœæ²¡æœ‰ï¼Œä¼šåˆ›å»ºæ–°çš„ PointOfInterestRuntimeComponent ç»„ä»¶å¹¶å°†è¿™ä¸ªç»„ä»¶æ·»åŠ åˆ°å®ä½“ä¸­ã€‚è¿™ä¸ªç»„ä»¶å­˜å‚¨çš„æ˜¯åªæœ‰åœ¨è¿è¡Œæ—¶ä½¿ç”¨çš„æ•°å€¼ï¼Œæ— éœ€ç”¨ Reality Composer Pro ç¼–è¾‘ã€‚",
      "tips": ""
    },
    "By putting this value into a separate component and adding it to entities at runtime, Reality Composer Pro never displays it in the inspector. The PointOfInterestRuntimeComponent stores an identifier called an attachment tag, which uniquely identifies an attachment so the app can retrieve and display it at the appropriate time.": {
      "zh": "åœ¨è¿è¡Œæ—¶å°†æ•°å€¼æ”¾åœ¨å•ç‹¬çš„ç»„ä»¶ä¸­ï¼Œå¹¶æŠŠç»„ä»¶æ·»åŠ åˆ°å®ä½“ä¸­ï¼ŒReality Composer Pro ä¸ä¼šåœ¨ Inspector å±æ€§çª—å£ä¸­æ˜¾ç¤ºå‡ºè¿™ä¸ªè¿è¡Œæ—¶ç»„ä»¶ã€‚PointOfInterestRuntimeComponent ç”¨ attachmentTag å±æ€§å­˜å‚¨é™„å±è§†å›¾çš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œè¿™æ ·åº”ç”¨ç¨‹åºä¼šåœ¨åˆé€‚çš„æ—¶å€™é€šè¿‡ attachmentTag è·å–ç›¸åº”è§†å›¾å¹¶æ˜¾ç¤ºå‡ºæ¥ã€‚",
      "tips": ""
    },
    "Next, Diorama creates a SwiftUI view called a LearnMoreView with the information from the PointOfInterestComponent, tags that view, and stores the tag in the PointOfInterestRuntimeComponent. Finally, it stores the view in an AttachmentProvider, which is a custom class that maintains references to the attachment views so they donâ€™t get deallocated when theyâ€™re not in a scene.": {
      "zh": "æ¥ä¸‹æ¥ï¼Œ Diorama åˆ›å»º LearnMoreView ç±»å‹çš„ SwiftUI è§†å›¾ï¼Œæ˜¾ç¤º PointOfInterestComponent ä¸­çš„ä¿¡æ¯ï¼Œæ¥ä¸‹æ¥è®¾ç½®è¯¦ç»†è§†å›¾çš„ tag å€¼ï¼ŒåŒæ—¶ä½¿ç”¨ç›¸åŒçš„ tag å€¼è®¾ç½® PointOfInterestRuntimeComponent çš„ attachmentTag å±æ€§ã€‚æœ€åï¼Œè®²è¿™äº›è¯¦ç»†è§†å›¾å­˜å‚¨åœ¨ AttachmentProvider ä¸­ï¼ŒAttachmentProvider æ˜¯ç”¨æ¥ç»´æŠ¤æŒæœ‰é™„å±è§†å›¾å¼•ç”¨çš„è‡ªå®šä¹‰ç±»ï¼Œä»¥é˜²è¿™äº›è§†å›¾æ²¡æœ‰åœ¨åœºæ™¯ä¸­è€Œè¢«é‡Šæ”¾ã€‚",
      "tips": ""
    },
    "Display point of interest attachments": {
      "zh": "å±•ç¤ºæ ‡å¿—æ™¯ç‚¹çš„é™„å±è§†å›¾",
      "tips": ""
    },
    "Assigning a view to an attachment provider doesnâ€™t actually display that view in the scene. The initializer for RealityView has an optional view builder called attachments thatâ€™s used to specify the attachments.": {
      "zh": "å°†è§†å›¾æ·»åŠ åˆ° AttachmentProvider ä¸­æ—¶ï¼Œå¹¶ä¸ä¼šç«‹å³æ˜¾ç¤ºåœ¨åœºæ™¯ä¸­ã€‚å¯ä»¥é€‰æ‹© RealityView æœ‰åä¸º attachments çš„è§†å›¾æ„å»ºå™¨ï¼ˆ ViewBuilderï¼‰å‚æ•°çš„åˆå§‹åŒ–æ–¹æ³•ï¼Œè¿™ä¸ªè§†å›¾æ„å»ºå™¨åˆ›å»ºçš„é™„å±è§†å›¾æŒ‡å®šç»™äº† attachments å‚æ•°ã€‚",
      "tips": ""
    },
    "In the update closure of the initializer, which RealityKit calls when the contents of the view change, the app queries for entities with a PointOfInterestRuntimeComponent, uses the tag from that component to retrieve the correct attachment for it, and then adds that attachment and places it above its location on the map.": {
      "zh": "å½“ RealityKit è§†å›¾å†…å®¹å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œä¼šè°ƒç”¨åˆå§‹åŒ–æ—¶æŒ‡å®š update é—­åŒ…ï¼Œåœ¨è¿™ä¸ªé—­åŒ…ä¸­ä¼šé€šè¿‡ PointOfInterestRuntimeComponent ç±»å‹æŸ¥è¯¢ç›¸åº”çš„å®ä½“ï¼Œé€šè¿‡ç»„ä»¶çš„ attachmentTag å±æ€§è·å–å¯¹åº”çš„é™„å±è§†å›¾ï¼Œç„¶åå°†é™„å±è§†å›¾æ·»åŠ åˆ°åœ°å›¾ä¸Šå¹¶è®¾ç½®å®ƒçš„ä½ç½®ã€‚ï¼ˆè¯‘è€…æ³¨ï¼šè¯¦ç»†è¯·å‚é˜… RealityView çš„åˆå§‹åŒ–æ–¹æ³•ï¼‰ã€‚",
      "tips": ""
    },
    "Create custom materials with Shader Graph": {
      "zh": "ä½¿ç”¨ Shader Graph åˆ›å»ºè‡ªå®šä¹‰çš„ç´ æ",
      "tips": ""
    },
    "To switch between the two different topographical maps, Diorama shows a slider that morphs the map between the two locations. To accomplish this, and to draw elevation lines on the map, the FlatTerrain entity in the DioramaAssembled scene uses a Shader Graph material. Shader Graph is a node-based material editor thatâ€™s built into Reality Composer Pro. Shader Graph gives you the ability to create dynamic materials that you can change at runtime. Prior to Reality Composer Pro, the only way to implement a dynamic material like this was to create a CustomMaterial and write Metal shaders to implement the necessary logic.": {
      "zh": "Diorama é€šè¿‡æ»‘åŠ¨æ¡æ§åˆ¶ä¸¤å¼ åœ°å›¾ä¹‹é—´æ¸å˜åœ°åˆ‡æ¢ã€‚ä¸ºäº†è¾¾åˆ°è¿™ç§æ•ˆæœï¼Œå…ˆåœ¨åœ°å›¾ä¸Šç»˜åˆ¶ç­‰é«˜ç¿”ï¼ŒDioramaAssembled åœºæ™¯ä¸­çš„ FlatTerrain å®ä½“ä½¿ç”¨çš„ Shader Graph ç´ æã€‚ Shader Graph æ˜¯åŸºäºèŠ‚ç‚¹ï¼ˆ node-base ï¼‰çš„ç´ æç¼–è¾‘å™¨ï¼Œå®ƒå·²ç»é›†æˆåˆ° Reality Composer Pro ã€‚ä½¿ç”¨ Shader Graph å¯ä»¥åˆ›å»ºè¿è¡Œæ—¶æ”¹å˜çš„åŠ¨æ€ç´ æã€‚åœ¨ Reality Composer Pro æ¨å‡ºä¹‹å‰ï¼Œå®ç°åŠ¨æ€ç´ æå”¯ä¸€åŠæ³•å°±æ˜¯åˆ›å»ºè‡ªå®šä¹‰ç´ æ CustomMaterial å¹¶é€šè¿‡ç¼–å†™ Metal Shader å®ç°å¿…è¦é€»è¾‘ã€‚",
      "tips": ""
    },
    "Dioramaâ€™s DynamicTerrainMaterialEnhanced does two things. It draws contour lines on the map based on height data stored in displacement map images, and it also offsets the vertices of the flat disk based on the same data. By interpolating between two different height maps, the app achieves a smooth transition between the two different sets of height data.": {
      "zh": "Diorama é¡¹ç›®ä¸­çš„ DynamicTerrainMaterialEnhanced åšäº†ä¸¤ä»¶äº‹æƒ…ï¼šæ ¹æ®åœ°å›¾æ¨¡å‹çš„ä½ç§»è´´å›¾ä¸­å­˜å‚¨é«˜åº¦æ•°æ®æ¥æç»˜ç­‰é«˜çº¿å’Œå¹³é¢åœ†å½¢ä¸Šåœ°å½¢å¤–è¡¨çš„é¡¶ç‚¹ï¼›é€šè¿‡åœ¨ä¸¤ä¸ªä¸åŒçš„é«˜åº¦åœ°å›¾ä¹‹é—´è¿›è¡Œæ’å€¼ã€‚åº”ç”¨ç¨‹åºå®ç°äº†åœ¨ä¸¤ç»„æœ‰ä¸åŒçš„é«˜åº¦æ•°æ®çš„åœ°å›¾ä¹‹é—´å¹³æ»‘åˆ‡æ¢ã€‚",
      "tips": ""
    },
    "When you build Shader Graph materials, you can give them input parameters called promoted inputs that you set from Swift code. This allows you to implement logic that previously required writing a Metal shader. The materials you build in the editor can affect both the look of an entity using the custom surface output node, which equates to writing Metal code in a fragment shader, or the position of vertices using the geometry modifier output, which equates to Metal code running in a vertex shader.": {
      "zh": "åœ¨åˆ›å»º Shader Graph ç´ ææ—¶ï¼Œä½ å¯ä»¥åœ¨Swiftä»£ç ä¸­é€šè¿‡ Promote Input å‚æ•°ç»™ Shader Graph ç´ æä¼ é€’æ•°æ®ã€‚è¿™æ ·å¯ä»¥å®ç°ç¼–å†™ Metal Shader æ‰€éœ€è¦çš„é€»è¾‘ã€‚ä½¿ç”¨ç¼–è¾‘å™¨åˆ›å»ºçš„ç´ æåï¼Œå¯ä»¥ä½¿ç”¨ç´ æä¸­è‡ªå®šä¹‰å¤–è¡¨çš„è¾“å‡ºèŠ‚ç‚¹ï¼ˆ custom surface output ï¼‰ä½œç”¨ä¸å®ä½“çš„å¤–è§‚ï¼Œè¿™ç­‰ä»·äºç¼–å†™ Fragment Shader çš„ Metal ä»£ç ï¼›ä¹Ÿå¯ä»¥ä½¿ç”¨ç´ æä¸­é›†åˆä¿®æ”¹å™¨çš„è¾“å‡ºï¼ˆ geometry modifier output ï¼‰æ‘†æ”¾é¡¶ç‚¹çš„ä½ç½®ï¼Œè¿™ç­‰ä»·äºç¼–å†™ Vertex Shader çš„ Metal ä»£ç ã€‚",
      "tips": ""
    },
    "Node graphs can contain subgraphs, which are similar to functions. They contain reusable sets of nodes with inputs and outputs. Subgraphs contain the logic to draw the contour lines and the logic to offset the vertices. Double-click a subgraph to edit it. For more information about building materials using Shader Graph, see Explore Materials in Reality Composer Pro.": {
      "zh": "èŠ‚ç‚¹å›¾ï¼ˆ Node graph ï¼‰å¯ä»¥åŒ…å«å­å›¾ï¼ˆ Subgraph ï¼‰ï¼Œè¿™ç±»ä¼¼å‡½æ•°ã€‚å®ƒä»¬åŒ…å«ä¸€ç³»åˆ—å¯é‡ç”¨çš„è¾“å…¥å’Œè¾“å‡ºèŠ‚ç‚¹ã€‚å­å›¾ï¼ˆ Subgraph ï¼‰åŒ…å«ç»˜åˆ¶ç­‰é«˜çº¿å’Œè°ƒæ•´é¡¶ç‚¹çš„é€»è¾‘ã€‚åŒå‡»å­å›¾ï¼ˆ Subgraph ï¼‰è¿›è¡Œç¼–è¾‘æ“ä½œã€‚æ›´å¤šå…³äºä½¿ç”¨ Shader Graph åˆ›å»ºç´ æï¼Œè¯·å‚ç…§ Explore Materials in Reality Composer Pro ã€‚",
      "tips": ""
    },
    "Update the Shader Graph material at runtime": {
      "zh": "è¿è¡Œæ—¶æ›´æ–° Shader Graph ç´ æ",
      "tips": ""
    },
    "To change the map, DynamicTerrainMaterialEnhanced has a promoted input called Progress. If that parameter is set to 1.0, it displays Catalina Island. If itâ€™s set to 0, it displays Yosemite. Any other number shows a state in transition between the two. When someone manipulates the slider, the app updates that input parameter based on the sliderâ€™s value.": {
      "zh": "DynamicTerrainMaterialEnhanced æœ‰åä¸º Progress çš„ Promoted Input å‚æ•°ã€‚å¦‚æœå°†å‚æ•°è®¾ç½®ä¸º 1.0 ï¼Œåˆ™ä¼šæ˜¾ç¤º Catalina Islandã€‚å¦‚æœè§å‚æ•°è®¾ä¸º 0 ï¼Œåˆ™ä¼šæ˜¾ç¤º Yosemiteã€‚å¦‚æœå°†å‚æ•°è®¾ç½®ä¸º 0 åˆ° 1 ä¹‹é—´çš„æ•°å€¼ï¼Œåˆ™æ˜¾ç¤ºä¸¤ä¸ªåœ°å›¾åˆ‡æ¢æ—¶çš„ä¸­é—´çŠ¶æ€ã€‚å½“ç”¨æˆ·æ“ä½œæ»‘åŠ¨æ¡æ—¶ï¼Œåº”ç”¨ç¨‹åºä¼šç”¨æ»‘åŠ¨æ¡å½“å‰çš„æ•°å€¼æ›´æ–°è¾“å…¥å‚æ•°ã€‚",
      "tips": ""
    },
    "Important": {
      "zh": "è¦ç‚¹",
      "tips": ""
    },
    "Shader Graph material parameters are case-sensitive. If the capitalization is wrong, your code wonâ€™t actually update the material.": {
      "zh": "Shader Graph ç´ æå‚æ•°çš„åç§°æ˜¯åŒºåˆ†å¤§å°å†™çš„ã€‚å¦‚æœå¤§å†™å’Œå°å†™çš„æ‹¼å†™ä¸æ­£ç¡®ï¼Œä½ çš„ä»£ç å°±æ— æ³•æ›´æ–°ææ–™ã€‚",
      "tips": ""
    },
    "The app sets the value of the input parameter in a function called handleMaterial() that the sliderâ€™s .onChanged closure calls. That function retrieves the ShaderGraphMaterial from the terrain entity and calls setParameter(name:value:) on it.": {
      "zh": "åº”ç”¨ç¨‹åºä¼šåœ¨ Slider çš„ .onChanged å›è°ƒé—­åŒ…ä¸­è°ƒç”¨ handleMaterial() å‡½æ•°ï¼Œåœ¨å‡½æ•°ä¸­è·å– terrain å®ä½“ä¸­çš„ ShaderGraphMaterial ç´ æï¼Œç„¶åè°ƒç”¨ç´ æçš„ setParameter(name:value:) çš„æ–¹æ³•å»æ›´æ–°ç´ æçš„è¾“å…¥å‚æ•°ã€‚",
      "tips": ""
    }
  },
  "visionos/drawing-sharp-layer-based-content": {
    "Drawing sharp layer-based content in visionOS": {
      "zh": "åœ¨ visionOS ä¸­ç»˜åˆ¶åŸºäºå›¾å±‚çš„æ¸…æ™°å†…å®¹",
      "tips": ""
    },
    "Deliver text and vector images at multiple resolutions from custom Core Animation layers in visionOS.": {
      "zh": "åœ¨ visionOS ä¸­ï¼Œä»è‡ªå®šä¹‰çš„ Core Animation å›¾å±‚ä¸­ä»¥å¤šç§åˆ†è¾¨ç‡æä¾›æ–‡æœ¬å’ŒçŸ¢é‡å›¾å½¢",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "If your app uses Core Animation layers directly, update your layer code to draw a high-resolution version of your content when appropriate. SwiftUI and UIKit views use Core Animation layers to manage interface content efficiently. When a view draws its content, the underlying layer captures that content and caches it to improve subsequent render operations.": {
      "zh": "å¦‚æœä½ çš„åº”ç”¨ç›´æ¥ä½¿ç”¨äº† Core Animation å›¾å±‚ï¼ˆlayerï¼‰ï¼Œè¯·æ›´æ–°è¿™éƒ¨åˆ†ä»£ç ï¼Œä»¥ä¾¿åœ¨é€‚å½“çš„æ—¶å€™ç»˜åˆ¶é«˜åˆ†è¾¨ç‡ç‰ˆæœ¬çš„å†…å®¹ã€‚SwiftUI å’Œ UIKit è§†å›¾ä½¿ç”¨ Core Animation å±‚æ¥é«˜æ•ˆç®¡ç†ç•Œé¢å†…å®¹ã€‚å½“ä¸€ä¸ª View ç»˜åˆ¶å…¶å†…å®¹æ—¶ï¼Œåº•å±‚çš„ layer ä¼šæ•è·è¯¥å†…å®¹å¹¶å¯¹å…¶è¿›è¡Œç¼“å­˜ï¼Œä¸ºåç»­çš„æ¸²æŸ“æ“ä½œä½œå‡ºä¼˜åŒ–ã€‚",
      "tips": ""
    },
    "Core Animation on most Apple platforms rasterizes your layer at the same resolution as the screen, but Core Animation on visionOS can rasterize at different resolutions to maximize both content clarity and performance. The system follows the personâ€™s eyes and renders content immediately in front of them at the highest possible resolution. Outside of this focal area, the system renders content at progressively lower resolutions to reduce GPU workloads. Because the content is in the personâ€™s peripheral vision, these lower resolutions donâ€™t impact the contentâ€™s clarity. As the personâ€™s eyes move around, the system redraws content at different resolutions to match the change in focus.": {
      "zh": "å¤§å¤šæ•° Apple å¹³å°ä¸Šçš„ Core Animation ä½¿ç”¨ä¸å±å¹•ç›¸åŒçš„åˆ†è¾¨ç‡å¯¹å›¾å±‚è¿›è¡Œæ …æ ¼åŒ–ï¼Œä½†æ˜¯ visionOS æœ‰æ‰€ä¸åŒï¼Œåœ¨ visionOS ä¸Šçš„ Core Animation å¯ä»¥ä»¥ä¸åŒçš„åˆ†è¾¨ç‡æ …æ ¼åŒ–ï¼Œä»¥æœ€å¤§åŒ–æå‡ç»˜åˆ¶å†…å®¹çš„æ¸…æ™°åº¦å’Œæ€§èƒ½ã€‚ç³»ç»Ÿä¼šè·Ÿè¸ªäººçœ¼ï¼Œæ ¹æ®äººçœ¼æ‰€åœ¨ç„¦ç‚¹ä»¥å°½å¯èƒ½é«˜çš„åˆ†è¾¨ç‡ç«‹å³å‘ˆç°å†…å®¹ã€‚åœ¨æ­¤ç„¦ç‚¹çš„åŒºåŸŸä¹‹å¤–ï¼Œç³»ç»Ÿä»¥é€æ¸é™ä½çš„åˆ†è¾¨ç‡æ¸²æŸ“å†…å®¹ï¼Œä»¥å‡å°‘ GPU å·¥ä½œè´Ÿè½½ã€‚ç”±äºç„¦ç‚¹å¤–çš„å†…å®¹ä½äºäººçš„å‘¨è¾¹è§†è§‰ä¸­ï¼Œå› æ­¤è¿™äº›è¾ƒä½çš„åˆ†è¾¨ç‡ä¸ä¼šå½±å“å†…å®¹çš„æ¸…æ™°åº¦ã€‚å½“äººçš„çœ¼ç›å››å¤„ç§»åŠ¨æ—¶ï¼Œç³»ç»Ÿä¼šä»¥ä¸åŒçš„åˆ†è¾¨ç‡é‡æ–°ç»˜åˆ¶å†…å®¹ï¼Œæ¥åŒ¹é…ç„¦ç‚¹çš„å˜åŒ–ã€‚",
      "tips": ""
    },
    "If you deliver content using custom CALayer objects, you can configure your custom layers to support drawing at different resolutions. If you donâ€™t perform this extra configuration step, each layer rasterizes its content at a @2x scale factor, which is good enough for most content and matches what the layer provides on a Retina display. However, if you opt in to drawing at different resolutions, the layer rasterizes its content at up to @8x scale factor in visionOS, which adds significant detail to text and vector-based content.": {
      "zh": "å¦‚æœä½¿ç”¨è‡ªå®šä¹‰ CALayer å¯¹è±¡æä¾›å†…å®¹ï¼Œåˆ™å¯ä»¥é…ç½®ä½ çš„è‡ªå®šä¹‰å›¾å±‚ä»¥æ”¯æŒä»¥ä¸åŒåˆ†è¾¨ç‡æ¥è¿›è¡Œç»˜åˆ¶ã€‚å¦‚æœä¸æ‰§è¡Œè¿™ä¸€é¢å¤–çš„é…ç½®æ­¥éª¤ï¼Œåˆ™æ¯ä¸ªå›¾å±‚éƒ½ä¼šä»¥ @2x çš„æ¯”ä¾‹æ …æ ¼åŒ–å…¶å†…å®¹ï¼Œè¿™å¯¹äºå¤§å¤šæ•°å†…å®¹æ¥è¯´å·²ç»è¶³å¤Ÿäº†ï¼Œå¹¶ä¸”ä¸å›¾å±‚åœ¨ Retina æ˜¾ç¤ºå±ä¸Šæä¾›çš„å†…å®¹ç›¸åŒ¹é…ã€‚ä½†æ˜¯ï¼Œå¦‚æœæ‚¨é€‰æ‹©ä»¥ä¸åŒçš„åˆ†è¾¨ç‡è¿›è¡Œç»˜åˆ¶ï¼Œåˆ™å›¾å±‚ä¼šåœ¨ visionOS ä¸­ä»¥é«˜è¾¾  @8x çš„æ¯”ä¾‹æ …æ ¼åŒ–å…¶å†…å®¹ï¼Œä»è€Œä¸ºæ–‡æœ¬å’ŒåŸºäºçŸ¢é‡çš„å†…å®¹æ·»åŠ å¤§é‡ç»†èŠ‚ã€‚",
      "tips": ""
    },
    "Request dynamic scaling for custom layers": {
      "zh": "è¯·æ±‚è‡ªå®šä¹‰å›¾å±‚çš„åŠ¨æ€ç¼©æ”¾",
      "tips": ""
    },
    "Dynamic content scaling is off by default for all Core Animation layers, and frameworks or apps must turn on this support explicitly. If your interface uses only SwiftUI or UIKit views, you donâ€™t need to do anything to support this feature. SwiftUI and UIKit enable it automatically for views that benefit from the added detail, such as text views and image views with SF Symbols or other vector-based artwork. However, the frameworks donâ€™t enable the feature for all views, including UIView and View.": {
      "zh": "é»˜è®¤æƒ…å†µä¸‹ï¼Œæ‰€æœ‰ Core Animation å›¾å±‚çš„åŠ¨æ€å†…å®¹ç¼©æ”¾éƒ½å¤„äºå…³é—­çŠ¶æ€ï¼Œæ¡†æ¶æˆ–åº”ç”¨å¿…é¡»æ˜¾å¼åœ°å¯ç”¨æ­¤æ”¯æŒã€‚å¦‚æœæ‚¨çš„ç•Œé¢ä»…ä½¿ç”¨ SwiftUI æˆ– UIKit è§†å›¾ï¼Œåˆ™æ— éœ€æ‰§è¡Œä»»ä½•æ“ä½œå³å¯æ”¯æŒæ­¤åŠŸèƒ½ã€‚SwiftUI å’Œ UIKit ä¼šè‡ªåŠ¨ä¸ºé‚£äº›å—ç›Šäºè¢«æ·»åŠ äº†ç»†èŠ‚çš„è§†å›¾å¯ç”¨å®ƒï¼Œä¾‹å¦‚å¸¦æœ‰ SF ç¬¦å·çš„æ–‡æœ¬å’Œå›¾åƒè§†å›¾ï¼Œæˆ–å…¶ä»–åŸºäºçŸ¢é‡çš„ç¾æœ¯èµ„æºã€‚ä½†æ˜¯ï¼Œæ¡†æ¶ä¸ä¼šä¸ºæ‰€æœ‰è§†å›¾ï¼ˆåŒ…æ‹¬ UIView å’Œ View ï¼‰å¯ç”¨è¯¥åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "If your visionOS interface includes custom Core Animation layers, you can enable the wantsDynamicContentScaling property of any CALayer objects that contain vector-based content. Setting this property to true tells the system that you support rendering your layerâ€™s content at different resolutions. However, the setting is not a guarantee that the system applies dynamic content scaling to your content. The system can disable the feature if your layer draws using incompatible functions or techniques.": {
      "zh": "å¦‚æœæ‚¨çš„ visionOS ç•Œé¢åŒ…å«è‡ªå®šä¹‰çš„ Core Animation å›¾å±‚ï¼Œå¯¹äºåŒ…å«åŸºäºçŸ¢é‡çš„å†…å®¹çš„ä»»æ„ CALayer å¯¹è±¡ï¼Œæ‚¨éƒ½å¯ä»¥å¯ç”¨å®ƒä»¬çš„ wantsDynamicContentScaling å±æ€§ã€‚å°†æ­¤å±æ€§è®¾ç½®ä¸º true ä¼šå‘ŠçŸ¥ç³»ç»Ÿæ‚¨æ”¯æŒä»¥ä¸åŒçš„åˆ†è¾¨ç‡æ¸²æŸ“å›¾å±‚çš„å†…å®¹ã€‚ä½†æ˜¯ï¼Œæ­¤è®¾ç½®å¹¶ä¸èƒ½ä¿è¯ç³»ç»Ÿå°†åŠ¨æ€å†…å®¹ç¼©æ”¾åº”ç”¨äºæ‚¨çš„å†…å®¹ã€‚å¦‚æœå›¾å±‚ä½¿ç”¨ä¸å…¼å®¹çš„å‡½æ•°æˆ–æŠ€æœ¯è¿›è¡Œç»˜åˆ¶ï¼Œç³»ç»Ÿå¯èƒ½ä¼šç¦ç”¨è¯¥å±æ€§ã€‚",
      "tips": ""
    },
    "The following example shows how to enable this feature for a CATextLayer object. After configuring the layer, set the wantsDynamicContentScaling property to true and add the layer to your layer hierarchy.": {
      "zh": "ä»¥ä¸‹ç¤ºä¾‹æ¼”ç¤ºå¦‚ä½•ä¸º CATextLayer å¯¹è±¡å¯ç”¨æ­¤åŠŸèƒ½ã€‚é…ç½®å›¾å±‚åï¼Œå°† wantsDynamicContentScaling å±æ€§è®¾ç½®ä¸º true ï¼Œç„¶åå°†æ­¤å›¾å±‚æ·»åŠ åˆ°å›¾å±‚å±‚æ¬¡ç»“æ„ä¸­ã€‚",
      "tips": ""
    },
    "Dynamic content scaling works best when the layer contains text or vector-based content. Donâ€™t enable the feature if you do any of the following in your layer:": {
      "zh": "å½“å›¾å±‚åŒ…å«æ–‡æœ¬æˆ–åŸºäºçŸ¢é‡çš„å†…å®¹æ—¶ï¼ŒåŠ¨æ€å†…å®¹ç¼©æ”¾æ•ˆæœæœ€ä½³ã€‚å¦‚æœåœ¨å›¾å±‚ä¸­æ‰§è¡Œä»¥ä¸‹ä»»ä¸€æ“ä½œï¼Œè¯·å‹¿å¯ç”¨è¯¥åŠŸèƒ½ï¼š",
      "tips": ""
    },
    "You set the layerâ€™s content using the contents property.": {
      "zh": "æ‚¨ä½¿ç”¨ contents å±æ€§è®¾ç½®äº†å›¾å±‚çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "You draw primarily bitmap-based content.": {
      "zh": "æ‚¨ä¸»è¦ç»˜åˆ¶çš„æ˜¯åŸºäºä½å›¾çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "You redraw your layerâ€™s contents repeatedly over a short time period.": {
      "zh": "æ‚¨å¯èƒ½ä¼šåœ¨çŸ­æ—¶é—´å†…å¤šæ¬¡é‡ç»˜æ‚¨çš„å†…å®¹ã€‚",
      "tips": ""
    },
    "The CAShapeLayer class ignores the value of the wantsDynamicContentScaling property and always enables dynamic content scaling. For other Core Animation layers, you must enable the feature explicitly to take advantage of it.": {
      "zh": "CAShapeLayer ç±»å¿½ç•¥ wantsDynamicContentScaling å±æ€§çš„å€¼ï¼Œå¹¶å§‹ç»ˆå¯ç”¨åŠ¨æ€å†…å®¹ç¼©æ”¾ã€‚å¯¹äºå…¶ä»– Core Animation å›¾å±‚ï¼Œå¿…é¡»æ˜¾å¼å¯ç”¨è¯¥åŠŸèƒ½æ‰èƒ½åˆ©ç”¨å®ƒã€‚",
      "tips": ""
    },
    "Draw the layerâ€™s content dynamically": {
      "zh": "åŠ¨æ€ç»˜åˆ¶å›¾å±‚çš„å†…å®¹",
      "tips": ""
    },
    "Dynamic content scaling requires you to draw your layerâ€™s contents using one of the prescribed methods. If you define a custom subclass of CALayer, draw your layerâ€™s content in the draw(in:) method. If you use a CALayerDelegate object to draw the layerâ€™s content, use the delgateâ€™s drawLayer:inContext: method instead.": {
      "zh": "åŠ¨æ€å†…å®¹ç¼©æ”¾è¦æ±‚æ‚¨ä½¿ç”¨æŸä¸ªæŒ‡å®šçš„æ–¹æ³•ç»˜åˆ¶å›¾å±‚çš„å†…å®¹ã€‚å¦‚æœå®šä¹‰äº†ä¸€ä¸ªè‡ªå®šä¹‰çš„ CALayer å­ç±»ï¼Œè¯·åœ¨ draw(in:) æ–¹æ³•ä¸­ç»˜åˆ¶å›¾å±‚çš„å†…å®¹ã€‚å¦‚æœä½¿ç”¨ CALayerDelegate å¯¹è±¡ç»˜åˆ¶å›¾å±‚çš„å†…å®¹ï¼Œè¯·æ”¹ç”¨ delgate ä¸­çš„ drawLayer:inContext: æ–¹æ³•ã€‚",
      "tips": ""
    },
    "When you enable dynamic content scaling for a layer, the system captures your appâ€™s drawing commands for playback later. As the personâ€™s eyes move, the system draws the layer at higher resolutions when someone looks directly at it, or at lower resolutions otherwise. Because the redraw operations implicitly communicate what the person is looking at, the system performs them outside of your appâ€™s process. Letting the system handle these operations maintains the personâ€™s privacy while still giving your app the benefits of high-resolution drawing.": {
      "zh": "å½“æ‚¨ä¸ºå›¾å±‚å¯ç”¨åŠ¨æ€å†…å®¹ç¼©æ”¾æ—¶ï¼Œç³»ç»Ÿä¼šæ•è·åº”ç”¨ç¨‹åºçš„ç»˜å›¾å‘½ä»¤ä»¥ä¾›ä»¥åé‡ç»˜ã€‚å½“äººçš„çœ¼ç›ç§»åŠ¨æ—¶ï¼Œå¦‚æœè§†çº¿ç›´è§†å›¾å±‚ï¼Œç³»ç»Ÿä¼šä»¥æ›´é«˜çš„åˆ†è¾¨ç‡ç»˜åˆ¶å›¾å±‚ï¼Œå¦åˆ™ç³»ç»Ÿä¼šä»¥è¾ƒä½çš„åˆ†è¾¨ç‡ç»˜åˆ¶å›¾å±‚ã€‚ç”±äºé‡ç»˜æ“ä½œéšå¼é€éœ²äº†ç”¨æˆ·æ­£åœ¨æŸ¥çœ‹çš„å†…å®¹ï¼Œå› æ­¤ç³»ç»Ÿä¼šåœ¨åº”ç”¨è¿›ç¨‹ä¹‹å¤–æ‰§è¡Œè¿™äº›æ“ä½œã€‚è®©ç³»ç»Ÿå¤„ç†è¿™äº›æ“ä½œä¸ä»…å¯ä»¥ä¿æŠ¤ç”¨æˆ·éšç§ï¼ŒåŒæ—¶å¯ä½¿æ‚¨çš„åº”ç”¨ç¨‹åºèƒ½å¤Ÿå—ç›Šäºé«˜åˆ†è¾¨ç‡ç»˜åˆ¶ã€‚",
      "tips": ""
    },
    "Some Core Graphics routines are incompatible with dynamic content scaling. Even if you enable dynamic content scaling for your layer, the system automatically disables the feature if your layer uses any of the following:": {
      "zh": "ä¸€äº› Core Graphics çš„ API ä¸åŠ¨æ€å†…å®¹ç¼©æ”¾ä¸å…¼å®¹ã€‚å³ä½¿æ‚¨ä¸ºå›¾å±‚å¯ç”¨äº†åŠ¨æ€å†…å®¹ç¼©æ”¾ï¼Œå¦‚æœæ‚¨çš„å›¾å±‚ä½¿ç”¨ä»¥ä¸‹ä»»ä¸€é€‰é¡¹ï¼Œç³»ç»Ÿä¹Ÿä¼šè‡ªåŠ¨ç¦ç”¨è¯¥åŠŸèƒ½ï¼š",
      "tips": ""
    },
    "Core Graphics shaders.": {
      "zh": "ä½¿ç”¨ Core Graphics çš„ ç€è‰²å™¨ï¼ˆshaderï¼‰",
      "tips": ""
    },
    "APIs that set intent, quality, or other bitmap-related properties. For example, donâ€™t call CGContextSetInterpolationQuality.": {
      "zh": "è®¾ç½®æ„å›¾ã€è´¨é‡æˆ–å…¶ä»–ä½å›¾ç›¸å…³å±æ€§çš„ APIã€‚ä¾‹å¦‚ï¼Œä¸è¦è°ƒç”¨ CGContextSetInterpolationQuality ã€‚",
      "tips": ""
    },
    "A CGBitmapContext to draw content.": {
      "zh": "ç”¨äºç»˜åˆ¶å†…å®¹çš„ CGBitmapContext",
      "tips": ""
    },
    "If your app creates timer-based animations, donâ€™t animate layer changes using your drawing method. Calling setNeedsDisplay() on your layer repeatedly in a short time causes the system to draw the layer multiple times in quick succession. Because visionOS needs a little extra time to draw a layer at high resolution, each redraw request forces it to throw away work. A better option is to animate layer-based properties to achieve the same effect, or use a CAShapeLayer to animate paths when needed.": {
      "zh": "å¦‚æœæ‚¨çš„åº”ç”¨åˆ›å»ºåŸºäºè®¡æ—¶å™¨çš„åŠ¨ç”»ï¼Œè¯·ä¸è¦ä½¿ç”¨ç»˜åˆ¶æ–¹æ³•å¯¹å›¾å±‚æ›´æ”¹è¿›è¡ŒåŠ¨ç”»å¤„ç†ã€‚åœ¨çŸ­æ—¶é—´å†…é‡å¤è°ƒç”¨å›¾å±‚çš„ setNeedsDisplay() æ–¹æ³•ä¼šå¯¼è‡´ç³»ç»Ÿå¿«é€Ÿè¿ç»­å¤šæ¬¡ç»˜åˆ¶å›¾å±‚ã€‚ç”±äº visionOS éœ€è¦ä¸€äº›é¢å¤–çš„æ—¶é—´æ¥ä»¥é«˜åˆ†è¾¨ç‡ç»˜åˆ¶å›¾å±‚ï¼Œå› æ­¤æ¯æ¬¡é‡ç»˜è¯·æ±‚éƒ½ä¼šå¼ºåˆ¶å®ƒæ”¾å¼ƒå½“å‰å·¥ä½œã€‚æ›´å¥½çš„é€‰æ‹©æ˜¯å¯¹åŸºäºå›¾å±‚çš„å±æ€§è¿›è¡ŒåŠ¨ç”»å¤„ç†ä»¥å®ç°ç›¸åŒçš„æ•ˆæœï¼Œæˆ–è€…åœ¨éœ€è¦æ—¶ä½¿ç”¨ CAShapeLayer å¯¹è·¯å¾„è¿›è¡ŒåŠ¨ç”»å¤„ç†ã€‚",
      "tips": ""
    },
    "Modify layer hierarchies to improve performance": {
      "zh": "ä¿®æ”¹å›¾å±‚å±‚æ¬¡ç»“æ„ä»¥æ”¹å–„æ€§èƒ½",
      "tips": ""
    },
    "The backing store for a layer consumes more memory at higher resolutions than at lower resolutions. Measure your appâ€™s memory usage before and after you enable dynamic content scaling to make sure the increased memory cost is worth the benefit. If your appâ€™s memory usage increases too much, limit which layers adopt dynamic content scaling. You can also reduce the amount of memory each layer uses in the following ways:": {
      "zh": "å›¾å±‚çš„åç«¯å­˜å‚¨åœ¨è¾ƒé«˜åˆ†è¾¨ç‡ä¸‹æ¯”åœ¨è¾ƒä½åˆ†è¾¨ç‡ä¸‹æ¶ˆè€—æ›´å¤šçš„å†…å­˜ã€‚åœ¨å¯ç”¨åŠ¨æ€å†…å®¹ç¼©æ”¾ä¹‹å‰å’Œä¹‹åæµ‹é‡åº”ç”¨çš„å†…å­˜ä½¿ç”¨æƒ…å†µï¼Œä»¥ç¡®ä¿å¢åŠ çš„å†…å­˜æˆæœ¬ç‰©æœ‰æ‰€å€¼ã€‚å¦‚æœåº”ç”¨çš„å†…å­˜ä½¿ç”¨é‡å¢åŠ è¿‡å¤šï¼Œè¯·å¯¹æŸäº›å›¾å±‚æ˜¯å¦é‡‡ç”¨åŠ¨æ€å†…å®¹ç¼©æ”¾åŠ ä»¥é™åˆ¶ã€‚æ‚¨è¿˜å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼å‡å°‘æ¯ä¸ªå›¾å±‚ä½¿ç”¨çš„å†…å­˜é‡ï¼š",
      "tips": ""
    },
    "Make your layer the smallest size possible. Larger layers require significantly more memory, especially at higher resolutions. Make the size of the layer match the size of your content by eliminating padding or extra space.": {
      "zh": "å°½å¯èƒ½æœ€å°åŒ–æ‚¨çš„å›¾å±‚å°ºå¯¸ã€‚è¶Šå¤§çš„å›¾å±‚éœ€è¦çš„å†…å­˜ä¹Ÿè¶Šå¤šï¼Œå°¤å…¶æ˜¯åœ¨æ›´é«˜çš„åˆ†è¾¨ç‡ä¸‹ã€‚é€šè¿‡æ¶ˆé™¤ç¼©è¿›æˆ–å‘¨å›´é¢å¤–çš„ç©ºé—´ï¼Œæ¥ä½¿å›¾å±‚çš„å¤§å°ä¸å†…å®¹çš„å¤§å°ç›¸åŒ¹é…ã€‚",
      "tips": ""
    },
    "Separate complex content into different layers. Instead of drawing everything in a single layer, build your content from multiple layers and arrange them hierarchically to achieve the same result. Enable dynamic content scaling only in the layers that actually need it.": {
      "zh": "å°†å¤æ‚å†…å®¹ç½®äºä¸åŒå›¾å±‚ã€‚ç›¸æ¯”åœ¨å•ä¸ªå›¾å±‚ä¸­ç»˜åˆ¶æ‰€æœ‰å†…å®¹ï¼Œä¸å¦‚ä»å¤šä¸ªå›¾å±‚æ„å»ºå†…å®¹å¹¶åˆ†å±‚æ’åˆ—å®ƒä»¬ï¼Œä»¥è¾¾åˆ°ç›¸åŒçš„æ•ˆæœã€‚ä»…åœ¨å®é™…éœ€è¦çš„å›¾å±‚ä¸­å¯ç”¨åŠ¨æ€å†…å®¹ç¼©æ”¾ã€‚",
      "tips": ""
    },
    "Apply special effects using layer properties whenever possible. Applying effects during drawing might require you to increase the layerâ€™s size. For example, apply scale and rotation effects to the layerâ€™s transform property, instead of during drawing.": {
      "zh": "å°½å¯èƒ½ä½¿ç”¨å›¾å±‚å±æ€§æ¥åº”ç”¨ç‰¹æ®Šæ•ˆæœã€‚åœ¨ç»˜åˆ¶è¿‡ç¨‹ä¸­åº”ç”¨æŸäº›æ•ˆæœå¯èƒ½éœ€è¦å¢åŠ å›¾å±‚çš„å ç”¨å¤§å°ã€‚ä¾‹å¦‚ï¼Œè¯·å°†ç¼©æ”¾å’Œæ—‹è½¬æ•ˆæœåº”ç”¨äºå›¾å±‚çš„ transform å±æ€§ï¼Œè€Œä¸æ˜¯åœ¨ç»˜åˆ¶è¿‡ç¨‹ä¸­è¿™ä¹ˆåšã€‚",
      "tips": ""
    },
    "Donâ€™t draw your layerâ€™s content at different resolutions in advance and cache the images. Maintaining multiple images requires more memory. If you do cache images, draw them only at @2x scale factor.": {
      "zh": "ä¸è¦æå‰ç”¨ä¸åŒçš„åˆ†è¾¨ç‡ç»˜åˆ¶å›¾å±‚çš„å†…å®¹å¹¶ç¼“å­˜å›¾åƒã€‚ç»´æŠ¤å¤šä¸ªå›¾åƒéœ€è¦æ›´å¤šå†…å­˜ã€‚å¦‚æœæ‚¨ç¡®éœ€ç¼“å­˜å›¾åƒï¼Œè¯·ä»…ä»¥ @2x çš„æ¯”ä¾‹ç»˜åˆ¶å®ƒä»¬ã€‚",
      "tips": ""
    },
    "Donâ€™t use your drawing code to draw a single image. If your layerâ€™s content consists of an image, assign that image to the layerâ€™s contents property directly.": {
      "zh": "ä¸è¦ä½¿ç”¨ç»˜åˆ¶ä»£ç ç»˜åˆ¶å•ä¸ªå›¾åƒã€‚å¦‚æœå›¾å±‚çš„å†…å®¹ç”±å›¾åƒç»„æˆï¼Œè¯·ç›´æ¥å°†è¯¥å›¾åƒåˆ†é…ç»™å›¾å±‚çš„ contents å±æ€§ã€‚",
      "tips": ""
    },
    "Complex drawing code can also lead to performance issues. A layer with many strokes can render quickly at lower scale factors, but might be computationally too complex to render at larger scales. If a complex layer doesnâ€™t render correctly at higher resolutions, turn off dynamic content scaling and measure the render times again.": {
      "zh": "å¤æ‚çš„ç»˜å›¾ä»£ç ä¹Ÿå¯èƒ½å¯¼è‡´æ€§èƒ½é—®é¢˜ã€‚ä¸€ä¸ªå…·æœ‰è®¸å¤šæè¾¹çš„å›¾å±‚å¯ä»¥åœ¨è¾ƒä½åˆ†è¾¨ç‡ä¸‹å¿«é€Ÿæ¸²æŸ“ï¼Œä½†åœ¨è®¡ç®—ä¸Šå¯èƒ½è¿‡äºå¤æ‚ï¼Œç»§è€Œæ— æ³•åœ¨è¾ƒå¤§æ¯”ä¾‹ä¸‹æ¸²æŸ“ã€‚å¦‚æœå¤æ‚å›¾å±‚æ— æ³•åœ¨æ›´é«˜åˆ†è¾¨ç‡ä¸‹æ­£ç¡®æ¸²æŸ“ï¼Œè¯·å…³é—­åŠ¨æ€å†…å®¹ç¼©æ”¾å¹¶å†æ¬¡æµ‹é‡æ¸²æŸ“æ—¶é—´ã€‚",
      "tips": ""
    }
  },
  "visionos/happybeam": {
    "Happy Beam": {
      "zh": "å¿«ä¹å…‰æŸ",
      "tips": ""
    },
    "Leverage a Full Space to create a fun game using ARKit.": {
      "zh": "ä½¿ç”¨ ARKit åœ¨ Full Space ä¸­åˆ›å»ºæœ‰è¶£çš„æ¸¸æˆã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "In visionOS, you can create fun, dynamic games and apps using several different frameworks to create new kinds of spatial experiences: RealityKit, ARKit, SwiftUI, and Group Activities. This sample introduces Happy Beam, a game where you and your friends can hop on a FaceTime call and play together.": {
      "zh": "åœ¨ visionOS ä¸­ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨å¤šç§ä¸åŒçš„æ¡†æ¶åˆ›å»ºæœ‰è¶£ã€åŠ¨æ€çš„æ¸¸æˆå’Œåº”ç”¨ï¼Œä»¥åˆ›å»ºæ–°å‹ç©ºé—´ä½“éªŒï¼šRealityKitã€ARKitã€SwiftUI å’Œ Group Activitiesã€‚æ­¤ç¤ºä¾‹ä»‹ç»äº†å¿«ä¹å…‰æŸ(Happy Beam)ï¼Œè¿™æ˜¯ä¸€æ¬¾æ¸¸æˆï¼Œæ‚¨å’Œæœ‹å‹å¯ä»¥åœ¨å…¶ä¸­è¿›è¡Œ FaceTime é€šè¯å¹¶ä¸€èµ·ç©ã€‚",
      "tips": ""
    },
    "Youâ€™ll learn the mechanics of the game where grumpy clouds float around in the space, and people play by making a heart shape with their hands to project a beam. People aim the beam at the clouds to cheer them up, and a score counter keeps track of how well each player does cheering up the clouds.": {
      "zh": "è¿™ä¸ªæ¸¸æˆçš„æœºåˆ¶æ˜¯ï¼šæš´èºä¹Œäº‘åœ¨ç©ºé—´ä¸­æ¼‚æµ®ï¼Œç©å®¶é€šè¿‡ç”¨å¿ƒå½¢æ‰‹åŠ¿æŠ•å°„å…‰æŸæ¥è¿›è¡Œæ¸¸æˆã€‚ç©å®¶ä½¿ç”¨å…‰æŸå°„å‡»ä¹Œäº‘å¹¶ä½¿å…¶æŒ¯ä½œèµ·æ¥ï¼ŒåŒæ—¶è®°åˆ†å™¨ä¼šè®°å½•æ¯ä¸ªç©å®¶åœ¨æŒ¯å¥‹ä¹Œäº‘æ—¶çš„è¡¨ç°ã€‚",
      "tips": "Grumpy clouds åœ¨æ­¤å¤„è¢«è¯‘ä¸ºæš´èºä¹Œäº‘ã€‚"
    },
    "Design the game interface in SwiftUI": {
      "zh": "ä½¿ç”¨ SwiftUI è®¾è®¡æ¸¸æˆç•Œé¢",
      "tips": ""
    },
    "Most apps in visionOS launch as a window that opens different scene types depending on the needs of the app.": {
      "zh": "visionOS ä¸­çš„å¤§å¤šæ•°åº”ç”¨éƒ½ä»¥çª—å£çš„å½¢å¼å¯åŠ¨ï¼Œè¯¥çª—å£ä¼šæ ¹æ®åº”ç”¨çš„éœ€è¦æ‰“å¼€ä¸åŒçš„åœºæ™¯ç±»å‹ã€‚",
      "tips": ""
    },
    "Here you see how Happy Beam presents a fun interface to people by using several SwiftUI views that display a welcome screen, a coaching screen that gives instructions, a scoreboard, and a game-ending screen.": {
      "zh": "åœ¨è¿™é‡Œï¼Œæ‚¨å¯ä»¥çœ‹åˆ° Happy Beam å¦‚ä½•ä½¿ç”¨å¤šä¸ª SwiftUI è§†å›¾å‘ç©å®¶å‘ˆç°ä¸€ä¸ªæœ‰è¶£çš„ç”¨æˆ·ç•Œé¢ï¼Œå…¶ä¸­åŒ…æ‹¬äº†æ¬¢è¿ç•Œé¢ã€æä¾›è§„åˆ™è¯´æ˜çš„æ•™å­¦ç•Œé¢ã€è®°åˆ†æ¿å’Œæ¸¸æˆç»“æŸç•Œé¢ã€‚",
      "tips": ""
    },
    "The following shows you the primary view in the app that displays each phase of gameplay:": {
      "zh": "ä¸‹æ–¹ä»£ç ä¸­åŒ…å«äº†åº”ç”¨ä¸­æ¯ä¸ªæ¸¸æˆé˜¶æ®µæ˜¾ç¤ºçš„ä¸»è¦è§†å›¾ï¼š",
      "tips": ""
    },
    "When 3D content starts to appear, the game opens an immersive space to present content outside of the main window and in a personâ€™s surroundings.": {
      "zh": "å½“ 3D å†…å®¹å¼€å§‹å‡ºç°æ—¶ï¼Œæ¸¸æˆä¼šæ‰“å¼€ä¸€ä¸ªæ²‰æµ¸å¼ç©ºé—´ï¼Œä»¥åœ¨ä¸»çª—å£ä¹‹å¤–ï¼Œç©å®¶å‘¨å›´ç¯å¢ƒä¹‹ä¸­å‘ˆç°å†…å®¹ã€‚",
      "tips": ""
    },
    "The HappyBeam container view declares a dependency on openImmersiveSpace:": {
      "zh": "HappyBeam å®¹å™¨è§†å›¾å®šä¹‰äº†ä¸€ä¸ªåä¸º openImmersiveSpace çš„ä¾èµ–ï¼š",
      "tips": "ä¾èµ–å˜é‡ openImmersiveSpace çš„ç±»å‹æ˜¯ OpenImmersiveSpaceActionï¼Œæ˜¯ç”¨äºæ‰“å¼€æ²‰æµ¸å¼ç©ºé—´çš„æ“ä½œï¼Œè¯¦è§ https://developer.apple.com/documentation/swiftui/openimmersivespaceaction"
    },
    "It later uses that dependency to open the space from the appâ€™s declaration when itâ€™s time to start showing 3D content:": {
      "zh": "ç¨åï¼Œå½“éœ€è¦å¼€å§‹æ˜¾ç¤º 3D å†…å®¹æ—¶ï¼Œè¯¥è§†å›¾ä¼šä½¿ç”¨æ­¤ä¾èµ–ä»åº”ç”¨çš„å£°æ˜ä¸­æ‰“å¼€æ²‰æµ¸å¼ç©ºé—´ï¼š",
      "tips": ""
    },
    "Detect a heart gesture with ARKit": {
      "zh": "ä½¿ç”¨ ARKit æ£€æµ‹å¿ƒå½¢æ‰‹åŠ¿",
      "tips": ""
    },
    "The Happy Beam app recognizes the central heart-shaped hands gesture using ARKitâ€™s support for 3D hand tracking in visionOS. Using hand tracking requires a running session and authorization from the wearer. It uses the NSHandsTrackingUsageDescription user info key to explain to players why the app requests permission for hand tracking.": {
      "zh": "Happy Beam åº”ç”¨ç¨‹åºä½¿ç”¨ ARKit æ”¯æŒçš„ visionOS ä¸­ 3D æ‰‹éƒ¨è¿½è¸ªåŠŸèƒ½æ¥è¯†åˆ«ä¸­å¤®å¿ƒå½¢æ‰‹åŠ¿ã€‚ä½¿ç”¨æ‰‹éƒ¨è¿½è¸ªéœ€è¦ä¸€ä¸ªè¿è¡Œä¸­çš„ä¼šè¯ï¼ˆARKitSessionï¼‰ä»¥åŠè®¾å¤‡ä½©æˆ´è€…çš„æˆæƒã€‚å®ƒä½¿ç”¨ NSHandsTrackingUsageDescription ç”¨æˆ·ä¿¡æ¯é”®ä¸­çš„å­—ç¬¦ä¸²å‘ç©å®¶è§£é‡Šä¸ºä»€ä¹ˆåº”ç”¨ç¨‹åºè¯·æ±‚æ‰‹éƒ¨è¿½è¸ªæƒé™ã€‚",
      "tips": "æƒ³äº†è§£æ›´å¤šå’Œ ARKitSession ç›¸å…³çš„å†…å®¹ï¼Œè¯·å‚è€ƒ https://developer.apple.com/documentation/arkit/arkitsession"
    },
    "Hand-tracking data isnâ€™t available when your app is only displaying a window or volume. Instead, itâ€™s available when you present an immersive space, as in the previous example.": {
      "zh": "å½“æ‚¨çš„åº”ç”¨ä»…æ˜¾ç¤ºçª—å£æˆ–ä½“é‡æ—¶ï¼Œæ‰‹éƒ¨è¿½è¸ªæ•°æ®ä¸å¯ç”¨ã€‚ç›¸åï¼Œå½“æ‚¨æ¼”ç¤ºæ²‰æµ¸å¼ç©ºé—´æ—¶ï¼Œå®ƒå¯ç”¨ï¼Œå¦‚ä¸Šä¾‹æ‰€ç¤ºã€‚",
      "tips": ""
    },
    "You can detect gestures using ARKit data with a level of accuracy that depends on your use case and intended experience. For example, Happy Beam could require strict positioning of finger joints to closely resemble a heart shape. Instead, however, it prompts people to make a heart shape and uses a heuristic to indicate when the gesture is close enough.": {
      "zh": "æ‚¨å¯ä»¥ä½¿ç”¨ ARKit æ•°æ®æ£€æµ‹æ‰‹åŠ¿ï¼Œå…¶å‡†ç¡®ç¨‹åº¦å–å†³äºæ‚¨çš„ç”¨ä¾‹å’Œé¢„æœŸä½“éªŒã€‚ä¾‹å¦‚ï¼ŒHappy Beam å¯ä»¥æ›´åŠ ä¸¥æ ¼åœ°è¦æ±‚æ‰‹æŒ‡å…³èŠ‚ä½ç½®ï¼Œè§„å®šæ‰‹åŠ¿å¿…é¡»éå¸¸æ¥è¿‘å¿ƒå½¢ã€‚ç„¶è€Œï¼Œå®é™…ä¸Šåº”ç”¨ä¼šæç¤ºç”¨æˆ·æ‘†å‡ºå¿ƒå½¢æ‰‹åŠ¿ï¼Œå¹¶ä½¿ç”¨å¯å‘å¼çš„æ–¹æ³•æ¥æç¤ºæ‰‹åŠ¿å·²ç»è¶³å¤Ÿæ¥è¿‘å¿ƒå½¢ã€‚",
      "tips": ""
    },
    "The following checks whether a personâ€™s thumbs and index fingers are almost touching:": {
      "zh": "ä¸‹è¿°ä»£ç æ£€æŸ¥ç©å®¶çš„æ‹‡æŒ‡å’Œé£ŸæŒ‡æ˜¯å¦è¿‘ä¹æ¥è§¦ï¼š",
      "tips": ""
    },
    "Support several kinds of input": {
      "zh": "æ”¯æŒå¤šç§è¾“å…¥ç±»å‹",
      "tips": ""
    },
    "To support accessibility features and general user preferences, include multiple kinds of input in an app that uses hand tracking as one form of input.": {
      "zh": "ä¸ºäº†æ”¯æŒè¾…åŠ©åŠŸèƒ½å’Œç”¨æˆ·é¦–é€‰é¡¹ï¼Œè¯·åœ¨ä½¿ç”¨æ‰‹éƒ¨è¿½è¸ªä½œä¸ºè¾“å…¥å½¢å¼çš„åº”ç”¨ä¸­åŒ…å«å¹¶æ”¯æŒå¤šç§è¾“å…¥ç±»å‹ã€‚",
      "tips": ""
    },
    "Happy Beam supports several kinds of input:": {
      "zh": "Happy Beam æ”¯æŒä»¥ä¸‹å‡ ç§è¾“å…¥æ–¹å¼ï¼š",
      "tips": ""
    },
    "Display 3D content with RealityKit": {
      "zh": "ä½¿ç”¨ RealityKit å±•ç¤º 3D å†…å®¹",
      "tips": ""
    },
    "The 3D content in the app comes in the form of assets that you can export from Reality Composer Pro. You place each asset in the RealityView that represents your immersive space.": {
      "zh": "åº”ç”¨ç¨‹åºä¸­çš„ 3D å†…å®¹ä»¥èµ„æºçš„å½¢å¼æä¾›ï¼Œæ‚¨å¯ä»¥ä» Reality Composer Pro ä¸­å¯¼å‡ºè¿™äº›èµ„æºã€‚åº”ç”¨å°†æ¯ä¸ªèµ„æºæ”¾ç½®åœ¨ä¸€ä¸ªä»£è¡¨æ²‰æµ¸å¼ç©ºé—´çš„ RealityView ä¸­ã€‚",
      "tips": ""
    },
    "The following shows how Happy Beam generates clouds when the game starts, as well as materials for the floor-based beam projector. Because the game uses collision detection to keep score â€” the beam cheers up grumpy clouds when they collide â€” you make collision shapes for each model that might be involved.": {
      "zh": "ä¸‹è¿°ä»£ç å±•ç¤ºäº† Happy Beam åœ¨æ¸¸æˆå¼€å§‹æ—¶å¦‚ä½•ç”Ÿæˆäº‘æœµï¼Œä»¥åŠåœ°é¢ä¸Šçš„æ¿€å…‰å‘å°„å™¨çš„æè´¨ã€‚å› ä¸ºæ¸¸æˆä½¿ç”¨ç¢°æ’æ£€æµ‹æ¥è®¡ç®—å¾—åˆ†â€”â€”å½“ç¢°æ’æ—¶ï¼Œå…‰æŸä¼šè®©æš´èºä¹Œäº‘å¼€å¿ƒèµ·æ¥â€”â€”æ‰€ä»¥ä½ è¦ä¸ºæ¯ä¸ªå¯èƒ½å‚ä¸äº’åŠ¨çš„æ¨¡å‹åˆ¶ä½œç¢°æ’ä½“ç§¯ã€‚",
      "tips": ""
    },
    "Add SharePlay support for multiplayer gaming experiences": {
      "zh": "æ·»åŠ åŒæ’­å…±äº«ä»¥æ”¯æŒå¤šäººæ¸¸æˆä½“éªŒ",
      "tips": "SharePlay çš„å®˜æ–¹ä¸­è¯‘ä¸ºåŒæ’­å…±äº«ï¼Œè§ https://developer.apple.com/cn/shareplay/"
    },
    "You use the Group Activities framework in visionOS to support SharePlay during a FaceTime call. Happy Beam uses Group Activities to sync the score, active players list, and the position of each playerâ€™s projected beam.": {
      "zh": "æ‚¨å¯ä»¥åœ¨ visionOS ä¸­é€šè¿‡ Group Activities æ¡†æ¶åœ¨ FaceTime é€šè¯æœŸé—´æ”¯æŒåŒæ’­å…±äº«ã€‚Happy Beam ä½¿ç”¨ Group Activities æ¥åŒæ­¥åˆ†æ•°ã€æ´»è·ƒç©å®¶åˆ—è¡¨ä»¥åŠæ¯ä¸ªç©å®¶å°„å‡ºå…‰æŸçš„ä½ç½®ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨æ„",
      "tips": ""
    },
    "Developers using the Apple Vision Pro developer kit can test spatial SharePlay experiences on-device by installing the Persona Preview Profile.": {
      "zh": "ä½¿ç”¨ Apple Vision Pro developer kit çš„å¼€å‘è€…å¯ä»¥é€šè¿‡å®‰è£… Persona Preview Profile åœ¨è®¾å¤‡ä¸Šæµ‹è¯•ç©ºé—´ä¸­çš„åŒæ’­å…±äº«ä½“éªŒã€‚",
      "tips": ""
    },
    "Use a reliable channel to send information thatâ€™s important to be correct, even if it can be slightly delayed as a result. The following shows how Happy Beam updates the game modelâ€™s score state in response to a score message:": {
      "zh": "ä½¿ç”¨å¯é çš„é¢‘é“å‘é€è¦æ±‚æ­£ç¡®æ€§çš„ä¿¡æ¯ï¼Œå³ä½¿å› æ­¤å¯èƒ½ä¼šç¨æœ‰å»¶è¿Ÿã€‚ä¸‹é¢å±•ç¤ºäº† Happy Beam å¦‚ä½•æ ¹æ®åˆ†æ•°ä¿¡æ¯æ›´æ–°æ¸¸æˆæ¨¡å‹çš„åˆ†æ•°çŠ¶æ€ï¼š",
      "tips": ""
    },
    "Use an unreliable messenger for sending data with low-latency requirements. Because the delivery mode is unreliable, some messages might not make it. Happy Beam uses the unreliable mode to send live updates to the position of the beam when each participant in the call chooses the Spatial option in FaceTime.": {
      "zh": "ä½¿ç”¨ä¸å¯é çš„ä¿¡ä½¿å‘é€å…·æœ‰ä½å»¶è¿Ÿè¦æ±‚çš„æ•°æ®ã€‚ç”±äºä¼ é€’æ¨¡å¼ä¸å¯é ï¼Œå› æ­¤æŸäº›æ¶ˆæ¯å¯èƒ½æ— æ³•é€è¾¾ã€‚å½“ FaceTime å‚ä¸è€…åœ¨é€šè¯ä¸­é€‰æ‹© Spatial é€‰é¡¹æ—¶ï¼ŒHappy Beam ä¼šä½¿ç”¨ä¸å¯é æ¨¡å¼å‘é€å…‰æŸä½ç½®çš„å®æ—¶æ›´æ–°ã€‚",
      "tips": ""
    },
    "The following shows how Happy Beam serializes beam data for each message:": {
      "zh": "ä¸‹è¿°ä»£ç å±•ç¤ºäº† Happy Beam å¦‚ä½•åœ¨æ¯æ¡æ¶ˆæ¯ä¸­åºåˆ—åŒ–å…‰æŸæ•°æ®ï¼š",
      "tips": ""
    }
  },
  "visionos/improving-accessibility-support-in-your-app": {
    "Improving accessibility support in your visionOS app": {
      "zh": "åœ¨ä½ çš„ visionOS åº”ç”¨ä¸­å¢å¼ºå¯¹è¾…åŠ©åŠŸèƒ½çš„æ”¯æŒ",
      "tips": ""
    },
    "Update your code to ensure everyone can access your appâ€™s content in visionOS.": {
      "zh": "æ›´æ–°ä½ çš„ä»£ç ä»¥ç¡®ä¿æ‰€æœ‰ç”¨æˆ·éƒ½å¯ä»¥åœ¨ visionOS ä¸­è®¿é—®ä½ çš„åº”ç”¨å†…å®¹ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è§ˆ",
      "tips": ""
    },
    "visionOS is an immersive platform that supports people of all abilities. Even though experiences incorporate stunning visual content and hand- and eye-tracking technologies, people can engage with content in other ways. In fact, the platform supports people in many different situations, including those who are blind, have low vision, have limited mobility, or have limb differences. With the help of assistive technologies, people can interact with all of your appâ€™s content.": {
      "zh": "visionOS æ˜¯ä¸€ä¸ªå¯ä»¥æ”¯æŒä¸åŒäººç¾¤çš„æ²‰æµ¸å¼å¹³å°ã€‚è™½ç„¶å¹³å°çš„ä½“éªŒèåˆäº†å¼•äººå…¥èƒœçš„è§†è§‰å†…å®¹å’Œæ‰‹çœ¼è¿½è¸ªæŠ€æœ¯ï¼Œä½†ç”¨æˆ·ä»å¯ä»¥é€šè¿‡å…¶ä»–æ–¹å¼ä¸å†…å®¹äº’åŠ¨ã€‚äº‹å®ä¸Šï¼Œå¹³å°ä¸ºè®¸å¤šä¸åŒäººç¾¤éƒ½æä¾›äº†æ”¯æŒï¼ŒåŒ…æ‹¬è§†åŠ›éšœç¢è€…ã€è¡ŒåŠ¨ä¸ä¾¿è€…æˆ–æ˜¯æœ‰è‚¢ä½“å·®å¼‚çš„ç”¨æˆ·ã€‚åœ¨è¾…åŠ©æŠ€æœ¯çš„å¸®åŠ©ä¸‹ï¼Œç”¨æˆ·å°±èƒ½å…¨é¢åœ°ä¸åº”ç”¨ä¸­çš„å†…å®¹è¿›è¡Œäº’åŠ¨ã€‚",
      "tips": ""
    },
    "During development, enable VoiceOver and other assistive features and test your appâ€™s accessibility support. Make sure people can navigate your appâ€™s interface intuitively, and that all of the necessary elements are present. Improve the descriptive information for those elements to communicate their intended purpose. And make sure your app adapts to changing conditions, such as changes to the Dynamic Type setting while your app is running.": {
      "zh": "åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œå»ºè®®å¯ç”¨ VoiceOver ä»¥åŠå…¶ä»–è¾…åŠ©ç‰¹æ€§ï¼Œæ¥æµ‹è¯•ä½ çš„åº”ç”¨å¯¹è¾…åŠ©åŠŸèƒ½çš„æ”¯æŒæƒ…å†µã€‚è¦ç¡®ä¿ç”¨æˆ·èƒ½å¤Ÿç›´è§‚åœ°æ“ä½œåº”ç”¨ç•Œé¢ï¼Œå¹¶ç¡®è®¤æ‰€æœ‰å¿…è¦çš„å…ƒç´ éƒ½å·²å±•ç¤ºåˆ°ä½ã€‚ä¸ºè¿™äº›å…ƒç´ å¢åŠ æè¿°ä¿¡æ¯ï¼Œä¼ è¾¾å…¶é¢„æœŸçš„ç”¨é€”ã€‚å¹¶ä¸”ç¡®ä¿ä½ çš„åº”ç”¨èƒ½å¤Ÿé€‚é…é‚£äº›ä¼šåŠ¨æ€æ”¹å˜çš„è®¾ç½®ï¼Œä¾‹å¦‚åœ¨åº”ç”¨è¿è¡Œæ—¶ Dynamic Type çš„è®¾ç½®å‘ç”Ÿå˜åŒ–ã€‚",
      "tips": ""
    },
    "For general information about supporting accessibility, see Accessibility. For design guidance, see Human Interface Guidelines > Accessibility.": {
      "zh": "å¦‚éœ€äº†è§£æœ‰å…³æ”¯æŒè¾…åŠ©åŠŸèƒ½çš„å†…å®¹ï¼Œè¯·å‚é˜…â€œè¾…åŠ©åŠŸèƒ½â€ã€‚å¯¹äºè®¾è®¡æŒ‡å¯¼ï¼Œå‚è§äººæœºç•Œé¢æŒ‡å— > è¾…åŠ©åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "Add accessibility traits to RealityKit entities": {
      "zh": "ç»™ RealityKit å®ä½“æ·»åŠ è¾…åŠ©åŠŸèƒ½ç‰¹æ€§",
      "tips": ""
    },
    "VoiceOver and other assistive technologies rely on the accessibility information that your appâ€™s views and content provide. SwiftUI and UIKit provide default information for the standard system views, but RealityKit doesnâ€™t provide default information for the entities in your scenes.": {
      "zh": "VoiceOver ä»¥åŠå…¶ä»–è¾…åŠ©æŠ€æœ¯ä¾èµ–äºä½ åº”ç”¨çš„è§†å›¾å’Œå†…å®¹æ‰€æä¾›çš„è¾…åŠ©åŠŸèƒ½ä¿¡æ¯ã€‚è™½ç„¶ SwiftUI å’Œ UIKit å·²ä¸ºæ ‡å‡†çš„ç³»ç»Ÿè§†å›¾æ§ä»¶æä¾›äº†é»˜è®¤ä¿¡æ¯ï¼Œä½†æ˜¯ RealityKit å¹¶ä¸ä¼šä¸ºä½ åœºæ™¯ä¸­çš„å®ä½“é¢„è®¾ä»»ä½•ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "To configure the accessibility information for a RealityKit entity, add an instance of AccessibilityComponent to the entity. Use this component to specify the same values you specify for the rest of your appâ€™s views. The following example shows how to create this component and add it to an entity:": {
      "zh": "è¦ä¸º RealityKit å®ä½“èµ‹äºˆè¾…åŠ©åŠŸèƒ½ä¿¡æ¯ï¼Œå°±éœ€è¦ç»™è¿™ä¸ªå®ä½“æ·»åŠ ä¸€ä¸ª AccessibilityComponent å®ä¾‹ã€‚ä½¿ç”¨è¿™ä¸ªç»„ä»¶ä½ å¯ä»¥åƒè®¾å®šä½ åº”ç”¨ä¸­å…¶ä»–è§†å›¾ä¸€æ ·åœ°å»è®¾ç½®ç›¸åŒçš„å‚æ•°å€¼ã€‚ä»¥ä¸‹çš„ç¤ºä¾‹ä»£ç å±•ç¤ºäº†å¦‚ä½•å»åˆ›å»ºè¿™ä¸ªç»„ä»¶å¹¶å°†å…¶æ·»åŠ åˆ°å®ä½“ä¸­ï¼š",
      "tips": ""
    },
    "People can use VoiceOver to initiate specific types of actions on your entities. Assign a value to the systemActions property of your component if your entity supports the incrementing or decrementing of its value, or supports activation with a gesture other than a standard tap. You donâ€™t need to set a system action if you let people interact with the entity using a standard single-tap gesture.": {
      "zh": "ç”¨æˆ·èƒ½å¤Ÿå€ŸåŠ© VoiceOver è§¦å‘ä½ çš„å®ä½“ä¸­çš„ç‰¹å®šæ“ä½œã€‚å¦‚æœä½ çš„å®ä½“æ”¯æŒæ”¹å˜å€¼çš„å¤§å°ï¼Œæˆ–è€…èƒ½é€šè¿‡éæ ‡å‡†ç‚¹å‡»æ‰‹åŠ¿è¢«æ¿€æ´»ï¼Œé‚£ä¹ˆå°±éœ€è¦ä¸ºä½ çš„ç»„ä»¶ä¸­çš„ systemActions å±æ€§è®¾ç½®ä¸€ä¸ªå€¼ã€‚ä¸è¿‡ï¼Œå¦‚æœç”¨æˆ·ä½¿ç”¨çš„æ˜¯å•å‡»æ‰‹åŠ¿æ¥å’Œå®ä½“è¿›è¡Œäº¤äº’ï¼Œé‚£å°±æ— éœ€è®¾å®šè¯¥å±æ€§ã€‚",
      "tips": ""
    },
    "The following example uses the content of a RealityView to determine when activation events occur on the viewâ€™s entities. After subscribing to the viewâ€™s activation events, the code sets up an asynchronous task to handle incoming events. When a new event occurs, the task executes the custom code to handle a collision.": {
      "zh": "ä»¥ä¸‹çš„ä»£ç ç¤ºä¾‹åˆ©ç”¨äº† RealityView çš„ content å±æ€§æ¥åˆ¤æ–­åœ¨è§†å›¾ä¸Šçš„å®ä½“ä½•æ—¶å»è§¦å‘æ¿€æ´»è¾…åŠ©åŠŸèƒ½çš„äº‹ä»¶ã€‚åœ¨è®¢é˜…äº†è§†å›¾çš„è¿™é¡¹äº‹ä»¶åï¼Œä»£ç ä¼šç»‘å®šä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡å»å¤„ç†æ¥æ”¶åˆ°çš„äº‹ä»¶ã€‚å½“æ–°çš„äº‹ä»¶äº§ç”Ÿæ—¶ï¼Œè¿™ä¸ªä»»åŠ¡å°±ä¼šè°ƒç”¨ handleCollision æ–¹æ³•ä»¥å¤„ç†è¯¥å®ä½“çš„ç¢°æ’äº‹ä»¶ã€‚",
      "tips": ""
    },
    "Add support for Direct Gesture mode": {
      "zh": "ä¸ºç›´æ¥æ‰‹åŠ¿æ“ä½œæ¨¡å¼æä¾›æ”¯æŒ",
      "tips": ""
    },
    "When VoiceOver is active in visionOS, people use hand gestures to navigate your appâ€™s interface and inspect elements. To prevent your appâ€™s code from interfering with VoiceOver interactions, the system doesnâ€™t deliver hand input to your app during this time. However, a person can perform a special VoiceOver gesture to enable Direct Gesture mode, which leaves VoiceOver enabled but restores hand input to your app.": {
      "zh": "å½“åœ¨ visionOS ä¸­å¯ç”¨äº† VoiceOver æ—¶ï¼Œç”¨æˆ·ä¼šå€ŸåŠ©æ‰‹åŠ¿æ¥æµè§ˆä½ çš„åº”ç”¨ç•Œé¢å’ŒæŸ¥çœ‹ç›¸åº”å…ƒç´ å†…å®¹ã€‚ä¸ºäº†é¿å…ä½ çš„ç¨‹åºå¹²æ‰°åˆ° VoiceOver çš„äº¤äº’ï¼Œåœ¨æ­¤æœŸé—´ï¼Œç³»ç»Ÿä¸ä¼šç»™ä½ çš„ç¨‹åºä¼ è¾¾æ‰‹åŠ¿è¾“å…¥çš„ä¿¡å·ã€‚ä¸è¿‡ï¼Œç”¨æˆ·ä»æ—§å¯ä»¥é€šè¿‡ä¸€ä¸ªç‰¹åˆ«çš„ VoiceOver æ‰‹åŠ¿æ¥å¯ç”¨ç›´æ¥æ‰‹åŠ¿æ“ä½œæ¨¡å¼ï¼ˆDirect Gesture modeï¼‰ï¼Œè¿™ç§æ¨¡å¼å…è®¸åœ¨ä¿æŒ VoiceOver æ­£å¸¸å·¥ä½œçš„åŒæ—¶æ¢å¤æ‰‹åŠ¿è¾“å…¥å¯¹ç¨‹åºçš„å½±å“ã€‚",
      "tips": ""
    },
    "Add VoiceOver announcements to your code to communicate the results of meaningful events. VoiceOver speaks these announcements at all times, but they are particularly useful when Direct Gesture mode is on. The following example posts an announcement when a custom gesture causes an interaction with a game piece:": {
      "zh": "åœ¨ä½ çš„ä»£ç ä¸­æ·»åŠ æ”¯æŒ VoiceOver çš„æç¤ºï¼Œæ¥ä¼ è¾¾é‡è¦äº‹ä»¶çš„ç»“æœã€‚VoiceOver ä¼šéšæ—¶æ’­æ”¾è¿™äº›æç¤ºï¼Œå°¤å…¶æ˜¯åœ¨ç›´æ¥æ‰‹åŠ¿æ“ä½œæ¨¡å¼ä¸‹ï¼Œè¿™äº›æç¤ºä¼šæ›´å…·æ„ä¹‰ã€‚ä»¥ä¸‹çš„ç¤ºä¾‹ä»£ç ä¼šåœ¨è‡ªå®šä¹‰æ‰‹åŠ¿ä¸æ¸¸æˆæ£‹å­è§¦å‘äº¤äº’æ—¶äº§ç”Ÿæç¤ºå†…å®¹ï¼š",
      "tips": ""
    },
    "Provide alternatives to input that involves physical movement": {
      "zh": "ç»™æ¶‰åŠç‰©ç†åŠ¨ä½œçš„è¾“å…¥æ–¹å¼æä¾›é¢å¤–é€‰æ‹©",
      "tips": ""
    },
    "Reduced mobility can affect a personâ€™s ability to interact with your appâ€™s content. When designing your appâ€™s input model, avoid experiences that require specific body movements or positions. For example, if your app supports custom hand gestures, add menu commands for each gesture so someone can enter them using a keyboard or assistive device.": {
      "zh": "å—é™çš„ç§»åŠ¨èƒ½åŠ›ä¼šå½±å“ä¸€ä¸ªäººä¸ä½ çš„åº”ç”¨å†…å®¹äº¤äº’çš„èƒ½åŠ›ã€‚åœ¨è®¾è®¡åº”ç”¨çš„è¾“å…¥æ–¹å¼æ—¶ï¼Œå°½é‡é¿å…ä¾èµ–ç‰¹å®šçš„èº«ä½“åŠ¨ä½œæˆ–æ˜¯å§¿åŠ¿ã€‚ä¸¾ä¸ªä¾‹å­æ¥è¯´ï¼Œå¦‚æœä½ çš„åº”ç”¨æ”¯æŒè‡ªå®šä¹‰æ‰‹éƒ¨åŠ¨ä½œï¼Œé‚£ä¹ˆåº”è¯¥ä¸ºæ¯ä¸€ä¸ªæ‰‹åŠ¿æä¾›ç›¸åº”çš„èœå•å‘½ä»¤ï¼Œä»è€Œè®©ç”¨æˆ·èƒ½é€šè¿‡é”®ç›˜æˆ–è€…è¾…åŠ©è®¾å¤‡è¿›è¡Œæ“ä½œã€‚",
      "tips": ""
    },
    "Some assistive technologies let people interact with your app using only their eyes. Using these technologies they can select, scroll, long press, or drag items in your interface. Even if you support other types of interactions, give people a way to access all of your appâ€™s behavior using only these interactions.": {
      "zh": "æœ‰äº›è¾…åŠ©æŠ€æœ¯è®©ç”¨æˆ·åªéœ€ç”¨ä»–ä»¬çš„åŒçœ¼å°±èƒ½å’Œåº”ç”¨è¿›è¡Œäº¤äº’ã€‚å€ŸåŠ©è¿™äº›æŠ€æœ¯ï¼Œä»–ä»¬èƒ½å¤Ÿåœ¨ä½ æä¾›çš„ç•Œé¢ä¸­é€‰å–ã€æ»šåŠ¨ã€é•¿æŒ‰æˆ–æ‹–æ‹½å†…å®¹ã€‚å› æ­¤ï¼Œå³ä½¿ä½ çš„åº”ç”¨æ”¯æŒå…¶å®ƒç±»å‹çš„äº¤äº’ï¼Œä¹Ÿè¯·åŠ¡å¿…ç¡®ä¿ç”¨æˆ·èƒ½ä»…é€šè¿‡è¿™äº›çœ¼åŠ¨æ“ä½œå°±èƒ½å…¨æ–¹ä½ä½¿ç”¨ä½ çš„åº”ç”¨ã€‚",
      "tips": ""
    },
    "Avoid head-anchored content": {
      "zh": "é¿å…å›ºå®šäºå¤´éƒ¨çš„å†…å®¹",
      "tips": ""
    },
    "Some assistive technologies allow people to navigate or view your appâ€™s interface using head movements. As the personâ€™s head moves, the assistive technology focuses on the item directly in front of them. Content that follows the movements of the personâ€™s head interferes with the behavior of these assistive technologies.": {
      "zh": "ä¸€äº›è¾…åŠ©æŠ€æœ¯èƒ½è®©ç”¨æˆ·é€šè¿‡å¤´éƒ¨çš„ç§»åŠ¨æ¥æ“ä½œæˆ–æµè§ˆä½ çš„åº”ç”¨ç•Œé¢ã€‚éšç€ç”¨æˆ·å¤´éƒ¨çš„ç§»åŠ¨ï¼Œè¿™äº›æŠ€æœ¯ä¼šå°†å†…å®¹ç›´æ¥åœ°èšç„¦åœ¨ç”¨æˆ·çš„è§†çº¿å‰ã€‚å¦‚æœä¸€äº›æ˜¾ç¤ºå†…å®¹éšç€ç”¨æˆ·å¤´éƒ¨çš„ç§»åŠ¨è€Œå‘ç”Ÿå˜åŒ–ï¼Œé‚£ä¹ˆè¿™å°†ä¼šå¹²æ‰°è¿™äº›è®¾å¤‡çš„æ­£å¸¸ä½¿ç”¨ã€‚",
      "tips": ""
    },
    "When designing your interface, place content in windows or anchor it to locations other than the virtual camera. If you do need head-anchored content, provide an alternative solution when relevant assistive technologies are in use. For example, you might move head-anchored content to an anchor point that doesnâ€™t follow the personâ€™s head movements.": {
      "zh": "åœ¨æ„é€ ä½ çš„ç•Œé¢æ—¶ï¼Œå»ºè®®å°†å†…å®¹è®¾å®šåœ¨çª—å£ä¸­ï¼Œæˆ–æ˜¯é”šå®šåœ¨ä¸è™šæ‹Ÿæ‘„åƒæœºæ— å…³çš„ä½ç½®ã€‚å¦‚æœè€ƒè™‘åˆ°ä½ ç¡®å®è¦ä½¿ç”¨å›ºå®šäºå¤´éƒ¨çš„å†…å®¹ï¼Œé‚£ä¹ˆåœ¨ç”¨æˆ·ä½¿ç”¨ç›¸å…³è¾…åŠ©æŠ€æœ¯æ—¶ï¼Œéœ€è¦æä¾›å¯æ›¿ä»£çš„è§£å†³æ–¹æ¡ˆã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥å°†åŸæœ¬å›ºå®šäºå¤´éƒ¨çš„å†…å®¹ç§»è‡³é”šå®šä½ç½®ï¼Œä½¿ä¹‹å’Œç”¨æˆ·çš„å¤´éƒ¨ç§»åŠ¨åŠ¨ä½œæ— å…³ã€‚",
      "tips": ""
    },
    "To determine when to change the anchoring approach for your content, check the accessibilityPrefersHeadAnchorAlternative environment variable in SwiftUI, or call the AXPrefersHeadAnchorAlternative() function. This environment variable is true when an assistive technology is in use that conflicts with head-anchored content. Adapt your content to use alternate anchoring mechanisms at that time.": {
      "zh": "ä½ å¯ä»¥åœ¨ SwiftUI ä¸­æ£€æŸ¥ accessibilityPrefersHeadAnchorAlternative è¿™ä¸ªç¯å¢ƒå˜é‡ï¼Œæˆ–æ˜¯è°ƒç”¨ AXPrefersHeadAnchorAlternative æ–¹æ³•æ¥åˆ¤æ–­ä½•æ—¶å»æ”¹å˜ä½ çš„åº”ç”¨å†…å®¹çš„é”šå®šæ–¹å¼ã€‚å½“æ­£åœ¨ä½¿ç”¨çš„è¾…åŠ©è®¾å¤‡ä¸å¤´éƒ¨é”šå®šå†…å®¹äº§ç”Ÿå†²çªæ—¶ï¼Œè¿™ä¸ªå˜é‡ä¼šè¿”å› trueã€‚æ¯å½“è¿™ä¸ªæ—¶å€™ï¼Œå°±åº”å½“å»è°ƒæ•´ä½ åº”ç”¨çš„å†…å®¹æ¥å…¼å®¹æ–°çš„é”šå®šæ–¹å¼ã€‚",
      "tips": ""
    },
    "Limit motion effects in your content": {
      "zh": "å‡å¼±åº”ç”¨å†…å®¹çš„åŠ¨æ€æ•ˆæœ",
      "tips": ""
    },
    "Motion effects on any immersive device can be jarring, even for people who arenâ€™t sensitive to motion. Limit the use of motion effects that incorporate rapid movement, bouncing or wave-like movement, zooming animations, multi-axis movement, spinning, or rotations. When the person wearing the device is sensitive to motion effects, eliminate the use of these effects altogether.": {
      "zh": "å¯¹äºä»»ä½•æ²‰æµ¸å¼è®¾å¤‡æ¥è¯´ï¼Œè¿‡äºå¼ºçƒˆçš„åŠ¨æ€æ•ˆæœå¯èƒ½ä¼šè®©äººæ„Ÿåˆ°ä¸é€‚ï¼Œå³ä½¿å¯¹äºé‚£äº›å¯¹åŠ¨æ•ˆå¹¶ä¸æ•æ„Ÿçš„äººä¹Ÿæ˜¯å¦‚æ­¤ã€‚å°½é‡å‡å°‘å¯¹å¿«é€Ÿç§»åŠ¨ã€å¼¹è·³è´§æ³¢çŠ¶è¿åŠ¨ã€ç¼©æ”¾åŠ¨ç”»ã€å¤šè½´ç§»åŠ¨ã€æ—‹è½¬åœ¨å†…çš„åŠ¨æ•ˆè¿ç”¨ã€‚ç‰¹åˆ«æ˜¯å½“ä½¿ç”¨è®¾å¤‡çš„äººå¯¹åŠ¨æ•ˆæ•æ„Ÿæ—¶ï¼Œéœ€è¦å½»åº•é¿å…ä½¿ç”¨è¿™äº›å…ƒç´ ã€‚",
      "tips": ""
    },
    "The Reduce Motion system setting lets you know when to provide alternatives for all of your appâ€™s motion effects. Access this setting using the accessibilityReduceMotion environment variable in SwiftUI or with the isReduceMotionEnabled property in UIKit. When the setting is true, provide suitable alternatives for motion effects or eliminate them altogether. For example, show a static snapshot of the ocean instead of a video.": {
      "zh": "ç³»ç»Ÿè®¾ç½®ä¸­çš„å‡å¼±åŠ¨æ€æ•ˆæœå¯ä»¥æç¤ºä½ ä»€ä¹ˆæƒ…å†µä¸‹åº”å½“ä¸ºä½ åº”ç”¨ä¸­çš„åŠ¨æ€æ•ˆæœæä¾›æ›¿ä»£æ–¹æ¡ˆã€‚ä½ å¯ä»¥åœ¨ SwiftUI ä¸­é€šè¿‡ accessibilityReduceMotion ç¯å¢ƒå˜é‡ï¼Œæˆ–æ˜¯ UIKit ä¸­é€šè¿‡ isReduceMotionEnabled å±æ€§æ¥è®¿é—®è¿™ä¸ªè®¾ç½®ã€‚å½“è¢«å¼€å¯æ—¶ï¼Œå°è¯•ä¸ºè¿™äº›åŠ¨æ•ˆå‘ˆç°åˆé€‚çš„æ›¿ä»£æ–¹æ¡ˆï¼Œæˆ–æ˜¯å®Œå…¨ç§»é™¤å®ƒä»¬ã€‚æ¯”å¦‚ï¼Œä½ å¯ä»¥é€‰æ‹©å±•ç¤ºä¸€å¼ é™æ€æµ·æ´‹çš„å›¾ç‰‡æ¥ä»£æ›¿æ’­æ”¾è§†é¢‘ã€‚",
      "tips": ""
    },
    "For more information, see Human Interface Guidelines > Motion.": {
      "zh": "æ¬²äº†è§£æ›´å¤šå†…å®¹ï¼Œè¯¦è§äººæœºç•Œé¢æŒ‡å— > åŠ¨æ€æ•ˆæœ",
      "tips": ""
    },
    "Include captions for audio content": {
      "zh": "ä¸ºéŸ³é¢‘å†…å®¹æ·»åŠ å­—å¹•",
      "tips": ""
    },
    "For people who are deaf or hard of hearing, provide high-quality captions for your appâ€™s content. Captions are a necessity to some, but are practical for everyone in certain situations. For example, captions are useful to someone watching a video in a noisy environment. Remember to include captions not just for text and dialogue, but also for music and sound effects in your content. For Spatial Audio content, include information in your captions that indicates the direction of various sounds.": {
      "zh": "å¯¹äºæ‚£æœ‰è€³è‹æˆ–å¬éšœçš„äººæ¥è¯´ï¼Œæä¾›é«˜è´¨é‡çš„å­—å¹•æ˜¾å¾—æ ¼å¤–é‡è¦ã€‚è™½ç„¶å­—å¹•å¯¹äºæŸäº›äººæ˜¯å¿…é¡»çš„ï¼Œä½†åœ¨ç‰¹å®šæƒ…å†µä¸‹ä¹Ÿé€‚ç”¨ä»»ä½•äººã€‚æ¯”å¦‚ï¼Œåœ¨å–§é—¹çš„ç¯å¢ƒä¸­è§‚çœ‹è§†é¢‘æ—¶ï¼Œå­—å¹•å°±å¤§æœ‰ç”¨å¤„ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸ä»…å¯¹è¯å’Œæ–‡å­—éœ€è¦å­—å¹•ï¼ŒéŸ³ä¹å’ŒéŸ³æ•ˆä¹ŸåŒæ ·éœ€è¦æ·»åŠ å­—å¹•ã€‚å¯¹äºç©ºé—´éŸ³é¢‘å†…å®¹ï¼Œè¿˜åº”åœ¨å­—å¹•ä¸­æ ‡æ³¨å‡ºå£°éŸ³çš„æ¥æºæ–¹å‘ã€‚",
      "tips": ""
    },
    "AVKit and AVFoundation provide built-in support for displaying captioned content. These frameworks configure the font, size, color, and style of the captions automatically according to the personâ€™s accessibility settings. For example, the frameworks adopt the current Dynamic Type setting when displaying text.": {
      "zh": "AVKit å’Œ AVFoundation æä¾›å¯¹äºæ˜¾ç¤ºå­—å¹•å†…å®¹çš„å†…ç½®æ”¯æŒã€‚è¿™äº›æ¡†æ¶ä¼šæ ¹æ®ç”¨æˆ·çš„è¾…åŠ©åŠŸèƒ½è®¾ç½®ï¼Œè‡ªåŠ¨è°ƒæ•´å­—å¹•çš„å­—ä½“ã€å¤§å°ã€é¢œè‰²å’Œæ ·å¼ã€‚ä¾‹å¦‚ï¼Œå®ƒä»¬åœ¨æ˜¾ç¤ºæ–‡æœ¬æ—¶ä¼šåº”ç”¨å½“å‰çš„ Dynamic Type è®¾å®šã€‚",
      "tips": ""
    },
    "If you have a custom video engine, check the isClosedCaptioningEnabled accessibility setting to determine when to display captions. To get the correct appearance information for your captioned content, adopt Media Accessibility in your project. This framework provides you with the optimal font, color, and opacity information to apply to captioned text and images.": {
      "zh": "å¦‚æœä½ ä½¿ç”¨çš„æ˜¯è‡ªå®šä¹‰çš„è§†é¢‘å¼•æ“ï¼Œä½ å¯ä»¥é€šè¿‡æ£€æŸ¥è¾…åŠ©åŠŸèƒ½è®¾å®šä¸­çš„ isClosedCaptioningEnabled æ¥åˆ¤æ–­ä½•æ—¶å±•ç¤ºå­—å¹•ã€‚æƒ³è¦è·å–æ­£ç¡®çš„å­—å¹•å†…å®¹æ˜¾ç¤ºæ•ˆæœï¼Œä½ åº”åœ¨é¡¹ç›®ä¸­å¼•å…¥ Media Accessibilityã€‚è¿™ä¸ªæ¡†æ¶èƒ½æä¾›æœ€ä½³çš„å­—ä½“ã€é¢œè‰²å’Œé€æ˜åº¦ä¿¡æ¯ï¼Œä»¥ä¾¿ä½ åœ¨å¸¦å­—å¹•çš„æ–‡æœ¬å’Œå›¾åƒä¸Šä½¿ç”¨ã€‚",
      "tips": ""
    }
  },
  "visionos/incorporating-real-world-surroundings-in-an-immersive-experience": {
    "Incorporating real-world surroundings in an immersive experience": {
      "zh": "",
      "tips": ""
    },
    "Create an immersive experience by making your appâ€™s content respond to the local shape of the world.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Scene reconstruction helps bridge the gap between the rendered 3D content in your app and the personâ€™s surroundings. Use scene reconstruction in ARKit to give your app an idea of the shape of the personâ€™s surroundings and to bring your app experience into their world. Immersive experiences â€” those that use the mixed space style â€” are best positioned to incorporate this kind of contextual information: scene reconstruction is only available in spaces and isnâ€™t as relevant for the full space style.": {
      "zh": "",
      "tips": ""
    },
    "In addition to providing a 3D mesh of the shape of different nearby objects, ARKit gives a classification to each mesh face it detects. For example, it might classify a face of a mesh as being part of an appliance, a piece of furniture, or structural information about the room like the position of walls and floors. The following video shows virtual cubes colliding with the scene reconstruction mesh, which makes the cubes appear to land on a table:": {
      "zh": "",
      "tips": ""
    },
    "Configure a scene reconstruction session": {
      "zh": "",
      "tips": ""
    },
    "Scene reconstruction requires the ARKitSession.AuthorizationType.worldSensing authorization type and corresponding usage description that you supply in your appâ€™s Info.plist file. The following starts a session and processes updates as ARKit refines its reconstruction of the personâ€™s surroundings:": {
      "zh": "",
      "tips": ""
    },
    "Add real-world interactivity using collision components": {
      "zh": "",
      "tips": ""
    },
    "You can make rendered 3D content more lifelike by having it appear to interact physically with objects in the personâ€™s surroundings, like furniture and floors. Use RealityKitâ€™s collision components and physics support to provide these interactions in your app. The generateStaticMesh(from:) method bridges between scene reconstruction and RealityKitâ€™s physics simulation.": {
      "zh": "",
      "tips": ""
    },
    "Warning": {
      "zh": "",
      "tips": ""
    },
    "Be mindful of how much content you include in immersive scenes that use the mixed style. Content that fills a significant portion of the screen, even if that content is partially transparent, can prevent the person from seeing potential hazards in their surroundings. If you want to immerse the person in your content, configure your space with the full style. For more information, see Creating fully immersive experiences in your app.": {
      "zh": "",
      "tips": ""
    },
    "Use low-priority tasks to generate meshes, because generating them is a computationally expensive operation. The following creates a mesh entity with collision shapes using scene reconstruction:": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "Scene reconstruction meshes only support the PhysicsBodyMode.static physics body component mode.": {
      "zh": "",
      "tips": ""
    },
    "Each object in the scene reconstruction mesh updates its originFromAnchorTransform information independently and requires a separate static mesh because ARKit subdivides its representation of the world into multiple, distinct sections.": {
      "zh": "",
      "tips": ""
    },
    "Display scene reconstruction meshes during debugging": {
      "zh": "",
      "tips": ""
    },
    "People using an app that leverages scene reconstruction typically donâ€™t need to see a visual rendering of the scene reconstruction mesh. The system already shows passthrough video in an immersive experience. However, temporarily displaying the scene reconstruction mesh can help while youâ€™re developing and debugging your app. In Xcodeâ€™s debugging toolbar, click the Enable Visualizations button and select Collision Shapes. Because each element of the scene reconstruction mesh has a collision component, the details of the mesh appear in the debug visualization. For more information, see Diagnosing issues in the appearance of a running app.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/interacting-with-your-app-in-the-visionos-simulator": {
    "Interacting with your app in the visionOS simulator": {
      "zh": "",
      "tips": ""
    },
    "Use your Mac to navigate spaces and control interactions with your visionOS apps in Simulator.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Use Simulator to run apps in visionOS without installing them on a physical device. When you run your app in Simulator, you can see a monoscopic view of your appâ€™s windows and 3D content inside an immersive space. Use your Mac to alter the viewpoint of the app within the space and navigate the appâ€™s interface.": {
      "zh": "",
      "tips": ""
    },
    "Interact with your app": {
      "zh": "",
      "tips": ""
    },
    "To use your Macâ€™s pointer and keyboard to create gestures, choose â€œSelect to interact with the sceneâ€ from the buttons at the bottom-right of a visionOS simulator window. The current gaze position tracks your pointer movements when you hover over content within the space.": {
      "zh": "",
      "tips": ""
    },
    "Use the following actions to trigger gestures:": {
      "zh": "",
      "tips": ""
    },
    "Gesture": {
      "zh": "",
      "tips": ""
    },
    "To simulate": {
      "zh": "",
      "tips": ""
    },
    "Tap": {
      "zh": "",
      "tips": ""
    },
    "Click.": {
      "zh": "",
      "tips": ""
    },
    "Double-tap": {
      "zh": "",
      "tips": ""
    },
    "Double-click.": {
      "zh": "",
      "tips": ""
    },
    "Touch and hold": {
      "zh": "",
      "tips": ""
    },
    "Click and hold.": {
      "zh": "",
      "tips": ""
    },
    "Drag (left, right, up, and down)": {
      "zh": "",
      "tips": ""
    },
    "Drag left, right, up, and down.": {
      "zh": "",
      "tips": ""
    },
    "Drag (forward and back)": {
      "zh": "",
      "tips": ""
    },
    "Shift-drag up and down.": {
      "zh": "",
      "tips": ""
    },
    "Two-handed gestures": {
      "zh": "",
      "tips": ""
    },
    "Press and hold the Option key to display touch points. Move the pointer while pressing the Option key to change the distance between the touch points. Move the pointer and hold the Shift and Option keys to reposition the touch points.": {
      "zh": "",
      "tips": ""
    },
    "Activate device buttons using menu items or by clicking the controls in the simulator window toolbar.": {
      "zh": "",
      "tips": ""
    },
    "Navigate the space": {
      "zh": "",
      "tips": ""
    },
    "Use your Macâ€™s pointer and the keyboard to reposition your viewpoint in a visionOS simulator window:": {
      "zh": "",
      "tips": ""
    },
    "Movement": {
      "zh": "",
      "tips": ""
    },
    "Forward": {
      "zh": "",
      "tips": ""
    },
    "Press the W key (or Up Arrow key), or perform a pinch gesture moving two fingers away from each other on a trackpad.": {
      "zh": "",
      "tips": ""
    },
    "Backward": {
      "zh": "",
      "tips": ""
    },
    "Press the S key (or Down Arrow key), or perform a pinch gesture moving two fingers toward each other on a trackpad.": {
      "zh": "",
      "tips": ""
    },
    "Left": {
      "zh": "",
      "tips": ""
    },
    "Press the A key (or Left Arrow key), or scroll left using a trackpad or Magic Mouse.": {
      "zh": "",
      "tips": ""
    },
    "Right": {
      "zh": "",
      "tips": ""
    },
    "Press the D key (or Right Arrow key), or scroll right using a trackpad or Magic Mouse.": {
      "zh": "",
      "tips": ""
    },
    "Up": {
      "zh": "",
      "tips": ""
    },
    "Press the E key, or scroll up using a trackpad or Magic Mouse.": {
      "zh": "",
      "tips": ""
    },
    "Down": {
      "zh": "",
      "tips": ""
    },
    "Press the Q key, or scroll down using a trackpad or Magic Mouse.": {
      "zh": "",
      "tips": ""
    },
    "You can also control the viewpoint with a standard drag. To do so, choose â€œDrag to pan the cameraâ€ from the buttons at the bottom-right of the simulator window to move the viewpoint left, right, up or down and choose â€œDrag to dolly the cameraâ€ to move it forward or backward.": {
      "zh": "",
      "tips": ""
    },
    "To change your viewing angle, Control-drag inside a visionOS simulator window. You can choose â€œDrag to tilt the cameraâ€ from the buttons at the bottom-right of the simulator window to use a drag without the Control key.": {
      "zh": "",
      "tips": ""
    },
    "To reset the viewpoint and viewing angle for a visionOS simulator, choose the Reset Camera button from the toolbar at the top-right of its window.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "To capture the input from the pointer and keyboard, bypassing navigation control, to direct the input to the simulated device, use the Pointer Capture and Keyboard Capture buttons in the toolbar at the top-right of a visionOS simulator window. Press the Esc (Escape) key to disable capture and restore navigation controls.": {
      "zh": "",
      "tips": ""
    },
    "When moving with a trackpad or Magic Mouse, Simulator respects the natural scrolling setting on macOS.": {
      "zh": "",
      "tips": ""
    },
    "You can also use a game controller to control your movement. Use the left stick to move left, right, forward or back. Use R2 and L2 to move up and down. Use the right stick on a game controller to pan around the space.": {
      "zh": "",
      "tips": ""
    },
    "Switch between simulated scenes": {
      "zh": "",
      "tips": ""
    },
    "Simulator provides multiple built-in scenes you can use to simulate passthrough in different surroundings. These include unique room layouts and furniture for different testing scenarios, each available in different lighting conditions.": {
      "zh": "",
      "tips": ""
    },
    "Use the simulated scene to test:": {
      "zh": "",
      "tips": ""
    },
    "Readability of your app in varying backgrounds and varying lighting conditions.": {
      "zh": "",
      "tips": ""
    },
    "Different scenarios, including limited and cluttered surroundings, to see how your app adapts to them.": {
      "zh": "",
      "tips": ""
    },
    "Content layout, positioning, and scale.": {
      "zh": "",
      "tips": ""
    },
    "Spatial audio and acoustics.": {
      "zh": "",
      "tips": ""
    },
    "To change the simulated scene, click the Simulated Scenes button in the toolbar at the top-right of a visionOS simulator window and choose a different scene.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/making-your-app-compatible-with-visionos": {
    "Making your existing app compatible with visionOS": {
      "zh": "ä½¿ç°æœ‰åº”ç”¨ä¸ visionOS å…¼å®¹",
      "tips": ""
    },
    "Modify your iPadOS or iOS app to run successfully in visionOS.": {
      "zh": "ä¿®æ”¹ä½ çš„ iPadOS æˆ– iOS åº”ç”¨ï¼Œä»¥ä¾¿åœ¨ visionOS ä¸­æˆåŠŸè¿è¡Œã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "A compatible iPadOS or iOS app links against the iOS SDK and runs in visionOS. Although visionOS provides a complete set of iOS frameworks for linking, some features of those frameworks might be unavailable due to hardware or usage differences. To ensure your app runs correctly in visionOS, handle any missing features gracefully and provide workarounds wherever possible.": {
      "zh": "å…¼å®¹çš„ iPadOS æˆ– iOS åº”ç”¨å¯é“¾æ¥ iOS SDK å¹¶åœ¨ visionOS ä¸­è¿è¡Œã€‚å°½ç®¡ visionOS æä¾›äº†ä¸€å¥—å®Œæ•´çš„ iOS æ¡¥æ¥æ¡†æ¶ï¼Œä½†ç”±äºç¡¬ä»¶æˆ–ä½¿ç”¨ä¸Šçš„å·®å¼‚ï¼Œè¿™äº›æ¡†æ¶çš„æŸäº›åŠŸèƒ½å¯èƒ½æ— æ³•ä½¿ç”¨ã€‚ä¸ºç¡®ä¿ä½ çš„åº”ç”¨èƒ½åœ¨ visionOS ä¸­æ­£ç¡®è¿è¡Œï¼Œè¯·ä¼˜é›…åœ°åº”å¯¹å¯èƒ½ç¼ºå¤±çš„åŠŸèƒ½ï¼Œå¹¶å°½å¯èƒ½æä¾›å˜é€šæ–¹æ³•ã€‚",
      "tips": ""
    },
    "Perform availability and authorization checks before using features": {
      "zh": "ä½¿ç”¨åŠŸèƒ½å‰è¿›è¡Œå¯ç”¨æ€§å’Œæˆæƒæ£€æŸ¥",
      "tips": ""
    },
    "Some frameworks offer APIs to let you determine when framework features are available or whether your app is authorized to use them. Always check these APIs before you try to use the corresponding features, and donâ€™t assume a feature is available because the necessary hardware is present. The deviceâ€™s configuration also plays a role in determining the results of some availability and authorization checks, and features might not be present when your app runs in Simulator. If an availability or authorization check fails, donâ€™t try to use the associated feature in your app.": {
      "zh": "æœ‰äº›æ¡†æ¶æä¾›äº† API è®©ä½ æ£€æŸ¥æ¡†æ¶åŠŸèƒ½ä½•æ—¶å¯ç”¨ï¼Œæˆ–ä½ çš„åº”ç”¨æ˜¯å¦å·²è¢«æˆæƒä½¿ç”¨è¿™äº›åŠŸèƒ½ã€‚åœ¨å°è¯•ä½¿ç”¨ç›¸åº”åŠŸèƒ½ä¹‹å‰ï¼Œè¯·åŠ¡å¿…æ£€æŸ¥è¿™äº› APIï¼Œä¸è¦å› ä¸ºå­˜åœ¨å¿…è¦çš„ç¡¬ä»¶å°±è®¤ä¸ºæŸé¡¹åŠŸèƒ½å¯ç”¨ã€‚è®¾å¤‡çš„é…ç½®ä¹Ÿä¼šå¯¹æŸäº›å¯ç”¨æ€§å’Œæˆæƒæ£€æŸ¥çš„ç»“æœäº§ç”Ÿå½±å“ï¼Œå¦å¤–å½“ä½ çš„åº”ç”¨åœ¨æ¨¡æ‹Ÿå™¨ä¸­è¿è¡Œæ—¶ï¼ŒæŸäº›åŠŸèƒ½å¯èƒ½å¹¶ä¸å­˜åœ¨ã€‚å¦‚æœå¯ç”¨æ€§æˆ–æˆæƒæ£€æŸ¥å¤±è´¥ï¼Œè¯·ä¸è¦å°è¯•åœ¨åº”ç”¨ä¸­ä½¿ç”¨ç›¸å…³åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "The following frameworks support availability or authorization checks:": {
      "zh": "ä»¥ä¸‹æ¡†æ¶æ”¯æŒå¯ç”¨æ€§æˆ–æˆæƒæ£€æŸ¥ï¼š",
      "tips": ""
    },
    "ActivityKit. Check the areActivitiesEnabled property of ActivityAuthorizationInfo to determine if Live Activities are authorized.": {
      "zh": "ActivityKitã€‚æ£€æŸ¥ ActivityAuthorizationInfo çš„ areActivitiesEnabled å±æ€§ï¼Œä»¥ç¡®è®¤â€å®æ—¶æ´»åŠ¨â€œæ˜¯å¦å·²è·å¾—æˆæƒã€‚",
      "tips": ""
    },
    "ARKit. Check the isSupported property of your configuration object to determine availability of augmented reality features. In visionOS, ARKit views such as ARView are never available, so isolate interface code containing those views to the iOS version of your app.": {
      "zh": "ARKitã€‚æ£€æŸ¥é…ç½®å¯¹è±¡çš„ isSupported å±æ€§ï¼Œä»¥ç¡®è®¤å¢å¼ºç°å®åŠŸèƒ½æ˜¯å¦å¯ç”¨ã€‚åœ¨ visionOS ä¸­ï¼ŒARView ç­‰ ARKit è§†å›¾æ€»æ˜¯ä¸å¯ç”¨ï¼Œå› æ­¤è¯·å°†åŒ…å«è¿™äº›è§†å›¾çš„æ¥å£ä»£ç éš”ç¦»åˆ° iOS ç‰ˆæœ¬çš„åº”ç”¨ä¸­ã€‚",
      "tips": ""
    },
    "AVFoundation. Identify what cameras are available using the AVCaptureDevice.DiscoverySession class. Donâ€™t assume the presence of specific cameras.": {
      "zh": "AVFoundationã€‚ä½¿ç”¨ AVCaptureDevice.DiscoverySession ç±»ç¡®è®¤å“ªäº›æ‘„åƒå¤´å¯ç”¨ã€‚ä¸è¦å‡è®¾å­˜åœ¨ç‰¹å®šçš„æ‘„åƒå¤´ã€‚",
      "tips": ""
    },
    "Automatic Assessment Configuration. Check for error values when you configure an AEAssessmentSession object.": {
      "zh": "è‡ªåŠ¨è¯„ä¼°é…ç½®ã€‚è¯·åœ¨é…ç½® AEAssessmentSession å¯¹è±¡æ—¶æ£€æŸ¥é”™è¯¯å€¼ã€‚",
      "tips": ""
    },
    "Contacts. Use the CNContactStore class to determine your appâ€™s authorization status.": {
      "zh": "è”ç³»äººã€‚ä½¿ç”¨ CNContactStore ç±»ç¡®è®¤åº”ç”¨çš„æˆæƒçŠ¶æ€ã€‚",
      "tips": ""
    },
    "Core Bluetooth. Use the CBCentralManager and CBPeripheralManager classes to determine feature availability and your appâ€™s authorization status.": {
      "zh": "æ ¸å¿ƒè“ç‰™ã€‚ä½¿ç”¨ CBCentralManager å’Œ CBPeripheralManager ç±»ç¡®è®¤åŠŸèƒ½å¯ç”¨æ€§å’Œåº”ç”¨çš„æˆæƒçŠ¶æ€ã€‚",
      "tips": ""
    },
    "Core Haptics. Call the capabilitiesForHardware() method of the haptic engine to determine the available features.": {
      "zh": "æ ¸å¿ƒè§¦è§‰ã€‚è°ƒç”¨è§¦è§‰å¼•æ“çš„ capabilitiesForHardware() æ–¹æ³•ç¡®è®¤å¯ç”¨åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "Core Location. Check the properties of CLLocationManager to determine the availability of location services.": {
      "zh": "æ ¸å¿ƒä½ç½®ã€‚æ£€æŸ¥ CLLocationManager çš„å±æ€§ä»¥ç¡®è®¤ä½ç½®æœåŠ¡çš„å¯ç”¨æ€§ã€‚",
      "tips": ""
    },
    "Core Motion. Check the properties of CMMotionManager to determine the availability of accelerometers, gyroscopes, magnetometers, and other hardware sensors.": {
      "zh": "æ ¸å¿ƒè¿åŠ¨ã€‚æ£€æŸ¥ CMMotionManager çš„å±æ€§ï¼Œä»¥ç¡®è®¤åŠ é€Ÿè®¡ã€é™€èºä»ªã€ç£åŠ›è®¡å’Œå…¶ä»–ç¡¬ä»¶ä¼ æ„Ÿå™¨æ˜¯å¦å¯ç”¨ã€‚",
      "tips": ""
    },
    "Core NFC. Check the readingAvailable property of your reader session to determine if NFC tag reading is available.": {
      "zh": "æ ¸å¿ƒ NFCã€‚æ£€æŸ¥è¯»å–å™¨ä¼šè¯çš„ readingAvailable å±æ€§ï¼Œä»¥ç¡®è®¤ NFC æ ‡ç­¾è¯»å–æ˜¯å¦å¯ç”¨ã€‚",
      "tips": ""
    },
    "EventKit. Use the EKEventStore class to determine your appâ€™s authorization status.": {
      "zh": "EventKitã€‚ä½¿ç”¨ EKEventStore ç±»ç¡®è®¤åº”ç”¨çš„æˆæƒçŠ¶æ€ã€‚",
      "tips": ""
    },
    "ExposureNotification. Use the ENManager class to determine your appâ€™s authorization status.": {
      "zh": "ExposureNotificationã€‚ä½¿ç”¨ ENManager ç±»ç¡®è®¤åº”ç”¨çš„æˆæƒçŠ¶æ€ã€‚",
      "tips": ""
    },
    "HealthKit. Use the HKHealthStore class to determine if health-related data is available.": {
      "zh": "HealthKitã€‚ä½¿ç”¨ HKHealthStore ç±»ç¡®è®¤å¥åº·ç›¸å…³æ•°æ®æ˜¯å¦å¯ç”¨ã€‚",
      "tips": ""
    },
    "HomeKit. Check the properties of HMHomeManager to determine your appâ€™s authorization status.": {
      "zh": "HomeKitã€‚æ£€æŸ¥ HMHomeManager çš„å±æ€§ï¼Œç¡®è®¤åº”ç”¨çš„æˆæƒçŠ¶æ€ã€‚",
      "tips": ""
    },
    "Local Authentication. Use the LAContext class to determine the authentication policies you can use.": {
      "zh": "æœ¬åœ°èº«ä»½éªŒè¯ã€‚ä½¿ç”¨ LAContext ç±»ç¡®è®¤å¯ä»¥ä½¿ç”¨çš„èº«ä»½éªŒè¯ç­–ç•¥ã€‚",
      "tips": ""
    },
    "Media Player. Use the MPMediaLibrary class to determine your appâ€™s authorization status.": {
      "zh": "åª’ä½“æ’­æ”¾å™¨ã€‚ä½¿ç”¨ MPMediaLibrary ç±»ç¡®è®¤åº”ç”¨çš„æˆæƒçŠ¶æ€ã€‚",
      "tips": ""
    },
    "Nearby Interaction. Check the deviceCapabilities property of your session to determine whether features are available.": {
      "zh": "é‚»è¿‘äº¤äº’ã€‚æ£€æŸ¥ä¼šè¯çš„ deviceCapabilities å±æ€§ï¼Œç¡®è®¤åŠŸèƒ½æ˜¯å¦å¯ç”¨ã€‚",
      "tips": ""
    },
    "PhotoKit. Use the PHPhotoLibrary class to determine your appâ€™s authorization status.": {
      "zh": "PhotoKitã€‚ä½¿ç”¨ PHPhotoLibrary ç±»ç¡®è®¤åº”ç”¨çš„æˆæƒçŠ¶æ€ã€‚",
      "tips": ""
    },
    "ProximityReader. Check the isSupported property of the card reader object to determine if Tap to Pay on iPhone is available.": {
      "zh": "ProximityReaderã€‚æ£€æŸ¥è¯»å¡å™¨å¯¹è±¡çš„ isSupported å±æ€§ï¼Œä»¥ç¡®è®¤ iPhone ä¸Šçš„â€œTap to Payâ€æ˜¯å¦å¯ç”¨ã€‚",
      "tips": ""
    },
    "ReplayKit. Check the isAvailable property of RPScreenRecorder to determine if screen recording support is available.": {
      "zh": "ReplayKitã€‚æ£€æŸ¥ RPScreenRecorder çš„ isAvailable å±æ€§ï¼Œä»¥ç¡®è®¤å±å¹•å½•åˆ¶åŠŸèƒ½æ˜¯å¦å¯ç”¨ã€‚",
      "tips": ""
    },
    "RoomPlan. Check the isSupported property of the RoomCaptureSession object to determine if LiDAR scanning is available on the device.": {
      "zh": "RoomPlanã€‚æ£€æŸ¥ RoomCaptureSession å¯¹è±¡çš„ isSupported å±æ€§ï¼Œä»¥ç¡®è®¤è®¾å¤‡ä¸Šæ˜¯å¦æ”¯æŒ 3D æ¿€å…‰æ‰«æã€‚",
      "tips": "LiDAR æ˜¯ Light Detection And Ranging çš„ç¼©å†™ï¼Œé€šå¸¸è¢«ç§°ä¸ºâ€œ3D æ¿€å…‰æ‰«æâ€ã€‚"
    },
    "SensorKit. Use the SRSensorReader class to determine your appâ€™s authorization status.": {
      "zh": "SensorKitã€‚ä½¿ç”¨ SRSensorReader ç±»ç¡®è®¤åº”ç”¨çš„æˆæƒçŠ¶æ€ã€‚",
      "tips": ""
    },
    "Speech. Use the SFSpeechRecognizer class to determine if speech recognition is available.": {
      "zh": "è¯­éŸ³ã€‚ä½¿ç”¨ SFSpeechRecognizer ç±»ç¡®è®¤è¯­éŸ³è¯†åˆ«æ˜¯å¦å¯ç”¨ã€‚",
      "tips": ""
    },
    "User Notifications. Use the getNotificationSettings(completionHandler:) method of UNUserNotificationCenter to determine your appâ€™s authorization status.": {
      "zh": "ç”¨æˆ·é€šçŸ¥ã€‚ä½¿ç”¨ UNUserNotificationCenter çš„ getNotificationSettings(completionHandler:) æ–¹æ³•ç¡®è®¤åº”ç”¨çš„æˆæƒçŠ¶æ€ã€‚",
      "tips": ""
    },
    "WatchConnectivity. Call the isSupported() method of the WCSession object to determine if the framework is available.": {
      "zh": "WatchConnectivityã€‚è°ƒç”¨ WCSession å¯¹è±¡çš„ isSupported() æ–¹æ³•æ¥ç¡®è®¤æ¡†æ¶æ˜¯å¦å¯ç”¨ã€‚",
      "tips": ""
    },
    "Handle environmental differences appropriately": {
      "zh": "å¦¥å–„å¤„ç†ç¯å¢ƒå·®å¼‚",
      "tips": ""
    },
    "Apple frameworks take a device-agnostic approach whenever possible to minimize issues when you use them on different device types. Apple devices come in a variety of shapes and sizes, and with different sets of features. Rather than build your app for a specific device, make sure it adapts to any device and can gracefully handle differences.": {
      "zh": "Apple æ¡†æ¶åœ¨è®¾è®¡æ—¶å°½å¯èƒ½åœ°é‡‡ç”¨äº†æ— è§†è®¾å¤‡çš„æ–¹å¼ï¼Œä»¥å‡å°‘åœ¨ä¸åŒç±»å‹è®¾å¤‡ä¸Šä½¿ç”¨æ—¶å‡ºç°çš„é—®é¢˜ã€‚è‹¹æœè®¾å¤‡çš„å½¢çŠ¶å’Œå¤§å°å„ä¸ç›¸åŒï¼ŒåŠŸèƒ½ä¹Ÿä¸å°½ç›¸åŒã€‚ä¸å…¶ä¸ºç‰¹å®šè®¾å¤‡æ„å»ºåº”ç”¨ï¼Œä¸å¦‚ç¡®ä¿åº”ç”¨èƒ½é€‚åº”ä»»ä½•è®¾å¤‡ï¼Œå¹¶èƒ½ä»å®¹åº”å¯¹å·®å¼‚ã€‚",
      "tips": ""
    },
    "Build robustness into your app during the design process. Avoid assumptions that might cause your app to break when it runs on a new device, and make sure your app adapts dynamically to different conditions. For example:": {
      "zh": "è¯·åœ¨åº”ç”¨çš„è®¾è®¡è¿‡ç¨‹ä¸­è€ƒè™‘åˆ°ç¨³å¥æ€§ã€‚è¯·é¿å…å¯èƒ½å¯¼è‡´åº”ç”¨åœ¨æ–°è®¾å¤‡ä¸Šè¿è¡Œæ—¶å‘ç”Ÿæ•…éšœçš„å‡è®¾ï¼Œå¹¶ç¡®ä¿ä½ çš„åº”ç”¨èƒ½åŠ¨æ€åœ°é€‚åº”ä¸åŒçš„æ¡ä»¶ã€‚ä¾‹å¦‚ï¼š",
      "tips": ""
    },
    "Donâ€™t assume the device type or idiom is always iPhone, iPad, or iPod Touch. Avoid decisions based on the current idiom. If you do rely on the current idiom, provide reasonable defaults for unknown idioms.": {
      "zh": "ä¸è¦å‡è®¾è®¾å¤‡ç±»å‹æˆ–æƒ¯ç”¨åæ€»æ˜¯ iPhoneã€iPad æˆ– iPod Touchã€‚è¯·é¿å…æ ¹æ®å½“å‰çš„æƒ¯ç”¨ååšå‡ºå†³å®šã€‚å¦‚æœä½ ç¡®å®ä¾èµ–å½“å‰çš„æƒ¯ç”¨åï¼Œè¯·ä¸ºæœªçŸ¥æƒ¯ç”¨åæä¾›åˆç†çš„é»˜è®¤å€¼ã€‚",
      "tips": ""
    },
    "Design your app to handle unavailable hardware or features. Specific hardware and features might be unavailable for many different reasons. For example, a feature might be unavailable when your app runs in Simulator. Perform availability checks whenever possible, and handle missing features gracefully.": {
      "zh": "å°†åº”ç”¨è®¾è®¡ä¸ºèƒ½å¤Ÿå¯¹åº”ä¸å¯ç”¨çš„ç¡¬ä»¶æˆ–åŠŸèƒ½ã€‚å¯¼è‡´ç‰¹å®šç¡¬ä»¶å’ŒåŠŸèƒ½ä¸å¯ç”¨çš„åŸå› å¤šç§å¤šæ ·ã€‚ä¾‹å¦‚ï¼Œå½“åº”ç”¨åœ¨æ¨¡æ‹Ÿå™¨ä¸­è¿è¡Œæ—¶ï¼ŒæŸä¸ªåŠŸèƒ½æˆ–è®¸ä¸å¯ç”¨ã€‚è¯·å°½å¯èƒ½åœ°æ‰§è¡Œå¯ç”¨æ€§æ£€æŸ¥ï¼Œå¹¶ä»å®¹åº”å¯¹åŠŸèƒ½ç¼ºå¤±ã€‚",
      "tips": ""
    },
    "Design your windows and views to adapt dynamically. Build your interface to adapt dynamically to any size using SwiftUI or Auto Layout. Assume the size of your app can change dynamically.": {
      "zh": "è®¾è®¡èƒ½å¤ŸåŠ¨æ€é€‚åº”çš„çª—å£å’Œè§†å›¾ã€‚ä½¿ç”¨ SwiftUI æˆ–è‡ªåŠ¨å¸ƒå±€æ¥æ„å»ºç•Œé¢ï¼Œä»¥ä¾¿åŠ¨æ€é€‚åº”ä»»ä½•å°ºå¯¸ã€‚è¯·å‡è®¾åº”ç”¨çš„å°ºå¯¸ä¼šåŠ¨æ€å˜åŒ–ã€‚",
      "tips": ""
    },
    "Donâ€™t assume the device has a specific number of displays. People can connect iPad and iPhone to an external display, and visionOS devices use two displays to create a stereoscopic version of your appâ€™s content.": {
      "zh": "ä¸è¦å‡è®¾è®¾å¤‡æœ‰ç‰¹å®šæ•°é‡çš„æ˜¾ç¤ºå±ã€‚äººä»¬å¯ä»¥å°† iPad å’Œ iPhone è¿æ¥åˆ°å¤–éƒ¨æ˜¾ç¤ºå±ï¼Œè€Œ visionOS è®¾å¤‡åˆ™ä½¿ç”¨ä¸¤ä¸ªæ˜¾ç¤ºå±æ¥åˆ›å»ºåº”ç”¨å†…å®¹çš„ç«‹ä½“ç‰ˆã€‚",
      "tips": ""
    },
    "Donâ€™t make assumptions based on the available frameworks or symbols. The presence or absence of frameworks or code symbols is an unreliable way to identify a device type, and can change in later software updates.": {
      "zh": "ä¸è¦æ ¹æ®å¯ç”¨çš„æ¡†æ¶æˆ–ç¬¦å·åšå‡ºå‡è®¾ã€‚æŸä¸ªæ¡†æ¶æˆ–ä»£ç ç¬¦å·çš„å­˜åœ¨æˆ–ç¼ºå¤±ä¸æ˜¯è¯†åˆ«è®¾å¤‡ç±»å‹çš„å¯é æ–¹æ³•ï¼Œè€Œä¸”å¯èƒ½ä¼šåœ¨ä»Šåçš„è½¯ä»¶æ›´æ–°ä¸­å˜åŒ–ã€‚",
      "tips": ""
    },
    "Donâ€™t assume your app runs in the background. visionOS doesnâ€™t support the location, external accessory, or Bluetooth-peripheral background execution modes.": {
      "zh": "ä¸è¦å‡è®¾ä½ çš„åº”ç”¨åœ¨åå°è¿è¡Œã€‚visionOS ä¸æ”¯æŒå®šä½ã€å¤–éƒ¨è®¿é—®æˆ–è“ç‰™å¤–è®¾åå°æ‰§è¡Œæ¨¡å¼ã€‚",
      "tips": ""
    },
    "Donâ€™t assume that background apps are hidden. In visionOS, the windows of background apps remain visible, but are dimmed when no one looks at them. The only time app windows disappear is when one app presents an immersive space.": {
      "zh": "ä¸è¦å‡è®¾æ‰€æœ‰åå°åº”ç”¨éƒ½æ˜¯éšè—çš„ã€‚åœ¨ visionOS ä¸­ï¼Œåå°åº”ç”¨çš„çª—å£ä»ç„¶å¯è§ï¼Œä½†åœ¨æœªè¢«è§‚çœ‹æ—¶ä¼šå˜æš—ã€‚åªæœ‰å½“æŸä¸ªåº”ç”¨å‘ˆç°å‡ºæ²‰æµ¸å¼ç©ºé—´æ—¶ï¼Œåº”ç”¨çª—å£æ‰ä¼šæ¶ˆå¤±ã€‚",
      "tips": ""
    },
    "When you make decisions using device details, your app might produce inconsistent or erroneous results on an unknown device type, or it might fail altogether. Find solutions that rely on environmental information, rather than the device type. For example, SwiftUI and UIKit start layout using the appâ€™s window size, which isnâ€™t necessarily the same size as the deviceâ€™s display.": {
      "zh": "å½“ä½ ä½¿ç”¨è®¾å¤‡è¯¦ç»†ä¿¡æ¯è¿›è¡Œå†³ç­–æ—¶ï¼Œä½ çš„åº”ç”¨å¯èƒ½ä¼šåœ¨æœªçŸ¥è®¾å¤‡ç±»å‹ä¸Šäº§ç”Ÿä¸ä¸€è‡´æˆ–é”™è¯¯çš„ç»“æœï¼Œæˆ–è€…å½»åº•å´©æºƒã€‚è¯·å¯»æ‰¾ä¾èµ–ç¯å¢ƒä¿¡æ¯è€Œéè®¾å¤‡ç±»å‹çš„è§£å†³æ–¹æ¡ˆã€‚ä¾‹å¦‚ï¼ŒSwiftUI å’Œ UIKit ä½¿ç”¨åº”ç”¨çš„çª—å£å¤§å°å¯åŠ¨å¸ƒå±€ï¼Œè€Œçª—å£å¤§å°å¹¶ä¸ä¸€å®šä¸è®¾å¤‡æ˜¾ç¤ºå±å¤§å°ç›¸åŒã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "å¤‡æ³¨",
      "tips": ""
    },
    "Device-specific information is available when you absolutely need it, but validate the information you receive and provide reasonable default behavior for unexpected values.": {
      "zh": "åœ¨ç»å¯¹å¿…è¦æ—¶å¯ä»¥ä½¿ç”¨è®¾å¤‡ç‰¹å®šä¿¡æ¯ï¼Œä½†è¦å¯¹æ”¶åˆ°çš„ä¿¡æ¯è¿›è¡ŒéªŒè¯ï¼Œå¹¶ä¸ºæ„å¤–å€¼æä¾›åˆç†çš„é»˜è®¤è¡Œä¸ºã€‚",
      "tips": ""
    },
    "Audit your interface code": {
      "zh": "å®¡æ ¸ä½ çš„ç•Œé¢ä»£ç ",
      "tips": ""
    },
    "To minimize disruptions, visionOS runs your compatible iPad or iPhone app in an environment that matches an iPad as much as possible. Windows and views retain the same appearance that they have in iPadOS or iOS, and the system sizes your appâ€™s window to fit an iPad whenever possible.": {
      "zh": "ä¸ºäº†æœ€å¤§é™åº¦åœ°å‡å°‘å¹²æ‰°ï¼ŒvisionOS ä¼šå°½å¯èƒ½åœ¨ä¸ iPad ç›¸åŒ¹é…çš„ç¯å¢ƒä¸­è¿è¡Œå…¼å®¹çš„ iPad æˆ– iPhone åº”ç”¨ã€‚çª—å£å’Œè§†å›¾ä¿ç•™äº†ä¸ iPadOS æˆ– iOS ä¸­ç›¸åŒçš„å¤–è§‚ï¼Œè€Œä¸”ç³»ç»Ÿä¼šå°½å¯èƒ½è°ƒæ•´åº”ç”¨çª—å£çš„å¤§å°ä»¥é€‚åº” iPadã€‚",
      "tips": ""
    },
    "When building your appâ€™s interface, make choices that ensure your app runs well in visionOS too. Adopt the following best practices for your interface-related code:": {
      "zh": "åœ¨æ„å»ºåº”ç”¨çš„ç•Œé¢æ—¶ï¼Œè¯·é€‰æ‹©èƒ½ç¡®ä¿ä½ çš„åº”ç”¨åœ¨ visionOS ä¸­ä¹Ÿèƒ½æ­£å¸¸è¿è¡Œçš„é€‰é¡¹ã€‚å¯¹äºä¸ç•Œé¢ç›¸å…³çš„ä»£ç ï¼Œè¯·é‡‡ç”¨ä»¥ä¸‹æœ€ä½³å®è·µï¼š",
      "tips": ""
    },
    "Support iPad and iPhone in the same app. Create one app that supports both device types, rather than separate apps for each device. SwiftUI and UIKit support adaptable interfaces, and Xcode provides tools to help you visualize your interface at different supported sizes.": {
      "zh": "åœ¨ä¸€ä¸ªåº”ç”¨ä¸­æ”¯æŒ iPad å’Œ iPhoneã€‚åˆ›å»ºä¸€ä¸ªåŒæ—¶æ”¯æŒä¸¤ç§è®¾å¤‡ç±»å‹çš„åº”ç”¨ï¼Œè€Œä¸æ˜¯ä¸ºæ¯ç§è®¾å¤‡åˆ†åˆ«åˆ›å»ºåº”ç”¨ã€‚SwiftUI å’Œ UIKit æ”¯æŒè‡ªé€‚åº”ç•Œé¢ï¼Œè€Œ Xcode æä¾›çš„å·¥å…·å¯å¸®åŠ©ä½ åœ¨ä¸åŒçš„æ”¯æŒå°ºå¯¸ä¸‹æ˜¾ç¤ºç•Œé¢ã€‚",
      "tips": ""
    },
    "Organize your interface using scenes. Scenes are a fundamental tool for managing your appâ€™s interface. Use the scene types in SwiftUI and UIKit to assemble and manage the views you display in windows.": {
      "zh": "ä½¿ç”¨åœºæ™¯æ¥ç»„ç»‡ç•Œé¢ã€‚åœºæ™¯æ˜¯ç®¡ç†åº”ç”¨ç•Œé¢çš„åŸºæœ¬å·¥å…·ã€‚ä½¿ç”¨ SwiftUI å’Œ UIKit ä¸­çš„åœºæ™¯ç±»å‹æ¥ç»„åˆå’Œç®¡ç†ä½ åœ¨çª—å£ä¸­æ˜¾ç¤ºçš„è§†å›¾ã€‚",
      "tips": ""
    },
    "Adapt your interface to any size. Design your interface to adapt naturally to different sizes. For an introduction to SwiftUI views and layout, see Declaring a custom view. For information about laying out views in UIKit, see View layout.": {
      "zh": "è®©ç•Œé¢é€‚åº”ä»»ä½•å°ºå¯¸ã€‚å°†ä½ çš„ç•Œé¢è®¾è®¡æˆèƒ½è‡ªç„¶é€‚åº”ä¸åŒå°ºå¯¸ã€‚æœ‰å…³ SwiftUI è§†å›¾å’Œå¸ƒå±€çš„ä»‹ç»ï¼Œè¯·å‚é˜…å£°æ˜è‡ªå®šä¹‰è§†å›¾ã€‚æœ‰å…³åœ¨ UIKit ä¸­å¸ƒå±€è§†å›¾çš„ä¿¡æ¯ï¼Œè¯·å‚é˜…è§†å›¾å¸ƒå±€ã€‚",
      "tips": ""
    },
    "Donâ€™t access screen details. visionOS provides reasonable values for UIScreen objects, but donâ€™t use those values to make decisions.": {
      "zh": "ä¸è¦è®¿é—®å±å¹•ç»†èŠ‚ã€‚visionOS ä¸º UIScreen å¯¹è±¡æä¾›äº†åˆç†çš„å€¼ï¼Œä½†è¯·ä¸è¦ä½¿ç”¨è¿™äº›å€¼æ¥åšå†³ç­–ã€‚",
      "tips": ""
    },
    "Specify the supported interface orientations. Add the UISupportedInterfaceOrientations key to your appâ€™s Info.plist file to specify the interface orientations it supports. Support all interface orientations whenever possible. visionOS adds an interface rotation for your app button only when this key is present.": {
      "zh": "æŒ‡å®šæ”¯æŒçš„ç•Œé¢æ–¹å‘ã€‚åœ¨åº”ç”¨çš„ Info.plist æ–‡ä»¶ä¸­æ·»åŠ  UISupportedInterfaceOrientations é”®ä»¥æŒ‡å®šæ”¯æŒçš„ç•Œé¢æ–¹å‘ã€‚è¯·å°½å¯èƒ½åœ°æ”¯æŒæ‰€æœ‰çš„ç•Œé¢æ–¹å‘ã€‚åªæœ‰å½“è¯¥é”®å­˜åœ¨æ—¶ï¼ŒvisionOS æ‰ä¼šä¸ºä½ çš„åº”ç”¨æŒ‰é’®æ·»åŠ ç•Œé¢æ—‹è½¬ã€‚",
      "tips": ""
    },
    "Update hover effects in custom views. Hover effects convey the focused view or control in your interface. Standard system views apply hover effects as needed. For custom views and controls, verify that the hover effects look appropriate in visionOS. Add or update the content shape for your hover effects if needed.": {
      "zh": "æ›´æ–°è‡ªå®šä¹‰è§†å›¾ä¸­çš„æ‚¬åœæ•ˆæœã€‚æ‚¬åœæ•ˆæœç”¨äºè¡¨æ˜ç•Œé¢ä¸­è¢«é€‰ä¸­çš„è§†å›¾æˆ–æ§ä»¶ã€‚æ ‡å‡†ç³»ç»Ÿè§†å›¾ä¼šæ ¹æ®éœ€è¦æ·»åŠ æ‚¬åœæ•ˆæœã€‚å¯¹äºè‡ªå®šä¹‰è§†å›¾å’Œæ§ä»¶ï¼Œè¯·ç¡®è®¤æ‚¬åœæ•ˆæœåœ¨ visionOS ä¸­çœ‹èµ·æ¥æ˜¯å¦åˆé€‚ã€‚å¿…è¦æ—¶ï¼Œä¸ºæ‚¬åœæ•ˆæœæ·»åŠ æˆ–æ›´æ–°å†…å®¹å½¢çŠ¶ã€‚",
      "tips": ""
    },
    "Adopt vector-based images when possible. Vector-based images scale well to different sizes while retaining a crisp appearance. If you use bitmap-based assets, make them the exact size you need. Donâ€™t use oversized assets, which require extra work to display at the correct size.": {
      "zh": "å°½å¯èƒ½é‡‡ç”¨åŸºäºçŸ¢é‡çš„å›¾åƒã€‚åŸºäºçŸ¢é‡çš„å›¾åƒå¯ä»¥å¾ˆå¥½åœ°ç¼©æ”¾è‡³ä¸åŒå°ºå¯¸ï¼ŒåŒæ—¶ä¿æŒæ¸…æ™°çš„å¤–è§‚ã€‚å¦‚æœä½ ä½¿ç”¨åŸºäºä½å›¾çš„èµ„æºï¼Œè¯·å°†å®ƒä»¬ç”Ÿæˆä¸ºæ‰€éœ€çš„ç²¾ç¡®å°ºå¯¸ã€‚ä¸è¦ä½¿ç”¨è¿‡å¤§çš„èµ„æºï¼Œå› ä¸ºé‚£æ ·éœ€è¦é¢å¤–çš„å·¥ä½œæ‰èƒ½å°†å®ƒä»¬æ˜¾ç¤ºä¸ºæ­£ç¡®å°ºå¯¸ã€‚",
      "tips": ""
    },
    "If you want visionOS to display your appâ€™s interface in a particular orientation at launch, add the UIPreferredDefaultInterfaceOrientation key to your appâ€™s Info.plist file. Set the value of the key to one of the values in your appâ€™s UISupportedInterfaceOrientations key. For example, to specify a preference for a portrait orientation, set the value to UIInterfaceOrientationPortrait. Add ~ipad or ~iphone to the key name to specify device-specific orientation preferences.": {
      "zh": "å¦‚æœä½ å¸Œæœ› visionOS åœ¨å¯åŠ¨æ—¶ä»¥ç‰¹å®šæ–¹å‘å±•ç¤ºåº”ç”¨çš„ç•Œé¢ï¼Œè¯·åœ¨åº”ç”¨çš„ Info.plist æ–‡ä»¶ä¸­æ·»åŠ  UIPreferredDefaultInterfaceOrientation é”®ç›˜ã€‚å°†è¯¥é”®çš„å€¼è®¾ç½®ä¸ºåº”ç”¨çš„ UISupportedInterfaceOrientations é”®ä¸­çš„å€¼ä¹‹ä¸€ã€‚ä¾‹å¦‚ï¼Œå¦‚è¦æŒ‡å®šåå¥½çºµå‘ï¼Œè¯·å°†å€¼è®¾ç½®ä¸º UIInterfaceOrientationPortraitã€‚åœ¨é”®åä¸­æ·»åŠ  ~ipad æˆ– ~iphone ä»¥æŒ‡å®šç‰¹å®šè®¾å¤‡çš„æ–¹å‘é¦–é€‰é¡¹ã€‚",
      "tips": ""
    },
    "Respond gracefully to missing features": {
      "zh": "ä¼˜é›…åœ°åº”å¯¹åŠŸèƒ½ç¼ºå¤±",
      "tips": ""
    },
    "If your app relies on frameworks that behave differently in visionOS, update your code to handle those differences. Availability checks give you a clear indication when you canâ€™t use a feature, but some frameworks might have more subtle behavior. Throughout your code, make sure you respond to unusual situations:": {
      "zh": "å¦‚æœä½ çš„åº”ç”¨ä¾èµ–çš„æ¡†æ¶åœ¨ visionOS ä¸­è¡¨ç°ä¸åŒï¼Œè¯·æ›´æ–°ä½ çš„ä»£ç ä»¥å¤„ç†è¿™äº›å·®å¼‚ã€‚å¯ç”¨æ€§æ£€æŸ¥ä¼šåœ¨æ— æ³•ä½¿ç”¨æŸé¡¹åŠŸèƒ½æ—¶ç»™å‡ºæ˜ç¡®æŒ‡ç¤ºï¼Œä½†æŸäº›æ¡†æ¶å¯èƒ½ä¼šæœ‰æ›´å¾®å¦™çš„å·®å¼‚ã€‚è¯·åœ¨ä½ çš„æ‰€æœ‰ä»£ç ä¸­ï¼Œç¡®ä¿èƒ½åº”å¯¹ä»¥ä¸‹å¼‚å¸¸æƒ…å†µï¼š",
      "tips": ""
    },
    "Handle error conditions. If a function throws an exception or returns an error, handle the error. Use error information to adjust your appâ€™s behavior or provide an explanation of why it canâ€™t perform certain operations.": {
      "zh": "å¤„ç†é”™è¯¯æƒ…å†µã€‚å¦‚æœå‡½æ•°æŠ›å‡ºå¼‚å¸¸æˆ–è¿”å›é”™è¯¯ï¼Œè¯·å¤„ç†é”™è¯¯ã€‚ä½¿ç”¨é”™è¯¯ä¿¡æ¯æ¥è°ƒæ•´åº”ç”¨è¡Œä¸ºï¼Œæˆ–è§£é‡Šæ— æ³•æ‰§è¡ŒæŸäº›æ“ä½œçš„åŸå› ã€‚",
      "tips": ""
    },
    "Handle nil or empty values gracefully. Validate objects and return values before you try to use them.": {
      "zh": "ä¼˜é›…åœ°å¤„ç† nil æˆ–ç©ºå€¼ã€‚åœ¨å°è¯•ä½¿ç”¨å¯¹è±¡å’Œè¿”å›å€¼ä¹‹å‰å¯¹å…¶è¿›è¡ŒéªŒè¯ã€‚",
      "tips": ""
    },
    "Update your interface. Provide appropriate messaging in your interface when a feature is missing, or remove feature-specific views entirely if you can do so cleanly. Donâ€™t leave empty views where the feature was.": {
      "zh": "æ›´æ–°ç•Œé¢ã€‚å½“æŸä¸€åŠŸèƒ½ç¼ºå¤±æ—¶ï¼Œè¯·åœ¨ç•Œé¢ä¸­æä¾›å±•ç¤ºé€‚å½“çš„ä¿¡æ¯ï¼Œå¦‚èƒ½å¹²å‡€åˆ©è½åœ°ç§»é™¤ç‰¹å®šåŠŸèƒ½è§†å›¾ï¼Œåˆ™è¯·å®Œå…¨ç§»é™¤ã€‚ä¸è¦åœ¨åŠŸèƒ½çš„åŸä½ç½®ç•™ä¸‹ç©ºè§†å›¾ã€‚",
      "tips": ""
    },
    "For information about frameworks that behave differently in visionOS, see Checking whether your existing app is compatible with visionOS.": {
      "zh": "å…³äºåœ¨ visionOS ä¸­è¡¨ç°ä¸åŒçš„æ¡†æ¶çš„ä¿¡æ¯ï¼Œè¯·å‚é˜…æ£€æŸ¥ç°æœ‰åº”ç”¨æ˜¯å¦ä¸ visionOS å…¼å®¹ã€‚",
      "tips": ""
    },
    "Remove code that uses deprecated APIs": {
      "zh": "ç§»é™¤ä½¿ç”¨äº†åºŸå¼ƒ API çš„ä»£ç ",
      "tips": ""
    },
    "If your app currently uses deprecated APIs or frameworks, update your code to use appropriate replacements. Deprecated symbols represent outdated features, and in some cases might not do anything when you call them. To prevent potential issues, replace them with modern equivalents to ensure your code behaves as expected.": {
      "zh": "å¦‚æœä½ çš„åº”ç”¨å½“å‰ä½¿ç”¨äº†åºŸå¼ƒçš„ API æˆ–æ¡†æ¶ï¼Œè¯·æ›´æ–°ä»£ç ä»¥ä½¿ç”¨é€‚å½“çš„æ›¿ä»£ã€‚åºŸå¼ƒç¬¦å·ä»£è¡¨ç€è¿‡æ—¶çš„åŠŸèƒ½ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œè°ƒç”¨å®ƒä»¬å¯èƒ½ä»€ä¹ˆä¹Ÿåšä¸äº†ã€‚ä¸ºé˜²æ­¢å‘ç”Ÿæ½œåœ¨çš„é—®é¢˜ï¼Œè¯·ä½¿ç”¨å½“å‰çš„ç­‰æ•ˆç¬¦å·æ›¿æ¢å®ƒä»¬ï¼Œä»¥ç¡®ä¿ä½ çš„ä»£ç æŒ‰é¢„æœŸè¿è¡Œã€‚",
      "tips": ""
    },
    "The following frameworks are deprecated in their entirety in iPadOS, iOS, and visionOS. If your app still uses these frameworks, move off of them immediately. The reference documentation for each framework includes information about how to update your code.": {
      "zh": "åœ¨ iPadOSã€iOS å’Œ visionOS ä¸­ï¼Œä»¥ä¸‹æ¡†æ¶å·²è¢«å®Œå…¨åºŸå¼ƒã€‚å¦‚æœä½ çš„åº”ç”¨ä»åœ¨ä½¿ç”¨è¿™äº›æ¡†æ¶ï¼Œè¯·ç«‹å³åœæ­¢ä½¿ç”¨ã€‚æ¯ä¸ªæ¡†æ¶çš„å‚è€ƒæ–‡æ¡£éƒ½åŒ…å«æœ‰å…³å¦‚ä½•æ›´æ–°ä»£ç çš„ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Accounts": {
      "zh": "Accounts",
      "tips": ""
    },
    "Address Book": {
      "zh": "Address Book",
      "tips": ""
    },
    "Address Book UI": {
      "zh": "Address Book UI",
      "tips": ""
    },
    "Assets Library": {
      "zh": "Assets Library",
      "tips": ""
    },
    "iAd": {
      "zh": "iAd",
      "tips": ""
    },
    "Newsstand Kit": {
      "zh": "Newsstand Kit",
      "tips": ""
    },
    "NotificationCenter": {
      "zh": "NotificationCenter",
      "tips": ""
    },
    "OpenGL ES": {
      "zh": "OpenGL ES",
      "tips": ""
    }
  },
  "visionos/monitoring_playback_progress_in_your_app": {
    "Monitoring playback progress in your app": {
      "zh": "",
      "tips": ""
    },
    "Observe the playback of a media asset to update your appâ€™s user-interface state.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Media playback apps commonly need to monitor playback progress to drive the state of player UI or perform other actions. Monitoring this state requires a higher level of time precision than key-value observing can deliver, so AVPlayer provides specific API to observe playback time. This article describes how you can observe this state at regular intervals or as playback crosses specific time boundaries.": {
      "zh": "",
      "tips": ""
    },
    "Observe the current playback time at regular intervals": {
      "zh": "",
      "tips": ""
    },
    "The most common way to observe a playerâ€™s current time is at regular intervals. Observing it this way is useful when driving the state of a time display in a playerâ€™s user interface.": {
      "zh": "",
      "tips": ""
    },
    "To observe the playerâ€™s current time at regular intervals, call its addPeriodicTimeObserver(forInterval:queue:using:) method. This method takes a CMTime value that represents the interval at which to observe the time, a serial dispatch queue, and a callback that the player invokes at the specified time interval. The following example adds an observer that the player calls every half-second during normal playback:": {
      "zh": "",
      "tips": ""
    },
    "Always pair a call to the playerâ€™s addPeriodicTimeObserver(forInterval:queue:using:) method with a call to removeTimeObserver(_:) when youâ€™re finished monitoring the state. Failing to observe this rule results in undefined behavior.": {
      "zh": "",
      "tips": ""
    },
    "Observe the playback of specific times within a media presentation": {
      "zh": "",
      "tips": ""
    },
    "Another way to observe the player is when it crosses specific times boundaries during playback. You can respond to the passage of these times by updating your player UI or performing other actions.": {
      "zh": "",
      "tips": ""
    },
    "To have the player notify your app as it cross specific points in the media timeline, call the playerâ€™s addBoundaryTimeObserver(forTimes:queue:using:) method. This method takes an array of NSValue objects that wrap CMTime values that define your boundary times, a serial dispatch queue, and a callback closure. The following example shows how to define boundary times for each quarter of playback:": {
      "zh": "",
      "tips": ""
    },
    "If you add either a periodic or boundary time observer, you need to remove observation by calling removeTimeObserver(_:) when complete.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/placing-content-on-detected-planes": {
    "Placing content on detected planes": {
      "zh": "åœ¨æ£€æµ‹åˆ°çš„å¹³é¢ä¸Šæ”¾ç½®å†…å®¹",
      "tips": ""
    },
    "Detect horizontal surfaces like tables and floors, as well as vertical planes like walls and doors.": {
      "zh": "æ£€æµ‹æ°´å¹³å¹³é¢ï¼ˆå¦‚æ¡Œå­å’Œåœ°æ¿ï¼‰ä»¥åŠå‚ç›´å¹³é¢ï¼ˆå¦‚å¢™å£å’Œé—¨ï¼‰ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "Flat surfaces are an ideal place to position content in an app that uses a Full Space in visionOS. They provide a place for virtual 3D content to live alongside a personâ€™s surroundings. Use plane detection in ARKit to detect these kinds of surfaces and filter the available planes based on criteria your app might need, such as the size of the plane, its proximity to someone, or a required plane orientation.": {
      "zh": "å¹³é¢æ˜¯åœ¨ visionOS ä¸Šä½¿ç”¨â€œå®Œæ•´ç©ºé—´â€çš„åº”ç”¨ä¸­æ”¾ç½®å†…å®¹çš„ç†æƒ³åœºæ‰€ã€‚å®ƒä»¬ä¸ºè™šæ‹Ÿ 3D å†…å®¹æä¾›äº†ä¸ç”¨æˆ·å‘¨å›´ç¯å¢ƒå…±å­˜çš„åœºæ‰€ã€‚ä½¿ç”¨ ARKit ä¸­çš„å¹³é¢æ£€æµ‹åŠŸèƒ½å¯æ£€æµ‹åˆ°è¿™ç±»è¡¨é¢ï¼Œå¹¶æ ¹æ®ä½ çš„åº”ç”¨å¯èƒ½éœ€è¦çš„æ¡ä»¶ï¼ˆå¦‚å¹³é¢å¤§å°ã€ä¸ç”¨æˆ·çš„è·ç¦»æˆ–æ‰€éœ€çš„å¹³é¢æ–¹å‘ï¼‰è¿‡æ»¤å¯ç”¨çš„å¹³é¢ã€‚",
      "tips": ""
    },
    "Use RealityKit anchor entities for basic plane anchoring": {
      "zh": "ä½¿ç”¨ RealityKit é”šç‚¹å®ä½“è¿›è¡ŒåŸºæœ¬çš„å¹³é¢é”šå®š",
      "tips": ""
    },
    "If you donâ€™t need a specific plane in your app and youâ€™re rendering your appâ€™s 3D content in RealityKit, you can use an AnchorEntity instead. This approach lets you attach 3D content to a plane without prompting the person for world-sensing permission and without any particular knowledge of where that plane is relative to the person.": {
      "zh": "å¦‚æœä½ çš„åº”ç”¨ä¸éœ€è¦ç‰¹å®šçš„å¹³é¢ï¼Œè€Œä¸”ä½ åœ¨ä½¿ç”¨ RealityKit æ¸²æŸ“åº”ç”¨çš„ 3D å†…å®¹ï¼Œé‚£ä¹ˆä½ å¯ä»¥ä½¿ç”¨é”šç‚¹å®ä½“ï¼ˆAnchorEntityï¼‰ä½œä¸ºä»£æ›¿ã€‚è¿™ç§æ–¹æ³•å¯ä»¥è®©ä½ å°† 3D å†…å®¹æ·»åŠ åˆ°ä¸€ä¸ªå¹³é¢ä¸Šï¼Œä¸”æ— éœ€æç¤ºç”¨æˆ·è·å¾—ä¸–ç•Œæ„ŸçŸ¥æƒé™ï¼Œä¹Ÿæ— éœ€å»äº†è§£è¯¥å¹³é¢ç›¸å¯¹äºç”¨æˆ·çš„ä½ç½®ã€‚",
      "tips": ""
    },
    "The following shows an anchor that you can use to attach entities to a table:": {
      "zh": "ä¸‹ä»£ç æ˜¾ç¤ºäº†ä¸€ä¸ªé”šç‚¹ï¼Œä½ å¯ä»¥ç”¨å®ƒå°†å®ä½“æ·»åŠ åˆ°æ¡Œå­ä¸Šï¼š",
      "tips": ""
    },
    "Anchor entities donâ€™t let you choose a specific plane in a personâ€™s surroundings, but rather let you ask for a plane with certain characteristics. When you need more specific plane selection or real-time information about the planeâ€™s position and orientation in the world, use ARKitSession and PlaneDetectionProvider.": {
      "zh": "é”šç‚¹å®ä½“ä¸å…è®¸ä½ é€‰æ‹©äººç‰©å‘¨å›´ç¯å¢ƒä¸­çš„ç‰¹å®šå¹³é¢ï¼Œè€Œæ˜¯å…è®¸ä½ è¯·æ±‚å…·æœ‰æŸäº›ç‰¹å¾çš„å¹³é¢ã€‚å½“ä½ éœ€è¦é€‰æ‹©æ›´å…·ä½“çš„å¹³é¢æˆ–æœ‰å…³å¹³é¢åœ¨ä¸–ç•Œä¸­ä½ç½®å’Œæ–¹å‘çš„å®æ—¶ä¿¡æ¯æ—¶ï¼Œè¯·ä½¿ç”¨ ARKitSession å’Œ PlaneDetectionProviderã€‚",
      "tips": ""
    },
    "Configure an ARKit session for plane detection": {
      "zh": "ä¸ºå¹³é¢æ£€æµ‹é…ç½® ARKit ä¼šè¯",
      "tips": ""
    },
    "Plane-detection information comes from an ARKitSession thatâ€™s configured to use a PlaneDetectionProvider. You can choose to detect horizontal planes, vertical planes, or both. Each plane that ARKit detects comes with a classification, like PlaneAnchor.Classification.table or PlaneAnchor.Classification.floor. You can use these classifications to further refine which kinds of planes your app uses to present content. Plane detection requires ARKitSession.AuthorizationType.worldSensing authorization.": {
      "zh": "å¹³é¢æ£€æµ‹ä¿¡æ¯æ¥è‡ªé…ç½®äº† PlaneDetectionProvider çš„ ARKitSessionã€‚ä½ å¯ä»¥é€‰æ‹©æ£€æµ‹æ°´å¹³æˆ–å‚ç›´å¹³é¢æˆ–ä¸¤è€…ã€‚ARKit æ£€æµ‹åˆ°çš„æ¯ä¸ªå¹³é¢éƒ½æœ‰ä¸€ä¸ªåˆ†ç±»ï¼Œå¦‚ PlaneAnchor.Classification.table æˆ– PlaneAnchor.Classification.floorã€‚ä½ å¯ä»¥ä½¿ç”¨è¿™äº›åˆ†ç±»æ¥è¿›ä¸€æ­¥é€‰æ‹©ç”¨å“ªç±»å¹³é¢æ¥åº”ç”¨ä¸­å‘ˆç°å†…å®¹ã€‚å¹³é¢æ£€æµ‹éœ€è¦ ARKitSession.AuthorizationType.worldSensing æˆæƒã€‚",
      "tips": ""
    },
    "The following starts a session that detects both horizontal and vertical planes, but filters out planes classified as windows:": {
      "zh": "ä¸‹é¢ä»£ç å¯åŠ¨çš„ä¼šè¯å¯æ£€æµ‹æ°´å¹³å’Œå‚ç›´å¹³é¢ï¼Œä½†ä¼šè¿‡æ»¤æ‰è¢«å½’ç±»ä¸ºçª—å£çš„å¹³é¢ï¼š",
      "tips": ""
    },
    "Create and update entities associated with each plane": {
      "zh": "åˆ›å»ºå¹¶æ›´æ–°ä¸å¹³é¢å…³è”çš„å®ä½“",
      "tips": ""
    },
    "If youâ€™re displaying content that needs to appear attached to a particular plane, update your content whenever you receive new information from ARKit. When a plane is no longer available in the personâ€™s surroundings, ARKit sends a removal event. Respond to these events by removing content associated with the plane.": {
      "zh": "å¦‚æœä½ åœ¨æ˜¾ç¤ºéœ€è¦ç»‘å®šè‡³ç‰¹å®šå¹³é¢çš„å†…å®¹ï¼Œè¯·åœ¨æ”¶åˆ°æ¥è‡ª ARKit çš„æ–°ä¿¡æ¯æ—¶æ›´æ–°è¿™äº›å†…å®¹ã€‚å½“ç”¨æˆ·å‘¨å›´ç¯å¢ƒä¸­çš„æŸä¸ªå¹³é¢ä¸å†å¯ç”¨æ—¶ï¼ŒARKit ä¼šå‘é€ç§»é™¤äº‹ä»¶ã€‚è¯·é€šè¿‡ç§»é™¤ä¸å¹³é¢ç›¸å…³çš„å†…å®¹æ¥å“åº”ç§»é™¤äº‹ä»¶ã€‚",
      "tips": ""
    },
    "The following shows plane updates that place a text entity on each plane in a personâ€™s surroundings; the text entity displays the kind of plane ARKit detected:": {
      "zh": "ä¸‹é¢ä»£ç å±•ç¤ºäº†æ›´æ–°å¹³é¢è¿‡ç¨‹ï¼šå‘ç”¨æˆ·å‘¨å›´çš„æ¯ä¸ªå¹³é¢ä¸Šæ”¾ç½®æ–‡æœ¬å®ä½“ï¼›æ–‡æœ¬å®ä½“æ˜¾ç¤ºçš„æ˜¯ ARKit æ£€æµ‹åˆ°çš„å¹³é¢ç±»å‹ï¼š",
      "tips": ""
    }
  },
  "visionos/positioning-and-sizing-windows": {
    "Positioning and sizing windows": {
      "zh": "å®šä½å’Œè°ƒæ•´çª—å£å¤§å°",
      "tips": ""
    },
    "Influence the initial geometry of windows that your app presents.": {
      "zh": "å½±å“åº”ç”¨å‘ˆç°çš„çª—å£çš„åˆå§‹å‡ ä½•ä½ç½®å’Œå¤§å°",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "visionOS and macOS enable people to move and resize windows. In some cases, your app can use scene modifiers to influence a windowâ€™s initial geometry on these platforms, as well as to specify the strategy that the system employs to place minimum and maximum size limitations on a window. This kind of configuration affects both windows and volumes, which are windows with the volumetric window style.": {
      "zh": "visionOS å’Œ macOS å…è®¸ç”¨æˆ·èƒ½å¤Ÿç§»åŠ¨å’Œè°ƒæ•´çª—å£å¤§å°ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä½ çš„åº”ç”¨å¯ä»¥ä½¿ç”¨åœºæ™¯ä¿®é¥°å™¨æ¥å½±å“çª—å£åœ¨è¿™äº›å¹³å°ä¸Šçš„åˆå§‹å‡ ä½•ä½ç½®å’Œå¤§å°ï¼Œä»¥åŠæŒ‡å®šç³»ç»Ÿç”¨äºåœ¨çª—å£ä¸Šè®¾ç½®æœ€å°å’Œæœ€å¤§å°ºå¯¸é™åˆ¶çš„ç­–ç•¥ã€‚è¿™ç§é…ç½®ä¼šå½±å“çª—å£å’Œç«‹ä½“çª—å£ï¼ˆå…·æœ‰ volumetric çª—å£æ ·å¼çš„çª—å£ï¼‰ã€‚",
      "tips": ""
    },
    "Your ability to configure window size and position is subject to the following constraints:": {
      "zh": "é…ç½®çª—å£å¤§å°å’Œä½ç½®çš„èƒ½åŠ›å—ä»¥ä¸‹é™åˆ¶ï¼š",
      "tips": ""
    },
    "The system might be unable to fulfill your request. For example, if you specify a default size thatâ€™s outside the range of the windowâ€™s resizability, the system clamps the affected dimension to keep it in range.": {
      "zh": "ç³»ç»Ÿå¯èƒ½æ— æ³•æ»¡è¶³ä½ çš„è¯·æ±‚ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæŒ‡å®šçš„é»˜è®¤å¤§å°è¶…å‡ºäº†çª—å£å¤§å°çš„å¯è°ƒæ•´èŒƒå›´ï¼Œåˆ™ç³»ç»Ÿä¼šæ”¶ç¼©å—å½±å“çš„å°ºå¯¸ä»¥ä½¿å…¶ä¿æŒåœ¨åˆç†èŒƒå›´å†…ã€‚",
      "tips": ""
    },
    "Although you can change the windowâ€™s content, you canâ€™t directly manipulate window position or size after the window appears. This ensures that people have full control over their workspace.": {
      "zh": "è™½ç„¶ä½ å¯ä»¥æ›´æ”¹çª—å£çš„å†…å®¹ï¼Œä½†ä¸èƒ½åœ¨çª—å£å‡ºç°åç›´æ¥æ“ä½œçª—å£ä½ç½®æˆ–å¤§å°ã€‚è¿™ç¡®ä¿äº†ç”¨æˆ·å¯ä»¥å®Œå…¨æ§åˆ¶ä»–ä»¬çš„å·¥ä½œç©ºé—´ã€‚",
      "tips": ""
    },
    "During state restoration, the system restores windows to their previous position and size.": {
      "zh": "åœ¨ app çŠ¶æ€æ¢å¤çš„æ—¶å€™ï¼Œç³»ç»Ÿä¼šå°†çª—å£æ¢å¤åˆ°å…¶ä»¥å‰çš„ä½ç½®å’Œå¤§å°ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "æ³¨æ„",
      "tips": ""
    },
    "Windows in iPadOS occupy the full screen, or share the screen with another window in Slide Over or Split View. You canâ€™t programmatically affect window geometry on that platform.": {
      "zh": "iPadOS ä¸­çš„çª—å£å æ®å…¨å±ï¼Œæˆ–åœ¨â€œä¾§æ‹‰â€ï¼ˆSlide Overï¼‰æˆ–â€œåˆ†å±æµè§ˆâ€ï¼ˆSplitï¼‰ä¸­ä¸å¦ä¸€ä¸ªçª—å£å…±äº«å±å¹•ã€‚ä½ æ— æ³•ä»¥ç¼–ç¨‹æ–¹å¼å½±å“è¯¥å¹³å°ä¸Šçš„çª—å£å‡ ä½•ä½ç½®å’Œå¤§å°ã€‚",
      "tips": ""
    },
    "Specify initial window position": {
      "zh": "æŒ‡å®šçª—å£åˆå§‹ä½ç½®",
      "tips": ""
    },
    "In macOS, the first time your app opens a window from a particular scene declaration, the system places the window at the center of the screen by default. For scene types that support multiple simultaneous windows, the system offsets each additional window by a small amount to avoid fully obscuring existing windows.": {
      "zh": "åœ¨ macOS ä¸­ï¼Œå½“ä½ çš„ App é¦–æ¬¡ä»ç‰¹å®šåœºæ™¯å£°æ˜ä¸­æ‰“å¼€çª—å£æ—¶ï¼Œç³»ç»Ÿä¼šé»˜è®¤å°†è¯¥çª—å£ç½®äºå±å¹•ä¸­å¤®ã€‚å¯¹äºæ”¯æŒå¤šä¸ªåŒæ—¶å¹¶å­˜çª—å£çš„åœºæ™¯ç±»å‹ï¼Œç³»ç»Ÿä¼šå°†æ¯ä¸ªæ–°æ·»åŠ çš„çª—å£åç§»ä¸€å°æ®µè·ç¦»ï¼Œä»¥é¿å…å®Œå…¨é®æŒ¡ç°æœ‰çª—å£ã€‚",
      "tips": ""
    },
    "You can override the default placement of the first window in macOS by applying the defaultPosition(_:) scene modifier to indicate where to place the window relative to the screen bounds. For example, you can request that the system place a new window in the bottom trailing corner of the screen:": {
      "zh": "ä½ å¯ä»¥é€šè¿‡åº”ç”¨ defaultPosition(_:) åœºæ™¯ä¿®é¥°å™¨æ¥æŒ‡ç¤ºçª—å£ç›¸å¯¹äºå±å¹•è¾¹ç•Œçš„æ”¾ç½®ä½ç½®ï¼Œä»è€Œè¦†ç›– macOS ä¸­é¦–ä¸ªçª—å£çš„é»˜è®¤ä½ç½®ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥è¯·æ±‚ç³»ç»Ÿåœ¨å±å¹•çš„å³ä¸‹è§’æ”¾ç½®ä¸€ä¸ªæ–°çª—å£ï¼š",
      "tips": ""
    },
    "The system aligns the point in the window that corresponds to the specified UnitPoint with the point in the screen that corresponds to the same unit point. You can use a built-in unit point, like bottomTrailing in the above example, or define a custom one.": {
      "zh": "ç³»ç»Ÿå°†çª—å£ä¸­ä¸æŒ‡å®š UnitPoint ç‚¹ç›¸å¯¹åº”çš„ç‚¹ä¸å±å¹•ä¸­ä¸åŒä¸€å•ä½ç‚¹ç›¸å¯¹åº”çš„ç‚¹å¯¹é½ã€‚ä½ å¯ä»¥ä½¿ç”¨å†…ç½®å•ä½ç‚¹ï¼ˆå¦‚ä¸Šä¾‹æ‰€ç¤ºçš„ bottomTrailingï¼‰ï¼Œä¹Ÿå¯ä»¥å®šä¹‰ä¸€ä¸ªè‡ªå®šä¹‰å•ä½ç‚¹ã€‚",
      "tips": ""
    },
    "Important": {
      "zh": "é‡è¦",
      "tips": ""
    },
    "You canâ€™t use defaultPosition(_:) in visionOS. The system always places new windows directly in front of people, where they happen to be looking at the moment the window opens. This helps to make people aware of new windows.": {
      "zh": "ä½ ä¸èƒ½åœ¨ visionOS ä¸­ä½¿ç”¨ defaultPosition(_:)ã€‚visionOS æ€»æ˜¯å°†æ–°çª—å£ç›´æ¥æ”¾ç½®åœ¨ç”¨æˆ·é¢å‰ï¼Œåœ¨çª—å£æ‰“å¼€æ—¶ç”¨æˆ·ä¸€çœ¼å°±èƒ½çœ‹åˆ°çš„ä½ç½®ã€‚è¿™æœ‰åŠ©äºç”¨æˆ·æ„ŸçŸ¥æ–°çª—å£çš„å‡ºç°ã€‚",
      "tips": ""
    },
    "Specify initial window size": {
      "zh": "æŒ‡å®šçª—å£åˆå§‹å¤§å°",
      "tips": ""
    },
    "You can indicate a default initial size for a new window that the system creates from a Scene declaration by applying one of the default size scene modifiers, like defaultSize(width:height:). For example, you can request that new windows that a WindowGroup generates occupy 600 points in the x-dimension and 400 points in the y-dimension:": {
      "zh": "ä½ å¯ä»¥é€šè¿‡åº”ç”¨é»˜è®¤å¤§å°åœºæ™¯ä¿®é¥°å™¨çš„å…¶ä¸­ä¸€ä¸ªï¼ˆå¦‚ defaultSize(width:height:) ï¼‰æ¥æŒ‡ç¤ºç³»ç»Ÿä» Scene å£°æ˜ä¸­åˆ›å»ºçš„æ–°çª—å£çš„é»˜è®¤åˆå§‹å¤§å°ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥è¯·æ±‚ WindowGroup ç”Ÿæˆçš„æ–°çª—å£åœ¨ x ç»´åº¦ä¸­å æ® 600 ä¸ªç‚¹ï¼Œåœ¨ y ç»´åº¦ä¸­å æ® 400 ä¸ªç‚¹ï¼š",
      "tips": ""
    },
    "The system might clamp the actual size of the window depending on both the windowâ€™s content and resizability settings.": {
      "zh": "ç³»ç»Ÿå¯èƒ½ä¼šæ ¹æ®çª—å£çš„å†…å®¹å’Œå¯è°ƒæ•´å¤§å°è®¾ç½®æ¥é™åˆ¶çª—å£çš„å®é™…å¤§å°ã€‚",
      "tips": ""
    },
    "Specify window resizability": {
      "zh": "æŒ‡å®šçª—å£å¤§å°çš„å¯è°ƒæ•´æ€§",
      "tips": ""
    },
    "Both macOS and visionOS provide interface controls that enable people to resize windows, within certain limits. For example, people can use the control that appears when they look at the corner of a visionOS window to resize a window on that platform.": {
      "zh": "macOS å’Œ visionOS éƒ½æä¾›ç›¸åº”çš„ç•Œé¢æ§ä»¶ï¼Œä½¿ç”¨æˆ·èƒ½å¤Ÿåœ¨ä¸€å®šé™åˆ¶å†…è°ƒæ•´çª—å£å¤§å°ã€‚ä¾‹å¦‚ï¼Œç”¨æˆ·å¯ä»¥ä½¿ç”¨æŸ¥çœ‹ visionOS çª—å£è§’è½æ—¶å‡ºç°çš„æ§ä»¶æ¥è°ƒæ•´è¯¥ç³»ç»Ÿå¹³å°ä¸Šçš„çª—å£å¤§å°ã€‚",
      "tips": ""
    },
    "You can specify how the system limits window resizability. The default resizability for all scenes is automatic. With that strategy, Settings windows use the contentSize strategy, where both the minimum and maximum window size match the respective minimum and maximum sizes of the content that the window contains. Other scene types use contentMinSize by default, which retains the minimum size restriction, but doesnâ€™t limit the maximium size.": {
      "zh": "ä½ å¯ä»¥æŒ‡å®šç³»ç»Ÿå¯¹çª—å£å°ºå¯¸è°ƒæ•´çš„é™åˆ¶ã€‚æ‰€æœ‰åœºæ™¯çš„é»˜è®¤å¯è°ƒæ•´æ€§ä¸º automaticã€‚åº”ç”¨è¯¥ç­–ç•¥æ—¶ï¼ŒSettings çª—å£ä½¿ç”¨è¯¥ contentSize ç­–ç•¥ï¼Œ å…¶ä¸­æœ€å°å’Œæœ€å¤§çª—å£å°ºå¯¸éƒ½ä¸çª—å£æ‰€åŒ…å«å†…å®¹çš„æœ€å°å’Œæœ€å¤§å°ºå¯¸ç›¸åŒ¹é…ã€‚å…¶ä»–åœºæ™¯ç±»å‹é»˜è®¤ä½¿ç”¨ contentMinSize ç­–ç•¥ ï¼Œå®ƒä¿ç•™äº†æœ€å°å°ºå¯¸é™åˆ¶ï¼Œä½†å¹¶ä¸é™åˆ¶æœ€å¤§å°ºå¯¸ã€‚",
      "tips": ""
    },
    "You can specify one of these resizability strategies explicitly by adding the windowResizability(_:) scene modifier to a scene. For example, people can resize windows from the following window group to between 100 and 400 points in both dimensions because the frame modifier imposes those bounds on the content view:": {
      "zh": "ä½ å¯ä»¥é€šè¿‡å‘åœºæ™¯æ·»åŠ  windowResizability(_:) åœºæ™¯ä¿®æ”¹å™¨æ¥æ˜¾å¼æŒ‡å®šæŸä¸ªç‰¹å®šçš„å¯è°ƒæ•´å°ºå¯¸ç­–ç•¥ã€‚ä¾‹å¦‚ï¼Œç”¨æˆ·å¯ä»¥å°†çª—å£çš„å¤§å°ä»ä»¥ä¸‹çª—å£ç»„è°ƒæ•´ä¸ºä¸¤ä¸ªç»´åº¦çš„ 100 åˆ° 400 ç‚¹ä¹‹é—´ï¼Œå› ä¸º frame ä¿®é¥°å™¨ä¼šå°†è¿™äº›è¾¹ç•Œå¼ºåŠ åœ¨å†…å®¹è§†å›¾ä¸Šï¼š",
      "tips": ""
    },
    "You can take this even further and enforce a specific size for a window with content that has a fixed size.": {
      "zh": "ä½ å¯ä»¥æ›´è¿›ä¸€æ­¥ï¼Œä¸ºå…·æœ‰å›ºå®šå¤§å°çš„å†…å®¹çš„çª—å£å¼ºåˆ¶æŒ‡å®šå°ºå¯¸ã€‚",
      "tips": ""
    },
    "Specify a volume size": {
      "zh": "æŒ‡å®šä¸€ä¸ªç«‹ä½“çª—å£çš„å¤§å°",
      "tips": ""
    },
    "When you create a volume, which is a window with the volumetric style, you can specify the volumeâ€™s size using one of the three-dimensional default size modifiers, like defaultSize(width:height:depth:in:). The following code creates a volume thatâ€™s one meter on a side:": {
      "zh": "å½“ä½ åˆ›å»ºä¸€ä¸ªç«‹ä½“çª—å£ï¼ˆå…·æœ‰ volumetric çª—å£æ ·å¼çš„çª—å£ï¼‰æ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨ä¸‰ç»´çš„é»˜è®¤å°ºå¯¸ä¿®é¥°å™¨ï¼ˆå¦‚ defaultSize(width:height:depth:in:)ï¼‰ï¼‰ã€‚",
      "tips": ""
    },
    "The volume maintains this size for its entire lifetime. People canâ€™t change the size of a volume at runtime.": {
      "zh": "ç«‹ä½“çª—å£å°†åœ¨å…¶æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…ä¿æŒæ­¤å¤§å°ã€‚ç”¨æˆ·æ— æ³•åœ¨è¿è¡Œæ—¶æ›´æ”¹ç«‹ä½“çª—å£çš„å¤§å°ã€‚",
      "tips": ""
    },
    "Although you can specify a volumeâ€™s size in points, itâ€™s typically better to use physical units, like the above code which specifies a size in meters. This is because the system renders a volume with fixed scaling rather than dynamic scaling, unlike a regular window, which means the volume appears more like a physical object than a user interface. For information about the different kinds of scaling, see Spatial layout.": {
      "zh": "è™½ç„¶ä½ å¯ä»¥ä»¥â€œç‚¹â€ä¸ºå•ä½æŒ‡å®šç«‹ä½“çª—å£çš„å¤§å°ï¼Œä½†é€šå¸¸æœ€å¥½ä½¿ç”¨ç‰©ç†å•ä½ï¼Œå¦‚ä¸Šé¢çš„ä»£ç ï¼Œå®ƒä»¥ç±³ä¸ºå•ä½æŒ‡å®šå¤§å°ã€‚è¿™æ˜¯å› ä¸ºä¸å¸¸è§„çª—å£ä¸åŒï¼Œç³»ç»Ÿä»¥å›ºå®šç¼©æ”¾è€Œä¸æ˜¯åŠ¨æ€ç¼©æ”¾çš„å½¢å¼æ¥å‘ˆç°ç«‹ä½“çª—å£ï¼Œè¿™æ„å‘³ç€ç«‹ä½“çª—å£çœ‹èµ·æ¥æ›´åƒæ˜¯ç‰©ç†å¯¹è±¡ï¼Œè€Œä¸æ˜¯ç”¨æˆ·ç•Œé¢ã€‚æœ‰å…³ä¸åŒç±»å‹ç¼©æ”¾çš„ä¿¡æ¯ï¼Œè¯·å‚é˜…ç©ºé—´å¸ƒå±€ã€‚",
      "tips": ""
    }
  },
  "visionos/presenting-windows-and-spaces": {
    "Presenting windows and spaces": {
      "zh": "å±•ç¤ºçª—å£å’Œç©ºé—´",
      "tips": ""
    },
    "Open and close the scenes that make up your appâ€™s interface.": {
      "zh": "æ‰“å¼€å’Œå…³é—­ç»„æˆåº”ç”¨ç•Œé¢çš„åœºæ™¯ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "An appâ€™s scenes, which contain views that people interact with, can take different forms. For example, a scene can fill a window, a tab in a window, or an entire screen. Some scenes can even place views throughout a personâ€™s surroundings. How a scene appears depends on its type, the platform, and the context.": {
      "zh": "ä¸€ä¸ªåº”ç”¨ç¨‹åºçš„åœºæ™¯ï¼ŒåŒ…æ‹¬äº†ç”¨æˆ·ä¸ä¹‹è¿›è¡Œäº¤äº’çš„è§†å›¾ï¼Œå®ƒå¯ä»¥æœ‰å¤šæ ·çš„å½¢å¼ã€‚ä¾‹å¦‚ï¼Œåœºæ™¯å¯ä»¥è¢«ä¸€ä¸ªçª—å£ã€ä¸€ä¸ªçª—å£ä¸­çš„é€‰é¡¹å¡æˆ–ä¸€æ•´ä¸ªå…¶ä»–åœºæ™¯æ‰€å¡«æ»¡ã€‚æœ‰äº›åœºæ™¯ç”šè‡³å¯ä»¥å°†è§†å›¾ç½®äºç”¨æˆ·çš„å‘¨å›´ç¯å¢ƒä¸­ã€‚åœºæ™¯çš„å‡ºç°æ–¹å¼å–å†³äºå…¶ç±»å‹ã€ç³»ç»Ÿå¹³å°å’Œä¸Šä¸‹æ–‡ã€‚",
      "tips": ""
    },
    "When someone launches your app, SwiftUI looks for the first WindowGroup, Window, or DocumentGroup in your app declaration and opens a scene of that type, typically filling a new window or the entire screen, depending on the platform. For example, the following app running in macOS presents a window that contains a MailViewer view:": {
      "zh": "å½“ç”¨æˆ·å¯åŠ¨ä½ çš„ app æ—¶ï¼ŒSwiftUI ä¼šåœ¨ä½ çš„ app å£°æ˜ä¸­æŸ¥æ‰¾é¦–ä¸ª WindowGroup ã€ Window æˆ– DocumentGroup ï¼Œç„¶åæ‰“å¼€è¯¥ç±»å‹çš„åœºæ™¯ï¼Œé€šå¸¸ä¼šç”¨ä¸€ä¸ªæ–°çª—å£æˆ–æ•´ä¸ªå±å¹•å¡«å……å®ƒï¼Œå…·ä½“å–å†³äºç³»ç»Ÿå¹³å°ã€‚ä¾‹å¦‚ï¼Œåœ¨ macOS ä¸­è¿è¡Œçš„ä»¥ä¸‹åº”ç”¨ä¼šæ˜¾ç¤ºä¸€ä¸ªåŒ…å« MailViewer è§†å›¾çš„çª—å£ï¼š",
      "tips": ""
    },
    "In visionOS, you can alternatively configure your app to open the first ImmersiveSpace that the app declares. In any case, specific platforms and configurations enable you to open more than one scene at a time. Under those conditions, you can use actions that appear in the environment to programmatically open and close the scenes in your app.": {
      "zh": "åœ¨ visionOS ä¸­ï¼Œæ‚¨ä¹Ÿå¯ä»¥å°† app é…ç½®ä¸ºæ‰“å¼€ app å£°æ˜çš„é¦–ä¸ª ImmersiveSpace ã€‚åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œç‰¹å®šçš„å¹³å°å’Œé…ç½®éƒ½å…è®¸æ‚¨ä¸€æ¬¡æ‰“å¼€å¤šä¸ªåœºæ™¯ã€‚åœ¨è¿™äº›æ¡ä»¶ä¸‹ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ç¯å¢ƒä¸­å‡ºç°çš„æ“ä½œäººä¸ºåœ°æ‰“å¼€å’Œå…³é—­åº”ç”¨ä¸­çš„åœºæ™¯ã€‚",
      "tips": ""
    },
    "Check for multiple-scene support": {
      "zh": "æ£€æŸ¥å¤šåœºæ™¯æ”¯æŒ",
      "tips": ""
    },
    "If you share code among different platforms and need to find out at runtime whether the current system supports displaying multiple scenes, read the supportsMultipleWindows environment value. The following code creates a button thatâ€™s hidden unless the app supports multiple windows:": {
      "zh": "å¦‚æœæ‚¨åœ¨ä¸åŒç³»ç»Ÿå¹³å°ä¸Šå…±äº«ä¸€å¥—ä»£ç ï¼Œå¹¶ä¸”éœ€è¦åœ¨è¿è¡Œæ—¶äº†è§£å½“å‰ç³»ç»Ÿæ˜¯å¦æ”¯æŒæ˜¾ç¤ºå¤šä¸ªåœºæ™¯ï¼Œè¯·è¯»å– supportsMultipleWindows ç¯å¢ƒå˜é‡ã€‚ä»¥ä¸‹ä»£ç åˆ›å»ºäº†ä¸€ä¸ªæŒ‰é’®ï¼Œåªæœ‰åœ¨ app æ”¯æŒå¤šä¸ªçª—å£æ—¶æŒ‰é’®æ‰ä¼šæ˜¾ç¤ºï¼š",
      "tips": ""
    },
    "The value that you read depends on both the platform and how you configure your app:": {
      "zh": "ä½ è¯»å–åˆ°çš„å€¼ç”±å¹³å°å’Œä½ çš„ app é…ç½®å…±åŒå†³å®šï¼š",
      "tips": ""
    },
    "In macOS, this property returns true for any app that uses the SwiftUI app lifecycle.": {
      "zh": "åœ¨ macOS ä¸­ï¼Œå¯¹äºä½¿ç”¨ SwiftUI app ç”Ÿå‘½å‘¨æœŸçš„ä»»ä½• appï¼Œè¯¥å€¼è¿”å› true ã€‚",
      "tips": ""
    },
    "In iPadOS and visionOS, this property returns true for any app that uses the SwiftUI app lifecycle and has the Information Property List key UIApplicationSupportsMultipleScenes set to true, and false otherwise.": {
      "zh": "åœ¨ iPadOS å’Œ visionOS ä¸­ï¼Œå¯¹äºä½¿ç”¨ SwiftUI app ç”Ÿå‘½å‘¨æœŸä¸” info plist ä¸­é”® UIApplicationSupportsMultipleScenes è®¾ä¸º true çš„ä»»ä½• appï¼Œæ­¤å±æ€§è¿”å› true ï¼Œå¦åˆ™è¿”å› false ã€‚",
      "tips": ""
    },
    "For all other platforms and configurations, the value returns false.": {
      "zh": "å¯¹äºæ‰€æœ‰å…¶ä»–ç³»ç»Ÿå¹³å°å’Œé…ç½®ï¼Œè¯¥å€¼è¿”å› false ã€‚",
      "tips": ""
    },
    "If your app only ever runs in one of these situations, you can assume the associated behavior and donâ€™t need to check the value.": {
      "zh": "å¦‚æœæ‚¨çš„ app ä»…åœ¨å…¶ä¸­ä¸€ç§æƒ…å†µä¸‹è¿è¡Œï¼Œåˆ™å¯ä»¥é»˜è®¤å…¶é‡‡å–å¯¹åº”çš„è¡Œä¸ºï¼Œè€Œæ— éœ€æ£€æŸ¥è¯¥å€¼ã€‚",
      "tips": ""
    },
    "Enable multiple simultaneous scenes": {
      "zh": "åŒæ—¶å¯ç”¨å¤šä¸ªå…±å­˜åœºæ™¯",
      "tips": ""
    },
    "You can always present multiple scenes in macOS. To enable an iPadOS or visionOS app to simultaneously display multiple scenes â€” including ImmersiveSpace scenes in visionOS â€” add the UIApplicationSupportsMultipleScenes key with a value of true in the UIApplicationSceneManifest dictionary of your appâ€™s Information Property List. Use the Info tab in Xcode for your appâ€™s target to add this key:": {
      "zh": "æ‚¨å§‹ç»ˆå¯ä»¥åœ¨ macOS ä¸­å‘ˆç°å¤šä¸ªåœºæ™¯ã€‚è‹¥è¦ä½¿ iPadOS æˆ– visionOS ä¸Šçš„ app èƒ½å¤ŸåŒæ—¶æ˜¾ç¤ºå¤šä¸ªåœºæ™¯ï¼ˆåŒ…æ‹¬ visionOS ä¸­çš„ ImmersiveSpace åœºæ™¯ï¼‰ï¼Œè¯·åœ¨ app ä¸­ info.plist é‡Œçš„ UIApplicationSceneManifest å­—å…¸ä¸­æ·»åŠ å€¼ä¸º true çš„ UIApplicationSupportsMultipleScenes é”®ã€‚åœ¨ Xcode ä¸­ï¼Œé€‰æ‹©ä½  app å¯¹åº”çš„ä¸€ä¸ª target çš„ info æ ‡ç­¾é¡µä»¥æ·»åŠ æ­¤é”®ï¼š",
      "tips": ""
    },
    "Apps on other platforms can display only one scene during their lifetime.": {
      "zh": "å…¶ä»–å¹³å°ä¸Šçš„ app åœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…åªèƒ½æ˜¾ç¤ºä¸€ä¸ªåœºæ™¯ã€‚",
      "tips": ""
    },
    "Open windows programmatically": {
      "zh": "ä»¥ç¼–ç¨‹æ–¹å¼æ‰“å¼€çª—å£",
      "tips": ""
    },
    "Some platforms provide built-in controls that enable people to open instances of the window-style scenes that your app defines. For example, in macOS people can choose File > New Window from the menu bar to open a new window. SwiftUI also provides ways for you to open new windows programmatically.": {
      "zh": "æŸäº›ç³»ç»Ÿå¹³å°æä¾›å†…ç½®æ§ä»¶ï¼Œä½¿ç”¨æˆ·èƒ½å¤Ÿæ‰“å¼€ app è‡ªå®šä¹‰çš„çª—å£æ ·å¼çš„åœºæ™¯çš„å®ä¾‹ã€‚ä¾‹å¦‚ï¼Œåœ¨ macOS ä¸­ï¼Œç”¨æˆ·å¯ä»¥ä»èœå•æ ä¸­é€‰å– File > New Window ä»¥æ‰“å¼€æ–°çª—å£ã€‚SwiftUI è¿˜ä¸ºæ‚¨æä¾›äº†ä»¥ç¼–ç¨‹æ–¹å¼æ‰“å¼€æ–°çª—å£çš„æ–¹æ³•ã€‚",
      "tips": ""
    },
    "To do this, get the openWindow action from the environment and call it with an identifier, a value, or both to indicate what kind of window to open and optionally what data to open it with. The following view opens a new instance of the previously defined mail viewer window when someone clicks or taps the button:": {
      "zh": "ä¸ºæ­¤ï¼Œè¯·ä»ç¯å¢ƒä¸­è·å– openWindow æ“ä½œï¼Œå¹¶ä½¿ç”¨æ ‡è¯†ç¬¦ã€å€¼æˆ–åŒæ—¶ä½¿ç”¨ä¸¤è€…è°ƒç”¨å®ƒï¼Œä»¥æŒ‡ç¤ºè¦æ‰“å¼€çš„çª—å£ç±»å‹ä»¥åŠè¦æ‰“å¼€çš„çª—å£ï¼ˆå¯é€‰ï¼‰æ•°æ®ã€‚å½“æœ‰äººå•å‡»æˆ–è½»æŒ‰è¯¥æŒ‰é’®æ—¶ï¼Œä»¥ä¸‹è§†å›¾å°†æ‰“å¼€ä¹‹å‰å®šä¹‰çš„é‚®ä»¶æŸ¥çœ‹å™¨çª—å£çš„æ–°å®ä¾‹ï¼š",
      "tips": ""
    },
    "When the action runs on a system that supports multiple scenes, SwiftUI looks for a window in the app declaration that has a matching identifier and creates a new scene of that type.": {
      "zh": "å½“è¯¥æ“ä½œåœ¨æ”¯æŒå¤šä¸ªåœºæ™¯çš„ç³»ç»Ÿä¸Šè¿è¡Œæ—¶ï¼ŒSwiftUI ä¼šåœ¨ app å£°æ˜ä¸­æŸ¥æ‰¾å…·æœ‰åŒ¹é…æ ‡è¯†ç¬¦çš„çª—å£ï¼Œå¹¶åˆ›å»ºè¯¥ç±»å‹çš„æ–°åœºæ™¯ã€‚",
      "tips": ""
    },
    "Important": {
      "zh": "é‡è¦",
      "tips": ""
    },
    "If supportsMultipleWindows is false and you try to open a new window, SwiftUI ignores the action and logs a runtime error.": {
      "zh": "å¦‚æœåœ¨ supportsMultipleWindows ä¸º false çš„æƒ…å†µä¸‹ï¼Œæ‚¨å°è¯•æ‰“å¼€ä¸€ä¸ªæ–°çª—å£ï¼ŒSwiftUI ä¼šå¿½ç•¥è¯¥æ“ä½œå¹¶è®°å½•ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚",
      "tips": ""
    },
    "In addition to opening more instances of an appâ€™s main window, as in the above example, you can also open other window types that your appâ€™s body declares. For example, you can open an instance of the Window that displays connectivity information:": {
      "zh": "é™¤äº†æ‰“å¼€ app ä¸»çª—å£çš„æ›´å¤šå®ä¾‹ï¼ˆå¦‚ä¸Šä¾‹æ‰€ç¤ºï¼‰ä¹‹å¤–ï¼Œè¿˜å¯ä»¥æ‰“å¼€ app çš„ body å†…å£°æ˜çš„å…¶ä»–çª—å£ç±»å‹ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥æ‰“å¼€æ˜¾ç¤ºè¿æ¥ä¿¡æ¯çš„ Window å®ä¾‹ï¼š",
      "tips": ""
    },
    "Open a space programmatically": {
      "zh": "ä»¥ç¼–ç¨‹æ–¹å¼æ‰“å¼€ç©ºé—´",
      "tips": ""
    },
    "In visionOS, you open an immersive space â€” a scene that you can use to present unbounded content in a personâ€™s surroundings â€” in much the same way that you open a window, except that you use the openImmersiveSpace action. The action runs asynchronously, so you use the await keyword when you call it, and typically do so from inside a Task:": {
      "zh": "åœ¨ visionOS ä¸­ï¼Œæ‚¨å¯ä»¥æ‰“å¼€ä¸€ä¸ªæ²‰æµ¸å¼ç©ºé—´ï¼ˆå¯ç”¨äºåœ¨ç”¨æˆ·å‘¨å›´ç¯å¢ƒä¸­å‘ˆç°æ— é™å†…å®¹çš„åœºæ™¯ï¼‰ï¼Œå…¶æ–¹å¼ä¸æ‰“å¼€çª—å£çš„æ–¹å¼å¤§è‡´ç›¸åŒï¼Œåªéœ€ä½¿ç”¨ openImmersiveSpace æ“ä½œã€‚è¯¥æ“ä½œä»¥å¼‚æ­¥æ–¹å¼è¿è¡Œï¼Œå› æ­¤åœ¨è°ƒç”¨å®ƒæ—¶éœ€ä½¿ç”¨ await å…³é”®å­—ï¼Œå¹¶ä¸”é€šå¸¸åœ¨ä¸€ä¸ª Task é—­åŒ…å†…éƒ¨æ‰§è¡Œæ­¤æ“ä½œï¼š",
      "tips": ""
    },
    "Because your app operates in a Full Space when you open an ImmersiveSpace scene, you can only open one scene of this type at a time. If you try to open a space when one is already open, the system logs a runtime error.": {
      "zh": "ç”±äºå½“æ‚¨æ‰“å¼€ ImmersiveSpace åœºæ™¯æ—¶ï¼Œæ‚¨çš„åº”ç”¨åœ¨ ImmersiveSpace ä¸­è¿è¡Œï¼Œå› æ­¤æ‚¨ä¸€æ¬¡åªèƒ½æ‰“å¼€ä¸€ä¸ªæ­¤ç±»åœºæ™¯ã€‚å¦‚æœå°è¯•åœ¨ç©ºé—´å·²å­˜åœ¨æ—¶å†æ¬¡æ‰“å¼€ç©ºé—´ï¼Œç³»ç»Ÿå°†è®°å½•ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚",
      "tips": ""
    },
    "Your app can display any number of windows together with an immersive space. However, when you open a space from your app, the system hides all windows that belong to other apps. After you dismiss your space, the other appsâ€™ windows reappear. Similarly, the system hides your appâ€™s windows if another app opens an immersive space.": {
      "zh": "ä½ çš„ app å¯ä»¥åœ¨ä¸€ä¸ªæ²‰æµ¸å¼ç©ºé—´ä¸­æ˜¾ç¤ºä»»æ„æ•°é‡çš„çª—å£ã€‚ã€‚ä½†æ˜¯ï¼Œå½“æ‚¨ä» app ä¸­æ‰“å¼€ç©ºé—´æ—¶ï¼Œç³»ç»Ÿä¼šéšè—å±äºå…¶ä»–åº”ç”¨ç¨‹åºçš„æ‰€æœ‰çª—å£ã€‚å…³é—­æ‚¨çš„ app çš„ç©ºé—´åï¼Œå…¶ä»–åº”ç”¨çš„çª—å£ä¼šé‡æ–°æ˜¾ç¤ºã€‚åŒæ ·åœ°ï¼Œå¦‚æœå¦ä¸€ä¸ª app æ‰“å¼€æ²‰æµ¸å¼ç©ºé—´ï¼Œç³»ç»Ÿä¼šéšè—æ‚¨çš„ app çš„çª—å£ã€‚",
      "tips": ""
    },
    "Designate a space as your appâ€™s main interface": {
      "zh": "å°†ç©ºé—´æŒ‡å®šä¸º app çš„ä¸»ç•Œé¢",
      "tips": ""
    },
    "When visionOS launches an app, it opens the first window group, window, or document scene that the appâ€™s body declares, just like on other platforms. This is true even if you first declare a space. However, if you want to open your app into an immersive space directly, specify a space as the default scene for your app by adding the UIApplicationPreferredDefaultSceneSessionRole key to your appâ€™s information property list and setting its value to UISceneSessionRoleImmersiveSpaceApplication. In that case, visionOS opens the first space that it finds in your app declaration.": {
      "zh": "å½“ visionOS å¯åŠ¨ä¸€ä¸ª app æ—¶ï¼Œå®ƒä¼šæ‰“å¼€ app çš„ body ä¸­å£°æ˜çš„ç¬¬ä¸€ä¸ªçª—å£ç»„ã€çª—å£æˆ–æ–‡æ¡£åœºæ™¯ï¼Œå°±åƒåœ¨å…¶ä»–ç³»ç»Ÿå¹³å°ä¸Šä¸€æ ·ã€‚å³ä½¿æ‚¨å…ˆå£°æ˜çš„æ˜¯ä¸€ä¸ªç©ºé—´ï¼Œä¹Ÿæ˜¯å¦‚æ­¤ã€‚ä½†æ˜¯ï¼Œå¦‚æœè¦ç›´æ¥åœ¨æ²‰æµ¸å¼ç©ºé—´ä¸­æ‰“å¼€ appï¼Œè¯·å°† UIApplicationPreferredDefaultSceneSessionRole é”®æ·»åŠ åˆ° app çš„ info.plist ä¸­å¹¶å°†å…¶å€¼è®¾ç½®ä¸º UISceneSessionRoleImmersiveSpaceApplication ï¼Œä»è€Œå°†ç©ºé—´æŒ‡å®šä¸º app çš„é»˜è®¤åœºæ™¯ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒvisionOS ä¼šæ‰“å¼€å®ƒåœ¨ app å£°æ˜ä¸­æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªç©ºé—´ã€‚",
      "tips": ""
    },
    "Be careful not to overwhelm people when starting your app with an immersive space. For design guidance, see Immersive experiences.": {
      "zh": "åœ¨ä»¥æ²‰æµ¸å¼ç©ºé—´å¯åŠ¨ app æ—¶ï¼Œé¿å…ç”¨æˆ·äº§ç”Ÿä¸çŸ¥æ‰€æªçš„æ„Ÿè§‰ã€‚æœ‰å…³è®¾è®¡æŒ‡å—ï¼Œè¯·å‚é˜…ã€Šæ²‰æµ¸å¼ä½“éªŒã€‹ã€‚",
      "tips": ""
    },
    "Close windows programmatically": {
      "zh": "ä»¥ç¼–ç¨‹æ–¹å¼å…³é—­çª—å£",
      "tips": ""
    },
    "People can close windows using system controls, like the close button built into the frame around a macOS window. You can also close windows programmatically. Get the dismissWindow action from the environment, and call it using the identifier of the window that you want to dismiss:": {
      "zh": "ç”¨æˆ·å¯ä»¥ä½¿ç”¨ç³»ç»Ÿè‡ªå¸¦çš„æ§ä»¶å…³é—­çª—å£ï¼Œä¾‹å¦‚ macOS çª—å£ä¸Šé¢ç³»ç»Ÿé»˜è®¤çš„å…³é—­æŒ‰é’®ã€‚æ‚¨å½“ç„¶ä¹Ÿå¯ä»¥ä»¥ç¼–ç¨‹æ–¹å¼å…³é—­çª—å£ã€‚ä»ç¯å¢ƒä¸­è·å– dismissWindow æ“ä½œï¼Œå¹¶ä½¿ç”¨è¦å…³é—­çš„çª—å£çš„æ ‡è¯†ç¬¦æ¥è°ƒç”¨å®ƒï¼š",
      "tips": ""
    },
    "In iPadOS and visionOS, the system ignores the dismiss action if you use it to close a window thatâ€™s your appâ€™s only open scene.": {
      "zh": "åœ¨ iPadOS å’Œ visionOS ä¸­ï¼Œå¦‚æœè¦å…³é—­æ˜¯å½“å‰ app å”¯ä¸€æ‰“å¼€çš„åœºæ™¯ï¼Œç³»ç»Ÿä¼šå¿½ç•¥è¯¥æ“ä½œã€‚",
      "tips": ""
    },
    "Close spaces programmatically": {
      "zh": "ä»¥ç¼–ç¨‹æ–¹å¼å…³é—­ç©ºé—´",
      "tips": ""
    },
    "To close a space, call the dismissImmersiveSpace action. Like the corresponding open space action, the close action operates asynchronously and requires the await keyword:": {
      "zh": "è‹¥è¦å…³é—­ç©ºé—´ï¼Œè¯·è°ƒç”¨ dismissImmersiveSpace æ“ä½œã€‚ä¸ç›¸åº”çš„æ‰“å¼€ç©ºé—´çš„æ“ä½œç±»ä¼¼ï¼Œå…³é—­æ“ä½œæ˜¯å¼‚æ­¥æ‰§è¡Œçš„ï¼Œå¹¶ä¸”éœ€è¦ await å…³é”®å­—ï¼š",
      "tips": ""
    },
    "You donâ€™t need to specify an identifier for this action, because there can only ever be one space open at a time. Like with windows, you canâ€™t dismiss a space thatâ€™s your appâ€™s only open scene.": {
      "zh": "æ‚¨æ— éœ€ä¸ºæ­¤æ“ä½œæŒ‡å®šæ ‡è¯†ç¬¦ï¼Œå› ä¸ºä¸€æ¬¡åªèƒ½æ‰“å¼€ä¸€ä¸ªç©ºé—´ã€‚ä¸çª—å£ä¸€æ ·ï¼Œä½ ä¸èƒ½å…³é—­ app å”¯ä¸€æ‰“å¼€çš„åœºæ™¯çš„ç©ºé—´ã€‚",
      "tips": ""
    },
    "Transition between a window and a space": {
      "zh": "åœ¨çª—å£å’Œç©ºé—´ä¹‹é—´è¿‡æ¸¡",
      "tips": ""
    },
    "Because you canâ€™t programmatically close the last open window or immersive space in a visionOS app, be sure to open a new scene before closing the old one. Pay particular attention to the sequencing when moving between a window and an immersive space, because the spaceâ€™s open and dismiss actions run asynchronously.": {
      "zh": "ç”±äºæ— æ³•ä»¥ç¼–ç¨‹æ–¹å¼å…³é—­ visionOS app ä¸­ä¸Šæ¬¡æ‰“å¼€çš„çª—å£æˆ–æ²‰æµ¸å¼ç©ºé—´ï¼Œå› æ­¤è¯·åŠ¡å¿…åœ¨å…³é—­æ—§åœºæ™¯ä¹‹å‰æ‰“å¼€æ–°åœºæ™¯ã€‚åœ¨çª—å£å’Œæ²‰æµ¸å¼ç©ºé—´ä¹‹é—´ç§»åŠ¨æ—¶ï¼Œè¯·ç‰¹åˆ«æ³¨æ„äº‹ä»¶å‘ç”Ÿçš„é¡ºåºï¼Œå› ä¸ºç©ºé—´çš„æ‰“å¼€å’Œå…³é—­æ“ä½œæ˜¯å¼‚æ­¥è¿è¡Œçš„ã€‚",
      "tips": ""
    },
    "For example, consider a chess game that begins by displaying a start button in a window. When someone taps the button, the app dismisses the window and opens an immersive space that presents a chess board. The following button demonstrates proper sequencing by opening the space and then closing the window:": {
      "zh": "ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸€ä¸ªå›½é™…è±¡æ£‹æ¸¸æˆï¼Œå®ƒé¦–å…ˆåœ¨çª—å£ä¸­æ˜¾ç¤ºä¸€ä¸ªå¼€å§‹æŒ‰é’®ã€‚å½“æœ‰äººç‚¹å‡»æŒ‰é’®æ—¶ï¼Œåº”ç”¨ç¨‹åºä¼šå…³é—­çª—å£å¹¶æ‰“å¼€ä¸€ä¸ªæ˜¾ç¤ºæ£‹ç›˜çš„æ²‰æµ¸å¼ç©ºé—´ã€‚ä»¥ä¸‹æŒ‰é’®æ¼”ç¤ºäº†ä¸€ä¸ªæ­£ç¡®çš„äº‹ä»¶é¡ºåº--å…ˆæ‰“å¼€ç©ºé—´ç„¶åå…³é—­çª—å£ï¼š",
      "tips": ""
    },
    "In the above code, itâ€™s important to include the dismissWindow action inside the task, so that it waits until the openImmersiveSpace action completes. If you put the action outside the task â€” either before or after â€” it might execute before the asynchronous open action completes, when the window is still the only open scene. In that case, the system opens the space but doesnâ€™t close the window.": {
      "zh": "åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼ŒåŠ¡å¿…å°† dismissWindow æ“ä½œæ”¾åœ¨ä¸€ä¸ª Task ä¸­ï¼Œä»¥ä¾¿å®ƒä¼šç­‰å¾… openImmersiveSpace æ“ä½œå®Œæˆåæ‰§è¡Œã€‚å¦‚æœå°†æ“ä½œæ”¾åœ¨ Task ä¹‹å¤–ï¼ˆæ— è®ºæ˜¯åœ¨ Task ä¹‹å‰è¿˜æ˜¯ä¹‹åï¼‰ï¼Œå®ƒå¯èƒ½ä¼šåœ¨å¼‚æ­¥æ‰“å¼€æ“ä½œå®Œæˆä¹‹å‰æ‰§è¡Œï¼Œæ­¤æ—¶çª—å£ä»æ˜¯å”¯ä¸€æ‰“å¼€çš„åœºæ™¯ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç³»ç»Ÿä¼šæ‰“å¼€ç©ºé—´ï¼Œä½†ä¸ä¼šå…³é—­çª—å£ã€‚",
      "tips": ""
    }
  },
  "visionos/running-your-app-in-simulator-or-on-a-device": {
    "Running your app in Simulator or on a device": {
      "zh": "",
      "tips": ""
    },
    "Launch your app in a simulated iOS, tvOS, watchOS, or visionOS device, or on a device connected to a Mac.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "To test your app, build and run it on a simulated or real device. Use simulated devices to debug your app on a variety of hardware to which you donâ€™t have immediate access. The tradeoff is that simulated devices run within the Simulator app on your Mac and donâ€™t replicate the performance or features of an actual device. To verify your app runs exactly as intended, run it on one or more real devices. You can connect a real device to your Mac using a cable, or for iOS, tvOS, or visionOS apps, connect it over Wi-Fi after you pair it with Xcode.": {
      "zh": "",
      "tips": ""
    },
    "SwiftUI previews let you see your appâ€™s interface without building and running your app. For more information on these dynamic previews, see Previews in Xcode.": {
      "zh": "",
      "tips": ""
    },
    "Select a build scheme and run destination": {
      "zh": "",
      "tips": ""
    },
    "Before you build and run your app, select a build scheme that includes the target for your app. A scheme is a collection of project details and settings that tell Xcode how to build and run a product from your project. Xcode determines where the resulting product can run based on the scheme you select, and populates the run destination menu in the toolbar with the list of available devices. For example, if the scheme contains a tvOS app, Xcode includes only tvOS simulators and devices as potential run destinations.": {
      "zh": "",
      "tips": ""
    },
    "To learn more about schemes, see Customizing the build schemes for a project.": {
      "zh": "",
      "tips": ""
    },
    "Important": {
      "zh": "",
      "tips": ""
    },
    "When running apps in Simulator, some hardware-specific features might not be available. Frameworks that provide access to device-specific features also provide API to tell you when those features are available. Call those APIs and handle the case where a feature isnâ€™t available. To test the feature itself, run your code on a real device.": {
      "zh": "",
      "tips": ""
    },
    "Configure the list of simulated devices": {
      "zh": "",
      "tips": ""
    },
    "Manage real and simulated devices in the Devices and Simulators window in Xcode. To view this window, choose Window > Devices and Simulators. View and configure simulated devices from the Simulators tab.": {
      "zh": "",
      "tips": ""
    },
    "To add a new simulated device, click the plus (+) button at the bottom of the list of simulators and specify the configuration you want. You can add new simulators to specify a different device type or operating system version than the default set. To remove a simulator from the list, select it and press Delete.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "Xcode requires the Simulator runtime for each platform and system version for which you build and run Simulator. If Xcode doesnâ€™t display device types for a platform, you might need to install that platformâ€™s Simulator runtime. For more information on this installation, see Installing and managing Simulator runtimes.": {
      "zh": "",
      "tips": ""
    },
    "Connect real devices to your Mac": {
      "zh": "",
      "tips": ""
    },
    "To view and manage connections to your real devices, choose the Devices tab in the Devices and Simulators window in Xcode. The Devices tab shows the currently connected and disconnected devices and can help you diagnose problems that might occur. For example, Xcode might show a device as unavailable if itâ€™s not running an operating system version your app supports. It also shows new devices available for pairing with your Xcode installation. Pair a device with Xcode to include them in the list of run destinations for your projects.": {
      "zh": "",
      "tips": ""
    },
    "To pair a device with a physical connection, connect the device to your Mac using an appropriate cable. Unlock the device and follow any instructions that appear in Xcode or on the device.": {
      "zh": "",
      "tips": ""
    },
    "To pair Apple Vision Pro or Apple TV without a physical connection:": {
      "zh": "",
      "tips": ""
    },
    "Ensure that both your Mac and the device to connect are on the same Wi-Fi network. The Wi-Fi network must be compatible with Bonjour.": {
      "zh": "",
      "tips": ""
    },
    "Broadcast the device to the target Mac over the local network. To do this for a visionOS device, choose Settings > General > Remote Devices and for a tvOS device, choose Settings > Remotes and Devices > Remote App and Devices.": {
      "zh": "",
      "tips": ""
    },
    "Select the device from the list in the Devices and Simulators window in Xcode and click the pairing button which triggers a code to appear on the target device.": {
      "zh": "",
      "tips": ""
    },
    "Enter the code on the Mac to complete the pairing process.": {
      "zh": "",
      "tips": ""
    },
    "After pairing is complete, the device shows up under connected devices in Devices and Simulators window in Xcode. You donâ€™t need to keep a paired device physically connected to your Mac to install and run apps. If your device is connected to Wi-Fi on the same network as your Mac, Xcode can use that connection to install and run your app.": {
      "zh": "",
      "tips": ""
    },
    "To pair an Apple Watch to a Mac, connect its companion iPhone to the Mac with a cable, and ensure that the iPhone is paired for development. After this step, follow any instructions on the Apple Watch to trust the Mac. When paired through an iPhone running iOS 17 or later, Xcode connects to the Apple Watch over Wi-Fi. Series 5 and older models of Apple Watch additionally require the Apple Watch and Mac to be associated with the same Bonjour-compatible Wi-Fi network. When paired through an iPhone running older versions of iOS, Xcode requires the iPhone to remain connected to the Mac in order to develop on any model of Apple Watch.": {
      "zh": "",
      "tips": ""
    },
    "Before installing your app, perform a few additional steps:": {
      "zh": "",
      "tips": ""
    },
    "Specify your Apple ID in the Account preferences in Xcode.": {
      "zh": "",
      "tips": ""
    },
    "Specify a valid team in your projectâ€™s Signing & Capabilities pane.": {
      "zh": "",
      "tips": ""
    },
    "Code sign your macOS app if it includes capabilities that require code signing; see Adding capabilities to your app.": {
      "zh": "",
      "tips": ""
    },
    "Register the device with your team if you belong to the Apple Developer Program.": {
      "zh": "",
      "tips": ""
    },
    "Enable Developer Mode on an iOS, watchOS, or visionOS device, as described in Enabling Developer Mode on a device.": {
      "zh": "",
      "tips": ""
    },
    "You donâ€™t need to configure a Mac device to run your macOS apps. Similarly, to run the macOS version of an iPad app, choose My Mac (the Mac running Xcode) as the device.": {
      "zh": "",
      "tips": ""
    },
    "Run the app": {
      "zh": "",
      "tips": ""
    },
    "Click the Run button in the toolbar or choose Product > Run to build and run the app on the selected simulated or real device. View the status of the build in the activity area of the toolbar.": {
      "zh": "",
      "tips": ""
    },
    "If the build is successful, Xcode runs the app and opens a debugging session in the debug area. Use the controls in the debug area to step through your code, inspect variables, and interact with the debugger.": {
      "zh": "",
      "tips": ""
    },
    "If the build is unsuccessful, click the indicators in the activity area to read the error or warning messages in the Issue navigator. Alternatively, choose View > Navigators > Show Issue Navigator to view the messages.": {
      "zh": "",
      "tips": ""
    },
    "When youâ€™re done testing the app, click the Stop button in the toolbar.": {
      "zh": "",
      "tips": ""
    },
    "Interact with the simulated environment": {
      "zh": "",
      "tips": ""
    },
    "If you choose a simulated device as the run destination, Simulator launches and displays a window that corresponds to the simulated environment. For some devices, Simulator surrounds the screen content with a shell that resembles the target device. In visionOS, it displays a synthetic space to mimic the experience someone would have when they wear the device.": {
      "zh": "",
      "tips": ""
    },
    "Each device shell and space has specific controls to support interactions. For device-specific details, see the reference on interactions.": {
      "zh": "",
      "tips": ""
    },
    "Interacting with your app in the iOS and iPadOS simulator": {
      "zh": "",
      "tips": ""
    },
    "Interacting with your app in the tvOS simulator": {
      "zh": "",
      "tips": ""
    },
    "Interacting with your app in the watchOS simulator": {
      "zh": "",
      "tips": ""
    },
    "Interacting with your app in the visionOS simulator": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/setting-up-access-to-arkit-data": {
    "Setting up access to ARKit data": {
      "zh": "",
      "tips": ""
    },
    "Check whether your app can use ARKit and respect peopleâ€™s privacy.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "In visionOS, ARKit can enable new kinds of experiences that leverage data such as hand tracking and world sensing. The system gates access to this kind of sensitive information. Because people can decline your appâ€™s request to use ARKit data or revoke access later, you need to provide alternative ways to use your app and to handle cases where your app loses access to data.": {
      "zh": "",
      "tips": ""
    },
    "Add usage descriptions for ARKit data access": {
      "zh": "",
      "tips": ""
    },
    "People need to know why your app wants to access data from ARKit. Add the following keys to your appâ€™s information property list to provide a user-facing usage description that explains how your app uses the data:": {
      "zh": "",
      "tips": ""
    },
    "Use this key if your app uses hand tracking.": {
      "zh": "",
      "tips": ""
    },
    "Use this key if your app uses image tracking, plane detection, or scene reconstruction.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "World tracking â€” unlike world sensing â€” doesnâ€™t require authorization. For more information, see Tracking specific points in world space.": {
      "zh": "",
      "tips": ""
    },
    "Choose between up-front or as-needed authorization": {
      "zh": "",
      "tips": ""
    },
    "You can choose when someone sees an authorization request to use ARKit data. If you need precise control over when the request appears, call the requestAuthorization(for:) method on ARKitSession to explicitly authorize access at the time you call it. Otherwise, people see an authorization request when you call the run(_:) method. This is an implicit authorization because the timing of the request depends entirely on when you start the session.": {
      "zh": "",
      "tips": ""
    },
    "Open a space and run a session": {
      "zh": "",
      "tips": ""
    },
    "To help protect peopleâ€™s privacy, ARKit data is available only when your app presents a Full Space and other apps are hidden. Present one of these space styles before calling the run(_:) method.": {
      "zh": "",
      "tips": ""
    },
    "The following shows an app structure thatâ€™s set up to use a space with ARKit:": {
      "zh": "",
      "tips": ""
    },
    "Call openImmersiveSpace from your appâ€™s user interface to create a space, start running an ARKit session, and kick off an immersive experience. The following shows a simple view with a button that opens the space:": {
      "zh": "",
      "tips": ""
    },
    "Provide alternatives for declined and revoked authorizations": {
      "zh": "",
      "tips": ""
    },
    "Someone might not want to give your app access to data from ARKit, or they might choose to revoke that access later in Settings. Handle these situations gracefully, and remove or transition content that depends on ARKit data. For example, you might fade out content that you need to remove, or recenter content to an appropriate starting position. If your app uses ARKit data to place content in a personâ€™s surroundings, consider letting people place content using the system-provided interface.": {
      "zh": "",
      "tips": ""
    },
    "Providing alternatives is especially important if youâ€™re using ARKit for user input. People using accessibility features, trackpads, keyboards, or other forms of input might need a way to use your app without ARKit.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/swift-splash": {
    "Swift Splash": {
      "zh": "Swift Splash",
      "tips": ""
    },
    "Use RealityKit to create an interactive ride in visionOS.": {
      "zh": "ä½¿ç”¨ RealityKit åœ¨ visionOS ä¸­æ­å»ºä¸€ä¸ªäº¤äº’å¼çš„æ°´ä¸Šæ¸¸ä¹è®¾æ–½ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è§ˆ",
      "tips": ""
    },
    "Apple Vision Proâ€™s ability to combine virtual content seamlessly with the real world allows for many kinds of interactive virtual experiences. Swift Splash leverages RealityKit and Reality Composer Pro to create a virtual water slide by combining modular slide pieces. When the builder finishes their ride, they can release an adventurous goldfish to try it out.": {
      "zh": "Apple Vision Pro èƒ½å¤Ÿå°†è™šæ‹Ÿå†…å®¹å’Œç°å®ä¸–ç•Œæ— ç¼ç»“åˆï¼Œä»è€Œä¸ºè¯¸å¤šç±»å‹çš„è™šæ‹Ÿäº¤äº’ä½“éªŒæä¾›å¯èƒ½ã€‚Swift Splash ä½¿ç”¨ RealityKit å’Œ Reality Composer Pro æ¥æ„å»ºä¸€ä¸ªç”±æ¨¡å—åŒ–çš„æ»‘é“éƒ¨ä»¶ç»„æˆçš„è™šæ‹Ÿæ°´ä¸Šæ»‘æ¢¯ã€‚è€Œå½“å»ºé€ è€…å®Œæˆäº†ä»–ä»¬çš„æ¸¸ä¹è®¾æ–½ï¼Œå°±èƒ½å¤Ÿé‡Šæ”¾ä¸€åªå‹‡äºå†’é™©çš„å°é‡‘é±¼å»ä½“éªŒä»–ä»¬çš„ä½œå“ã€‚",
      "tips": ""
    },
    "Swift Splash uses multiple Reality Composer Scenes to create prepackaged entity hierarchies that represent each of the slide pieces the player connects to construct their ride. It demonstrates how to hide and reveal sections of the entity hierarchy based on the current state of the app. For example, each slide piece contains an animated fish entity thatâ€™s hidden until the ride runs and the fish arrives at that particular piece. While Swift Splash is a fun, game-like experience, the core idea of assembling virtual objects out of predefined parts can also be used as the basis for a productivity or creation app.": {
      "zh": "Swift Splash ä½¿ç”¨å¤šä¸ª Reality Composer åœºæ™¯å½¢æˆé¢„è®¾çš„å®ä½“å±‚æ¬¡ç»“æ„ï¼Œè¿™äº›ç»“æ„ä»£è¡¨äº†ç©å®¶åœ¨æ„ç­‘æ¸¸ä¹è®¾æ–½è¿‡ç¨‹ä¸­æ‰€éœ€è¦è¡”æ¥çš„æ¯ä¸€å—æ»‘é“éƒ¨ä»¶ã€‚å®ƒç¤ºèŒƒäº†å¦‚ä½•ä¾ç…§åº”ç”¨çš„å½“å‰çŠ¶æ€å»éšè—å’Œå±•ç¤ºå®ä½“å±‚æ¬¡ç»“æ„çš„éƒ¨åˆ†ã€‚ä¸¾ä¸ªä¾‹å­æ¥è¯´ï¼Œæ¯ä¸€ç‰‡æ»‘é“éƒ¨ä»¶åŒ…å«äº†ä¸€æ¡ä¼šæ¸¸åŠ¨ä½†éšè—ç€çš„é±¼ï¼Œç›´è‡³å¯åŠ¨æ•´ä¸ªæ¸¸ä¹è®¾æ–½è£…ç½®ä¸”å°é±¼åˆ°è¾¾æŒ‡å®šç‰©ä»¶æ—¶æ‰ä¼šè¢«çœ‹åˆ°ã€‚å°½ç®¡ Swift Splash çœ‹ä¸Šå»æä¾›äº†ä¸€ç§æœ‰è¶£çš„ã€ç±»ä¼¼æ¸¸æˆçš„ä½“éªŒï¼Œä¸è¿‡å…¶æœ¬è´¨åˆ©ç”¨é¢„è®¾éƒ¨åˆ†æ¥æ„é€ è™šæ‹Ÿç‰©ä»¶çš„æ ¸å¿ƒæ€æƒ³ä¹Ÿå¯ä»¥è¢«ç”¨äºç”Ÿäº§åŠ›æˆ–æ˜¯åˆ›é€ æ€§åº”ç”¨çš„åŸºç¡€ã€‚",
      "tips": ""
    },
    "Swift Splash scenes include Shader Graph materials built in Reality Composer Pro to change the appearance of the ride at runtime. Each piece can be configured to display in one of three materials: metal, wood, or plastic. Other Shader Graph materials create special effects, such as the movement of the water and the flashing lights on the start and end pieces. Even particle effects are included in some of these prepackaged entities, such as the fireworks that play when the goldfish crosses the finish line.": {
      "zh": "Swift Splash çš„åœºæ™¯å›Šæ‹¬äº†åœ¨ Reality Composer Pro ä¸­å†…å»ºçš„ Shader Graph æè´¨ï¼Œå®ƒä»¬ç”¨äºåœ¨è¿è¡Œæ—¶æ”¹å˜æ¸¸ä¹è®¾æ–½çš„å¤–è§‚ã€‚æ¯ä¸€å—æ»‘é“éƒ¨ä»¶éƒ½å¯ä»¥è¢«è®¾å®šç”¨æ¥å±•ç¤ºä¸‰ç§ä¸åŒæè´¨ä¸­çš„æŸä¸€ç§ï¼šé‡‘å±ã€æœ¨è´¨æˆ–å¡‘æ–™ã€‚å…¶ä»–é£æ ¼çš„ Shader Graph æè´¨ä¼šåˆ›å»ºç‰¹æ•ˆï¼Œä¾‹å¦‚æ°´çš„æµåŠ¨ä»¥åŠèµ·ç‚¹å’Œç»ˆç‚¹ç‰©ä»¶ä¸Šçš„é—ªå…‰ç¯ç¯æ•ˆã€‚ç”šè‡³å…¶ä¸­çš„ä¸€äº›é¢„è®¾å®ä½“å†…è¿˜åŒ…å«äº†ç²’å­æ•ˆæœï¼Œæ¯”å¦‚å½“å°é‡‘é±¼æŠµè¾¾ç»ˆç‚¹çº¿æ—¶ç»½æ”¾çš„ç¤¼èŠ±ã€‚",
      "tips": ""
    },
    "Build slide pieces in Reality Composer Pro": {
      "zh": "åœ¨ Reality Composer Pro ä¸­æ„å»ºæ°´ä¸Šæ»‘é“éƒ¨ä»¶",
      "tips": ""
    },
    "Slide pieces are the building blocks of Swift Splash. The Reality Composer project contains a separate scene for each one. In addition to the 3D models that make up the slide piece, each scene contains a number of other entities the app uses to animate and place the slide piece.": {
      "zh": "æ»‘é“éƒ¨ä»¶æ˜¯æ„å»º Swift Splash é¡¹ç›®çš„åŸºç¡€æ¨¡å—ã€‚Reality Composer ä¸ºæ¯ä¸€ä¸ªç‰©ä»¶å…ƒç´ æä¾›äº†ç‹¬ç«‹çš„ç¼–è¾‘åœºæ™¯ã€‚é™¤äº†ç»„æˆæ»‘æ¢¯çš„ 3D æ¨¡å‹ä»¥å¤–ï¼Œæ¯ä¸€ä¸ªåœºæ™¯è¿˜åŒ…å«äº†è‹¥å¹²ä¸ªåœ¨ç¨‹åºä¸­ç”¨äºå¯¹æ»‘é“éƒ¨ä»¶è¿›è¡ŒåŠ¨ç”»å’Œå®šä½çš„å…¶ä»–å®ä½“ã€‚",
      "tips": ""
    },
    "In the hierarchy viewer on the left side of the screenshot above, there are two transform entities called connect_in and connect_out. These transforms mark the points where the slide piece connects to the next or previous piece. Swift Splash uses these transforms to place new pieces at the end of the existing slide, as well as to snap pieces to other slide pieces when you manually move them near each other.": {
      "zh": "åœ¨ä¸Šæ–¹å±å¹•æˆªå›¾å·¦ä¾§çš„å±‚çº§æ£€è§†é¢æ¿ä¸­ï¼Œæœ‰ä¸¤ä¸ªè¢«ç§°ä½œ connect_in å’Œ connect_out çš„å˜æ¢èŠ‚ç‚¹ã€‚è¿™ä¸¤ä¸ªå˜æ¢èŠ‚ç‚¹ä¼šå¯¹æ»‘é“éƒ¨ä»¶çš„å‰åè¿æ¥åšå‡ºæ ‡è®°ã€‚Swift Splash å°±æ˜¯åˆ©ç”¨äº†è¿™äº›èŠ‚ç‚¹ä»è€Œå°†æ–°çš„æ»‘é“éƒ¨ä»¶å¯¹æ¥åˆ°ç°æœ‰å†…å®¹çš„æœ«ç«¯ï¼Œä¹Ÿå¯é€šè¿‡æ‰‹åŠ¨ç§»åŠ¨æ»‘é“éƒ¨ä»¶å¹¶é è¿‘å…¶ä»–ç‰©ä»¶çš„æ–¹å¼å°†å®ƒä»¬å¸é™„åœ¨ä¸€èµ·ã€‚",
      "tips": ""
    },
    "Slide pieces demonstrate the two primary mechanisms Swift Splash uses to find entities at runtime. For some entities, such as connect_in, Swift Splash uses a naming convention and retrieves the entities by name or suffix when it needs to use them. In other cases, such as when names arenâ€™t unique or the retrieving code needs configuration values, Swift Splash uses a custom component to mark and retrieve entities.": {
      "zh": "è¿™ä¸ªæ»‘é“éƒ¨ä»¶çª—å£å±•ç¤ºäº†åœ¨ Swift Splash ä¸­é€šè¿‡è¿è¡Œæ—¶å»æŸ¥æ‰¾å®ä½“çš„ä¸¤ç§ä¸»è¦æœºåˆ¶ã€‚å¯¹äºä¸€äº›å®ä½“æ¥è¯´ï¼Œä¾‹å¦‚ connect_inï¼ŒSwift Splash ä¼šå€ŸåŠ©å‘½åè§„åˆ™å¹¶åœ¨éœ€è¦ä½¿ç”¨è¿™äº›å®ä½“æ—¶é€šè¿‡åŒ¹é…åç§°æˆ–åç¼€æ¥è·å–å®ƒä»¬ã€‚åœ¨å…¶ä»–åœºæ™¯ä¸‹ï¼Œä¾‹å¦‚åç§°ä¸å”¯ä¸€æˆ–è€…å¿…é¡»é€šè¿‡é…ç½®å€¼å–å¾—å®ä½“æ—¶ï¼ŒSwift Splash ä¼šä½¿ç”¨è‡ªå®šä¹‰ç»„ä»¶æ¥å¯¹å®ä½“è¿›è¡Œæ ‡è®°å’Œæ£€ç´¢ã€‚",
      "tips": ""
    },
    "For example, animated entities that appear when the ride runs contain a component called RideAnimationComponent. The app uses this component to determine if the entity is an animation that plays while the ride is running. The component also stores additional state the app needs to implement the ride animation, such as a property called duration that specifies when to start the animations on the next connected slide piece.": {
      "zh": "ä¸¾ä¾‹æ¥è¯´ï¼Œå½“æ¸¸ä¹è®¾æ–½è¿è¡Œèµ·æ¥åå‡ºç°çš„åŠ¨ç”»å®ä½“ä¼šåŒ…å«ä¸€ä¸ªåä¸º RideAnimationComponent çš„ç»„ä»¶ã€‚ç¨‹åºå€ŸåŠ©è¿™ä¸ªç»„ä»¶æ¥åˆ¤æ–­è¿™ä¸ªå®ä½“æ˜¯å¦ä¸ºè®¾æ–½åœ¨è¿è¡ŒçŠ¶æ€ä¸‹æ’­æ”¾çš„åŠ¨ç”»ã€‚è¯¥ç»„ä»¶è¿˜è´Ÿè´£å­˜å‚¨è¿™ä¸ªç¨‹åºå®ç°æ¸¸ä¹è®¾æ–½åŠ¨ç”»æ‰€éœ€è¦çš„é¢å¤–çŠ¶æ€ä¿¡æ¯ï¼Œæ¯”å¦‚åä¸º duration çš„å±æ€§ï¼Œå®ƒç”¨äºæ˜ç¡®ä½•æ—¶å»å¯åŠ¨ä¸‹ä¸€ä¸ªå·²ç»è¿æ¥çš„æ»‘æ¢¯ç»„ä»¶ä¸Šçš„åŠ¨ç”»ã€‚",
      "tips": ""
    },
    "RideAnimationComponent also includes a property called isPersistent. Persistent ride animations stay visible at all times but only animate when the ride is running, such as the animated door on the start piece. Nonpersistent ride animations, such as the fish swimming through a slide piece, display only while the ride is running and the fish swims through that particular piece.": {
      "zh": "RideAnimationComponent ç»„ä»¶è¿˜æœ‰ä¸€ä¸ªåä¸º isPersistent çš„å±æ€§ã€‚æŒç»­çš„æ°´ä¸Šæ¸¸ä¹è®¾æ–½åŠ¨ç”»å†…å®¹æ˜¯å§‹ç»ˆå¯è§çš„ï¼Œä¸è¿‡åªæœ‰å½“è®¾æ–½åœ¨è¿è¡Œæ—¶æ‰ä¼šå»æ‰§è¡ŒåŠ¨ç”»ï¼Œåƒæ˜¯åœ¨èµ·ç‚¹åŒºå—ä¸Šé€šè¿‡åŠ¨ç”»æ‰“å¼€çš„é—¨ã€‚éæŒç»­çš„è®¾æ–½åŠ¨ç”»ï¼Œä¾‹å¦‚å°é±¼åœ¨æ»‘é“å†…æ¸¸è¿‡ï¼Œåªä¼šåœ¨è®¾æ–½è¿è¡Œå¹¶ä¸”å°é±¼æ­£åœ¨é€šè¿‡å¯¹åº”çš„æ»‘é“ç‰©ä»¶æ—¶æ‰ä¼šæ˜¾ç¤ºå‡ºæ¥ã€‚",
      "tips": ""
    },
    "Avoid duplicate materials with material references": {
      "zh": "é€šè¿‡æè´¨å¼•ç”¨é¿å…é‡å¤çš„æè´¨å®ä¾‹",
      "tips": ""
    },
    "Many of Swift Splashâ€™s slide pieces use the same materials. For example, the shader graph material that changes pieces from metal to wood to plastic is shared by all but one of the slide pieces. To avoid having duplicate copies of each material, Swift Splash leverages USD material references to share materials between multiple entities in multiple scenes.": {
      "zh": "åœ¨ Swift Splash ä¸­ï¼Œè®¸å¤šæ»‘é“éƒ¨ä»¶ä¼šä½¿ç”¨ç›¸åŒçš„æè´¨å…ƒç´ ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œæ‰€æœ‰éƒ¨ä»¶éƒ½å…±äº«ç€åŒä¸€ä¸ªèƒ½å¤Ÿå°†éƒ¨ä»¶ä»é‡‘å±è½¬å˜æˆæœ¨è´¨æˆ–æ˜¯å¡‘æ–™çš„ç€è‰²å™¨å›¾å½¢æè´¨ã€‚ä¸ºäº†é¿å…æ¯ä¸€ç§æè´¨éƒ½äº§ç”Ÿé‡å¤çš„å‰¯æœ¬ï¼ŒSwift Splash å€ŸåŠ© USD æè´¨å¼•ç”¨ç‰¹æ€§ï¼Œåšåˆ°äº†åœ¨å¤šä¸ªåœºæ™¯çš„å¤šä¸ªå®ä½“ä¹‹é—´å…±äº«æè´¨ã€‚",
      "tips": "æœ‰å…³ USDï¼ˆUniversal Scene Descriptionï¼‰çš„æ¦‚è¿°å’Œå®šä¹‰ï¼šhttps://www.nvidia.cn/omniverse/usd/#:~:text=USD%20%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80,%E7%9A%84%E4%BB%BB%E4%BD%95%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E3%80%82"
    },
    "The Reality Composer Pro project contains a separate scene for each shared material, containing only that one material. Other track pieces create references to that material. If you change the original material, it affects all of the entities that reference it. For example, a scene called M_RainbowLights.usda contains the material M_RainbowLights, and both StartPiece.usda and EndPiece.usda reference that material.": {
      "zh": "Reality Composer Pro å·¥ç¨‹ä¸­å¯¹æ¯ä¸€ä¸ªå…±äº«çš„æè´¨éƒ½åšäº†ç‹¬ç«‹çš„åœºæ™¯è®¾å®šï¼Œè¿™ä¸ªåœºæ™¯åªåŒ…å«äº†é‚£ä¸€ç§æè´¨ã€‚å…¶ä»–çš„è½¨é“éƒ¨ä»¶åªä¼šå»ºç«‹å¯¹è¿™æè´¨çš„å¼•ç”¨ã€‚å¦‚æœä½ å°è¯•æ”¹å˜åŸå§‹æè´¨ï¼Œå°±ä¼šå½±å“æ‰€æœ‰å¼•ç”¨äº†å®ƒçš„å®ä½“ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªåä¸º M_RainbowLights.usda çš„åœºæ™¯åŒ…å«äº† M_RainbowLights çš„æè´¨ï¼Œè€Œ StartPiece.usda å’Œ EndPiece.usda ä¸¤è€…éƒ½å¼•ç”¨äº†è¿™ç§æè´¨ã€‚",
      "tips": ""
    },
    "Parallelize the asset load": {
      "zh": "å¹¶è¡ŒåŒ–çš„èµ„äº§åŠ è½½",
      "tips": ""
    },
    "To maximize load speed and make the most efficient use of available compute resources, Swift Splash parallelizes loading scenes from the Reality Composer project using a TaskGroup. The app creates a separate Task for each of the scenes it needs to load.": {
      "zh": "ä¸ºäº†å°½å¯èƒ½æå‡åŠ è½½é€Ÿåº¦ä»¥åŠæœ€é«˜æ•ˆåœ°è¿ç”¨å¯ç”¨çš„è®¡ç®—èµ„æºï¼ŒSwift Splash é€šè¿‡ TaskGroup å¹¶è¡ŒåŒ–åœ°åŠ è½½ Reality Composer å·¥ç¨‹ä¸­çš„æ‰€æœ‰åœºæ™¯ã€‚ç¨‹åºä¼šä¸ºéœ€è¦åŠ è½½èµ„äº§çš„æ¯ä¸€ä¸ªåœºæ™¯åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„ Taskã€‚",
      "tips": ""
    },
    "The app then uses an async iterator to wait for and receive the results.": {
      "zh": "ç¨‹åºéšåä¼šä½¿ç”¨å¼‚æ­¥è¿­ä»£å™¨æ¥ç­‰å¾…å¹¶æ¥æ”¶åŠ è½½ç»“æœã€‚",
      "tips": ""
    },
    "For more information on task groups, see Concurrency in The Swift Programming Language.": {
      "zh": "æœ‰å…³ä»»åŠ¡ç»„ï¼ˆtask groupsï¼‰çš„æ›´å¤šä¿¡æ¯ï¼Œè¯¦è§ The Swift Programming Language ä¸­çš„ Concurrency ç›¸å…³å†…å®¹ã€‚",
      "tips": ""
    },
    "Each of these loaded pieces acts as a template. When the player adds a new piece of that type, the app clones the piece loaded from Reality Composer Pro and adds the clone to the scene.": {
      "zh": "æ¯ä¸€ä¸ªå·²ç»åŠ è½½çš„éƒ¨ä»¶éƒ½ä¼šè¢«çœ‹ä½œæ˜¯ä¸€ä¸ªæ¨¡æ¿ã€‚å½“ç©å®¶åœ¨é¡¹ç›®ä¸­æ·»åŠ äº†åŒç±»éƒ¨ä»¶æ—¶ï¼Œç¨‹åºä¼šä» Reality Composer Pro ä¸­å¤åˆ¶åŠ è½½è¿‡çš„éƒ¨ä»¶ï¼Œç„¶åå°†è¯¥éƒ¨ä»¶æ·»åŠ åˆ°åœºæ™¯ä¸­ã€‚",
      "tips": ""
    },
    "Specify sort ordering for transparent entities": {
      "zh": "æŒ‡å®šé€æ˜å®ä½“çš„æ’åºé¡ºåº",
      "tips": ""
    },
    "When multiple entities have more than one overlapping, nonopaque material, RealityKitâ€™s default depth-sorting can cause it to draw those entities in the wrong order. As a result, some entities may not be visible from certain angles or in certain positions relative to other transparent entities. The default depth sorting is based on the center of the entityâ€™s bounding box, which may result in the incorrect drawing order when there are multiple overlapping materials with any amount of transparency. You can see an example of this by looking at the start piece in Reality Composer Pro, or by watching the video below.": {
      "zh": "å½“é‡åˆ°å¤šä¸ªå®ä½“äº§ç”Ÿè¶…è¿‡ä¸€ä¸ªé‡å ï¼Œå¹¶ä¸”å­˜åœ¨éä¸é€æ˜çš„æè´¨æ—¶ï¼ŒRealityKit çš„é»˜è®¤æ·±åº¦æ’åºå¯èƒ½ä¼šæŒ‰ç…§é”™è¯¯çš„é¡ºåºç»˜åˆ¶è¿™äº›å®ä½“å†…å®¹ã€‚è¿™å°±å¯¼è‡´ï¼Œä»ç‰¹å®šè§’åº¦æˆ–æ˜¯ç›¸å¯¹äºå…¶ä»–é€æ˜å®ä½“çš„ç‰¹å®šä½ç½®ä¸Šçœ‹ï¼Œæœ‰ä¸€éƒ¨åˆ†å®ä½“å¯èƒ½æ— æ³•è¢«çœ‹åˆ°ã€‚é»˜è®¤æ·±åº¦æ’åºçš„è®¡ç®—åŸºäºå®ä½“è¾¹ç•Œç›’çš„ä¸­å¿ƒç‚¹ï¼Œå½“å­˜åœ¨å¤šä¸ªä»»ä½•é€æ˜åº¦çš„é‡å æè´¨æ—¶ï¼Œå¯èƒ½ä¼šå¼•å‘ä¸æ­£ç¡®çš„ç»˜åˆ¶é¡ºåºã€‚ä½ å¯ä»¥åœ¨ Reality Composer Pro ä¸­æŸ¥çœ‹èµ·å§‹éƒ¨ä»¶ï¼Œæˆ–è§‚çœ‹ä¸‹æ–¹çš„è§†é¢‘æ¥äº†è§£ç¤ºä¾‹çš„è¡¨ç°å½¢å¼ã€‚",
      "tips": ""
    },
    "The following video demonstrates the problem. If the three boxes are the bounding boxes for three different transparent entities, and the small spheres are the box centers, the sphere thatâ€™s closest to the camera changes as the camera moves around the boxes, which changes the order that RealityKitâ€™s default depth sorting algorithm draws them.": {
      "zh": "ä¸‹æ–¹çš„è§†é¢‘æ¼”ç¤ºäº†è¿™ä¸ªé—®é¢˜ã€‚å‡è®¾è¿™ä¸‰ä¸ªçŸ©å½¢æ¡†åˆ†åˆ«æ˜¯ä¸‰ä¸ªä¸åŒçš„é€æ˜å®ä½“çš„è¾¹ç•Œç›’ï¼Œå…¶ä¸­çš„åœ†å½¢åˆ™ä»£è¡¨ç€ç›’å­çš„ä¸­å¿ƒï¼Œå½“æ‘„åƒæœºåœ¨çŸ©å½¢æ¡†å‘¨å›´ç§»åŠ¨æ—¶ï¼Œè·ç¦»æ‘„åƒæœºæœ€è¿‘çš„åœ†å½¢å°±ä¼šæ”¹å˜ï¼Œè¿™å°±ä¼šå½±å“ RealityKit çš„é»˜è®¤æ·±åº¦æ’åºç®—æ³•ç»˜åˆ¶å®ƒä»¬çš„é¡ºåºã€‚",
      "tips": ""
    },
    "Swift Splash assigns a ModelSortGroupComponent to each of the transparent entities to manually specify the relative depth sorting. To fix the transparency issues in the start piece in the video above, Swift Splash instructs RealityKit to draw the opaque parts of the fish first, its transparent goggles second, the water third, the glass globe fourth, and the selection glow shell last. Swift Splash does this by assigning a ModelSortGroupComponent to each of the overlapping entities using the same ModelSortGroup, but with a different order specified.": {
      "zh": "Swift Splash ä¼šä¸ºæ¯ä¸€ä¸ªé€æ˜å®ä½“å…³è”ä¸€ä¸ª ModalSortGroupComponent ç»„ä»¶ï¼Œç”¨äºæ‰‹åŠ¨å»æŒ‡å®šç›¸å¯¹çš„æ·±åº¦æ’åºã€‚ä¸ºäº†ä¿®æ­£ä¸Šæ–¹è§†é¢‘ä¸­èµ·å§‹éƒ¨ä»¶çš„é€æ˜åº¦é—®é¢˜ï¼ŒSwift Splash ä¼šå‘½ä»¤ RealityKit é¦–å…ˆå»ç»˜åˆ¶é±¼çš„ä¸é€æ˜éƒ¨åˆ†ï¼Œå†è€…æ˜¯é€æ˜çš„æŠ¤ç›®é•œï¼Œç¬¬ä¸‰æ˜¯æ°´ï¼Œç¬¬å››æ˜¯ç»ç’ƒçƒï¼ŒæŠŠé€‰ä¸­å‘å…‰çš„å¤–å£³ä½œä¸ºæœ€åçš„ç»˜åˆ¶ç‰©ä»¶ã€‚Swift Splash é€šè¿‡ä½¿ç”¨ç›¸åŒçš„ä½†åˆ¶å®šäº†ä¸åŒé¡ºåºçš„ ModelSortGroupï¼Œå¹¶ä¸ºæ¯ä¸€ä¸ªé‡å å®ä½“å…³è” ModelSortGroupComponent ç»„ä»¶æ¥å®ç°è¿™ä¸€ç‚¹ã€‚",
      "tips": ""
    },
    "Traverse connected track pieces": {
      "zh": "é€ä¸ªæ“ä½œè¿æ¥çš„è½¨é“éƒ¨ä»¶",
      "tips": ""
    },
    "The root entity for all of the individual slide pieces has a ConnectableComponent. This custom component marks the entity as one that can be connected or snapped to other connectable entities. At runtime, the app adds a ConnectableStateComponent to each slide piece it adds. The component stores state information for the track piece that doesnâ€™t need to be edited in Reality Composer Pro. Among the state information that this component stores is a reference to the next and previous piece.": {
      "zh": "æ‰€æœ‰ç‹¬ç«‹çš„æ»‘é“éƒ¨ä»¶çš„æ ¹å®ä½“éƒ½æœ‰ä¸€ä¸ª ConnectableComponent ç»„ä»¶ã€‚è¿™ä¸ªå¯è‡ªå®šä¹‰çš„ç»„ä»¶ä¼šå°†å®ä½“æ ‡è®°ä¸ºå…è®¸è¿æ¥æˆ–è€…å¸é™„åˆ°å…¶ä»–å¯è¿æ¥çš„å®ä½“ã€‚åœ¨ç¨‹åºè¿è¡Œæ—¶ï¼Œåº”ç”¨ä¼šä¸ºæ¯ä¸€ä¸ªæ·»åŠ çš„éƒ¨ä»¶éƒ½æ–°å¢ä¸€ä¸ª ConnectableStateComponent ç»„ä»¶ã€‚è¿™ä¸ªç»„ä»¶å‚¨å­˜çš„è½¨é“éƒ¨ä»¶çŠ¶æ€ä¿¡æ¯ä¸éœ€åœ¨ Reality Composer Pro è¿›è¡Œç¼–è¾‘ä¿®æ”¹ã€‚åœ¨è¿™ä¸ªç»„ä»¶å­˜å‚¨çš„çŠ¶æ€ä¿¡æ¯ä¸­ä¹Ÿæ¶µç›–äº†å‰åéƒ¨ä»¶çš„è¿æ¥å…³ç³»ã€‚",
      "tips": ""
    },
    "To iterate through the entire ride, ignoring any disconnected pieces, the app gets a reference to the start piece and then iterates until nextPiece is nil. This iteration, similar to iterating a linked list, repeats many times throughout the app. One example is the function that calculates the duration of the built ride by iterating through the individual pieces and adding up the duration of their animations.": {
      "zh": "è¦æŠŠæ•´æ¡æ¸¸ä¹è®¾æ–½ä¸²è”èµ·æ¥ï¼Œç•¥å»æœªå¯¹æ¥ä¸Šçš„æ»‘é“éƒ¨ä»¶ï¼Œåº”ç”¨ç¨‹åºå¯ä»¥ä»èµ·å§‹éƒ¨ä»¶è·å–ä¸€ä¸ªå¼•ç”¨ï¼Œç„¶åéå†ç›´è‡³æ²¡æœ‰åç»­éƒ¨ä»¶ã€‚è¿™ç§è¿­ä»£ï¼Œç±»ä¼¼äºéå†ä¸€æ¡é“¾è¡¨ï¼Œä¼šåœ¨åº”ç”¨ä¸­è¢«é‡å¤è¿ç”¨å¾ˆå¤šæ¬¡ã€‚ä¸€ä¸ªä¾‹å­å°±æ˜¯è®¡ç®—å·²æ­å»ºçš„è®¾æ–½è¿è¡Œæ—¶é•¿çš„å‡½æ•°ï¼Œå®ƒé€šè¿‡éå†æ•´è½¨ä¸Šæ¯æ¡å•ç‹¬çš„éƒ¨ä»¶å¹¶å°†å®ƒä»¬æ‰§è¡ŒåŠ¨ç”»çš„æ—¶é•¿ä¾æ¬¡ç´¯åŠ æ¥å®Œæˆè®¡ç®—ã€‚",
      "tips": ""
    },
    "Interact with the ride": {
      "zh": "ä½“éªŒæ¸¸ä¹è®¾æ–½",
      "tips": ""
    },
    "To build and edit the ride, players interact with Swift Splash in two different ways. They interact with SwiftUI windows to perform certain tasks, such as adding a new piece or deleting an existing piece of the ride. They also manipulate slide pieces using standard visionOS gestures, including taps, double taps, drags, and rotates. The player taps on a piece to select or deselect it. When a player double taps a piece, they select that piece without deselecting any other selected pieces. When someone drags a piece, it moves around the immsersive space, snapping together with other pieces if placed near one. A two-finger rotate gesture spins the selected track piece or pieces on the Z-axis.": {
      "zh": "æœ‰ä¸¤ç§ä¸åŒçš„æ–¹å¼å¯ä¾›ç©å®¶åœ¨ Swift Splash ä¸­è¿›è¡Œäº¤äº’æ¥æ„å»ºå’Œç¼–è¾‘æ¸¸ä¹è®¾æ–½ã€‚ä»–ä»¬å¯ä»¥é€šè¿‡ SwiftUI çª—å£å®Œæˆç‰¹å®šçš„æ“ä½œï¼Œä¾‹å¦‚æ–°å¢ä¸€æ®µæ–°æ»‘é“ï¼Œæˆ–æ˜¯ç§»é™¤ä¸€æ®µå·²ç»æ·»åŠ åˆ°è®¾æ–½ä¸­çš„æ»‘é“éƒ¨ä»¶ã€‚ç©å®¶è¿˜å¯åˆ©ç”¨ visionOS æ”¯æŒçš„æ ‡å‡†æ‰‹åŠ¿æ¥æ“ä½œéƒ¨ä»¶ï¼ŒåŒ…æ‹¬ç‚¹æŒ‰ã€åŒå‡»ã€æ‹–åŠ¨å’Œæ—‹è½¬ã€‚ç©å®¶ç‚¹å‡»éƒ¨ä»¶ä»¥é€‰æ‹©æˆ–å–æ¶ˆé€‰æ‹©å®ƒã€‚å½“ç©å®¶åŒå‡»éƒ¨ä»¶æ—¶ï¼Œä»–ä»¬ä¼šé€‰æ‹©è¯¥éƒ¨ä»¶ï¼Œè€Œä¸ä¼šå–æ¶ˆé€‰ä¸­çš„å…¶ä»–éƒ¨ä»¶ã€‚å½“æœ‰äººå»æ‹–ç§»éƒ¨ä»¶æ—¶ï¼Œå®ƒä¼šåœ¨æ²‰æµ¸å¼ç©ºé—´ä¸­ç§»åŠ¨ï¼Œå¦‚æœå’Œå¦ä¸€ä¸ªéƒ¨ä»¶é å¾—è¶³å¤Ÿè¿‘ï¼Œå®ƒä»¬å°±ä¼šè‡ªåŠ¨å¸é™„åœ¨ä¸€èµ·ã€‚ä½¿ç”¨ä¸¤æŒ‡æ—‹è½¬æ‰‹åŠ¿ä¼šè®©é€‰ä¸­çš„è½¨é“éƒ¨ä»¶æˆ–æ‰€æœ‰éƒ¨ä»¶æ²¿ç€ Z è½´è¿›è¡Œæ—‹è½¬ã€‚",
      "tips": ""
    },
    "Swift Splash handles all of these interactions using standard SwiftUI gestures targeted to an entity. To support any of these gestures at any time, the app declares them using SimultaneousGesture. The code for all of the gestures are contained in TrackBuildingView, which controls the appâ€™s immersive space. Hereâ€™s how the app defines the rotation gesture:": {
      "zh": "Swift Splash åœ¨ç›®æ ‡å®ä½“ä¸Šé‡‡ç”¨æ ‡å‡†çš„ SwiftUI æ‰‹åŠ¿å»å¤„ç†å…¶æ‰€æœ‰çš„äº¤äº’æ“ä½œã€‚ä¸ºäº†èƒ½éšæ—¶ç»™ä»»æ„æ‰‹åŠ¿æä¾›æ”¯æŒï¼Œåº”ç”¨å†…ä½¿ç”¨ SimultaneousGesture æ¥è¿›è¡Œå£°æ˜ã€‚æ‰€æœ‰çš„æ‰‹åŠ¿ä»£ç éƒ½åŒ…å«åœ¨ TrackBuildingView ä¸­ï¼Œè¿™ä¸ªè§†å›¾ç®¡ç†ç€åº”ç”¨å†…çš„æ²‰æµ¸å¼ç©ºé—´ã€‚ä»¥ä¸‹æ˜¯åœ¨åº”ç”¨ä¸­å®šä¹‰æ—‹è½¬æ‰‹åŠ¿çš„ä»£ç ï¼š",
      "tips": ""
    },
    "Because multiple tap gestures on the same RealityView execute with a different number of taps, multiple gestures may be called at once. If a player double taps an entity, for example, both the single tap and the double tap gesture code get called, and the app has to determine which one to execute. Swift Splash makes this determination by using a Boolean state variable. If a player single taps, it sets that variableÂ â€” called shouldSingleTap â€” to true. Then it waits for a period of time before executing the rest of its code. If shouldSingleTap gets set to false while itâ€™s waiting, the code doesnâ€™t execute. When SwiftSplash detects a double tap gesture, it sets shouldSingleTap to false, preventing the single-tap code from firing when it executes the double-tap code.": {
      "zh": "å› ä¸ºåœ¨ç›¸åŒçš„ RealityView ä¸Šæ‰§è¡Œçš„å¤šæ¬¡ç‚¹æŒ‰æ‰‹åŠ¿å¯èƒ½å¸¦æœ‰ä¸åŒçš„ç‚¹å‡»æ¬¡æ•°ï¼Œå¤šç§æ‰‹åŠ¿å¯èƒ½ä¼šåŒæ—¶è¢«å“åº”ã€‚ä¸¾ä¸ªä¾‹å­æ¥è¯´ï¼Œå¦‚æœç©å®¶å¯¹ä¸€ä¸ªå®ä½“è¿›è¡ŒåŒå‡»æ“ä½œï¼Œå®é™…ä¸Šå•å‡»å’ŒåŒå‡»çš„æ‰‹åŠ¿ä»£ç éƒ½ä¼šè¢«è°ƒç”¨ï¼Œæœ€ç»ˆæ‰§è¡Œçš„æ‰‹åŠ¿ç”±ç¨‹åºå†³å®šã€‚Swift Splash é€šè¿‡ä¸€ä¸ªå¸ƒå°”çŠ¶æ€å˜é‡æ¥åšè¿™ä¸ªå†³å®šã€‚å¦‚æœç©å®¶å•å‡»äº†ï¼Œç¨‹åºä¼šå°†æ­¤å˜é‡ï¼ˆå«åš shouldSingleTapï¼‰è®¾ç½®ä¸º trueã€‚ç„¶åç¨‹åºä¼šç­‰å¾…ä¸€æ®µæ—¶é—´å†å»æ‰§è¡Œåç»­çš„ä»£ç ã€‚å¦‚æœåœ¨ç­‰å¾…é˜¶æ®µ shouldSingleTap è¢«è®¾å®šä¸º falseï¼Œé‚£ä¹ˆä»£ç å°±ä¸ä¼šè¢«æ‰§è¡Œã€‚å½“ Swift Splash æ£€æµ‹åˆ°ä¸€ä¸ªåŒå‡»æ‰‹åŠ¿ï¼Œå®ƒä¼šå°† shouldSingleTap è®¾ç½®ä¸º falseï¼Œä»¥é¿å…åœ¨æ‰§è¡ŒåŒå‡»ä»£ç æ—¶è§¦å‘å•å‡»ä»£ç ã€‚",
      "tips": ""
    }
  },
  "visionos/tracking-images-in-3d-space": {
    "Tracking preregistered images in 3D space": {
      "zh": "åœ¨ä¸‰ç»´ç©ºé—´ä¸­è¿½è¸ªé¢„ç™»è®°å›¾åƒ",
      "tips": ""
    },
    "Place content based on the current position of a known image in a personâ€™s surroundings.": {
      "zh": "æ ¹æ®å·²çŸ¥å›¾åƒçš„å½“å‰ä½ç½®åœ¨ç”¨æˆ·å‘¨å›´æ”¾ç½®å†…å®¹ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "Use ARKitâ€™s support for tracking 2D images to place 3D content in a space. ARKit provides updates to the imageâ€™s location as it moves relative to the person. If you supply one or more reference images in your appâ€™s asset catalog, people can use a real-world copy of that image to place virtual 3D content in your app. For example, if you design a pack of custom playing cards and provide those assets to people in the form of a real-world deck of playing cards, they can place unique content per card in a fully immersive experience.": {
      "zh": "ä½¿ç”¨ ARKit å¯¹äºŒç»´å›¾åƒçš„è¿½è¸ªæ”¯æŒï¼Œåœ¨ç©ºé—´ä¸­æ”¾ç½®ä¸‰ç»´å†…å®¹ã€‚å½“å›¾åƒç›¸å¯¹äºç”¨æˆ·ç§»åŠ¨æ—¶ï¼ŒARKit ä¼šæä¾›å›¾åƒä½ç½®çš„æ›´æ–°ã€‚å¦‚æœä½ åœ¨åº”ç”¨çš„èµ„æºç›®å½•ä¸­æä¾›äº†ä¸€å¼ æˆ–å¤šå¼ å‚è€ƒå›¾ç‰‡ï¼Œç”¨æˆ·å°±å¯ä»¥ä½¿ç”¨è¯¥å›¾åƒçš„çœŸå®å‰¯æœ¬åœ¨åº”ç”¨ä¸­æ”¾ç½®è™šæ‹Ÿçš„ä¸‰ç»´å†…å®¹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ è®¾è®¡äº†ä¸€å‰¯å®šåˆ¶çº¸ç‰Œ,å¹¶ä»¥çœŸå®çš„çº¸ç‰ŒåŒ…çš„å½¢å¼å°†è¿™äº›èµ„æºæä¾›ç»™ç”¨æˆ·ï¼Œä»–ä»¬å°±å¯ä»¥åœ¨å®Œå…¨æ²‰æµ¸å¼çš„ä½“éªŒä¸­ä¸ºæ¯å¼ ç‰Œæ·»åŠ ç‹¬ç‰¹çš„å†…å®¹ã€‚",
      "tips": "è¿™ä¸€æ®µçš„çº¸ç‰Œä¾‹å­å¯èƒ½æœ‰ç‚¹éš¾ç†è§£ï¼Œå¯ä»¥æƒ³è±¡ä¸€ä¸‹å“ˆåˆ©æ³¢ç‰¹ç”µå½±ä¸­å‡ºç°çš„æŠ¥çº¸ä¸Šä¼šåŠ¨çš„ç…§ç‰‡ã€‚"
    },
    "The following example tracks a set of images loaded from an appâ€™s asset catalog:": {
      "zh": "ä¸‹é¢çš„ä»£ç å±•ç¤ºäº†å¦‚ä½•è¿½è¸ªä»åº”ç”¨èµ„æºç›®å½•ä¸­åŠ è½½çš„ä¸€ç»„å›¾åƒï¼š",
      "tips": ""
    },
    "If you know the real-world dimensions of the images youâ€™re tracking, use the physicalSize property to improve tracking accuracy. The estimatedScaleFactor property provides information about how the scale of the tracked image differs from the expected physical size you provide.": {
      "zh": "å¦‚æœä½ çŸ¥é“æ‰€è¿½è¸ªå›¾åƒçš„å®é™…å°ºå¯¸ï¼Œå¯ä½¿ç”¨ physicalSize å±æ€§æ¥æé«˜è¿½è¸ªç²¾åº¦ã€‚estimatedScaleFactor å±æ€§æä¾›äº†è¿½è¸ªå›¾åƒçš„å®é™…å°ºå¯¸ä¸ä½ é¢„æœŸçš„ç‰©ç†å°ºå¯¸ä¹‹é—´çš„å·®å¼‚ä¿¡æ¯ã€‚",
      "tips": ""
    }
  },
  "visionos/tracking-points-in-world-space": {
    "Tracking specific points in world space": {
      "zh": "è¿½è¸ªä¸–ç•Œç©ºé—´ä¸­çš„ç‰¹å®šç‚¹",
      "tips": ""
    },
    "Retrieve the position and orientation of anchors your app stores in ARKit.": {
      "zh": "æ£€ç´¢åº”ç”¨åœ¨ ARKit ä¸­å­˜å‚¨é”šç‚¹çš„ä½ç½®å’Œæ–¹å‘ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "Use world anchors along with an ARKit sessionâ€™s WorldTrackingProvider to track points of interest in the world over time, as a person moves while wearing the device, and across device usage sessions. For example, someone might place a 3D object in a specific position on their desk and expect it to come back the next time they use the device.": {
      "zh": "å°†ä¸–ç•Œé”šç‚¹ä¸ ARKit ä¼šè¯çš„ WorldTrackingProvider ç»“åˆä½¿ç”¨ï¼Œå¯ä»¥éšç€ä½©æˆ´è®¾å¤‡ç”¨æˆ·çš„ç§»åŠ¨ï¼Œè·¨è®¾å¤‡ã€è·¨ä¼šè¯åœ°è¿½è¸ªä½ æ„Ÿå…´è¶£çš„ä¸–ç•Œç‚¹ã€‚ä¾‹å¦‚ï¼Œç”¨æˆ·å¯èƒ½ä¼šå°†ä¸€ä¸ª 3D ç‰©ä½“æ”¾ç½®åœ¨æ¡Œå­çš„ç‰¹å®šä½ç½®ï¼Œå¹¶å¸Œæœ›ä¸‹æ¬¡ä½¿ç”¨è®¾å¤‡æ—¶å®ƒå†æ¬¡å‡ºç°åœ¨åŒä¸€ä½ç½®ã€‚",
      "tips": ""
    },
    "ARKit keeps track of a unique identifier for each world anchor your app creates and automatically places those anchors back in the space when the person returns to your app in the same location. A world tracking provider also provides the position of the device the person is wearing.": {
      "zh": "ARKit ä¼šä¸ºåº”ç”¨åˆ›å»ºçš„æ¯ä¸ªä¸–ç•Œé”šç‚¹æ”¶å½•ä¸€ä¸ªå”¯ä¸€æ ‡è¯†ç¬¦ï¼Œå½“ç”¨æˆ·åœ¨åŒä¸€åœ°ç‚¹è¿”å›ä½ çš„åº”ç”¨æ—¶ï¼ŒARKit ä¼šè‡ªåŠ¨å°†è¿™äº›é”šç‚¹æ”¾å›ç©ºé—´ã€‚ä¸–ç•Œè¿½è¸ªæä¾›ç¨‹åºè¿˜ä¼šæä¾›ç”¨æˆ·ä½©æˆ´è®¾å¤‡çš„ä½ç½®ã€‚",
      "tips": ""
    },
    "Start an ARKit session with world tracking": {
      "zh": "ä½¿ç”¨ä¸–ç•Œè¿½è¸ªå¯åŠ¨ ARKit ä¼šè¯",
      "tips": ""
    },
    "Use an ARKitSession configured for world tracking to start receiving updates on the world anchors your app places. The following shows updates to world anchors your app previously registered using the addAnchor(_:) method:": {
      "zh": "ä½¿ç”¨ä¸ºä¸–ç•Œè¿½è¸ªé…ç½®è¿‡çš„ ARKitSession å¼€å§‹æ¥æ”¶åº”ç”¨æ”¾ç½®çš„ä¸–ç•Œé”šç‚¹çš„æ›´æ–°ã€‚ä¸‹é¢ä»£ç å±•ç¤ºäº†åº”ç”¨ä¹‹å‰ä½¿ç”¨æ–¹æ³• addAnchor(_:) æ³¨å†Œçš„ä¸–ç•Œé”šç‚¹çš„æ›´æ–°ï¼š",
      "tips": ""
    },
    "Important": {
      "zh": "é‡è¦",
      "tips": ""
    },
    "If a person repositions the current space â€” for example, by holding down the Digital Crown â€” world anchor updates begin updating their position relative to the new world origin. For example, a world anchor placed on a table still reports information about the tableâ€™s position, but those positions are relative to the updated world origin.": {
      "zh": "å¦‚æœç”¨æˆ·é‡æ–°å®šä½å½“å‰ç©ºé—´ï¼ˆä¾‹å¦‚æŒ‰ä½æ•°ç è¡¨å† ï¼‰ï¼Œä¸–ç•Œé”šç‚¹æ›´æ–°å°†å¼€å§‹æ›´æ–°å…¶ç›¸å¯¹äºæ–°ä¸–ç•ŒåŸç‚¹çš„ä½ç½®ã€‚ä¾‹å¦‚ï¼Œæ”¾ç½®åœ¨æ¡Œå­ä¸Šçš„ä¸–ç•Œé”šç‚¹ä»ä¼šæŠ¥å‘Šæ¡Œå­çš„ä½ç½®ä¿¡æ¯ï¼Œä½†è¿™äº›ä½ç½®æ˜¯ç›¸å¯¹äºæ›´æ–°åçš„ä¸–ç•ŒåŸç‚¹çš„ã€‚",
      "tips": ""
    },
    "Create and add world anchors": {
      "zh": "åˆ›å»ºå’Œæ·»åŠ ä¸–ç•Œé”šç‚¹",
      "tips": ""
    },
    "You can create world anchors for any point of interest in your appâ€™s world coordinate system once youâ€™ve started a world tracking ARKit session. For example, you might track that a person placed an item at a particular offset from a desk in their space:": {
      "zh": "å¯åŠ¨ä¸–ç•Œè¿½è¸ª ARKit ä¼šè¯åï¼Œä½ å¯ä»¥åœ¨åº”ç”¨çš„ä¸–ç•Œåæ ‡ç³»ä¸­ä¸ºä»»ä½•æ„Ÿå…´è¶£çš„ç‚¹åˆ›å»ºä¸–ç•Œé”šç‚¹ã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½ä¼šè¿½è¸ªåˆ°ç”¨æˆ·å°†æŸä»¶ç‰©å“æ”¾ç½®åœ¨ç©ºé—´å†…è·æ¡Œå­æœ‰ç‰¹å®šä½ç§»çš„æŸä¸€ä½ç½®ï¼š",
      "tips": ""
    },
    "Once you add a world anchor to your appâ€™s tracking provider using the addAnchor(_:) method, the anchorUpdates sequence in the current session and future runs of your app provides updates to the current position of that new world anchor.": {
      "zh": "ä½¿ç”¨ addAnchor(_:) æ–¹æ³•å°†ä¸–ç•Œé”šç‚¹æ·»åŠ åˆ°åº”ç”¨çš„è¿½è¸ªæä¾›ç¨‹åºåï¼Œå½“å‰å’Œæœªæ¥è¿è¡Œçš„åº”ç”¨ä¼šè¯ä¸­çš„ anchorUpdates åºåˆ—ä¼šæŒç»­æ›´æ–°è¯¥æ–°é”šç‚¹çš„å½“å‰ä½ç½®ã€‚",
      "tips": ""
    },
    "Persist world anchors across sessions": {
      "zh": "è·¨ä¼šè¯ä¿ç•™ä¸–ç•Œé”šç‚¹",
      "tips": ""
    },
    "The only information ARKit persists about the world anchors in your app is their UUID â€” a WorldAnchor instanceâ€™s id property â€” and pose in a particular space. Itâ€™s your appâ€™s responsibility to persist additional information, such as the meaning of each anchor. For example, you might save local data about a custom 3D lamp model that a person placed on their desk.": {
      "zh": "ARKit ä¿ç•™çš„ä½ åº”ç”¨ä¸­ä¸–ç•Œé”šç‚¹çš„å”¯ä¸€ä¿¡æ¯æ˜¯å®ƒä»¬çš„ UUIDï¼ˆWorldAnchor å®ä¾‹çš„ id å±æ€§ï¼‰ä»¥åŠåœ¨ç‰¹å®šç©ºé—´ä¸­çš„ä½ç½®ã€‚ä½ çš„åº”ç”¨è´Ÿè´£ä¿ç•™å…¶ä»–ä¿¡æ¯ï¼Œè­¬å¦‚æ¯ä¸ªé”šç‚¹çš„å«ä¹‰ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥ä¿å­˜ç”¨æˆ·æ”¾åœ¨æ¡Œå­ä¸Šçš„è‡ªå®šä¹‰ 3D å°ç¯æ¨¡å‹çš„æœ¬åœ°æ•°æ®ã€‚",
      "tips": ""
    },
    "As a person moves from town-to-town or room-to-room, your app wonâ€™t receive all of the world anchor updates from each place someone used your app. Instead, the anchorUpdates sequence only provides world anchors for nearby objects.": {
      "zh": "å½“ç”¨æˆ·ä»ä¸€ä¸ªåŸå¸‚ç§»åŠ¨åˆ°å¦ä¸€ä¸ªåŸå¸‚æˆ–ä»ä¸€ä¸ªæˆ¿é—´ç§»åŠ¨åˆ°å¦ä¸€ä¸ªæˆ¿é—´æ—¶ï¼Œåº”ç”¨ä¸ä¼šä»è¢«ä½¿ç”¨è¿‡çš„æ¯ä¸ªåœ°æ–¹æ¥æ”¶æ‰€æœ‰çš„ä¸–ç•Œé”šç‚¹æ›´æ–°ã€‚ç›¸åï¼Œ anchorUpdates åºåˆ—ä»…ä¸ºé™„è¿‘çš„ç‰©ä½“æä¾›ä¸–ç•Œé”šç‚¹æ›´æ–°ã€‚",
      "tips": ""
    },
    "Track the device position in the world": {
      "zh": "è¿½è¸ªè®¾å¤‡åœ¨ä¸–ç•Œä¸­çš„ä½ç½®",
      "tips": ""
    },
    "Use the Compositor Services framework and the WorldTrackingProvider classâ€™s queryDeviceAnchor(atTimestamp:) method to get low-latency information about the current and future-predicted pose of the personâ€™s device in world space. For more information, see Drawing fully immersive content using Metal.": {
      "zh": "ä½¿ç”¨ Compositor Services æ¡†æ¶å’Œ WorldTrackingProvider ç±»çš„ queryDeviceAnchor(atTimestamp:) æ–¹æ³•åœ¨ç©ºé—´ä¸­è·å–æœ‰å…³ç”¨æˆ·è®¾å¤‡å½“å‰å’Œæœªæ¥é¢„æµ‹å§¿åŠ¿çš„ä½å»¶è¿Ÿä¿¡æ¯ã€‚æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ä½¿ç”¨ Metal ç»˜åˆ¶å®Œå…¨æ²‰æµ¸å¼å†…å®¹ã€‚",
      "tips": ""
    }
  },
  "visionos/trimming_and_exporting_media_in_visionos": {
    "Trimming and exporting media in visionOS": {
      "zh": "åœ¨ visionOS ä¸­å‰ªè¾‘å’Œå¯¼å‡ºåª’ä½“",
      "tips": ""
    },
    "Display standard controls in your app to edit the timeline of the currently playing media.": {
      "zh": "åœ¨åº”ç”¨ä¸­æ˜¾ç¤ºæ ‡å‡†æ§ä»¶ï¼Œä»¥ç¼–è¾‘å½“å‰æ’­æ”¾åª’ä½“çš„æ—¶é—´è½´ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "You use AVPlayerViewController to present the system video-player interface in your visionOS app. In addition to its primary role, AVPlayerViewController can also provide a media-trimming experience similar to the interface of QuickTime Player in macOS, like that below.": {
      "zh": "ä½ å¯ä»¥ä½¿ç”¨ AVPlayerViewController åœ¨ä½ çš„ visionOS åº”ç”¨ä¸­æ˜¾ç¤ºç³»ç»Ÿé»˜è®¤çš„è§†é¢‘æ’­æ”¾å™¨ç•Œé¢ã€‚é™¤äº†å…¶ä¸»è¦ä½œç”¨å¤–ï¼ŒAVPlayerViewController è¿˜èƒ½æä¾›ç±»ä¼¼äº macOS ä¸­ QuickTime Player ç•Œé¢çš„åª’ä½“å‰ªè¾‘ä½“éªŒï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚",
      "tips": ""
    },
    "When you enable this feature, people can specify a segment of the media timeline for display. This article describes how to adopt this feature in your app, and shows how to use AVFoundation to export the trimmed result.": {
      "zh": "å¯ç”¨æ­¤åŠŸèƒ½åï¼Œç”¨æˆ·å¯ä»¥æŒ‡å®šæ˜¾ç¤ºåª’ä½“æ—¶é—´è½´çš„æŸä¸ªç‰‡æ®µã€‚æœ¬æ–‡å°†ä»‹ç»å¦‚ä½•åœ¨åº”ç”¨ä¸­é‡‡ç”¨è¿™ä¸€åŠŸèƒ½ï¼Œå¹¶è¯´æ˜å¦‚ä½•ä½¿ç”¨ AVFoundation å¯¼å‡ºå‰ªè¾‘åçš„ç»“æœã€‚",
      "tips": ""
    },
    "Determine whether the media supports trimming": {
      "zh": "ç¡®å®šåª’ä½“æ˜¯å¦æ”¯æŒå‰ªè¾‘",
      "tips": ""
    },
    "Apps typically provide a user-interface element to put the player view controller into trimming mode. Because the player doesnâ€™t support trimming certain media, such as HTTP Live Streaming or protected content, apps observe the state of the canBeginTrimming property to update the enabled state of their user interface accordingly. For example, the following code observes the state of the canBeginTrimming property and updates the state of a published property, which sets the appropriate enabled state in the UI:": {
      "zh": "åº”ç”¨é€šå¸¸ä¼šæä¾›ä¸€ä¸ª UI å…ƒç´ ï¼Œè®©æ’­æ”¾å™¨è§†å›¾æ§åˆ¶å™¨è¿›å…¥å‰ªè¾‘æ¨¡å¼ã€‚ç”±äºæ’­æ”¾å™¨ä¸æ”¯æŒå‰ªè¾‘æŸäº›åª’ä½“ï¼Œå¦‚ HTTP å®æ—¶æµåª’ä½“æˆ–å—ä¿æŠ¤çš„å†…å®¹ï¼Œå› æ­¤åº”ç”¨ä¼šè§‚å¯Ÿ canBeginTrimming å±æ€§çš„çŠ¶æ€ï¼Œå¹¶ç›¸åº”åœ°æ›´æ–°ç”¨æˆ·ç•Œé¢çš„å¯ç”¨çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹ä»£ç ä¼šè§‚å¯Ÿ canBeginTrimming å±æ€§çš„çŠ¶æ€ï¼Œå¹¶æ›´æ–°å·²å‘å¸ƒå±æ€§çš„çŠ¶æ€ï¼Œä»è€Œåœ¨ UI ä¸­è®¾ç½®ç›¸åº”çš„å¯ç”¨çŠ¶æ€ï¼š",
      "tips": ""
    },
    "Enable the trimming user interface": {
      "zh": "å¯ç”¨å‰ªè¾‘ç”¨æˆ·ç•Œé¢",
      "tips": ""
    },
    "After you determine that the player view controller supports editing the current mediaâ€™s timeline, call the playerâ€™s beginTrimming(completionHandler:) method to enable its trimming interface. Call this method from an asynchronous context:": {
      "zh": "ç¡®å®šæ’­æ”¾å™¨è§†å›¾æ§åˆ¶å™¨æ”¯æŒç¼–è¾‘å½“å‰åª’ä½“çš„æ—¶é—´è½´åï¼Œè°ƒç”¨æ’­æ”¾å™¨çš„ beginTrimming(completionHandler:) æ–¹æ³•å¯ç”¨å…¶å‰ªè¾‘ç•Œé¢ã€‚ä½ éœ€è¦åœ¨å¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­è°ƒç”¨æ­¤æ–¹æ³•ï¼š",
      "tips": ""
    },
    "This method returns a Boolean value that indicates whether the user pinched the Done button or the Cancel button. Pinching the Done button causes the view controller to update the values of the player itemâ€™s reversePlaybackEndTime and forwardPlaybackEndTime properties to match the trimmed selection.": {
      "zh": "æ­¤æ–¹æ³•è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œè¡¨ç¤ºç”¨æˆ·æ˜¯æŒ‰äº† \"å®Œæˆ \"æŒ‰é’®è¿˜æ˜¯ \"å–æ¶ˆ \"æŒ‰é’®ã€‚æŒ‰ä¸‹ \"å®Œæˆ \"æŒ‰é’®ä¼šå¯¼è‡´è§†å›¾æ§åˆ¶å™¨æ›´æ–°æ’­æ”¾å™¨é¡¹ç›®çš„ reversePlaybackEndTime å’Œ forwardPlaybackEndTime å±æ€§å€¼ï¼Œä½¿å…¶ä¸å‰ªè¾‘åçš„é€‰åŒºç›¸åŒ¹é…ã€‚",
      "tips": ""
    },
    "Export the trimmed media selection": {
      "zh": "å¯¼å‡ºå‰ªè¾‘åçš„åª’ä½“é€‰åŒº",
      "tips": ""
    },
    "A convenient way to export your trimmed selection is to use AVAssetExportSession. This object provides a simple preset-based approach to transcode media in various formats. Create an instance of an export session by passing it the player itemâ€™s asset and an export preset. Additionally, configure its output URL and file type:": {
      "zh": "ä½¿ç”¨ AVAssetExportSession æ˜¯å¯¼å‡ºå‰ªè¾‘åé€‰åŒºçš„ä¾¿æ·æ–¹æ³•ã€‚è¯¥å¯¹è±¡æä¾›äº†ä¸€ç§åŸºäºé¢„è®¾çš„ç®€å•æ–¹æ³•ï¼Œå¯å¯¹å„ç§æ ¼å¼çš„åª’ä½“è¿›è¡Œè½¬ç ã€‚é€šè¿‡ä¼ å…¥æ’­æ”¾å™¨é¡¹ç›®çš„ç´ æå’Œå¯¼å‡ºé¢„è®¾ï¼Œæ¥åˆ›å»ºä¸€ä¸ªå¯¼å‡ºä¼šè¯çš„å®ä¾‹ã€‚æ­¤å¤–ï¼Œè¿˜è¦é…ç½®å…¶è¾“å‡º URL å’Œæ–‡ä»¶ç±»å‹ï¼š",
      "tips": ""
    },
    "To export only the portion of the asset that matches your trimmed selection, create a CMTimeRange based on the reverse and forward playback end times of the current player item:": {
      "zh": "è¦åªå¯¼å‡ºä¸å‰ªè¾‘é€‰åŒºåŒ¹é…çš„ç´ æéƒ¨åˆ†ï¼Œå¯æ ¹æ®å½“å‰æ’­æ”¾å™¨é¡¹ç›®çš„åå‘å’Œæ­£å‘æ’­å®Œæ—¶é—´åˆ›å»ºä¸€ä¸ª CMTimeRange:",
      "tips": ""
    },
    "Finally, begin the export operation to begin asynchronously transcoding the media to the output URL:": {
      "zh": "æœ€åï¼Œå¼€å§‹å¯¼å‡ºæ“ä½œï¼Œå°†åª’ä½“å¼‚æ­¥è½¬ç åˆ°è¾“å‡º URLï¼š",
      "tips": ""
    }
  },
  "visionos/understanding-the-realitykit-modular-architecture": {
    "Understanding RealityKitâ€™s modular architecture": {
      "zh": "äº†è§£ RealityKit çš„æ¨¡å—åŒ–æ¶æ„",
      "tips": ""
    },
    "Learn how everything fits together in RealityKit.": {
      "zh": "äº†è§£å¦‚ä½•åœ¨ RealityKit ä¸­å°†ä¸€åˆ‡ç»„åˆåœ¨ä¸€èµ·ã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è§ˆ",
      "tips": ""
    },
    "RealityKit is a 3D framework designed for building apps, games, and other immersive experiences. Although itâ€™s built in an object-oriented language and uses object-oriented design principles, RealityKitâ€™s architecture avoids heavy use of composition â€” where objects are built by adding instance variables that hold references to other objects â€” in favor of a modular design based on a paradigm called Entity Component System (ECS) that divides application objects into one of three types.": {
      "zh": "RealityKit æ˜¯ä¸“ä¸ºæ„å»ºåº”ç”¨ç¨‹åºã€æ¸¸æˆå’Œå…¶ä»–æ²‰æµ¸å¼ä½“éªŒè€Œè®¾è®¡çš„ 3D æ¡†æ¶ã€‚è™½ç„¶ï¼Œå®ƒæ˜¯ä½¿ç”¨é¢å‘å¯¹è±¡çš„ç¼–ç¨‹è¯­è¨€å’Œè®¾è®¡åŸåˆ™ï¼Œä½†æ˜¯ RealityKit é‡‡ç”¨äº† â€œå®ä½“-ç»„ä»¶-ç³»ç»Ÿâ€ æ¶æ„èŒƒå¼ï¼Œå°†åº”ç”¨ç¨‹åºä¸­å¯¹è±¡åˆ†ä¸º â€œå®ä½“ Entity â€ï¼Œâ€œç»„ä»¶ Component â€ï¼Œâ€ç³»ç»Ÿ System â€œä¸‰ç§ï¼Œä»è€Œé¿å…â€œç»„åˆæ¨¡å¼â€çš„ç¹é‡è®¾è®¡â€”â€”é€šè¿‡æ·»åŠ å®ä¾‹å˜é‡æ¥æŒæœ‰å…¶ä»–å¯¹è±¡å¼•ç”¨ä»è€Œæ„å»ºå¯¹è±¡ã€‚",
      "tips": "è¯‘è€…æ³¨ï¼šæœ¬æ–‡ä¸­çš„â€œç³»ç»Ÿâ€ï¼Œé™¤éç‰¹åˆ«æŒ‡æ˜ VisionOS ï¼Œå¦åˆ™é»˜è®¤æ˜¯ ECS ä¸­çš„â€œç³»ç»Ÿ System â€ï¼Œä¸‹é¢â€œåˆ›å»ºç³»ç»Ÿä»¥æ‰§è¡Œå®ä½“è¡Œä¸ºâ€å°èŠ‚ä¼šåšè¯¦ç»†ä»‹ç»â€œç³»ç»Ÿâ€ï¼› Entity Component System ( ECS ), â€œå®ä½“-ç»„ä»¶-ç³»ç»Ÿâ€æ˜¯ä¸€ç§è½¯ä»¶ä½“ç³»ç»“æ„æ¨¡å¼ï¼Œä¸»è¦ç”¨äºè§†é¢‘æ¸¸æˆå¼€å‘ä¸­ï¼Œç”¨äºè¡¨ç¤ºæ¸¸æˆä¸–ç•Œå¯¹è±¡ã€‚ECSåŒ…æ‹¬ç”±æ•°æ®ç»„ä»¶ç»„æˆçš„å®ä½“ï¼Œä»¥åŠåœ¨å®ä½“ç»„ä»¶ä¸Šè¿è¡Œçš„ç³»ç»Ÿã€‚ECSéµå¾ªç»„åˆä¼˜äºç»§æ‰¿çš„åŸåˆ™ï¼Œè¿™æ„å‘³ç€æ¯ä¸ªå®ä½“ä¸æ˜¯ç”±ç±»å‹å±‚æ¬¡ç»“æ„å®šä¹‰çš„ï¼Œè€Œæ˜¯ç”±ä¸å…¶å…³è”çš„ç»„ä»¶å®šä¹‰çš„ã€‚ç³»ç»Ÿå¯¹å…·æœ‰æ‰€éœ€ç»„ä»¶çš„æ‰€æœ‰å®ä½“è¿›è¡Œå…¨å±€æ“ä½œã€‚"
    },
    "Following the ECS paradigm allows you to re-use the functionality contained in a component in many different entities, even if they have very different inheritance chains. Even if two objects have no common ancestors other than Entity, you can add the same components to both of them and give them the same behavior or functionality.": {
      "zh": "éµå¾ª ECS èŒƒå¼å¯ä»¥åœ¨æœ‰ç€å„ä¸ç›¸åŒçš„ç»§æ‰¿é“¾çš„å®ä½“ä¹‹é—´ä¸­é‡ç”¨åŒä¸€ä¸ªç»„ä»¶ä¸­çš„åŠŸèƒ½ã€‚åˆæˆ–è€…æ˜¯åœ¨é™¤äº† Entity ä¹‹å¤–æ²¡æœ‰å…±åŒç¥–å…ˆçš„ä¸¤ä¸ªå¯¹è±¡ä¸­æ·»åŠ åŒä¸€ç»„ä»¶ï¼Œä»¥èµ‹äºˆå®ƒä»¬ç›¸åŒçš„â€œè¡Œä¸ºâ€æˆ–â€œåŠŸèƒ½â€ã€‚",
      "tips": ""
    },
    "Start with Entities": {
      "zh": "ä»å®ä½“å¼€å§‹",
      "tips": ""
    },
    "Entities are the core actors of RealityKit. Any object that you can put into a scene, whether visible or not, is an entity and must be a descendent of Entity. Entities can be 3D models, shape primitives, lights, or even invisible items like sound emitters or trigger volumes. Add components to entities to let them store additional state relevant to a specific type of functionality. Entities themselves contain relatively few properties: Nearly all entity state is stored on an entityâ€™s components.": {
      "zh": "å®ä½“åœ¨ RealityKit ä¸­æ‰®æ¼”æ ¸å¿ƒè§’è‰²ã€‚åœ¨åœºæ™¯ä¸­çš„ä»»ä½•ä¸€ä¸ªå¯¹è±¡éƒ½æ˜¯ Entity çš„åä»£ï¼Œä¸è®ºå¯¹è±¡æ˜¯å¦å¯è§ã€‚å®ä½“å¯ä»¥æ˜¯3Dæ¨¡å‹ï¼Œå‡ ä½•å›¾å…ƒï¼Œå…‰çº¿ï¼Œåˆæˆ–è€…åƒæ˜¯å‘å£°å™¨ï¼ˆ sound emitters ï¼‰å’Œç«‹ä½“è§¦å‘å™¨ï¼ˆ trigger volumes ï¼‰è¿™ç§éšå½¢çš„å­˜åœ¨ã€‚åœ¨å®ä½“ä¸­æ·»åŠ ç»„ä»¶ä»¥ä½¿ç»„ä»¶èƒ½å¤Ÿå­˜å‚¨ä¸ç‰¹å®šç±»å‹åŠŸèƒ½ç›¸å…³çš„é™„åŠ çŠ¶æ€ã€‚å®ä½“è‡ªèº«åŒ…å«ç›¸å¯¹è¾ƒå°‘çš„çŠ¶æ€å±æ€§ï¼šå‡ ä¹æ‰€æœ‰çš„å®ä½“çŠ¶æ€éƒ½å­˜å‚¨åœ¨å®ä½“çš„ç»„ä»¶ä¸­ã€‚",
      "tips": "shape primitives ï¼Œå‡ ä½•å›¾å…ƒï¼Œåœ¨æ„é€ å®ä½“å‡ ä½•ä¸­ï¼Œå›¾å…ƒæ˜¯ç®€å•çš„å‡ ä½•å½¢çŠ¶ï¼Œä¾‹å¦‚ç«‹æ–¹ä½“ï¼Œåœ†æŸ±ä½“ï¼Œçƒä½“ï¼Œåœ†é”¥ä½“ï¼Œæ£±é”¥ï¼Œåœ†ç¯ï¼› trigger volumes ï¼Œç«‹ä½“è§¦å‘å™¨ã€‚æ˜¯æ¸¸æˆå¼€å‘ä¸­å¸¸ç”¨çš„ä¸€ç§æœºåˆ¶ï¼Œç”¨äºæ£€æµ‹æ¸¸æˆä¸­çš„ç‰©ä½“æˆ–è§’è‰²æ˜¯å¦è¿›å…¥æˆ–ç¦»å¼€æŸä¸ªç‰¹å®šåŒºåŸŸã€‚å½“ç‰©ä½“æˆ–è§’è‰²ä¸è§¦å‘å™¨ç›¸äº¤æ—¶ï¼Œå¯ä»¥è§¦å‘ç‰¹å®šçš„äº‹ä»¶æˆ–è¡Œä¸ºã€‚ä¹Ÿå¯ä»¥æ£€æµ‹ç‰©ä½“ä¹‹é—´çš„ç¢°æ’ï¼Œå¹¶è¿›è¡Œç›¸åº”çš„å¤„ç†ï¼Œæ¯”å¦‚è®¡ç®—ä¼¤å®³ã€æ”¹å˜ç”Ÿå‘½å€¼ç­‰ã€‚"
    },
    "RealityKit provides a number of entity types you use to represent different kinds of objects. For example, a ModelEntity represents a 3D model, such as one imported from a .usdz or .reality file. These provided entities are essentially just an Entity with certain components already added to them. Adding a ModelComponent to an instance of Entity, for example, results in an entity with identical functionality to a ModelEntity.": {
      "zh": "RealityKit æä¾›äº†ä¸€äº›å®ä½“ç±»å‹æ¥ä»£è¡¨ä¸åŒç§ç±»çš„å¯¹è±¡ã€‚ä¾‹å¦‚ï¼ŒModelEntity ä»£è¡¨ä» .usdz æˆ–è€…æ˜¯ .reality æ–‡ä»¶å¯¼å…¥çš„ 3D æ¨¡å‹ã€‚RealityKit æä¾›çš„è¿™äº›å®ä½“åŸºæœ¬ä¸Šæ˜¯å·²ç»æœ‰äº†ç‰¹å®šç±»å‹ç»„ä»¶çš„ Entity ã€‚ä¾‹å¦‚ï¼Œåœ¨ Entity çš„å®ä¾‹ä¸­æ·»åŠ  ModelComponent ç»„ä»¶ï¼Œè¿™ä¸ªâ€œå®ä½“â€å°±ä¼šæœ‰å’Œ ModelEntity ç±»å‹çš„å®ä½“ç›¸æ‹¥å®Œå…¨çš„åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "Add components to entities": {
      "zh": "åœ¨å®ä½“æ·»åŠ ç»„ä»¶",
      "tips": ""
    },
    "Components are modular building blocks that you add to an entity; they identify which entities a system will act on, and maintain the per-entity state that systems rely on. Components can contain logic, but limit component logic to code that validates its property values or sets its initial state. Use systems for any logic that affects the behavior of entities or that potentially changes their state on every frame. To add accessibility information to an entity, for example, add a AccessibilityComponent to it and populate its fields with the information the accessibility system needs, such as putting the description that VoiceOver reads into its label property.": {
      "zh": "ç»„ä»¶æ˜¯æ·»åŠ åˆ°å®ä½“ä¸­çš„æ¨¡å—åŒ–æ„å»ºçš„ä»£ç å—ï¼›ç³»ç»Ÿé€šè¿‡ç»„ä»¶ç¡®å®šå¯¹å“ªäº›å®ä½“è¿›è¡Œæ“ä½œï¼Œç»„ä»¶åŒæ—¶ç»´æŠ¤ç³»ç»Ÿä¾èµ–çš„æ¯ä¸ªå®ä½“çš„çŠ¶æ€ã€‚ç»„ä»¶åªèƒ½åŒ…å«éªŒè¯å±æ€§å€¼æˆ–è€…è®¾ç½®åˆå§‹åŒ–çŠ¶æ€çš„é€»è¾‘ä»£ç ã€‚ç³»ç»Ÿæ˜¯ç”¨æ¥ç®¡ç†å½±å“å®ä½“è¡Œä¸ºæˆ–è€…æ¯ä¸€å¸§çŠ¶æ€æ½œåœ¨å˜åŒ–çš„é€»è¾‘ä»£ç ã€‚ä¸ºå®ä½“æ·»åŠ å¯è®¿é—®æ€§çš„ä¿¡æ¯ï¼Œä¾‹å¦‚ï¼Œå‘å…¶æ·»åŠ  AccessibilityComponent ç»„ä»¶ï¼ŒåŒæ—¶æ ¹æ®ç³»ç»Ÿéœ€è¦è®¿é—®çš„ä¿¡æ¯è®¾ç½®ç»„ä»¶çš„ç›¸åº”å­—æ®µï¼Œæ¯”å¦‚ VoiceOver ä¼šè¯»å–å®ƒçš„ label å±æ€§æ‰€åŒ…å«çš„æè¿°ä¿¡æ¯ï¼ˆâ€œå®ƒçš„ label å±æ€§â€æŒ‡çš„ AccessibilityComponent çš„ label å±æ€§ï¼‰ã€‚",
      "tips": "è¯‘è€…æ³¨ï¼šè¿™æ®µåŸæ–‡æ˜¯çªå‡ºä»‹ç»â€œç»„ä»¶ Componentâ€çš„ï¼Œä½†è¯»èµ·æ¥æœ‰ç‚¹ç»•ï¼Œä¾‹å¦‚ï¼šâ€œ they identify which entities a system will act on â€ï¼Œâ€œ  they â€æŒ‡çš„æ˜¯ç»„ä»¶ï¼Œæˆ‘æŠŠè¿™å¥è¯çš„ä¸»è°“å®¾æ¢äº†ä½ç½®ç¿»è¯‘ä¸ºï¼šâ€œç³»ç»Ÿé€šè¿‡ç»„ä»¶ç¡®å®šå¯¹å“ªäº›å®ä½“è¿›è¡Œæ“ä½œâ€ã€‚è¿™æ ·ç¿»è¯‘æ˜¯å› ä¸ºé€šè¿‡é˜…è¯»å®˜æ–¹æ—¶ä¾‹å­ä»£ç ç†è§£ä¸‹æ¥ï¼šç³»ç»Ÿï¼ˆ System ï¼‰æ˜¯é€šè¿‡ç»„ä»¶ï¼ˆ Component ï¼‰è¯†åˆ«å’Œæ“ä½œå®ä½“ï¼ˆ Entity ï¼‰ã€‚"
    },
    "Keep in mind that an entity can only hold one copy of any particular type of component at a time. So, for example, you canâ€™t add two accessibility components to one entity. If you add an accessibility component to an entity that already has one, the new component replaces the previous one.": {
      "zh": "è¯·è®°ä½ï¼Œä¸€ä¸ªå®ä½“ä¸€æ¬¡åªèƒ½æŒæœ‰æŸç§ç‰¹å®šç±»å‹ç»„ä»¶çš„ä¸€ä¸ªå‰¯æœ¬ã€‚ä¾‹å¦‚ï¼Œä¸èƒ½åœ¨åŒä¸€ä¸ªå®ä½“ä¸­æ·»åŠ ä¸¤ä¸ªå¯è®¿é—®æ€§ç»„ä»¶  AccessibilityComponent ã€‚å¦‚æœå®ä½“å·²ç»æ·»åŠ äº†ä¸€ä¸ªå¯è®¿é—®æ€§ç»„ä»¶ï¼Œæ–°æ·»åŠ çš„ä¼šå–ä»£ä¹‹å‰æ·»åŠ çš„ã€‚",
      "tips": ""
    },
    "Create systems to implement entity behavior": {
      "zh": "åˆ›å»ºç³»ç»Ÿä»¥æ‰§è¡Œå®ä½“è¡Œä¸º",
      "tips": ""
    },
    "A System contains code that RealityKit calls on every frame to implement a specific type of entity behavior or to update a particular type of entity state. Systems use components to store their entity-specific state and query for entities to act on by looking for ones with a specific component or combination of components.": {
      "zh": "ç³»ç»ŸåŒ…å«å®ç°ç‰¹å®šç±»å‹å®ä½“çš„è¡Œä¸ºï¼Œæˆ–è€…æ›´æ–°ç‰¹æ®Šç±»å‹å®ä½“çš„çŠ¶æ€çš„ä»£ç ï¼Œè€Œ RealityKit ä¼šåœ¨æ¯å¸§è°ƒç”¨â€œç³»ç»Ÿâ€çš„ä»£ç ã€‚ç³»ç»Ÿä½¿ç”¨ç»„ä»¶å­˜å‚¨å®ä½“ç‰¹å®šçŠ¶æ€ï¼ŒåŒæ—¶å¯ä»¥é€šè¿‡æŸç§ç±»å‹ç»„ä»¶æˆ–è€…å¤šç§ç±»å‹ç»„ä»¶ç»„åˆæŸ¥è¯¢éœ€è¦è¿›è¡Œæ“ä½œçš„å®ä½“ã€‚",
      "tips": ""
    },
    "For example, a game might have a damage system that monitors and updates the health of every entity that can be damaged or destroyed. Systems typically work together with one or more components, so that damage system might use a health component to keep track of how much damage each entity has taken and how much each one is able to take before itâ€™s destroyed. It might also interact with other components. For example, an entity might have an armor component that provides protection to the entity, and the damage system would also need to use the state stored in that component.": {
      "zh": "ä¾‹å¦‚ï¼Œæ¸¸æˆå¯ä»¥é€šè¿‡ä¼¤å®³ç³»ç»Ÿç›‘å¬å’Œæ›´æ–°å®ä½“ç”Ÿå‘½å€¼ï¼Œè¿™æ ·å®ä½“å°±å¯ä»¥è¢«ä¼¤å®³æˆ–è€…è¢«æ¯ç­ã€‚ç³»ç»Ÿä¼šé€šå¸¸æ“ä½œä¸€ä¸ªæˆ–å¤šä¸ªç»„ä»¶ï¼Œæ‰€ä»¥ä¼¤å®³ç³»ç»Ÿé€šè¿‡ç”Ÿå‘½å€¼ç»„ä»¶ è®°å½•æ¯ä¸ªå®ä½“å—åˆ°çš„ä¼¤å®³å€¼ï¼Œä»¥åŠæ¯ä¸ªå®ä½“åœ¨è¢«æ¯ç­ä¹‹å‰è¿˜èƒ½æ‰¿å—å¤šå°‘ä¼¤å®³ã€‚ç³»ç»Ÿä¹Ÿä¼šå’Œå…¶ä»–çš„ç»„ä»¶äº¤äº’ã€‚æ¯”å¦‚ï¼Œå®ä½“ä¹Ÿå¯ä»¥æœ‰ä¿æŠ¤ä½œç”¨çš„ç›”ç”²ç»„ä»¶ï¼Œè¿™æ—¶ä¼¤å®³ç³»ç»Ÿä¹Ÿä¼šå»ä½¿ç”¨è¯¥ç»„ä»¶å­˜å‚¨çš„çŠ¶æ€å€¼ã€‚",
      "tips": ""
    },
    "Every frame, the damage system queries for entities that have the health component and updates values on those entitiesâ€™ components based on the current state of the app. If an entity has taken too much damage, the system might trigger a specific animation or remove the entity from the scene.": {
      "zh": "æ¯å¸§åˆ·æ–°æ—¶ï¼Œä¼¤å®³ç³»ç»Ÿ ä¼šæŸ¥è¯¢æœ‰ç”Ÿå‘½å€¼ç»„ä»¶çš„å®ä½“ï¼Œå¹¶æ ¹æ®Appå½“å‰çš„çŠ¶æ€æ›´æ–°è¿™äº›å®ä½“çš„ç»„ä»¶ã€‚å¦‚æœå®ä½“å—åˆ°äº†è¿‡å¤§çš„ä¼¤å®³ï¼Œç³»ç»Ÿå°±ä¼šæ‰§è¡Œç‰¹æ®Šçš„åŠ¨ç”»ï¼Œæˆ–è€…å°†å®ä½“ä»åœºæ™¯ä¸­ç§»é™¤ã€‚",
      "tips": ""
    },
    "Writing entity logic in a system avoids duplication of work. Using traditional OOP design patterns, where this type of logic would reside on the entity class, can often result in the same calculations being performed multiple times, once for every entity potentially affected. No matter how many entities the calculation potentially impacts the system only has to do the calculation once.": {
      "zh": "é‡‡ç”¨ä¼ ç»Ÿçš„é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡æ¨¡å¼ï¼Œå®ä½“ç±»ä¼šåŒ…å«é€»è¾‘ä»£ç ï¼Œè¿™æ ·ä¼šå¯¼è‡´åŒæ ·çš„è®¡ç®—è¢«å¤šæ¬¡æ‰§è¡Œï¼Œå› ä¸ºæ¯ä¸ªå¯èƒ½ä¼šå—åˆ°ä¼¤å®³çš„å®ä½“éƒ½è¦æ‰§è¡Œä¸€æ¬¡ã€‚è€Œåœ¨ç³»ç»Ÿä¸­ç¼–å†™å®ä½“é€»è¾‘å¯ä»¥é¿å…é‡å¤æ€§çš„å·¥ä½œã€‚ä¸ç®¡æœ‰å¤šå°‘ä¸ªå®ä½“éœ€è¦è®¡ç®—ä¼¤å®³ï¼Œåªéœ€è¦ç³»ç»Ÿæ‰§è¡Œä¸€æ¬¡è®¡ç®—å³å¯ã€‚",
      "tips": ""
    },
    "For more information on creating systems, see Implementing systems for entities in a scene": {
      "zh": "æƒ³äº†è§£æ›´å¤šå…³äºç³»ç»Ÿåˆ›å»ºçš„ä¿¡æ¯ï¼Œè¯·å‚ç…§ Implementing systems for entities in a scene ã€‚",
      "tips": ""
    }
  },
  "visionos/visionos": {
    "visionOS": {
      "zh": "visionOS",
      "tips": ""
    },
    "Create a new universe of apps and games for Apple Vision Pro.": {
      "zh": "ä¸º Apple Vision Pro æ‰“é€ å…¨æ–°çš„åº”ç”¨å’Œæ¸¸æˆä¸–ç•Œã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è§ˆ",
      "tips": ""
    },
    "visionOS is the operating system that powers Apple Vision Pro. Use visionOS together with familiar tools and technologies to build immersive apps and games for spatial computing.": {
      "zh": "visionOS æ˜¯ä¸º Apple Vision Pro æä¾›æ”¯æŒçš„æ“ä½œç³»ç»Ÿã€‚å°† visionOS ä¸ç†Ÿæ‚‰çš„å·¥å…·å’ŒæŠ€æœ¯ç»“åˆä½¿ç”¨ï¼Œå¯ä¸ºç©ºé—´è®¡ç®—æ‰“é€ æ²‰æµ¸å¼çš„åº”ç”¨å’Œæ¸¸æˆã€‚",
      "tips": ""
    },
    "Developing for visionOS requires a Mac with Apple silicon. Create new apps using SwiftUI to take full advantage of the spectrum of immersion available in visionOS. If you have an existing iPad or iPhone app, add the visionOS destination to your appâ€™s target to gain access to the standard system appearance, and add platform-specific features to create a compelling experience. To provide continuous access to your content in the meantime, deliver a compatible version of your app that runs in visionOS.": {
      "zh": "ä¸º visionOS å¼€å‘éœ€è¦ä¸€å°é…å¤‡äº†è‹¹æœèŠ¯ç‰‡çš„ Macã€‚ä½¿ç”¨ SwiftUI åˆ›å»ºæ–°åº”ç”¨ï¼Œä»è€Œå……åˆ†åˆ©ç”¨ visionOS æä¾›çš„å„ç§æ²‰æµ¸å¼ä½“éªŒã€‚å¦‚æœä½ å·²æœ‰ iPad æˆ– iPhone åº”ç”¨ï¼Œå¯å°† visionOS ç»ˆç«¯æ·»åŠ åˆ°åº”ç”¨çš„ç›®æ ‡ä¸­ä»¥è®¿é—®æ ‡å‡†ç³»ç»Ÿå¤–è§‚ï¼Œå¹¶æ·»åŠ å¹³å°ç‰¹å®šçš„åŠŸèƒ½ä»¥åˆ›å»ºå¼•äººå…¥èƒœçš„ä½“éªŒã€‚åŒæ—¶ä¸ºäº†ç”¨æˆ·èƒ½å¤Ÿæ— é—´æ–­åœ°è®¿é—®ä½ çš„å†…å®¹ï¼Œè¯·æä¾›èƒ½åœ¨ visionOS ä¸­è¿è¡Œçš„å…¼å®¹ç‰ˆæœ¬åº”ç”¨ã€‚",
      "tips": ""
    },
    "Expand your app into immersive spaces": {
      "zh": "å°†åº”ç”¨æ‰©å±•åˆ°æ²‰æµ¸å¼ç©ºé—´",
      "tips": ""
    },
    "Start with a familiar window-based experience to introduce people to your content. From there, add SwiftUI scene types specific to visionOS, such as volumes and spaces. These scene types let you incorporate depth, 3D objects, and immersive experiences.": {
      "zh": "ä»ç†Ÿæ‚‰çš„çª—å£å¼ä½“éªŒå¼€å§‹ï¼Œå¼•å¯¼ç”¨æˆ·äº†è§£ä½ çš„å†…å®¹ã€‚åœ¨æ­¤åŸºç¡€ä¸Šï¼Œæ·»åŠ  visionOS ç‰¹æœ‰çš„ SwiftUI åœºæ™¯ç±»å‹ï¼Œå¦‚ä½“é‡å’Œç©ºé—´ã€‚è¿™äº›åœºæ™¯ç±»å‹å¯è®©ä½ å‘ˆç°æ·±åº¦ã€3D ç‰©ä½“å’Œæ²‰æµ¸å¼çš„ä½“éªŒã€‚",
      "tips": ""
    },
    "Build your appâ€™s 3D content with RealityKit and Reality Composer Pro, and display it with a RealityView. In an immersive experience, use ARKit to integrate your content with the personâ€™s surroundings.": {
      "zh": "ä½¿ç”¨ RealityKit å’Œ Reality Composer Pro æ„å»ºåº”ç”¨ä¸­çš„ 3D å†…å®¹ï¼Œå¹¶é€šè¿‡ RealityView å‘ˆç°å®ƒä»¬ã€‚åœ¨æ²‰æµ¸å¼ä½“éªŒä¸­ï¼Œä½¿ç”¨ ARKit å°†åº”ç”¨å†…å®¹ä¸ç”¨æˆ·å‘¨å›´ç¯å¢ƒæ•´åˆåœ¨ä¸€èµ·ã€‚",
      "tips": ""
    },
    "Explore new kinds of interaction": {
      "zh": "æ¢ç´¢æ–°å‹äº¤äº’æ–¹å¼",
      "tips": ""
    },
    "People can select an element by looking at it and tapping their fingers together. They can also pinch, drag, zoom, and rotate objects using specific hand gestures. SwiftUI provides built-in support for these standard gestures, so rely on them for most of your appâ€™s input. When you want to go beyond the standard gestures, use ARKit to create custom gestures.": {
      "zh": "ç”¨æˆ·å¯ä»¥é€šè¿‡æ³¨è§†æŸä¸ªå…ƒç´ å¹¶è½»ç‚¹æ‰‹æŒ‡æ¥é€‰æ‹©è¯¥å…ƒç´ ã€‚ä»–ä»¬è¿˜å¯ä»¥ä½¿ç”¨ç‰¹å®šçš„æ‰‹åŠ¿æ¥æåˆã€æ‹–åŠ¨ã€ç¼©æ”¾å’Œæ—‹è½¬å¯¹è±¡ã€‚SwiftUI æä¾›äº†å¯¹è¿™äº›æ ‡å‡†æ‰‹åŠ¿çš„å†…ç½®æ”¯æŒï¼Œå› æ­¤ä½ çš„åº”ç”¨çš„å¤§éƒ¨åˆ†è¾“å…¥éƒ½å¯ä»¥ä¾é å®ƒä»¬ã€‚å¦‚æœä½ æƒ³ä½¿ç”¨æ ‡å‡†æ‰‹åŠ¿ä¹‹å¤–çš„æ‰‹åŠ¿ï¼Œè¯·ä½¿ç”¨ ARKit åˆ›å»ºè‡ªå®šä¹‰æ‰‹åŠ¿ã€‚",
      "tips": ""
    },
    "Dive into featured sample apps": {
      "zh": "æ·±å…¥äº†è§£ç²¾é€‰ç¤ºä¾‹åº”ç”¨",
      "tips": ""
    },
    "Explore the core concepts for all visionOS apps with Hello World. Understand how to detect custom gestures using ARKit with Happy Beam. Discover streaming 2D and stereoscopic media with Destination Video. And learn how to build 3D scenes with RealityKit and Reality Composer Pro with Diorama and Swift Splash.": {
      "zh": "é€šè¿‡â€œä½ å¥½ï¼Œä¸–ç•Œâ€æ¢ç´¢æ‰€æœ‰ visionOS åº”ç”¨å…±é€šçš„æ ¸å¿ƒæ¦‚å¿µã€‚é€šè¿‡â€œå¿«ä¹å…‰æŸâ€äº†è§£å¦‚ä½•ä½¿ç”¨ ARKit æ£€æµ‹è‡ªå®šä¹‰æ‰‹åŠ¿ã€‚é€šè¿‡â€œç›®çš„åœ°è§†é¢‘â€æ¢ç´¢æ¼”ç¤º 2D å’Œç«‹ä½“åª’ä½“ã€‚é€šè¿‡â€œè¥¿æ´‹é•œâ€å’Œâ€œè¿…æ·é£æº…â€å­¦ä¹ å¦‚ä½•ä½¿ç”¨ RealityKit å’Œ Reality Composer Pro æ„å»º 3D åœºæ™¯ã€‚",
      "tips": ""
    }
  },
  "visionos/world": {
    "Hello World": {
      "zh": "ä½ å¥½ï¼Œä¸–ç•Œ ï¼ˆHello Worldï¼‰",
      "tips": ""
    },
    "Use windows, volumes, and immersive spaces to teach people about the Earth.": {
      "zh": "ä½¿ç”¨çª—å£ã€ä½“é‡å’Œæ²‰æµ¸å¼ç©ºé—´è®©ç”¨æˆ·äº†è§£åœ°çƒã€‚",
      "tips": ""
    },
    "Overview": {
      "zh": "æ¦‚è¿°",
      "tips": ""
    },
    "You can use visionOS scene types and styles to share information in fun and compelling ways. Features like volumes and immersive spaces let you put interactive virtual objects into peopleâ€™s environments, or put people into a virtual environment.": {
      "zh": "æ‚¨å¯ä»¥ä½¿ç”¨ visionOS åœºæ™¯ç±»å‹å’Œæ ·å¼ï¼Œä»¥æœ‰è¶£ä¸”å¼•äººå…¥èƒœçš„æ–¹å¼ä¼ è¾¾ä¿¡æ¯ã€‚ä½“é‡å’Œæ²‰æµ¸å¼ç©ºé—´ç­‰åŠŸèƒ½å¯ä»¥è®©ä½ å°†å¯äº¤äº’çš„è™šæ‹Ÿç‰©ä½“æ”¾å…¥ç”¨æˆ·çš„ç¯å¢ƒä¸­ï¼Œæˆ–åä¹‹å°†ç”¨æˆ·ç½®äºè™šæ‹Ÿç¯å¢ƒä¸­ã€‚",
      "tips": ""
    },
    "Hello World uses these tools to teach people about the Earth â€” the planet we call home. The app shows how the Earthâ€™s tilt creates the seasons, how objects move as they orbit the Earth, and how Earth appears from space.": {
      "zh": "Hello World ä½¿ç”¨äº†è¿™äº›å·¥å…·å‘ç”¨æˆ·ä»‹ç»åœ°çƒ--è¿™ä¸ªæˆ‘ä»¬ç§°ä¹‹ä¸ºå®¶çš„æ˜Ÿçƒã€‚è¯¥åº”ç”¨ç¨‹åºå±•ç¤ºäº†åœ°çƒçš„å€¾æ–œè§’å¦‚ä½•å½¢æˆå­£èŠ‚ï¼Œç‰©ä½“å¦‚ä½•å›´ç»•åœ°çƒè¿è¡Œï¼Œä»¥åŠåœ°çƒåœ¨å¤ªç©ºä¸­çš„æ ·å­ã€‚",
      "tips": ""
    },
    "The app uses SwiftUI to define its interface, including both 2D and 3D elements. To create, customize, and manage 3D models and effects, it also relies on the RealityKit framework and Reality Composer Pro.": {
      "zh": "è¯¥åº”ç”¨ç¨‹åºä½¿ç”¨ SwiftUI æ¥åˆ¶ä½œå…¶ç”¨æˆ·ç•Œé¢ï¼Œå…¶ä¸­åŒ…å«äº† 2D å’Œ 3D å…ƒç´ ã€‚ä¸ºäº†åˆ›å»ºã€è‡ªå®šä¹‰å’Œç®¡ç† 3D æ¨¡å‹å’Œæ•ˆæœï¼Œå®ƒè¿˜ä¾èµ–äº RealityKit æ¡†æ¶å’Œ Reality Composer Proã€‚",
      "tips": ""
    },
    "Create an entry point into the app": {
      "zh": "åˆ›å»ºåº”ç”¨çš„å…¥å£",
      "tips": ""
    },
    "Hello World constructs the scene that it displays at launch â€” the first scene that appears in the WorldApp structure â€” using a WindowGroup:": {
      "zh": "Hello World ä½¿ç”¨äº† WindowGroup æ¥æ„å»ºå¯åŠ¨æ—¶æ˜¾ç¤ºçš„åœºæ™¯ï¼ˆWorldApp ç»“æ„ä½“ä¸­å‡ºç°çš„ç¬¬ä¸€ä¸ªåœºæ™¯ï¼‰ï¼š",
      "tips": ""
    },
    "Like other platforms â€” for example, macOS and iOS â€” visionOS displays a window group as a familiar-looking window. In visionOS, people can resize and move windows around the Shared Space. Even if your app offers a sophisticated 3D experience, a window is a great starting point for an app because it eases people into the experience. Itâ€™s also a good place to provide instructions or controls.": {
      "zh": "ä¸å…¶ä»–å¹³å°ï¼ˆå¦‚ macOS å’Œ iOSï¼‰ä¸€æ ·ï¼ŒvisionOS å°†çª—å£ç»„æ˜¾ç¤ºä¸ºç”¨æˆ·ç†Ÿæ‚‰çš„çª—å£ã€‚åœ¨ visionOS ä¸­ï¼Œç”¨æˆ·å¯ä»¥åœ¨å…±äº«ç©ºé—´ä¸­è°ƒæ•´çª—å£å¤§å°å¹¶ç§»åŠ¨çª—å£ã€‚å³ä½¿ä½ çš„åº”ç”¨æä¾›äº†å¤æ‚çš„ 3D ä½“éªŒï¼Œçª—å£ä¹Ÿæ˜¯åº”ç”¨çš„ä¸€ä¸ªå¾ˆå¥½çš„èµ·ç‚¹ï¼Œå› ä¸ºå®ƒå¯ä»¥è®©ç”¨æˆ·ç”±æµ…å…¥æ·±åœ°é¡ºåˆ©è¿›å…¥ä½“éªŒã€‚åŒæ—¶çª—å£ä¹Ÿæ˜¯æä¾›è¯´æ˜æˆ–æ”¾ç½®æ§ä»¶çš„ç†æƒ³ä½ç½®ã€‚",
      "tips": ""
    },
    "Tip": {
      "zh": "æç¤º",
      "tips": ""
    },
    "This particular window group uses the plain window style to maintain control over the glass background effect that visionOS would otherwise automatically add.": {
      "zh": "æ­¤çª—å£ç»„ä½¿ç”¨äº† plain çª—å£æ ·å¼ä»¥ä¿æŒæ§ä»¶æ‚¬æµ®åœ¨æ¯›ç»ç’ƒèƒŒæ™¯ä¸Šçš„æ•ˆæœã€‚å³ä½¿æ²¡æœ‰æ­¤è¡Œä»£ç  visionOS ä¹Ÿä¼šè‡ªåŠ¨æ·»åŠ æ¯›ç»ç’ƒèƒŒæ™¯æ•ˆæœã€‚",
      "tips": ""
    },
    "Present different modules using a navigation stack": {
      "zh": "ä½¿ç”¨å¯¼èˆªæ ˆå±•ç¤ºä¸åŒçš„æ¨¡å—",
      "tips": ""
    },
    "After you watch a brief introductory animation that shows the text Hello World typing in, the Modules view that defines the primary sceneâ€™s content presents options to explore different aspects of the world. This view contains a table of contents at the root of a NavigationStack:": {
      "zh": "åœ¨è§‚çœ‹é”®å…¥æ–‡æœ¬ Hello World çš„ç®€çŸ­ä»‹ç»åŠ¨ç”»åï¼Œå®šä¹‰ä¸»åœºæ™¯å†…å®¹çš„ Modules è§†å›¾ä¼šæ˜¾ç¤ºå¤šç§æ¢ç´¢ä¸–ç•Œçš„é€‰é¡¹ã€‚æ­¤è§†å›¾åŒ…å«äº†ä¸€ä¸ªå¯¼èˆªæ ˆ ï¼ˆNavigationStackï¼‰ï¼Œå¯¼èˆªæ ˆçš„æ ¹è§†å›¾æ˜¯ä¸€ä¸ªç›®å½•ï¼š",
      "tips": ""
    },
    "A visionOS navigation stack has the same behavior that it has in other platforms. When it first appears, the stack displays its root view. When someone chooses an embedded NavigationLink, the stack draws a new view and displays a back button in the toolbar. When someone taps the back button, the stack restores the previous view.": {
      "zh": "visionOS å¯¼èˆªæ ˆä¸å…¶ä»–å¹³å°çš„å¯¼èˆªæ ˆå…·æœ‰ç›¸åŒçš„è¡Œä¸ºã€‚å½“å®ƒé¦–æ¬¡å‡ºç°æ—¶ï¼Œå¯¼èˆªæ ˆä¼šæ˜¾ç¤ºå…¶æ ¹è§†å›¾ã€‚å½“ç”¨æˆ·ç‚¹å‡»å†…åµŒçš„å¯¼èˆªé“¾æ¥ ï¼ˆNavigationLinkï¼‰ æ—¶ï¼Œå¯¼èˆªæ ˆä¼šç»˜åˆ¶ä¸€ä¸ªæ–°è§†å›¾å¹¶åœ¨å·¥å…·æ ä¸­æ˜¾ç¤ºä¸€ä¸ªåé€€æŒ‰é’®ã€‚å½“ç”¨æˆ·ç‚¹å‡»åé€€æŒ‰é’®æ—¶ï¼Œå¯¼èˆªå †å°†æ¢å¤ä¸Šä¸€ä¸ªè§†å›¾ã€‚",
      "tips": ""
    },
    "The trailing closure of the navigationDestination(for:destination:) view modifier in the code above displays a view when someone activates a link based on a module input that comes from the corresponding linkâ€™s initializer:": {
      "zh": "ä¸Šé¢ä»£ç ä¸­çš„ navigationDestination(for:destination:) è§†å›¾ä¿®é¥°ç¬¦çš„å°¾éƒ¨é—­åŒ…ï¼Œä¼šæ ¹æ®é“¾æ¥åˆå§‹åŒ–æ—¶ä¼ å…¥çš„æ¨¡å—ï¼Œåœ¨ç”¨æˆ·æ¿€æ´»é“¾æ¥æ—¶æ˜¾ç¤ºç›¸åº”çš„è§†å›¾ï¼š",
      "tips": ""
    },
    "The possible module values come from a custom Module enumeration:": {
      "zh": "å¯é€‰çš„æ¨¡å—å€¼æ¥æºäºè‡ªå®šä¹‰çš„ Module æšä¸¾ï¼š",
      "tips": ""
    },
    "Display an interactive globe in a new scene": {
      "zh": "åœ¨æ–°åœºæ™¯ä¸­æ˜¾ç¤ºå¯äº¤äº’çš„åœ°çƒä»ª",
      "tips": ""
    },
    "The globe module opens with a few facts about the Earth in the main window next to a decorative, flat image that supports the content. To help people understand even more, the module includes a button titled View Globe that opens a 3D interactive globe in a new window.": {
      "zh": "å½“åœ°çƒä»ªï¼ˆglobeï¼‰æ¨¡å—æ‰“å¼€æ—¶ï¼Œä¸»çª—å£ä¸­ä¼šæ˜¾ç¤ºä¸€äº›æœ‰å…³åœ°çƒçš„çŸ¥è¯†ï¼Œæ—è¾¹è£…é¥°ç€ä¸€ä¸ªè§£é‡Šå†…å®¹çš„å¹³é¢å›¾åƒã€‚ä¸ºäº†å¸®åŠ©ç”¨æˆ·æ›´å¥½åœ°ç†è§£æ¨¡å—å†…å®¹ï¼Œè¯¥æ¨¡å—åŒ…å«äº†ä¸€ä¸ªåä¸ºâ€œView Globeâ€çš„æŒ‰é’®ï¼Œè¯¥æŒ‰é’®å¯åœ¨æ–°çª—å£ä¸­æ‰“å¼€ä¸€ä¸ªä¸‰ç»´äº¤äº’å¼çš„åœ°çƒä»ªã€‚",
      "tips": ""
    },
    "To be able to open multiple scene types, Hello World includes the UIApplicationSceneManifest key in its Information Property List file. The value for this key is a dictionary that includes the UIApplicationSupportsMultipleScenes key with a value of true:": {
      "zh": "ä¸ºäº†èƒ½å¤Ÿæ‰“å¼€å¤šç§åœºæ™¯ç±»å‹ï¼ŒHello World åœ¨å…¶ Information Property List æ–‡ä»¶ä¸­åŒ…å«äº† UIApplicationSceneManifest é”®ã€‚è¯¥é”®çš„å€¼æ˜¯ä¸€ä¸ªå­—å…¸ï¼Œå…¶ä¸­åŒ…å«äº† UIApplicationSupportsMultipleScenes é”®ï¼Œä¸”å…¶å€¼ä¸ºï¼štrue",
      "tips": ""
    },
    "Declare a volumetric window for the globe": {
      "zh": "ä¸ºåœ°çƒä»ªå®šä¹‰ä¸€ä¸ªä¸‰ç»´çª—å£",
      "tips": ""
    },
    "With the key in place, the app makes use of a second WindowGroup in its App declaration. This new window group uses the Globe view as its content:": {
      "zh": "åœ¨ä¸Šè¿°é”®å€¼å°±ä½åï¼Œåº”ç”¨ç¨‹åºå°±å¯ä»¥åœ¨å…¶ App å£°æ˜ä¸­ä½¿ç”¨ç¬¬äºŒä¸ª WindowGroup äº†ã€‚è¿™ä¸ªæ–°çª—å£ç»„ä½¿ç”¨è§†å›¾ Globe ä½œä¸ºå…¶å†…å®¹ï¼š",
      "tips": ""
    },
    "This window group creates a window that has arbitrary depth â€” great for displaying a 3D model in a bounded region that behaves like a transparent box â€” because Hello World uses the volumetric window style scene modifier. People can move this box around the Shared Space like any other window, and the content remains fixed inside. The defaultSize(width:height:depth:in:) modifier specifies a size for the window in meters, including a depth dimension.": {
      "zh": "ç”±äº Hello World ä½¿ç”¨äº†ä¸‰ç»´ ï¼ˆvolumetricï¼‰ çª—å£æ ·å¼åœºæ™¯ä¿®é¥°ç¬¦ï¼Œå› æ­¤è¯¥çª—å£ç»„åˆ›å»ºäº†ä¸€ä¸ªå¯è‡ªå®šä¹‰æ·±åº¦çš„çª—å£--éå¸¸é€‚åˆåœ¨æœ‰è¾¹ç•Œçš„åŒºåŸŸä¸­æ˜¾ç¤ºä¸‰ç»´æ¨¡å‹ï¼Œå…¶è¡Œä¸ºå°±åƒä¸€ä¸ªé€æ˜çš„ç›’å­ã€‚ç”¨æˆ·å¯ä»¥åƒç§»åŠ¨ä»»ä½•å…¶ä»–çª—å£ä¸€æ ·åœ¨å…±äº«ç©ºé—´ä¸­ç§»åŠ¨è¿™ä¸ªç›’å­ï¼Œè€Œé‡Œé¢çš„å†…å®¹åˆ™ä¿æŒä¸å˜ã€‚defaultSize(width:height:depth:in:) ä¿®é¥°ç¬¦ç”¨æ¥æŒ‡å®šçª—å£çš„ï¼ˆåŒ…å«æ·±åº¦çš„ï¼‰å¤§å°ï¼ˆä»¥ç±³ä¸ºå•ä½ï¼‰ã€‚",
      "tips": ""
    },
    "The Globe view contains 3D content, but is still just a SwiftUI view. It contains two elements in a ZStack: a subview that draws a model of the Earth, and another that provides a control panel that people can use to configure the modelâ€™s appearance.": {
      "zh": "è¯¥ Globe è§†å›¾è™½ç„¶åŒ…å«äº† 3D å†…å®¹ï¼Œä½†å…¶æœ¬èº«ä»ç„¶åªæ˜¯ä¸€ä¸ª SwiftUI è§†å›¾ã€‚å®ƒçš„ ZStack ä¸­åŒ…å«äº†ä¸¤ä¸ªå…ƒç´ ï¼šä¸€ä¸ªç»˜åˆ¶åœ°çƒæ¨¡å‹çš„å­è§†å›¾ï¼Œå¦ä¸€ä¸ªå­è§†å›¾è´Ÿè´£æä¾›æ§åˆ¶é¢æ¿ï¼Œç”¨æˆ·å¯ä»¥ä½¿ç”¨å®ƒæ¥é…ç½®åœ°çƒä»ªçš„å¤–è§‚ã€‚",
      "tips": ""
    },
    "Open and dismiss the globe window": {
      "zh": "æ‰“å¼€å’Œå…³é—­åœ°çƒä»ªçª—å£",
      "tips": ""
    },
    "The globe module presents a View Globe button that people can tap to display the volumetric window or dismiss the window, depending on the current state. Hello World achieves this behavior by creating a Toggle with the button style, and embedding it in a custom GlobeToggle view.": {
      "zh": "åœ°çƒä»ªæ¨¡å—æ˜¾ç¤ºäº†ä¸€ä¸ª View Globe æŒ‰é’®ã€‚å½“ç”¨æˆ·ç‚¹å‡»è¯¥æŒ‰é’®åï¼Œç³»ç»Ÿä¼šæ ¹æ®å½“å‰çŠ¶æ€æ¥æ˜¾ç¤ºä¸‰ç»´çª—å£æˆ–å…³é—­çª—å£ã€‚Hello World é€šè¿‡åˆ›å»ºä¸€ä¸ªæŒ‰é’®æ ·å¼çš„ Toggleï¼Œå¹¶å°†å…¶åµŒå…¥åˆ°è‡ªå®šä¹‰ GlobeToggle è§†å›¾ä¸­æ¥å®ç°è¿™ä¸€åŠŸèƒ½ã€‚",
      "tips": ""
    },
    "When someone taps the toggle, the isShowingGlobe state changes, and the onChange(of:initial:_:) modifier calls the openWindow or dismissWindow action to open or dismiss the window, respectively. The view gets these actions from the environment and uses an identifier that matches the windowâ€™s identifier.": {
      "zh": "å½“ç”¨æˆ·ç‚¹å‡»åˆ‡æ¢æŒ‰é’®æ—¶ï¼ŒisShowingGlobe çŠ¶æ€ä¼šå‘ç”Ÿå˜åŒ–ï¼Œ ä¸” onChange(of:initial:_:) ä¿®é¥°ç¬¦ä¼šåˆ†åˆ«è°ƒç”¨ openWindow æˆ– dismissWindow æ“ä½œæ¥æ‰“å¼€æˆ–å…³é—­çª—å£ã€‚è§†å›¾ä»ç¯å¢ƒå˜é‡ä¸­è·å–è¿™äº›æ“ä½œï¼Œå¹¶ä½¿ç”¨å¯¹åº”çš„çª—å£æ ‡è¯†ç¬¦æ¥è¿è¡Œæ“ä½œã€‚",
      "tips": ""
    },
    "Display objects that orbit the Earth": {
      "zh": "æ˜¾ç¤ºç»•åœ°çƒè¿è¡Œçš„ç‰©ä½“",
      "tips": ""
    },
    "You use windows in visionOS the same way you do in other platforms. But windows in visionOS provide a small amount of depth you can use to create 3D effects â€” like elements that appear in front of other elements. Hello World takes advantage of this depth to present small models inline with 2D content.": {
      "zh": "åœ¨ visionOS ä¸­ä½¿ç”¨çª—å£çš„æ–¹å¼ä¸å…¶ä»–å¹³å°ç›¸åŒã€‚ä½†æ˜¯ï¼ŒvisionOS ä¸­çš„çª—å£æä¾›äº†å¯ç”¨äºåˆ›å»º 3D æ•ˆæœçš„å°‘é‡æ·±åº¦--æ¯”å¦‚æ˜¾ç¤ºåœ¨å…¶ä»–å…ƒç´ å‰æ–¹çš„å…ƒç´ ã€‚Hello World åˆ©ç”¨è¿™ç§æ·±åº¦æ¥åœ¨ 2D å†…å®¹çš„è¡Œé—´å±•ç¤ºå°çš„ 3D æ¨¡å‹ã€‚",
      "tips": ""
    },
    "The appâ€™s second module, Objects in Orbit, provides information about objects that go around the Earth, like the Moon and artificial satellites. To give a sense of what these objects look like, the module displays 3D models of these items directly inside the window.": {
      "zh": "åº”ç”¨çš„ç¬¬äºŒä¸ªæ¨¡å—ï¼Œâ€œè½¨é“ä¸Šçš„ç‰©ä½“â€ï¼ˆObjects in Orbitï¼‰æä¾›äº†æœˆçƒå’Œäººé€ å«æ˜Ÿç­‰ç»•åœ°çƒé£è¡Œçš„ç‰©ä½“çš„ä¿¡æ¯ã€‚ä¸ºäº†è®©ç”¨æˆ·äº†è§£è¿™äº›å¯¹è±¡çš„å¤–è§‚ï¼Œè¯¥æ¨¡å—ç›´æ¥åœ¨çª—å£å†…æ˜¾ç¤ºè¿™äº›å¯¹è±¡çš„ 3D æ¨¡å‹ã€‚",
      "tips": ""
    },
    "Hello World loads these models from the asset bundle using a Model3D structure inside a custom ItemView. The view scales and positions the model to fit the available space, and applies optional orientation adjustments:": {
      "zh": "Hello World åœ¨è‡ªå®šä¹‰çš„ ItemView ä¸­ä½¿ç”¨ Model3D ç»“æ„ä½“ä»èµ„æºåŒ…é‡ŒåŠ è½½è¿™äº›æ¨¡å‹ã€‚è§†å›¾ä¼šæ ¹æ®å¯ç”¨ç©ºé—´å¯¹æ¨¡å‹è¿›è¡Œç¼©æ”¾å’Œå®šä½ï¼Œå¹¶è§†æƒ…å†µè°ƒæ•´è§’åº¦ï¼š",
      "tips": ""
    },
    "The app uses this ItemView once for each model, placing each in an overlay that only becomes visible based on the current selection. For example, the following overlay displays the satellite model with a small amount of tilt in the x-axis and z-axis:": {
      "zh": "è¯¥åº”ç”¨ä¸ºæ¯ä¸ªæ¨¡å‹éƒ½åˆ›å»ºäº†ä¸Šè¿°çš„ ItemViewï¼Œå¹¶å°†å®ƒä»¬æ”¾åœ¨ä¸€ä¸ªå åŠ å±‚ä¸­ï¼Œ ä¸”åªæœ‰å½“å‰è¢«é€‰ä¸­çš„æ¨¡å‹ä¼šæ˜¾ç¤ºå‡ºæ¥ã€‚ä¾‹å¦‚ï¼Œä¸‹è¿°çš„å åŠ å±‚æ˜¾ç¤ºäº†ä¸€ä¸ªåœ¨ x è½´å’Œ z è½´ä¸Šæœ‰ç¨å¾®å€¾æ–œå«æ˜Ÿæ¨¡å‹ï¼š",
      "tips": ""
    },
    "The VStack that contains the models also contains a Picker that people use to select a model to view:": {
      "zh": "åŒ…å«ä¸Šè¿°æ¨¡å‹çš„ VStack ä¸­è¿˜åŒ…å«äº†ä¸€ä¸ª Pickerï¼Œç”¨æ¥é€‰æ‹©æŸ¥çœ‹çš„æ¨¡å‹ï¼š",
      "tips": ""
    },
    "When you add 3D effects to a 2D window, keep this guidance in mind:": {
      "zh": "å½“ä½ å‘ 2D çª—å£æ·»åŠ  3D æ•ˆæœæ—¶ï¼Œè¯·ç‰¢è®°ä»¥ä¸‹å‡ ç‚¹ï¼š",
      "tips": ""
    },
    "Donâ€™t overdo it. These kinds of effects add interest, but can unintentionally obscure important controls or information as people view the window from different directions.": {
      "zh": "ä¸è¦è¿‡åº¦ä½¿ç”¨ã€‚è¿™ç§ç±»å‹çš„æ•ˆæœè™½ç„¶å¢åŠ äº†è¶£å‘³æ€§ï¼Œä½†å½“ç”¨æˆ·ä»ä¸åŒæ–¹å‘æŸ¥çœ‹çª—å£æ—¶ï¼Œè¿™äº›æ•ˆæœæœ‰å¯èƒ½ä¼šæ— æ„ä¸­é®æŒ¡é‡è¦æ§ä»¶æˆ–ä¿¡æ¯ã€‚",
      "tips": ""
    },
    "Ensure that elements donâ€™t exceed the available depth. Excess depth causes elements to clip. Account for any position or orientation changes that might occur after initial placement.": {
      "zh": "ç¡®ä¿å…ƒç´ ä¸è¶…å‡ºå¯ç”¨æ·±åº¦ã€‚è¿‡å¤§çš„æ·±åº¦ä¼šå¯¼è‡´å…ƒç´ è¢«å‰ªåˆ‡ã€‚è¦è€ƒè™‘åˆ°åˆå§‹æ”¾ç½®åå¯èƒ½å‘ç”Ÿçš„ä½ç½®æˆ–è§’åº¦å˜åŒ–ã€‚",
      "tips": ""
    },
    "Avoid models intersecting with the backing glass. Again, account for potential movement after initial placement.": {
      "zh": "é¿å…æ¨¡å‹ä¸ç»ç’ƒèƒŒæ™¯ç›¸äº¤ã€‚å†æ¬¡å¼ºè°ƒï¼Œè¯·è€ƒè™‘åˆå§‹æ”¾ç½®ç‰©ä½“åå¯èƒ½å‘ç”Ÿçš„ç§»åŠ¨ã€‚",
      "tips": ""
    },
    "Show Earthâ€™s relationship to its satellites in an immersive space": {
      "zh": "åœ¨æ²‰æµ¸å¼ç©ºé—´ä¸­å±•ç¤ºåœ°çƒä¸å…¶å«æ˜Ÿçš„å…³ç³»",
      "tips": ""
    },
    "People can visualize how satellites move around the Earth because the appâ€™s orbit module displays the Earth, the Moon, and a communications satellite together as a single system. People can move the system anywhere in their environment or resize it using standard gestures. They can also move themselves around the system to get different perspectives.": {
      "zh": "ç”¨æˆ·å¯ä»¥ç›´è§‚åœ°çœ‹åˆ°å«æ˜Ÿæ˜¯å¦‚ä½•å›´ç»•åœ°çƒè¿åŠ¨çš„ï¼Œå› ä¸ºåº”ç”¨çš„è½¨é“æ¨¡å—å°†åœ°çƒã€æœˆçƒå’Œä¸€ä¸ªé€šä¿¡å«æ˜Ÿæ˜¾ç¤ºåœ¨åŒä¸€ä¸ªç³»ç»Ÿé‡Œã€‚ç”¨æˆ·å¯ä»¥å°†è¯¥ç³»ç»Ÿæ‹–åŠ¨åˆ°ç¯å¢ƒä¸­çš„ä»»ä½•ä½ç½®ï¼Œæˆ–ä½¿ç”¨æ ‡å‡†æ‰‹åŠ¿è°ƒæ•´å…¶å¤§å°ã€‚ç”¨æˆ·è‡ªå·±ä¹Ÿå¯ä»¥åœ¨ç³»ç»Ÿç§»åŠ¨ä»¥è·å¾—ä¸åŒçš„è§†è§’ã€‚",
      "tips": ""
    },
    "Note": {
      "zh": "å¤‡æ³¨",
      "tips": ""
    },
    "To learn about designing with gestures in visionOS, read Gestures in Human Interface Guidelines.": {
      "zh": "æƒ³äº†è§£å¦‚ä½•åœ¨ visionOS ä¸­ä½¿ç”¨æ‰‹åŠ¿è¿›è¡Œè®¾è®¡ï¼Œè¯·é˜…è¯»ã€Šç”¨æˆ·ç•Œé¢æŒ‡å—ã€‹ä¸­çš„æ‰‹åŠ¿ç« èŠ‚ã€‚",
      "tips": ""
    },
    "To create this visualization, the app displays the Orbit view â€” which contains a single RealityView that models the entire system â€” in an ImmersiveSpace scene with the mixed immersion style:": {
      "zh": "ä¸ºåˆ›å»ºè¿™ä¸€æ•ˆæœï¼Œåº”ç”¨åœ¨ mix æ²‰æµ¸é£æ ¼çš„ ImmersiveSpace åœºæ™¯ä¸­å±•ç¤ºäº† Orbit è§†å›¾--å…¶ä¸­åŒ…å«äº†ä¸€ä¸ªæ¨¡æ‹Ÿæ•´å¥—ç³»ç»Ÿçš„ RealityViewï¼š",
      "tips": ""
    },
    "As with any secondary scene in a visionOS app, this scene depends on having the UIApplicationSupportsMultipleScenes key in the Information Property List file. The app also opens and closes the space using a toggle view that resembles the one used for the globe:": {
      "zh": "ä¸ visionOS åº”ç”¨ä¸­çš„æ‰€æœ‰è¾…åŠ©åœºæ™¯ä¸€æ ·ï¼Œæ­¤åœºæ™¯ä¾èµ–äº Information Property List file æ–‡ä»¶ä¸­çš„ UIApplicationSupportsMultipleScenes é”®ã€‚åŒæ—¶ï¼Œåº”ç”¨è¿˜ä½¿ç”¨äº†ä¸åœ°çƒä»ªæ¨¡ç»„ä¸­ç±»ä¼¼çš„å¼€å…³æŒ‰é’®æ¥æ‰“å¼€å’Œå…³é—­ç©ºé—´ï¼š",
      "tips": ""
    },
    "There are a few key differences from the version that appears in the section Open and dismiss the globe window:": {
      "zh": "è¿™é‡Œä¸â€œæ‰“å¼€å’Œå…³é—­åœ°çƒä»ªçª—å£â€ä¸€èŠ‚ä¸­çš„ç‰ˆæœ¬æœ‰å‡ ä¸ªä¸»è¦åŒºåˆ«ï¼š",
      "tips": ""
    },
    "OrbitToggle uses openImmersiveSpace and dismissImmersiveSpace from the environment, rather than the window equivalents.": {
      "zh": "OrbitToggle ä½¿ç”¨äº†ç¯å¢ƒå˜é‡ä¸­çš„ openImmersiveSpace å’Œ dismissImmersiveSpace æ²‰æµ¸å¼ç©ºé—´æ“ä½œï¼Œè€Œä¸æ˜¯çª—å£æ“ä½œã€‚",
      "tips": ""
    },
    "The dismiss action in this case doesnâ€™t require an identifier, because people can only open one space at a time, even across apps.": {
      "zh": "è¿™æ—¶å…³é—­æ“ä½œä¸éœ€è¦æ ‡è¯†ç¬¦ï¼Œå› ä¸ºç”¨æˆ·ä¸€æ¬¡åªèƒ½æ‰“å¼€ä¸€ä¸ªæ²‰æµ¸å¼ç©ºé—´ï¼Œå³ä½¿åˆ‡æ¢åº”ç”¨ä¹Ÿæ˜¯å¦‚æ­¤ã€‚",
      "tips": ""
    },
    "The open and dismiss actions for spaces operate asynchronously, and so they appear inside a Task.": {
      "zh": "æ‰“å¼€å’Œå…³é—­ç©ºé—´æ“ä½œæ˜¯å¼‚æ­¥çš„ï¼Œå› æ­¤å®ƒä»¬çš„ä½¿ç”¨å‡ºç°åœ¨ Task é—­åŒ…ä¸­ã€‚",
      "tips": ""
    },
    "View the solar system from space using full immersion": {
      "zh": "ä½¿ç”¨å®Œå…¨æ²‰æµ¸å¼ä»å¤ªç©ºè§‚å¯Ÿå¤ªé˜³ç³»",
      "tips": ""
    },
    "The appâ€™s final module gives people a sense of the Earthâ€™s place in the solar system. Like other modules, this one includes information and a decorative image next to a button that leads to another visualization â€” in this case so people can experience Earth from space.": {
      "zh": "åº”ç”¨çš„æœ€åä¸€ä¸ªæ¨¡å—æ„åœ¨å¸®åŠ©ç”¨æˆ·äº†è§£åœ°çƒåœ¨å¤ªé˜³ç³»ä¸­çš„ä½ç½®ã€‚ä¸å…¶ä»–æ¨¡å—ä¸€æ ·ï¼Œè¿™ä¸ªæ¨¡å—åŒ…æ‹¬äº†è¯´æ˜ã€è£…é¥°å›¾åƒã€åŠä¸€ä¸ªæŒ‡å‘å¦ä¸€ä¸ªåœºæ™¯çš„æŒ‰é’®--åœ¨æœ¬æ¨¡å—çš„åœºæ™¯ä¸­ï¼Œç”¨æˆ·å¯ä»¥ä»å¤ªç©ºä¸­è§‚å¯Ÿåœ°çƒã€‚",
      "tips": ""
    },
    "When a person taps the button, the app takes over the entire display and shows stars in all directions. The Earth appears directly in front, the Moon to the right, and the Sun to the left. The main window also shows a small control panel that people can use to exit the fully immersive experience.": {
      "zh": "å½“ç”¨æˆ·ç‚¹å‡»æŒ‰é’®åï¼Œåº”ç”¨å°†æ¥ç®¡æ•´ä¸ªæ˜¾ç¤ºå±ï¼Œå¹¶åœ¨å„ä¸ªæ–¹ä½æ˜¾ç¤ºæ˜Ÿæ˜Ÿã€‚åœ°çƒå‡ºç°åœ¨æ­£å‰æ–¹ï¼Œæœˆçƒåœ¨å³ä¾§ï¼Œå¤ªé˜³åœ¨å·¦ä¾§ã€‚ä¸»çª—å£è¿˜æ˜¾ç¤ºäº†ä¸€ä¸ªå°å‹æ§åˆ¶é¢æ¿ï¼Œç”¨æˆ·å¯ä»¥ç”¨å®ƒæ¥é€€å‡ºå®Œå…¨æ²‰æµ¸å¼ä½“éªŒã€‚",
      "tips": ""
    },
    "People can exit full immersion by pressing the deviceâ€™s Digital Crown, but itâ€™s typically useful when you provide a built-in mechanism to maintain control of the experience within your app.": {
      "zh": "ç”¨æˆ·å¯ä»¥æŒ‰ä¸‹è®¾å¤‡çš„æ•°ç è¡¨å† æ¥é€€å‡ºå®Œå…¨æ²‰æµ¸å¼ä½“éªŒï¼Œä½†é€šå¸¸æƒ…å†µä¸‹ï¼Œåœ¨åº”ç”¨ç¨‹åºä¸­æä¾›ä¸€ä¸ªå†…ç½®æœºåˆ¶æ¥æ§åˆ¶ä½“éªŒæ˜¯éå¸¸æœ‰å¸®åŠ©çš„ã€‚",
      "tips": ""
    },
    "The app uses another immersive space scene for this module, but here with the full immersion style that turns off the passthrough video:": {
      "zh": "æœ¬æ¨¡å—ä½¿ç”¨äº†å¦ä¸€ä¸ªæ²‰æµ¸å¼ç©ºé—´åœºæ™¯ï¼Œä½†æ­¤å¤„ä½¿ç”¨çš„æ˜¯ full æ²‰æµ¸é£æ ¼ï¼Œå®ƒä¼šå…³é—­è®¾å¤‡çš„ç°å®æ˜ å°„åŠŸèƒ½ï¼š",
      "tips": ""
    },
    "This scene depends on the same UIApplicationSupportsMultipleScenes key that other secondary scenes do, and is activated by a SolarSystemToggle thatâ€™s similar to the ones that the app uses for the other scenes:": {
      "zh": "ä¸å…¶ä»–è¾…åŠ©åœºæ™¯ç›¸åŒï¼Œæ­¤åœºæ™¯ä¹Ÿä¾èµ–äºçš„ UIApplicationSupportsMultipleScenes é”®ï¼Œå¹¶ç”±ä¸å…¶ä»–åœºæ™¯ä¸­ç”¨çš„å¼€å…³ç±»ä¼¼çš„ SolarSystemToggle æ¿€æ´»ï¼š",
      "tips": ""
    },
    "This control appears in the main window to provide a way to begin the fully immersive experience, and separately in the control panel as a way to exit the experience. Because the app uses this control as two distinct buttons rather than as a toggle in one location, itâ€™s composed of a Button with behavior that changes depending on the app state rather than as a toggle with a button style.": {
      "zh": "æ­¤æ§ä»¶æ˜¾ç¤ºåœ¨ä¸»çª—å£ä¸­ï¼Œä»¥æä¾›è¿›å…¥å®Œå…¨æ²‰æµ¸å¼ä½“éªŒçš„å…¥å£ï¼ŒåŒæ—¶åˆå•ç‹¬æ˜¾ç¤ºåœ¨æ§åˆ¶é¢æ¿ä¸­ï¼Œä½œä¸ºé€€å‡ºä½“éªŒçš„ä¸€ç§æ–¹å¼ã€‚ç”±äºåº”ç”¨åœ¨ä¸åŒçš„ä¸¤ä¸ªä½ç½®å°†æ­¤æ§ä»¶ç”¨ä½œæŒ‰é’®ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªä½ç½®ä¸å˜çš„å¼€å…³ï¼Œå› æ­¤å®ƒæ˜¯ç”±ä¸€ä¸ªæ ¹æ®åº”ç”¨çŠ¶æ€è€Œæ”¹å˜è¡Œä¸ºçš„ Button æ„æˆçš„ï¼Œè€Œä¸æ˜¯ä½¿ç”¨äº†æŒ‰é’®æ ·å¼çš„ Toggleã€‚",
      "tips": ""
    },
    "To reuse the main window for the solar system controls, Hello World places both the navigation stack and the controls in a ZStack, and then sets the opacity of each to ensure that only one appears at a time:": {
      "zh": "ä¸ºäº†èƒ½åœ¨å¤ªé˜³ç³»æ¨¡å—çš„æ§ä»¶ä¸­å¤ç”¨ä¸»çª—å£ï¼ŒHello World å°†å¯¼èˆªæ ˆå’Œæ§ä»¶æ”¾åœ¨äº†ä¸€ä¸ª ZStack ä¸­ï¼Œç„¶åé€šè¿‡è®¾ç½®æ¯ä¸ªæ§ä»¶çš„ä¸é€æ˜åº¦ï¼Œç¡®ä¿æ¯æ¬¡åªæ˜¾ç¤ºä¸€ä¸ªè§†å›¾ï¼š",
      "tips": ""
    }
  }
}
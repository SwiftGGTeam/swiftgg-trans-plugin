{
  "sample-apps/aboutme": {
    "About Me": {
      "zh": "关于我",
      "tips": ""
    },
    "Display data from a central source in multiple views.": {
      "zh": "在多个视图中显示来自一个中心源的数据。",
      "tips": ""
    },
    "Welcome to the About Me app. In this walkthrough, you’ll learn the basics of using SwiftUI to display information across multiple tab views.": {
      "zh": "欢迎使用 About Me 应用程序。在这个演示中，你将学习使用 SwiftUI 在多个标签视图中显示信息。",
      "tips": ""
    },
    "Run the preview and tap to select the Home, Story, Favorites, and Fun Facts tabs at the bottom of the screen.": {
      "zh": "运行预览并选择屏幕底部的 Home, Story, Favorites, 和 Fun Facts 标签栏。",
      "tips": ""
    },
    "You can change all of the data, or content, in the app to be about any topic of your choice. While you walk through this sample, try swapping out the information and edit colors and modifiers to suit your style.": {
      "zh": "你可以按照你的偏好更改应用程序中的所有数据或者内容。在演示中，你可以修改信息和颜色以及修饰符来定制你的风格。",
      "tips": ""
    },
    "Tabbed Interface": {
      "zh": "标签视图",
      "tips": ""
    },
    "Explore how to set up a tabbed interface.": {
      "zh": "探索如何设置标签视图。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "This is the ContentView view. It’s the first view that you’ll see when you launch your app.": {
      "zh": "这是一个 ContentView 视图。它是应用程序的第一个视图。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "You create the user interface, or UI, for your app inside the body. The entire contents of your app are in the code below.": {
      "zh": "你可以在 body 中创建应用程序的用户界面。你的应用程序的所有内容都在 body 中。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "TabView is how you create a user interface with tabs. Inside the tab view, you list each of the tab items that you want.": {
      "zh": "TabView 是你创建的带有标签的展示用户界面的视图。在 tab 视图中，你列出了需要展示的标签项。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "To make a tab, create an instance of the view you want to display when someone taps a tab. The first tab view in the list is HomeView, so it’s the first tab you see when the app launches.": {
      "zh": "要创建一个标签，首先创建一个你想要显示的视图。在列表中的第一个标签视图是 HomeView，因此它是应用程序启动时显示的标签视图。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "Try commenting out a tab, using two slashes // at the beginning of each of the highlighted lines of code to see what happens to your UI.": {
      "zh": "尝试注释掉一个标签，使用两个斜杠 // 放在高亮的代码行的开头来看看你的 UI 会发生什么变化。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "Under the view, add the .tabItem modifier, and pass in a Label as the tab display. Without a tabItem, the tab for this view appears empty.": {
      "zh": "在视图中添加 .tabItem 修饰符，并传递一个 Label 作为标签显示。如果没有 .tabItem 修饰符，则此视图的标签显示为空。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第七步",
      "tips": ""
    },
    "The tabItem modifier only accepts Label, Text, and Image views. Including any other type of view, such as Button, results in an empty tab item.": {
      "zh": "tabItem 修饰符只接受 Label、Text 和 Image 视图。任何其他类型的视图，例如 Button 都将导致空的标签内容。",
      "tips": ""
    },
    "Your Data": {
      "zh": "你的数据",
      "tips": ""
    },
    "Modify your app data.": {
      "zh": "修改你的应用数据。",
      "tips": ""
    },
    "This file is where your app stores all of its data (information). In SwiftUI, it’s best to keep the data separate from the visual components of your app. While learning SwiftUI, you’ll frequently see the concept of having a “source of truth” for your data, which means that you only define a value in one place. You will practice this in a few steps when you begin to change the data.": {
      "zh": "这个文件是存储你的应用数据的地方。在 SwiftUI 中，最好将数据和应用的可视化组件分开。在学习 SwiftUI 时，你会经常看到将数据有一个 “真实来源” 的概念，这意味着你只在一个地方定义一个值，你将在下面的步骤中分几步练习修改数据。",
      "tips": ""
    },
    "This structure provides the blueprint for your data. It contains properties that define the name and type of data that the app stores. For instance, your app stores a story property as a String and a colors property as an array of Color values.": {
      "zh": "这个结构体表示你需要的数据结构。它包含定义应用存储的数据和类型。例如，你的应用存储一个 String 类型的 Story 属性和内部为 Color 类型的名为 colors 的数组。",
      "tips": ""
    },
    "This value, information, uses the Info structure to store all of the data used in your app. You can refer to this global variable by its name from any file of the project.": {
      "zh": "information 使用 Info 结构体来存储所有用于应用的数据。你可以在项目的任何文件中引用这个全局变量。",
      "tips": ""
    },
    "To personalize this project, change the string inside the quotes to your name.": {
      "zh": "要个性化这个项目，修改在引号内的字符串为你想要的内容。",
      "tips": ""
    },
    "The value for your name is only created this one time, making it the source of truth. Whenever you want to use your name in a component or view, you refer to this value by its name: information.name.": {
      "zh": "你定义的名称仅在这里创建一次，因此它是你数据源。当你想在组件或视图中使用你的名称时，你可以引用它的名称： information.name。",
      "tips": ""
    },
    "Before moving on, try changing the image. The string “Placeholder” refers to the name of an image in your app’s assets. To add a new image, open the sidebar and tap the Add New Item button in the toolbar. Choose Photo, and select an image from your Photos library. Then give your image a descriptive name.": {
      "zh": "在继续之前，尝试更改图片。字符串 “Placeholder” 代表应用程序的资产中的名字。要添加一个新的图片，打开工具栏并点击 Add New Item 按钮。选择 Photo 并选择你的图片库中的图片。然后为你的图片添加一个描述性的名称。",
      "tips": ""
    },
    "To use your new image, change “Placeholder” to the name of the new image you just added. Tap the the Home tab in the Preview to see your changes.": {
      "zh": "要使用你的新图片，更改 “Placeholder” 为你添加的新图片的名称。点击 Preview 中的 Home 按钮来查看你的修改。",
      "tips": ""
    },
    "Step 8": {
      "zh": "第八步",
      "tips": ""
    },
    "Swift Playgrounds adds your photo to the Assets section of the sidebar and highlights the name for you to edit. After you’ve named the image asset, change the string for this property to match its new name.": {
      "zh": "Swift Playgrounds 将你的图片添加到 Assets 列表中并高亮了你要修改的名称。命名你的图片资产后，更改这个属性的字符串以匹配你的新名称。",
      "tips": ""
    },
    "Home Tab": {
      "zh": "Home 标签页",
      "tips": ""
    },
    "Explore some basic SwiftUI code.": {
      "zh": "探索一些基本的 SwiftUI 代码。",
      "tips": ""
    },
    "The HomeView is the first tab of your app, so it’s the first thing you’ll see when the app launches. You’ve seen this in action already, when you first opened the project.": {
      "zh": "HomeView 是应用程序的第一个标签，因此它是应用程序启动时显示的标签。当你第一次打开项目时，你已经看到了这一点。",
      "tips": ""
    },
    "A VStack organizes its contents vertically from top to bottom on the screen.": {
      "zh": "VStack 在屏幕上从上到下排列内容。",
      "tips": ""
    },
    "A Text view displays the string inside the quotation marks.": {
      "zh": "文本视图将会显示引号内的字符串。",
      "tips": ""
    },
    "Try changing the string before moving on. Do you see your new text in the preview?": {
      "zh": "在继续之前尝试更改字符串。在预览中你看到了你设置的新文本了吗？",
      "tips": ""
    },
    "You can use modifiers to change how the app displays the text. Here are two good ones to know: You can use .font to specify different styles of text, and .fontWeight to change the weight of the font.": {
      "zh": "你可以使用修饰符来改变应用显示的文本。下面是两个值得了解的方法: 可以使用 .font 来指定不同的样式的文本，以及 .fontWeight 来改变文本的粗细。",
      "tips": ""
    },
    "Try changing .largeTitle and .bold to different values to see how they affect the view. To do this, delete the existing value — including the period (.) — then type a period and wait to see the options suggested in the autocompletion menu.": {
      "zh": "尝试更改 .largeTitle 和 .bold 来不同值来看如何影响视图。要做此事，需要删除现有值 — 包括点(.) — 然后输入点(.)，看看自动补全菜单中建议的选项。",
      "tips": ""
    },
    "The .padding modifier adds extra space between a view and the other views around it.": {
      "zh": ".padding 修饰符为视图与周围的视图添加额外的空间。",
      "tips": ""
    },
    "Here, you’re using the default SwiftUI padding. You can also specify a custom value, which you can spot below.": {
      "zh": "在这里，你使用的是默认 SwiftUI 间距。你也可以指定一个自定义值，你可以在下面找到它。",
      "tips": ""
    },
    "Step 9": {
      "zh": "第九步",
      "tips": ""
    },
    "This Image view displays the image that you changed in the Data file.": {
      "zh": "这个 Image 视图显示你修改的 Data 文件中的图片。",
      "tips": ""
    },
    "Step 10": {
      "zh": "第十步",
      "tips": ""
    },
    "This Image view has several common modifiers. The first one, .resizable, is very important to remember.": {
      "zh": "这个 Image 视图有多种常用修饰符。第一个 .resizable 非常重要需要记住。",
      "tips": ""
    },
    "Step 11": {
      "zh": "第十一步",
      "tips": ""
    },
    "It allows the image to adapt to the available space on the screen; otherwise the image appears at its full size, which may be very large.": {
      "zh": "它允许图片适应可用空间，否则图片会显示为完整尺寸，这可能会很大。",
      "tips": ""
    },
    "Step 12": {
      "zh": "第十二步",
      "tips": ""
    },
    "The .aspectRatio modifier requires the image to maintain its aspect ratio. By specifying .fit, you’re asking SwiftUI to resize the image so it fits within the available space.": {
      "zh": ".aspectRatio 修饰符需要图片保持其比例。通过指定 .fit，来要求 SwiftUI 将图片尺寸适应可用空间。",
      "tips": ""
    },
    "Step 13": {
      "zh": "第十三步",
      "tips": ""
    },
    "To see the effect of this modifier, try changing .fit to .fill, or comment out the line entirely.": {
      "zh": "要查看这个修饰符的效果，尝试更改 .fit 为 .fill 或完全注释整行。",
      "tips": ""
    },
    "Step 14": {
      "zh": "第十四步",
      "tips": ""
    },
    "You can give any view rounded corners with the .cornerRadius modifier. Try changing the value to make the corners larger or smaller.": {
      "zh": "你可以使用 .cornerRadius 修饰符给任何视图添加圆角。尝试更改值来改变圆角大小。",
      "tips": ""
    },
    "Story Tab": {
      "zh": "Story 标签页",
      "tips": ""
    },
    "Learn how to use a scroll view to create a scrolling narrative.": {
      "zh": "了解如何使用一个滚动视图来创建滚动故事。",
      "tips": ""
    },
    "This is the StoryView, where you can display a story about anything you want.": {
      "zh": "这是一个 StoryView，你可以显示任何想要的故事。",
      "tips": ""
    },
    "To let your story scroll if the text gets too long, wrap your Text view in a ScrollView.": {
      "zh": "想要在文本很长的情况下滚动，可以使用 ScrollView 来包裹文本视图。",
      "tips": ""
    },
    "This text view extracts information that you have in the Data file to build your story.": {
      "zh": "这个文本视图从 Data 文件中提取信息来构建故事。",
      "tips": ""
    },
    "To test the scroll view, open Data and edit the story text between the red quotation marks. Try writing a long story of your own, then come back to this preview and test how your page scrolls.": {
      "zh": "要测试滚动视图，打开 Data 文件并编辑红引号内的故事文本。尝试写一个长长的故事，然后返回预览并测试你的页面滚动。",
      "tips": ""
    },
    "Favorites Tab": {
      "zh": "Favorites 标签页",
      "tips": ""
    },
    "Build your UI using various stacks and loops.": {
      "zh": "使用各种堆栈和循环构建你的 UI。",
      "tips": ""
    },
    "The FavoritesView shows your favorite hobbies, foods, and colors.": {
      "zh": "FavoritesView 展示你喜欢的兴趣、食物和颜色。",
      "tips": ""
    },
    "Each of the three sections are organized the same way. You have a title at the top, and an HStack below it that displays the images, text, or colors horizontally.": {
      "zh": "这三个部分是同样组织方式。在顶部有一个标题，下面是一个显示图片、文字或颜色的 HStack。",
      "tips": ""
    },
    "The ForEach uses the global information data and iterates through the hobbies array. Because ForEach needs to know how to tell the items apart from each other, you pass \\.self as the argument to id.": {
      "zh": "ForEach 使用全局 information 数据并且迭代遍历 hobbies 数组。因为 ForEach 需要知道如何区分每一个项目，所以你需要传递 \\.self 作为参数当做 id。",
      "tips": ""
    },
    "In the hobbies example, you create an image inside the HStack using modifiers to adjust its size. For example, .resizable allows you to resize the images.": {
      "zh": "在 hobbies 示例中，你使用修饰符来调整图片的大小。例如：.resizable 让图片自适应。",
      "tips": ""
    },
    "Try replacing the .frame modifier with .scaledToFit or .scaledToFill, or removing the .resizable modifier. Did anything happen to your images?": {
      "zh": "尝试替换 .frame 修饰符为 .scaledToFit 或 .scaledToFill，或者删除 .resizable 修饰符。观察图片是否发生了什么变化？",
      "tips": ""
    },
    "Fun Facts Tab": {
      "zh": "Fun Facts 标签页",
      "tips": ""
    },
    "Make your app interactive by adding a button that displays a random fact about you.": {
      "zh": "通过添加一个显示随机事实的按钮来让你的应用有交互性。",
      "tips": ""
    },
    "In the FunFactsView you’ll use a Button view to change a fun fact string whenever someone taps it.": {
      "zh": "在 FunFactsView 中，你将使用 Button 视图，当用户点击时来改变一个 fun fact 字符串。",
      "tips": ""
    },
    "The variable funFact stores the fun fact displayed by this view. Because funFact uses @State, the fun fact Text view automatically updates with a new value whenever its value changes.": {
      "zh": "变量 funFact 用于显示这个视图。因为 funFact 使用 @State，只要 funFact 的值改变，文本视图就会自动更新。",
      "tips": ""
    },
    "When you tap this button, the code assigns funFact a new value, which then changes the string in the Text view above.": {
      "zh": "当你点击这个按钮时，代码将 funFact 的值改变，然后将文本视图上的字符串更改。",
      "tips": ""
    },
    "To edit the look of the button, try adding some modifiers. Add space around the button using .padding(), a background color using .background(Color.cyan), or rounded corners using .cornerRadius(15). Add these below the brace of the button’s closure.": {
      "zh": "要编辑按钮的外观，尝试添加一些修饰符。在按钮的闭包中添加内边距，使用 .padding()，使用 .background(Color.cyan) 添加背景颜色或使用 .cornerRadius(15) 来添加圆角。",
      "tips": ""
    },
    "This Text view shows the fun fact. It uses the variable funFact as its argument so it can show a new fun fact whenever the value changes.": {
      "zh": "这个 Text 视图显示的是 fun fact。它使用 funFact 作为其参数，因此每当值改变时，它就会显示一个新的 fun fact。",
      "tips": ""
    },
    "Choose Your Own Story": {
      "zh": "选择你自己的故事",
      "tips": ""
    },
    "Provide dynamic navigation between views.": {
      "zh": "提供视图间的动态导航。",
      "tips": ""
    }
  },
  "sample-apps/animatingshapes": {
    "Animating Shapes": {
      "zh": "动画形状",
      "tips": ""
    },
    "Learn how to use shapes and simple animations in SwiftUI.": {
      "zh": "学习如何在 SwiftUI 中使用形状和简单动画。",
      "tips": ""
    },
    "First up, you’ll learn to use the SwiftUI Shape protocol to create and modify shape views.": {
      "zh": "首先，你将学习使用 SwiftUI Shape 协议来创建和修改形状视图。",
      "tips": ""
    },
    "You’ll learn the basics of animating views and how to create animations – some easy, some more complex!": {
      "zh": "你将学习动画视图的基础知识以及如何创建动画 - 有些简单，有些更复杂！",
      "tips": ""
    },
    "Heart Pulse": {
      "zh": "心脏脉冲",
      "tips": ""
    },
    "Discover how to make a heart pulse in this basic animation.": {
      "zh": "探索如何在这个基本动画中使心脏跳动。",
      "tips": ""
    },
    "Step 1": {
      "zh": "",
      "tips": ""
    },
    "In this walkthrough, you will learn how to create a custom heart shape as well as how to make it pulse. From there, you’ll learn how to scale the pulsing heart up or down.": {
      "zh": "在这个演练中，你将学习如何创建一个自定义的心形，以及如何让它跳动。从那里开始，你将学习如何将跳动的心脏放大或缩小。",
      "tips": ""
    },
    "Step 2": {
      "zh": "",
      "tips": ""
    },
    "To create a heart shape, define a structure that adopts the Shape protocol by implementing the required path(in:) method.": {
      "zh": "为了创建一个心形，这里你通过实现 required path(in:) 方法，定义一个采用 Shape 协议的结构。",
      "tips": ""
    },
    "Step 3": {
      "zh": "",
      "tips": ""
    },
    "path.move starts the path at the point of the heart.": {
      "zh": "path.move 从心脏的点开始路径。",
      "tips": ""
    },
    "Step 4": {
      "zh": "",
      "tips": ""
    },
    "path.addCurve creates a curved line from where your point is to a specified end point. This is what draws the curved sides of the heart shape.": {
      "zh": "path.addCurve 会从你指定的起点到终点创建一条曲线。这就是绘制心形的曲线边的方法。",
      "tips": ""
    },
    "Step 5": {
      "zh": "",
      "tips": ""
    },
    "path.addArc adds the arcs at the top of the heart shape. By specifying the start and end angles, the path knows where to draw the arc. The arc is drawn off of specific points in the unit circle that you specify for the start and end angles.": {
      "zh": "path.addArc 会在心形的顶部添加圆弧。通过指定起始角度和结束角度，Path 实例知道在哪里绘制圆弧。圆弧是从你为起始角度和结束角度指定的单位圆的特定点绘制的。",
      "tips": ""
    },
    "Step 6": {
      "zh": "",
      "tips": ""
    },
    "To make the heart pulse, you’ll tap the play button. When the heart pulses, it scales up and then back down, repeating the animation indefinitely. Your heartPulse state property determines the scale of the heart in this animation.": {
      "zh": "为了让心脏跳动，你将点击播放按钮。当心脏跳动时，它会放大然后缩小，无限期地重复动画。在这个动画中，你的 heartPulse 状态属性决定了心脏的比例。",
      "tips": ""
    },
    "Step 7": {
      "zh": "",
      "tips": ""
    },
    "When you tap play, the heartPulse value increases. Setting autoreverses to true allows the animation to first play forward, as the heart scales up, and then backward as it scales back down again.": {
      "zh": "当你点击播放时，heartPulse 值会增加。将 autoreverses 设置为 true 允许动画首先正向播放，这会使心脏放大，然后反向播放，这会使它缩小。",
      "tips": ""
    },
    "Step 8": {
      "zh": "",
      "tips": ""
    },
    "By changing the value of heartPulse inside of a withAnimation closure, you animate any changes to its value with the animation you pass in, resulting in the pulsing effect. 💗": {
      "zh": "通过在 withAnimation 闭包中更改 heartPulse 的值，你可以使用传入的动画来动画化其值的任何更改，从而产生跳动的效果。💗",
      "tips": ""
    },
    "Spinning Animation": {
      "zh": "旋转动画",
      "tips": ""
    },
    "Discover how to create a spinning effect.": {
      "zh": "探索如何创建旋转效果。",
      "tips": ""
    },
    "Next, you’ll learn to create a spinning animation when you tap a button. Time to get dizzy!": {
      "zh": "接下来，你将学习如何在点击按钮时创建旋转动画。是时候让你头晕了！",
      "tips": ""
    },
    "There is no preset animation that actually causes a shape to spin, but you can create the illusion of spinning by changing the width of the shape. To do this, you’ll use a width state property.": {
      "zh": "这里没有预设的动画可以让形状旋转，但是你可以通过改变形状的宽度来制造旋转的幻觉。为此，你将使用一个 width 状态属性。",
      "tips": ""
    },
    "When you tap the button, the ellipse animates to change its width from 200 to 0. Notice that the Animation used is .easeInOut.repeatForever(autoreverses: true).speed(2). This chains together three animations to create a specific effect. Try to predict how each part of the animation affects the overall effect.": {
      "zh": "当你点击按钮时，椭圆动画将其宽度从 200 改变为 0。注意，使用的动画是 .easeInOut.repeatForever(autoreverses: true).speed(2)。这将三个动画链接在一起，以创建一个特定的效果。你可以试着预测动画的每个部分如何影响整体效果。",
      "tips": ""
    },
    "Here’s the sequence: .easeInOut first creates an animation that eases in and eases out. Then .repeatForever(autoreverses: true) takes the .easeInOut animation and puts it in a loop that runs forever. Because autoreverses is true, the animation first runs forward, then in reverse before starting over. And finally, .speed(2) determines how quickly the animation runs. With an argument of 2, it runs at 200 percent of its default speed.": {
      "zh": "动画的执行顺序如下：.easeInOut 首先创建一个缓入缓出的动画。然后 .repeatForever(autoreverses: true) 将 .easeInOut 动画放入一个永远运行的循环中。因为 autoreverses 是 true，所以动画首先正向运行，然后反向运行，然后再重新开始。最后，.speed(2) 确定动画运行的速度。使用 2 作为参数，它以其默认速度的 200% 运行。",
      "tips": ""
    },
    "This animation results in a spinning effect as the circle’s width changes first from 200 to 0, and then from 0 to 200, repeating the entire animation on a recurring loop.": {
      "zh": "这个动画会产生一个旋转的效果，因为圆的宽度首先从 200 变为 0，然后从 0 变为 200，在一个循环中重复整个动画。",
      "tips": ""
    },
    "Exploding Animation": {
      "zh": "爆炸动画",
      "tips": ""
    },
    "Learn how to create an explosion effect.": {
      "zh": "学习如何创建爆炸效果。",
      "tips": ""
    },
    "To create an exploding animation, you’ll replace a rectangle with many small rectangular pieces that animate outward.": {
      "zh": "要创建一个爆炸动画，你将用许多小的矩形块替换一个矩形，这些矩形块会以动画的形式向外移动。",
      "tips": ""
    },
    "The isExploded state property tracks whether the exploding animation is currently running. You’ll use this value to start all of the animations when you tap the button.": {
      "zh": "这个 isExploded 状态属性会跟踪爆炸动画是否正在运行。你将使用这个值来在点击按钮时启动所有的动画。",
      "tips": ""
    },
    "In the large Rectangle view, the opacity animates from 1 to 0 when isExploded is set to true; this makes the large rectangle disappear.": {
      "zh": "在这个大的 Rectangle 视图中，当 isExploded 设置为 true 时，不透明度从 1 以动画的形式变化为 0；这使得这个大矩形消失。",
      "tips": ""
    },
    "When the large rectangle disappears, you want many small rectangles to explode outward. To create this effect, you’ll first generate a large number of smaller rectangles using a ForEach. These rectangles are initially hidden behind the large rectangle in a ZStack. When the large rectangle disappears, you’ll see the smaller rectangles.": {
      "zh": "当这个大矩形消失时，你希望出现许多小矩形向外爆炸。为了创建这个效果，你首先要使用 ForEach 生成大量的小矩形。这些矩形最初被隐藏在一个 ZStack 中的大矩形后面。当大矩形消失时，你会看到这些小矩形。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实验",
      "tips": ""
    },
    "Try changing the number of small rectangles to see how that affects the animation.": {
      "zh": "尝试改变小矩形的数量，看看这对动画有什么影响。",
      "tips": ""
    },
    "For each of these small rectangles, you’ll use a conditional modifier to animate their offsets to random positions in the view. This makes it look like they’re little shards of the larger rectangle that propel out in different directions.": {
      "zh": "对于这些小矩形，你将使用一个条件修饰符来将它们的偏移量动画到视图中的随机位置。这使得它们看起来像是大矩形的小碎片，朝不同的方向喷射出去。",
      "tips": ""
    },
    "Add a twist! Try changing the speed of the ease-in -out animation for the small rectangles and see what happens.": {
      "zh": "加点变化！尝试改变小矩形的缓入缓出动画的速度，看看会发生什么。",
      "tips": ""
    },
    "As those little rectangles explode out, you’ll fade their opacity from 1 to 0 so they eventually disappear. And that’s your explosion animation. Now, you may be thinking, “This isn’t a real explosion, it’s an illusion.”, and you’re absolutely right. All animations are illusions, and you’re the magician who creates them. 🪄": {
      "zh": "当这些小矩形爆炸时，你会将它们的不透明度从 1 渐变为 0，这样它们最终会消失。这就是你的爆炸动画。现在，你可能会想，“这不是一个真正的爆炸，这只是一个幻觉。”，你是绝对正确的。所有的动画都是幻觉，而你就是创造它们的魔术师。🪄",
      "tips": ""
    },
    "Use scaling and animation delays to create a wave effect.": {
      "zh": "使用缩放和动画延迟来创建波浪效果。",
      "tips": ""
    },
    "Now that you’ve dabbled with some basic animations, take a look at how you can combine them to create a more advanced interactive effect. You’ll learn how to animate a grid of circles to form a fabulous wave effect when you tap them. In the preview, try tapping on different circles in the grid. What do you notice?": {
      "zh": "现在你已经尝试了一些基本的动画，看看你如何将它们结合起来创建一个更高级的交互效果。你将学习如何对一个圆圈网格进行动画处理，当你点击它们时，它们会形成一个神奇的波浪效果。在预览中，尝试点击网格中的不同圆圈。你注意到了什么？",
      "tips": ""
    },
    "You’ll need a few state properties to keep track of how the circles change when you tap them. The gridColumns property defines the columns for the grid, and colors provides the color options for the rainbow effect.": {
      "zh": "你将需要一些状态属性来跟踪圆圈在你点击它们时的变化。gridColumns 属性定义了网格的列，colors 为彩虹效果提供了颜色选项。",
      "tips": ""
    },
    "Try changing the number of columns, by changing the value for count in gridColumns. What happens if you change the colors in the colors array?": {
      "zh": "尝试通过改变 gridColumns 中 count 的值来改变列数。如果你改变 colors 数组中的颜色会发生什么？",
      "tips": ""
    },
    "The numCircles constant defines the number of circles in your grid. Your LazyVGrid uses gridColumns and numCircles to generate the initial grid of circles.": {
      "zh": "numCircle 常量定义了网格中圆圈的数量。你的 LazyVGrid 使用 gridColumns 和 numCircles 来生成圆圈的初始网格。",
      "tips": ""
    },
    "Try changing the value of numCircles and see how your grid changes.": {
      "zh": "尝试改变 numCircles 的值，看看你的网格如何变化。",
      "tips": ""
    },
    "The springAnimation constant defines the animation to use later in the animation modifier.": {
      "zh": "springAnimation 常量定义了稍后在动画修饰符中使用的动画。",
      "tips": ""
    },
    "Try changing some of these values and tap the grid to see how they affect the animation.": {
      "zh": "尝试改变其中一些值，然后点击网格，看看它们如何影响动画。",
      "tips": ""
    },
    "Your springAnimation is used to animate changes to the scale of the circles in the grid. However, to create a rolling wave effect you want to animate the circles in your grids at different times. Add delay(_:) to springAnimation to specify the duration of the animation delay for each individual circle. To calculate the delay, divide the circle’s index by the number of columns, taking the truncating remainder as a value between 1 and 10 (the number of columns). This creates a per-column animation effect.": {
      "zh": "你的 springAnimation 用于对网格中圆圈的缩放进行动画处理。然而，为了创建一个滚动的波浪效果，你希望以不同的时间对网格中的圆圈进行动画处理。将 delay(_:) 添加到 springAnimation 中，以指定每个单独圆圈的动画延迟持续时间。为了计算延迟，将圆圈的索引除以列数，将截断的余数作为 1 到 10 之间的值（列数）。这样就创建了一个每列动画效果。",
      "tips": ""
    },
    "The .animation modifier determines how the circle animates, but the value for scaleFactor and any changes made to scaleFactor are what causes the increase in scale.": {
      "zh": ".animation 修饰符决定了圆圈的动画方式，但是 scaleFactor 的值和对 scaleFactor 的任何更改才是导致缩放增加的原因。",
      "tips": ""
    },
    "The tapGesture modifier allows you to change the scaleFactor by tapping a circle in the grid. When you tap a circle, the value of scaleFactor is set based on that circle’s index. The further the circle’s position is in the grid, the larger the scaleFactor will be.": {
      "zh": "tapGesture 修饰符允许你通过点击网格中的一个圆圈来改变 scaleFactor。当你点击一个圆圈时，scaleFactor 的值是基于该圆圈的索引设置的。圆圈在网格中的位置越远，scaleFactor 就越大。",
      "tips": ""
    },
    "Because the index of circles starts at 0, you need to set the scaleFactor using index+1 so you never have to set the scaleFactor to an undefined number.": {
      "zh": "因为圆圈的索引从 0 开始，所以你需要使用 index+1 来设置 scaleFactor，这样你就永远不需要将 scaleFactor 设置为一个未定义的数字。",
      "tips": ""
    },
    "Step 9": {
      "zh": "",
      "tips": ""
    },
    "There you have it…a beautiful rolling rainbow!": {
      "zh": "就是这样...你已经拥有了美丽的的滚动彩虹",
      "tips": ""
    },
    "Try tinkering with this animation until it’s exactly as you like it. Good luck!": {
      "zh": "尝试调整这个动画，直到它完全符合你的喜好。祝你好运！",
      "tips": ""
    },
    "Use a drag gesture to move a grid of dots.": {
      "zh": "使用拖动手势来移动一个网格的点。",
      "tips": ""
    },
    "Draggin’ Drop Dots is very similar to Rollin’ Rainbow, but with some differences. Instead of changing the scale of the circles when you tap them, the circle’s offset changes based on a drag gesture applied to the entire grid. Time to dive into the code.": {
      "zh": "Draggin’ Drop Dots 与 Rollin’ Rainbow 非常相似，但也有一些不同之处。当你点击圆圈时，圆圈的偏移量会根据应用于整个网格的拖动手势而改变，而不是改变圆圈的缩放。是时候深入代码了。",
      "tips": ""
    },
    "This is a much larger grid than Rollin’ Rainbow – there are a lot more circles and columns. See what happens when you change the number of dots in the grid. Do you need more circles in this animation?": {
      "zh": "这是一个比 Rollin’ Rainbow 大得多的网格——有更多的圆圈和列。看看当你改变网格中的点数时会发生什么。你需要在这个动画中有更多的圆圈吗？",
      "tips": ""
    },
    "Add a drag gesture instead of a tap gesture so the grid moves when you drag it. You can use the translation value in the drag gesture closure to set the offset of each circle, resulting in the entire grid moving to the new drag.translation value.": {
      "zh": "添加一个拖动手势，而不是一个点击手势，这样当你拖动它时，网格就会移动。你可以在拖动手势闭包中使用 translation 值来设置每个圆圈的偏移量，从而导致整个网格移动到新的 drag.translation 值。",
      "tips": ""
    },
    "When the offset changes, you’ll animate the circles to their new positions. Instead of moving all of the dots at the same time, you can use delay on the animation so that each circle moves individually. If you set the delay based on each circle’s index, the circles will have a slightly different delay. This results in the entire grid animating one circle after the other. Because this animation would otherwise be very slow, you can divide the value for delay by the animationSpeed value to speed it up.": {
      "zh": "当手势的偏移量发生变化时，你将对圆圈进行动画处理，使它们处于新的位置。你可以使用动画上的延迟，而不是同时移动所有的点，这样每个圆圈就可以单独移动。如果你根据每个圆圈的索引设置延迟，那么圆圈的延迟就会略有不同。这导致整个网格会在一个圆圈之后动画执行结束之后再执行另一个圆圈的动画。因为这个动画本来会非常慢，所以你可以将延迟的值除以 animationSpeed 的值来加快速度。",
      "tips": ""
    },
    "Try changing the animationSpeed to something very low, like 20. How does the animation change?": {
      "zh": "尝试将 animationSpeed 更改为非常低的值，比如 20。动画会如何变化？",
      "tips": ""
    },
    "Dancing Dots": {
      "zh": "跳舞的点",
      "tips": ""
    },
    "Make the circles boogie!": {
      "zh": "让圆圈跳舞！",
      "tips": ""
    },
    "Animate more complex model data in cool and interesting ways using observable objects.": {
      "zh": "让更多复杂的模型数据以有趣的方式使用 observable 对象进行动画处理。",
      "tips": ""
    },
    "What if the changes you want to animate aren’t coming from user actions? SwiftUI has a way of animating published values in observable objects. Create an observable object BigDot that publishes an offset, color, scale, and an array of small dot observable objects. You’ll use this object to model the view animations you want in your view.": {
      "zh": "如果你想要动画处理的变化不是来自用户的操作怎么办？SwiftUI 有一种方法可以对 observable 对象中发布的值进行动画处理。创建一个 observable 对象 BigDot，它发布一个偏移量、颜色、比例和一个小点 observable 对象的数组。你将使用这个对象来模拟你在视图中想要的视图动画。",
      "tips": ""
    },
    "Add a SmallDot observable object that publishes a color and an offset.": {
      "zh": "添加一个 SmallDot observable 对象，它将发布一个颜色和一个偏移量。",
      "tips": ""
    },
    "When you create a bigDot, you also need to create an array of small dots that are linked to the big dot.": {
      "zh": "当你创建一个 bigDot 时，你还需要创建一个与 bigDot 相关联的 smallDot 数组。",
      "tips": ""
    },
    "Now, a grid of big dots needs to populate the grid with five small dots for every big dot. Because there are so many dots, you’ll use a DotTracker class when publishing an array of BigDots. This is the published value you’ll track to create your animations. What happens to the animation if you increase or decrease the number of smallDots in the array?": {
      "zh": "现在，一个大点的网格需要为每个大点填充五个小点。因为有这么多的点，所以在发布一个 BigDots 数组时，你将使用一个 DotTracker 类。这是你将跟踪的发布值，以创建你的动画。如果你增加或减少数组中的 smallDots 数量，动画会发生什么？",
      "tips": ""
    },
    "Your bigDots array has 100 BigDot instances that appear in the grid view.": {
      "zh": "你的 bigDots 数组有 100 个 BigDot 实例，它们出现在网格视图中。",
      "tips": ""
    },
    "You may notice that the BigDot class and DotTracker both include a randomizePositions() function that do almost the same thing. The function in BigDot creates random positions for each SmallDot in its smallDot array, while the function in DotTracker creates random positions for each BigDot. Together, these functions create the changes in the offset, color, and scale values reflected by animations in your grid view.": {
      "zh": "你可能会注意到，BigDot 类和 DotTracker 都包含一个 randomizePositions() 函数，它们几乎做了相同的事情。BigDot 中的函数为其 smallDot 数组中的每个 SmallDot 创建随机位置，而 DotTracker 中的函数为每个 BigDot 创建随机位置。这些函数一起在网格视图中创建了偏移量、颜色和比例值的变化，这些变化反映在动画中。",
      "tips": ""
    },
    "Try changing the value of the scale in the randomizePositions() function. What happens to the animation when you lower the scale value?": {
      "zh": "尝试修改 randomizePositions() 函数中的 scale 值。当你降低 scale 值时，动画会发生什么？",
      "tips": ""
    },
    "Add a resetPositions() function, so the dots reset to their original positions when you tap the reset button. This is very similar to the randomizePositions() function used to place circles in random locations around the view.": {
      "zh": "添加一个 resetPositions() 函数，这样当你点击重置按钮时，点会重置到它们的原始位置。这与用于在视图周围随机位置放置圆圈的 randomizePositions() 函数非常相似。",
      "tips": ""
    },
    "The randomizePositions() function calls bigDot.randomizePositions(). This puts every SmallDot in the smallDot array defined in the BigDot class into random positions.": {
      "zh": "randomizePositions() 函数会调用 bigDot.randomizePositions()。这将 BigDot 类中定义的 smallDot 数组中的每个 SmallDot 放置在随机位置。",
      "tips": ""
    },
    "The DancingDotsView needs to define an instance of the DotTracker as a @StateObject so SwiftUI redraws its contents whenever any of the view’s dots change color or position.": {
      "zh": "DansingDotsView 需要将 DotTracker 的实例定义为 @StateObject，这样 SwiftUI 就会在视图的任何点的颜色或位置发生变化时重新绘制其内容。",
      "tips": ""
    },
    "Step 10": {
      "zh": "",
      "tips": ""
    },
    "Add in this ForEach loop to place each BigDot tracked by the tracker into the grid.": {
      "zh": "将这个 ForEach 循环添加到 tracker 中，以将每个被 tracker 追踪的 BigDot 放置到网格中。",
      "tips": ""
    },
    "Step 11": {
      "zh": "",
      "tips": ""
    },
    "For each BigDot, you can create a circle view with its offset, color, and scale.": {
      "zh": "对于每个 BigDot，你可以通过配置它的偏移量、颜色和比例来创建一个圆形视图。",
      "tips": ""
    },
    "Step 12": {
      "zh": "",
      "tips": ""
    },
    "Because every BigDot has five SmallDots, you can do the same thing for the small dots.": {
      "zh": "因为每个 BigDot 都有五个 SmallDot，所以你可以对小点做同样的事情。",
      "tips": ""
    },
    "Step 13": {
      "zh": "",
      "tips": ""
    },
    "When you tap the play button, the circles animate and the randomizePositions() function is called. This causes the circles’ offsets to change, creating a dancing effect for the dots.": {
      "zh": "当你点击播放按钮时，圆圈会执行动画，同时 randomizePositions() 函数会被调用。这会导致圆圈的偏移量发生变化，为点创建一个跳舞效果。",
      "tips": ""
    },
    "Step 14": {
      "zh": "",
      "tips": ""
    },
    "Add this isAnimating state property, which calls the resetPositions() method and resets the circle’s positions when you tap Reset.": {
      "zh": "添加这个 isAnimating 状态属性，它会调用 resetPositions() 方法，并在你点击重置时重置圆圈的位置。",
      "tips": ""
    },
    "Step 15": {
      "zh": "",
      "tips": ""
    },
    "Because everything is animating, adding drawingGroup() helps to make the animation render smoothly.": {
      "zh": "因为一切内容都在执行动画，所以添加 drawingGroup() 有助于使动画渲染平滑。",
      "tips": ""
    },
    "Step 16": {
      "zh": "",
      "tips": ""
    },
    "Now you know how to create more complex animations with shapes. Time to take what you’ve learned in this guide and use it to make some cool Swift apps!": {
      "zh": "现在你知道如何使用形状创建更复杂的动画了。现在是时候将你在本指南中学到的知识用于制作一些很酷的 Swift 应用了！",
      "tips": ""
    },
    "Previewing the Camera Output": {
      "zh": "预览相机输出",
      "tips": ""
    },
    "Preview the output from the camera.": {
      "zh": "预览来自相机的输出。",
      "tips": ""
    },
    "Rollin Rainbow": {
      "zh": "",
      "tips": ""
    },
    "Draggin Drop It": {
      "zh": "",
      "tips": ""
    }
  },
  "sample-apps/bubblelevel": {
    "Bubble Level": {
      "zh": "",
      "tips": ""
    },
    "Access and display device sensor data by subscribing to notifications.": {
      "zh": "通过订阅通知来访问和显示设备传感器数据。",
      "tips": ""
    },
    "Welcome to Bubble Level.": {
      "zh": "欢迎来到“气泡水平仪”这堂课。",
      "tips": ""
    },
    "A bubble level helps you determine whether something is level or tilted.": {
      "zh": "气泡水平仪可帮助您确定一个物体是水平还是倾斜。",
      "tips": ""
    },
    "This app displays the orientation of your device as numbers and as a graphical version of a bubble level. Try tilting your device and watch the bubble move. Try to make your device level by centering the bubble in the crosshairs. Or place it on a surface like your bedroom floor to determine whether the floor is level.": {
      "zh": "这个 App 将会分别以数字和可视化的气泡水平仪来显示你设备的方向。你可以尝试倾斜你的设备并观察气泡移动，通过将气泡置于十字准线中心来使设备保持水平。或者将其放在卧室地板等表面上，以确定地板是否水平。",
      "tips": ""
    },
    "Motion Detector": {
      "zh": "",
      "tips": ""
    },
    "You can use the MotionDetector class to observe the motion of your device.": {
      "zh": "你可以使用这个 MotionDetector 类来观察你的设备的运动。",
      "tips": ""
    },
    "Step 1": {
      "zh": "",
      "tips": ""
    },
    "Your device has sensors such as accelerometers and gyroscopes that it uses to sense motion and orientation. The Core Motion framework gives you access to data from these and other sensors.": {
      "zh": "你的设备有加速计和陀螺仪等传感器，它们用于感知运动和方向。Core Motion 框架可以让你访问这些传感器和其他传感器的数据。",
      "tips": ""
    },
    "Step 2": {
      "zh": "",
      "tips": ""
    },
    "You use a CMMotionManager object to get motion data from sensors, such as the accelerometer. It gathers information from the sensors and translates their data into values that you can understand.": {
      "zh": "你将会使用 CMMotionManager 对象来获取传感器的运动数据，例如加速计。它会从传感器中收集信息，并将它们的数据转换为你可以理解的值。",
      "tips": ""
    },
    "Step 3": {
      "zh": "",
      "tips": ""
    },
    "The timer property stores a Timer instance. A timer waits for a period of time that you specify before running some code. The MotionDetector uses the timer to update its pitch, roll, and zAcceleration values at regular intervals, defined by the updateInterval property.": {
      "zh": "timer 这个属性存储了一个 Timer 实例。Timer 会在你指定的时间段之后运行一些代码。MotionDetector 使用 timer 来在 updateInterval 属性定义的时间间隔内更新它的 pitch、roll 和 zAcceleration 值。",
      "tips": ""
    },
    "Step 4": {
      "zh": "",
      "tips": ""
    },
    "You can choose an update interval that makes sense for your app. For example, you’ll want a short update interval for the bubble level in this project because the interface presents real-time data as the device moves.": {
      "zh": "你可以选择一个对你的应用程序有意义的更新间隔。例如，你将希望这个项目中的气泡水平仪有一个短的更新间隔，因为界面会随着设备的移动而实时显示数据。",
      "tips": ""
    },
    "Step 5": {
      "zh": "",
      "tips": ""
    },
    "These three properties store data for the tilt of your device in two dimensions (roll and pitch), as well as its vertical acceleration (zAcceleration).": {
      "zh": "这三个属性存储了你的设备在两个维度上的倾斜数据（roll 和 pitch），以及它的垂直加速度（zAcceleration）。",
      "tips": ""
    },
    "Step 6": {
      "zh": "",
      "tips": ""
    },
    "These properties have a @Published property wrapper, which means that any SwiftUI view that depends on their values updates when they change. You make a view dependent on a published property by referring to it in the view’s code. The BubbleLevel, LevelView, and OrientationDataView views use these properties, which enables them to update when the MotionDetector detects a change to the roll, pitch, or zAcceleration values.": {
      "zh": "这些属性有一个 @Published 属性包装器，这意味着任何依赖于它们值的 SwiftUI 视图会在它们改变时更新。你可以通过在视图的代码中引用它来使视图依赖于已发布的属性。BubbleLevel、LevelView 和 OrientationDataView 视图使用这些属性，这使它们能够在 MotionDetector 检测到 roll、pitch 或 zAcceleration 值的变化时更新。",
      "tips": ""
    },
    "Step 7": {
      "zh": "",
      "tips": ""
    },
    "This property stores code that runs when the MotionDetector updates its motion data. If you want to execute custom actions every time the motion data changes, you can put your own code into onUpdate in your instance of MotionDetector.": {
      "zh": "这个属性存储了当 MotionDetector 更新其运动数据时需要运行的代码。如果你想在每次运动数据发生变化时执行自定义操作，你可以将自己的代码放到 MotionDetector 的 onUpdate 中。",
      "tips": ""
    },
    "Step 8": {
      "zh": "",
      "tips": ""
    },
    "This method starts updating the motion detector.": {
      "zh": "这个方法会开始用传感器的数据更新我们的运动检测器的数据。",
      "tips": ""
    },
    "Step 9": {
      "zh": "",
      "tips": ""
    },
    "Always use isDeviceMotionAvailable to verify that motion data is available before you try to access it.": {
      "zh": "在你想要访问运动数据之前，记得始终使用 isDeviceMotionAvailable 来验证运动数据是否可用。",
      "tips": ""
    },
    "Step 10": {
      "zh": "",
      "tips": ""
    },
    "This method tells the CMMotionManager to start updating motion data.": {
      "zh": "这个方法会告诉 CMMotionManager 开始更新运动数据。",
      "tips": ""
    },
    "Step 11": {
      "zh": "",
      "tips": ""
    },
    "This code creates a new timer and schedules it to run. The updateInterval property tells the timer how long to wait between updates, and repeats is set to true so that the timer runs forever until you stop it. (If you pass false to repeats, the timer only runs once.)": {
      "zh": "这段代码创建了一个新的计时器并设定了其运作方式。updateInterval 属性会告诉计时器在每次数据更新之间需要等待多长时间，将 repeats 设置为 true 后，计时器就会一直运行，直到你停止它。（如果你传递 false 给 repeats，计时器只会运行一次。）",
      "tips": ""
    },
    "Step 12": {
      "zh": "",
      "tips": ""
    },
    "The block of code at the end of the line that reads { _ in is the start of a closure containing the code that the timer runs. The closure calls updateMotionData().": {
      "zh": "第一行最末端的 { _ in 是一个闭包的开始，包含了定时器运行的代码。这个闭包会调用 updateMotionData() 方法。",
      "tips": ""
    },
    "Step 13": {
      "zh": "",
      "tips": ""
    },
    "This method does the core work of the motion detector. It’s responsible for updating all the published properties with current data from the sensors, as well as calling the code in onUpdate.": {
      "zh": "这个方法是运动检测器的核心工作。它负责使用传感器的当前数据更新所有已发布的属性，以及调用 onUpdate",
      "tips": ""
    },
    "Step 14": {
      "zh": "",
      "tips": ""
    },
    "The deviceMotion data may not be there in certain conditions. The way you can tell if the data exists is to try to assign it to a variable or constant using if let. If the motion data exists, it’s assigned to data and the code inside the braces runs. Otherwise, it skips the entire if statement.": {
      "zh": "在一些情况下，deviceMotion 数据可能不存在。你可以通过 if let 来判断数据是否存在。如果 motion 数据存在，它会被赋值给 data 并且大括号内的代码会被执行。否则，整个 if 语句会被跳过。",
      "tips": ""
    },
    "Step 15": {
      "zh": "",
      "tips": ""
    },
    "A CMDeviceMotion instance represents device motion, stored here in data. It has quite a few properties describing the input from the motion sensors.": {
      "zh": "CMDeviceMotion 实例代表设备的运动，存储在 data 中。它有很多属性来描述传感器的输入。",
      "tips": ""
    },
    "Step 16": {
      "zh": "",
      "tips": ""
    },
    "Use the attitude property to get the device’s tilt in three directions. You may be familiar with X, Y, and Z axes in 3D space. Pitch, roll, and yaw are numbers that describe rotation along those axes.": {
      "zh": "使用 attitude 属性来获取设备在三个方向上的倾斜。你可能熟悉 3D 空间中的 X、Y 和 Z。Pitch（俯仰）、roll（翻滚）和 yaw（偏航）是描述沿这些轴旋转程度的数字。",
      "tips": ""
    },
    "Step 17": {
      "zh": "",
      "tips": ""
    },
    "Use the userAcceleration property to get the device’s acceleration after accounting for the downward pull of gravity. If it’s at rest, this number is 0. If it’s accelerating upward, the number is negative, and if it’s accelerating downward, the number is positive.": {
      "zh": "使用 userAcceleration 属性来获取设备在考虑到重力向下拉的情况下的加速度。如果它处于静止状态，这个数值为 0。如果它向上加速，这个数值为负数，如果它向下加速，这个数值为正数。",
      "tips": ""
    },
    "Step 18": {
      "zh": "",
      "tips": ""
    },
    "You run the code in onUpdate just as you’d call any function, with a set of parentheses following its name.": {
      "zh": "你可以像调用任何函数一样调用 onUpdate 中的代码，只需要在函数名后面加上一对括号。",
      "tips": ""
    },
    "Step 19": {
      "zh": "",
      "tips": ""
    },
    "This method stops updating the motion data. It does two important things:": {
      "zh": "这个方法会停止更新运动数据。它做了两件重要的事情：",
      "tips": ""
    },
    "Step 20": {
      "zh": "",
      "tips": ""
    },
    "First, it tells the CMMotionManager to stop updating its values by calling stopDeviceMotionUpdates(), then it stops the timer by calling invalidate().": {
      "zh": "首先，它会通过调用 stopDeviceMotionUpdates() 来告诉 CMMotionManager 停止更新它的值，然后通过调用 invalidate() 来停止定时器。",
      "tips": ""
    },
    "Step 21": {
      "zh": "",
      "tips": ""
    },
    "This deinitializer runs when a MotionDetector instance is about to go away. It’s important to clean up here; otherwise the timer would continue to run even after the motion detector is gone.": {
      "zh": "这个析构器会在 MotionDetector 实例即将消失时运行。在这里做一些善后工作是很重要的，否则计时器会在 motion detector 消失后继续运行。",
      "tips": ""
    },
    "Orientation Data View": {
      "zh": "朝向数据视图",
      "tips": ""
    },
    "Learn to display motion data as string values in the view.": {
      "zh": "学习将运动数据显示为视图中的字符串值。",
      "tips": ""
    },
    "The OrientationDataView displays the roll and pitch of your iPad as numbers. Roll is the degree of left and right tilt, and pitch is the degree of forward and backward tilt.": {
      "zh": "OrientationDataView 会将你的 iPad 的翻滚角和俯仰角以数字的形式显示出来。翻滚角是左右倾斜的角度，俯仰角是前后倾斜的角度。",
      "tips": ""
    },
    "This property holds a MotionDetector instance. The motion detector senses changes in your device’s motion and provides that data for you to use in your code.": {
      "zh": "这个属性会持有一个 MotionDetector 实例。运动检测器会感知你的设备运动的变化，并为你提供这些数据，以便你在代码中使用。",
      "tips": ""
    },
    "Because detector is an observable object, any changes made to its published values cause SwiftUI to automatically update any views using those values. In this case, changes from the device’s sensors update the Text view with the latest values for the pitch and roll.": {
      "zh": "因为 detector 是一个可观察对象，所以对它的 published 值所做的任何更改都会导致 SwiftUI 自动更新使用这些值的任何视图。在这种情况下，来自设备传感器的更改会使用最新的 roll 和 pitch 的值更新 Text 视图上的字符。",
      "tips": ""
    },
    "These two computed properties provide the strings used in the view. They take the roll or pitch value from the motion detector and format that number as a string with a fixed number of digits. The describeAsFixedLengthString() method is a custom method on the Double type. You can learn how it works in DoubleExtension.swift.": {
      "zh": "这两个计算属性提供了视图中使用的字符串。它们从 motion detector 中获取 roll 或 pitch 的值，并将该数字格式化为具有固定位数的字符串。describeAsFixedLengthString() 方法是 Double 类型的自定义方法。你可以在 DoubleExtension.swift 中了解它的工作原理。",
      "tips": ""
    },
    "Here is the value for the roll of the device, presented as text.": {
      "zh": "这里是设备的翻滚角的值，以文本形式呈现。",
      "tips": ""
    },
    "Because this view uses a published value from detector, SwiftUI updates it any time the motion detector’s roll value changes.": {
      "zh": "因为这个视图使用了 detector 的一个 published value，所以 SwiftUI 会在 detecotr 的 roll 值发生变化时更新它。",
      "tips": ""
    },
    "The .font modifier formats this Text view with a monospaced font. By default, a Text view uses a system font with proportional width, but that causes the text view to change its width as the numbers change.": {
      "zh": ".font 修饰符使用等宽字体格式化这个 Text 视图。默认情况下，Text 视图使用系统字体，它的宽度是比例宽度，但这会导致 Text 视图在数字变化时改变它的宽度。",
      "tips": ""
    },
    "With a monospaced font, each character has the same width. (For example, the strings 1.01 and 3.14 have different widths with a proportional font like Helvetica or Times, but 1.01 and 3.14 have the same width with a monospaced font like Courier or Menlo.)": {
      "zh": "在等宽字体下，每个字符的宽度都是相同的。（例如，1.01 和 3.14 这两个字符串在 Helvetica 或 Times 等比例字体下的宽度是不同的，但在 Courier 或 Menlo 等等宽字体下，1.01 和 3.14 的宽度是相同的。）",
      "tips": ""
    },
    "Bubble Level View": {
      "zh": "泡泡水平仪.pre视图",
      "tips": ""
    },
    "Learn to display the tilt of your device using a bubble level UI.": {
      "zh": "学习何使用 气泡水平仪的 UI 来显示设备的倾斜。",
      "tips": ""
    },
    "This view displays the tilt of your device by drawing a circle within a larger circular boundary with crosshairs to indicate its centerpoint. When your device is level, the bubble rests at the center of the frame. Try tilting your device to see how the bubble moves.": {
      "zh": "这个在自定义视图通过在一个较大的圆形边界内绘制一个圆圈，并用十字线来指示它的中心点，来显示你的设备的倾斜。当你的设备水平时，气泡会停留在框架的中心。试着倾斜你的设备，看看气泡是如何移动的。",
      "tips": ""
    },
    "This property holds a MotionDetector instance, which senses changes in your device’s motion. You can access this instance in your code to update the user interface as the motion data changes.": {
      "zh": "这个属性持有一个 MotionDetector 实例，它可以感知你的设备运动的变化。你可以在你的代码中访问这个实例，以便在运动数据发生变化时更新用户界面。",
      "tips": ""
    },
    "Because detector is an observable object, any changes to its published values allows SwiftUI to automatically update any views using those values. In this case, you’ll update the bubble’s position.": {
      "zh": "因为 detector 是一个可观察对象，所以任何对它的 published 值的更改都会使 SwiftUI 自动更新使用这些值的任何视图。在这种情况下，你将更新气泡的位置。",
      "tips": ""
    },
    "This property represents the range of values the motion detector reports as you tilt the device (assuming you don’t turn it upside down). Negative values indicate a tilt to the left, and positive values indicate a tilt to the right. (You could assign the value 3.14 to this property, but Double.pi is convenient shorthand for the mathematical constant π, and it’s a closer approximation because it includes many digits of precision.)": {
      "zh": "这个属性表示运动检测器在你倾斜设备时报告的值的范围（假设你没有把它倒过来）。负值表示向左倾斜，正值表示向右倾斜。（你可以给这个属性赋值 3.14，但 Double.pi 是数学常量 π 的方便简写，它是一个更接近的近似值，因为它的精度更高。）",
      "tips": ""
    },
    "This is the size of the level display, both width and height. You can change this value to make the display larger or smaller.": {
      "zh": "这就是水平仪显示的大小，宽度和高度。你可以改变这个值来使其显示得更大或更小。",
      "tips": ""
    },
    "It’s useful to define and use constants like these for important values in your code, rather than using the values themselves. When you read the code, you’ll have a better idea of what it does than if you see a lot of numbers with no context.": {
      "zh": "比起来直接使用这些值，定义和使用这样的常量来表示代码中的重要值更有用。当你阅读代码时，看到这样的常量通常比看到一堆没有上下文的数字更容易理解它的作用。",
      "tips": ""
    },
    "This property calculates the horizontal placement of the bubble using three steps.": {
      "zh": "这个属性使用三个步骤来计算气泡的水平位置。",
      "tips": ""
    },
    "First, adjust the roll value from the detector so that it has a minimum of 0 and goes up to the value of π, and store the adjusted value in zeroBasedRoll. This helps with the next part of the calculation, which needs values greater than 0.": {
      "zh": "首先，调整检测器的 roll 值，使其最小值为 0，最大值为 π，并将调整后的值存储在 zeroBasedRoll 中。这有助于下一部分的计算，该计算需要大于 0 的值。",
      "tips": ""
    },
    "Then, use this adjusted value to calculate the roll as a fraction of the entire range of roll values, so that full tilt left is 0.0, flat is 0.5, and full tilt right is 1.0.": {
      "zh": "接下来，使用这个调整后的值来计算 roll 作为整个 roll 值范围的一个分数，这样完全向左倾斜就是 0.0，水平就是 0.5，完全向右倾斜就是 1.0。",
      "tips": ""
    },
    "Multiplying the fraction with the size of the level gives you the X position of the bubble.": {
      "zh": "将这个分数乘以水平仪的大小，就得到了气泡的 X 位置。",
      "tips": ""
    },
    "Because all of these calculations are hidden in a property, your view’s body code remains simple and readable.": {
      "zh": "因为所有这些计算都隐藏在一个属性中，所以你的视图的 body 代码保持简单和可读。",
      "tips": ""
    },
    "While you can write all of the code here in a longer mathematical expression, decomposing the code makes it easier to understand. (Can you imagine having to explain this code if it were written in one line?!)": {
      "zh": "虽然你可以在这里写所有的代码，但是把代码分解开来会更容易理解。（你能想象如果这段代码写在一行里，你要怎么解释这段代码吗？！）",
      "tips": ""
    },
    "This property calculates the vertical position of the bubble in the same way that bubbleXPosition works.": {
      "zh": "这个属性以与 bubbleXPosition 相同的方式计算气泡的垂直位置。",
      "tips": ""
    },
    "This property returns a vertical line that you use to draw the bubble level display. Because there are multiple identical vertical lines, you can use this property whenever you need one rather than repeating the more complex code inside it.": {
      "zh": "这个属性返回一个垂直线，你可以用它来绘制气泡水平仪的显示。因为有多个相同的垂直线，所以你可以在需要一个垂直线时使用这个属性，而不是重复其中的更复杂的代码。",
      "tips": ""
    },
    "Here’s a circle with a gray foreground color that provides a visual boundary for the display.": {
      "zh": "这里是一个圆，它有一个灰色的前景色，为显示提供了一个视觉边界。",
      "tips": ""
    },
    "You can use a .frame modifier to give the circle a fixed width and height, which is important to draw the other components correctly.": {
      "zh": "你可以使用 .frame 修饰符给圆一个固定的宽度和高度，这对于正确绘制其他组件很重要。",
      "tips": ""
    },
    "The .overlay modifier adds a view on top of the circle that occupies the same area.": {
      "zh": ".overlay 修饰符在圆上面添加一个视图，该视图占用相同的区域。",
      "tips": ""
    },
    "The overlay is useful here because it positions the level’s components relative to the circle they’re drawn in.": {
      "zh": "overlay 在这里很有用，因为它将水平仪的组件相对于它们绘制的圆进行定位。",
      "tips": ""
    },
    "A ZStack view allows you to draw the components of the level over each other.": {
      "zh": "一个 ZStack .pre视图允许你将水平仪的组件绘制在彼此上面。",
      "tips": ""
    },
    "The first circle represents the bubble. Notice that the bubbleXPosition and bubbleYPosition values position the bubble inside the overlay view.": {
      "zh": "第一个代表气 泡。注意，bubbleXPosition 和 bubbleYPosition 值将气泡定位在覆盖视图内。",
      "tips": ""
    },
    "Because these properties use published values from MotionDetector, SwiftUI updates the bubble view’s position each time they change.": {
      "zh": "因为这在自定义些属性使用了 MotionDetector 的 published 值，所以 SwiftUI 在每次它们改变时都会更新气泡视图的位置。",
      "tips": ""
    },
    "Step 22": {
      "zh": "",
      "tips": ""
    },
    "In the center are a smaller circle and a crosshair made of two lines: one horizontal and one vertical.": {
      "zh": "在中心是一个较小的圆和一个由两条线组成的十字线：一条水平线和一条垂直线。",
      "tips": ""
    },
    "Step 23": {
      "zh": "",
      "tips": ""
    },
    "There are four other lines on the edge of the frame of the bubble level display. You can use the .position modifier to move them relative to their default position at the center of the overlay view.": {
      "zh": "这里还有其他四条线在气泡水平仪显示的边框上。你可以使用 .position 修饰符将它们相对于它们在覆盖视图中心的默认位置移动。",
      "tips": ""
    },
    "Double Extension": {
      "zh": "给 Double 类型增加扩展",
      "tips": ""
    },
    "Investigate using an extension on Double to format them in an easy to read way.": {
      "zh": "研究使用 Double 的扩展以一种易于阅读的方式格式化它们。",
      "tips": ""
    },
    "An extension is a way to make custom behavior for existing types. Declaring extension Double means you’re adding new capabilities to the Double type. Any time you use a Double value in your code, you can access anything defined in this extension.": {
      "zh": "扩展是为现有类型添加自定义行为的一种方式。声明扩展 Double 意味着你正在为 Double 类型添加新的功能。任何时候你在代码中使用 Double 值，你都可以访问在这个扩展中定义的任何东西。",
      "tips": ""
    },
    "This method returns a string describing the value of a Double using a fixed number of digits. You can pass in the number of integer digits and fraction digits you want, or leave those arguments out for the default values of 2.": {
      "zh": "这个方法返回一个字符串，描述一个 Double 的值，使用固定数量的数字。你可以传入你想要的整数位数和小数位数，或者忽略这些参数，使用默认值 2。",
      "tips": ""
    },
    "The formatted() method operates on a number of basic types such as Date, Int, and Double, which are all commonly represented as strings in an app. Because there are so many ways to format these strings, the formatted() method gives you ways to customize how they’re represented. For example, does a number represent a percentage, or a simple value, or maybe a price?": {
      "zh": "formatted() 方法对一些基本类型进行操作，比如 Date、Int 和 Double，它们在应用中都通常表示为字符串。因为有很多方法可以格式化这些字符串，所以 formatted() 方法提供了一些方法来自定义它们的表示方式。例如，一个数字代表一个百分比，还是一个简单的值，或者一个价格？",
      "tips": ""
    },
    "The argument to formatted() is a format style.": {
      "zh": "formatted() 的参数是一个 format style。",
      "tips": ""
    },
    "The .number style gives you a string describing this Double value as a simple number, as opposed to a percentage or a price.": {
      "zh": ".number style 给你一个字符串，描述这个 Double 值作为一个简单的数字，而不是一个百分比或一个价格。",
      "tips": ""
    },
    "The .number style has modifiers much like those for SwiftUI views.": {
      "zh": ".number style 有类似于 SwiftUI 视图的修饰符。",
      "tips": ""
    },
    "The .sign modifier lets you format the number so that it’s always preceded by a sign, even when the number is positive.": {
      "zh": ".sign 修饰符让你可以格式化数字，这样即使数字是正数，它也总是以一个符号开头。",
      "tips": ""
    },
    "The .precision modifier lets you specify exactly how many digits to use.": {
      "zh": ".precision 修饰符让你可以指定要使用多少位数字。",
      "tips": ""
    },
    "Seismometer": {
      "zh": "地震仪",
      "tips": ""
    },
    "Present dynamic data in custom views.": {
      "zh": "在自定义视图中呈现动态数据。",
      "tips": ""
    }
  },
  "sample-apps/capturingphotos-browsephotos": {
    "Browsing Your Photos": {
      "zh": "浏览你的照片",
      "tips": ""
    },
    "Browse the photos in your photo library.": {
      "zh": "浏览你照片库中的照片。",
      "tips": ""
    },
    "Enjoy taking photos? Most of us do, and it’s easy to end up with hundreds or thousands of photos in your library. 🏞": {
      "zh": "喜欢拍照吗？我们大多数人都喜欢，而且很容易在你的照片库中积累成百上千的照片。",
      "tips": ""
    },
    "Follow your photos as they’re retrieved from your photo library and displayed in a scrolling gallery you can browse.": {
      "zh": "让我们一步步看照片是如何从你的照片库中被检索出来，并让你可以在一个滚动的画廊中查看它们。",
      "tips": ""
    },
    "Using the Photo Collection": {
      "zh": "使用 PhotoCollection 对象",
      "tips": ""
    },
    "Learn about the photo collection in your data model and how it provides the photos for your gallery.": {
      "zh": "了解你数据模型中的 PhotoCollection 对象，以及它如何为画廊提供照片。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "Your data model has a photoCollection property that can represent any collection of items in your photo library. This could be your entire photo library, or just one album, or even the results from a search. You can include all of your photos in your library by initializing photoCollection with a Smart Album .smartAlbumUserLibrary.": {
      "zh": "你的数据模型中有一个 photoCollection 属性，它可以表示你照片库中任何一种项目的集合。这可以是你整个照片库，也可以只是一个相册，甚至可以是搜索的结果。 你可以通过指定 smartAlbum 参数为 .smartAlbumUserLibrary 来初始化 photoCollection，从而将照片库中的所有照片都包含进来。",
      "tips": ""
    },
    "Fetching the Photo Assets": {
      "zh": "获取照片资源",
      "tips": ""
    },
    "Each item in your photo collection is known as a photo asset. Find out how to fetch those assets.": {
      "zh": "PhotoCollection 中的每一个项目都被认为是一个照片资源。了解如何获取这些资源。",
      "tips": ""
    },
    "Your data model’s photoCollection has a photoAssets property that enables use of the photo assets collection just like you would an array. You can fetch a photo asset using its index: photoAssets[4], or use photoAssets.count to get the number of photos in the collection.": {
      "zh": "在你数据模型的 photoCollection 属性中是有一个 photoAssets 属性的，它可以让你像使用数组一样使用照片资源集合。 你可以像这样使用索引获取照片资源：photoAssets[4]；或者调用 photoAssets.count 来获取集合中的照片数量。",
      "tips": ""
    },
    "Tip": {
      "zh": "注释",
      "tips": ""
    },
    "You can also iterate over the assets in photoAssets using a loop. You’ll find this incredibly useful for building your gallery.": {
      "zh": "你也可以使用循环来遍历 photoAssets 中的所有资源。你会发现这对构建画廊非常有用。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "You’ll notice that photoAssets is a published property of PhotoCollection, which is an observable object. This means that you can respond to changes in the photo assets, such as when photos are added or deleted.": {
      "zh": "你会注意到 PhotoCollection 中的 photoAssets 属性被 @Published 修饰了，它是一个可观察对象。这意味着比如当照片被添加或删除时，你可以响应这些照片资源的变化。",
      "tips": ""
    },
    "Navigating to the Photo Gallery": {
      "zh": "导航到照片画廊",
      "tips": ""
    },
    "Find out how to navigate to the photo gallery and connect it to your photo library.": {
      "zh": "了解如何导航到照片画廊并将其与你的照片库连接起来。",
      "tips": ""
    },
    "In your camera view, use a navigation link to take you to your photo gallery. A navigation link is just like a button — you can even give it a label and an icon. You place this button to the left of the shutter button.": {
      "zh": "在你相机视图中，使用一个 NavigationLink 来进入照片画廊。NavigationLink 就像一个按钮，你甚至可以给它设置一个标签和图标。你可以将这个按钮放在快门按钮的左边。",
      "tips": ""
    },
    "When you tap or click a navigation link, SwiftUI takes you to another view — in this case, the photo collection view — that you use to display your photo gallery. If you use navigation links within a NavigationStack, SwiftUI manages the presentation of your views so you can easily navigate between them.": {
      "zh": "当你点击或按下一个 NavigationLink 时，SwiftUI 会带你进入另一个视图，在这个例子中是 PhotoCollectionView，你可以使用它来显示你的照片画廊。 如果你在 NavigationStack 中使用 NavigationLink 的话，SwiftUI 会负责管理你视图的呈现，使你可以在视图之间轻松地导航。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "By passing your model’s photoCollection to the PhotoCollectionView when you initialize it, you provide the collection of photos that you want to display in your gallery.": {
      "zh": "当你初始化 PhotoCollectionView 时，通过传递你模型的 photoCollection 给它，你便提供了想在画廊中展示的照片集合。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "When you open the gallery, you’ll no longer see the viewfinder, so there’s no need to keep updating it. Instead, you’d rather concentrate the device’s performance on displaying your photos. To control when the camera’s preview stream is active, use the navigation link’s onAppear(perform:) modifier to pause it when the gallery appears, and onDisappear(perform:) to resume it again when you navigate back to the camera.": {
      "zh": "当你打开画廊时，取景器将不会被看到，所以没有必要继续更新它。相反，你更希望将设备的性能集中使用在显示你的照片上。 为了控制摄像头预览流是否激活的状态，使用 NavigationLink 的 onAppear(perform:) 修饰符在画廊出现时暂停它，并在回到摄像头视图时在 onDisappear(perform:) 修饰符中恢复它。",
      "tips": ""
    },
    "Building the Photo Gallery": {
      "zh": "构建照片画廊",
      "tips": ""
    },
    "Discover how to display your photos in a scrolling grid.": {
      "zh": "探索如何在一个滚动网格中显示你的照片。",
      "tips": ""
    },
    "You use a PhotoCollectionView to display your photos in a scrolling grid, with the most recent photos at the top.": {
      "zh": "你使用一个 PhotoCollectionView 对象将你的照片在一个可滚动的网格中展示出来，最新的照片会放在最前面。",
      "tips": ""
    },
    "When you create your PhotoCollectionView, the photoCollection property initializes with a reference to your model’s photoCollection. It provides all of the data you need to build your photo gallery. By making photoCollection an observed object, SwiftUI updates your photo collection view in response to changes in the collection’s published values.": {
      "zh": "当你创建 PhotoCollectionView 时，photoCollection 属性会被初始化为一个指向你模型的 photoCollection 引用。它提供了构建你照片画廊所需的所有数据。 通过将 photoCollection 设置为一个可观察的对象，SwiftUI 会通过响应 photoCollection 的值变化，来更新你的 PhotoCollectionView。",
      "tips": ""
    },
    "You use a lazy vertical grid (LazyVGrid) to display your photos as items in a grid layout. Because the layout uses a vertical grid, you only need to decide how many columns you want and the spacing between each item. After the grid has the number of columns, it expands vertically to add enough rows for displaying all of your photos.": {
      "zh": "你使用一个 LazyVGrid 来将照片作为网格布局中的项目进行展示。由于布局使用的是垂直网格，所以只需要决定需要多少列和每个项目之间的间隔。 网格有了列数之后，它会垂直扩展以添加足够的行来显示所有的照片。",
      "tips": ""
    },
    "Note": {
      "zh": "注释",
      "tips": ""
    },
    "Why lazy? Well, if the grid is larger than its containing view, the view only displays the items that are currently visible. This “laziness” actually enhances the performance of your app, especially as you scroll through the grid of photos.": {
      "zh": "为什么选择延迟加载呢？如果网格比其容器视图大，那么视图只需要显示当前可见的项目。这种 “懒惰性” 实际上增强了你 app 的性能，尤其是在滚动照片网格时。",
      "tips": ""
    },
    "You could use a fixed number of columns in your grid, but a more responsive approach is to display as many columns as you can, depending on the width of the view. This creates a much better experience as people resize your app. To create a grid that adapts to the width of your view, define an adaptive GridItem and specify the size and spacing you want it to maintain.": {
      "zh": "你可以把网格中的列设置成固定数量，但更灵活的方法是根据视图的宽度显示尽可能多的列。当用户调整你 app 的大小时，这将创造出更好的用户体验。 为了创建一个适应视图宽度的网格，可以定义一个自适应的 GridItem，并指定你希望它保持的大小和间距。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "Imagine having hundreds — or thousands — of photos. Even with adaptive layout, your grid can get very tall — way taller than the space you have to display it! Make your grid scrollable by placing it inside a ScrollView. This makes it so your grid can have as many rows as it needs, and you’ll be able to scroll up and down through your photos.": {
      "zh": "想象一下，你有几百，甚至几千张的照片。即使是自适应布局，网格也可能会变得非常长，远远超过你用来显示它的空间！ 通过将它放在 ScrollView 中，使其可滚动。这就使得你的网格可以有尽可能多的行，并能够通过上下滚动查看照片。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "Inside your grid, use ForEach to iterate over the photo assets in your collection and generate a view for each asset — these views populate your grid. Because your grid is lazy, as you scroll, ForEach only operates on the visible photo assets.": {
      "zh": "在网格内，则使用 ForEach 对集合中的照片资源进行迭代，并为每个资源生成一个视图，用这些视图来填充网格。由于网格是延迟加载的，所以当你滚动时，ForEach 仅对可见的照片资源进行操作。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第七步",
      "tips": ""
    },
    "Create a NavigationLink for each grid item that, when tapped or clicked, displays the individual photo at full size using the destination PhotoView initialized with the photo asset.": {
      "zh": "为每个网格项创建一个 NavigationLink，当点击它时，通过使用点击的那个照片资源来初始化目标视图 PhotoView ，来以全尺寸显示单个照片。",
      "tips": ""
    },
    "Step 8": {
      "zh": "第八步",
      "tips": ""
    },
    "The photoItemView(asset:) method creates a view that displays a small image thumbnail for a photo asset. You’ll use this view as the label for the navigation link, displaying each link as a thumbnail-sized image of the photo.": {
      "zh": "photoItemView(asset:) 方法用于创建一个视图，其显示照片资源的小尺寸缩略图。你将使用此视图作为 NavigationLink 的标签，将每个 NavigationLink 以照片的缩略图大小来显示出来。",
      "tips": ""
    },
    "Displaying a Photo": {
      "zh": "显示一个照片",
      "tips": ""
    },
    "Learn how the photo view loads and displays your photo.": {
      "zh": "了解照片视图是如何加载和显示照片的。",
      "tips": ""
    },
    "When it comes to displaying a photo on its own, you’ll use PhotoView. In your photo view, you display a high-resolution image that you request from the photo. You also have an overlay with buttons for favoriting or deleting the photo.": {
      "zh": "当需要单独展示一张照片时，你会使用 PhotoView。在 PhotoView 中，会显示一张从 cache 中请求的高分辨率图像。另外还有一个放置收藏或删除照片按钮的叠加层。",
      "tips": ""
    },
    "Your photo view has a photoAsset property for the photo it displays. You pass this in when you initialize the PhotoView.": {
      "zh": "你的 PhotoView 中有一个名为 photoAsset 的属性，其用于显示照片。当你初始化 PhotoView 时，需要传入这个值。",
      "tips": ""
    },
    "You also initialize the view with a cache property that holds a reference to your image cache. You can request an image of a specified size from the image cache. After loading the image from the photo asset, the cache delivers it back to you. The image cache also keeps recently-requested images in memory, so it doesn’t have to reload them if you request them again.": {
      "zh": "你还需要在初始化视图时设置一个 cache 属性，该属性持有一个指向你图像缓存的引用。你可以从缓存中按指定的大小请求图像。 在从照片资源加载图像后，缓存会将其返回给你。此缓存还会在内存中保留最近请求的图像，所以如果你再次请求它们，就不需要重新加载。",
      "tips": ""
    },
    "Your view has an image state property ready to hold the image after loading it. It’s an optional type — Image? — because you want it to start off without any value.": {
      "zh": "你的视图有一个名为 image 的状态属性，用来保存加载后的图像。因为你希望它在开始时没有任何值，所以是一个 Image? 可选类型。",
      "tips": ""
    },
    "A view can use its task(priority:_:) modifier to run some code asynchronously whenever the view loads.": {
      "zh": "视图可以在加载时，使用其 task(priority:_:) 修饰符来异步运行一些代码。",
      "tips": ""
    },
    "This is where you add code to request a high-resolution image from the cache for the photo asset, specifying the size you want. You also provide the cache with a closure that contains code it can call when it has a result.": {
      "zh": "这块就是你添加的异步代码，作用是从缓存中请求照片资源的高分辨率图像，并指定需要的大小。你还需要提供一个闭包给缓存，此闭包会在请求图像有结果的时候被调用。",
      "tips": ""
    },
    "Your result closure receives one or more calls from the cache. If the cache already contains the image you requested, it immediately calls your closure with the image in its result. If the cache doesn’t have the requested image, then it loads the image from the photo asset and caches it. While loading the image, the cache may first call your closure with a low-resolution image, before finally delivering the high-resolution image in the result.": {
      "zh": "这个闭包会被缓存调用一次或多次。如果缓存中已经有你所请求的图像，那么它会立即用这个图像作为参数来调用此闭包。反之则会从照片资源中加载图像并将其缓存。 在加载图像时，获得高分辨率图像之前，缓存可能先用低分辨率图像来调用你的闭包。",
      "tips": ""
    },
    "Your result closure looks for an image in the result. If it finds one, it updates your image property.": {
      "zh": "你在闭包中会试图解包 result。如果解包成功，则会更新视图的 image 属性。",
      "tips": ""
    },
    "Step 9": {
      "zh": "第九步",
      "tips": ""
    },
    "Because you’ve made image a state property, SwiftUI updates your view when its value changes. If image contains a value, you unwrap the image and display it in your view.": {
      "zh": "因为 image 是一个状态属性，所以当其值改变时，SwiftUI 会自动更新视图。如果 image 不为空，则解包 image 并在视图中显示它。",
      "tips": ""
    },
    "Step 10": {
      "zh": "第十步",
      "tips": ""
    },
    "However, if image doesn’t have a value, you use a ProgressView to display a spinner as a placeholder. Look very carefully, and you might just see this spinner when your view first loads, before the cache has a chance to load an image from the photo asset.": {
      "zh": "然而，如果 image 为空，则会使用 ProgressView 来显示一个作为占位符的指示器。如果你仔细看的话，可能会在视图首次加载，并且缓存还在从照片资源加载图像时，看到这个指示器。",
      "tips": ""
    }
  },
  "sample-apps/capturingphotos-camerapreview": {
    "Previewing the Camera Output": {
      "zh": "预览摄像头输出",
      "tips": ""
    },
    "Preview the output from the camera.": {
      "zh": "预览摄像头的输出。",
      "tips": ""
    },
    "Your camera’s video output sends a continuous stream of individual images (video frames). You display these in a viewfinder so you can see exactly what the camera is looking at before composing your shot and taking a photo.": {
      "zh": "摄像头的视频输出会发送连续的单独图像流（视频帧）。你可以在取景器中显示这些图像，以便在构图和拍照前能准确地看到摄像头正在显示的内容。",
      "tips": ""
    },
    "Discover more about how this works. 🎞": {
      "zh": "了解更多关于这是如何工作的。",
      "tips": ""
    },
    "Section 1": {
      "zh": "第一节",
      "tips": ""
    },
    "Using the Camera": {
      "zh": "使用摄像头",
      "tips": ""
    },
    "Learn about the camera in your data model.": {
      "zh": "了解在你数据模型中的相机。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "Your data model has a camera property that represents one of the physical cameras — or capture devices — available to your device.": {
      "zh": "你的数据模型中有一个 camera 属性，其代表你设备中可用的一个物理摄像头或捕捉设备。",
      "tips": ""
    },
    "Note": {
      "zh": "注释",
      "tips": ""
    },
    "Your device may have access to several capture devices — for example, the front and back cameras on iPad — and you can switch between these using the camera’s switchCaptureDevice() method. Learn more about capture devices in Cameras and Media Capture.": {
      "zh": "你的设备可能可以访问多个捕捉设备（例如，iPad 的前后摄像头），并且你还可以通过它的 switchCaptureDevice() 方法在这些设备之间进行切换。 在 “Cameras and Media Capture” 中了解更多关于捕捉设备的信息。",
      "tips": ""
    },
    "Tip": {
      "zh": "提示",
      "tips": ""
    },
    "To start using the camera, you call its start() method: await model.camera.start()": {
      "zh": "为了开始使用摄像头，你需要这样调用它的 start() 方法：await model.camera.start()",
      "tips": ""
    },
    "Section 2": {
      "zh": "第二节",
      "tips": ""
    },
    "Exploring the Preview Stream": {
      "zh": "探索预览流",
      "tips": ""
    },
    "Learn about the stream of preview images from your camera.": {
      "zh": "了解来自于你摄像头的图像预览流。",
      "tips": ""
    },
    "After calling the camera’s start() method, its video output produces a stream of low-resolution preview images (video frames), at rates of up to 60 frames a second.": {
      "zh": "在调用 Camera 的 start() 方法后，它的视频输出会以每秒最多60帧的速度产生一个低分辨率的图像预览流（视频帧）。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "You receive these preview images through the camera’s previewStream property, as an asynchronous stream of CIImage (Core Image) objects.": {
      "zh": "你通过 Camera 的 previewStream 属性接收这些预览图像，previewStream 的类型是一个包含 CIImage 对象的异步流。",
      "tips": ""
    },
    "Section 3": {
      "zh": "第三节",
      "tips": ""
    },
    "Processing the Preview Stream": {
      "zh": "处理预览流",
      "tips": ""
    },
    "Learn how to process the preview stream so that it’s ready to display in the viewfinder.": {
      "zh": "学习如何处理预览流，使其可以在取景器中显示。",
      "tips": ""
    },
    "Your data model has a dedicated task to handle the stream of preview images from the camera, using its handleCameraPreviews function.": {
      "zh": "你的数据模型有一个专门的 Task 来处理从摄像头过来的图像预览流，这个 Task 则直接调用 handleCameraPreviews 函数。",
      "tips": ""
    },
    "You can learn more about Tasks in the Swift standard library.": {
      "zh": "你可以在 Swift 标准库中了解更多关于 Task 的信息。",
      "tips": ""
    },
    "In handleCameraPreviews, turn the preview stream of CIImage objects from the camera into a stream of Image views, ready for display.": {
      "zh": "在 handleCameraPreviews 中，将 camera 产生的类型为 CIImage 对象的预览流转化为一系列的 Image 视图，让其准备好进行显示。",
      "tips": ""
    },
    "An AsyncStream is a stream of values that are produced at time intervals. The values form a sequence, but with its values arriving asynchronously — an AsyncSequence. You can do many of the same things you can do with any other sequence of values, such as with an array.": {
      "zh": "AsyncStream 是一个每隔一段时间就会产生值的流。这些值会形成一个类型为 AsyncSequence 的序列，其值是异步到达的。你可以对它做许多与其他值序列（例如数组）相同的操作。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "In this case you use the stream’s map(_:) function to convert each element — $0 — into an Image instance using an image property extension of CIImage. This transforms the stream of CIImage instances into a stream of Image instances.": {
      "zh": "在这个例子中，你使用 stream 的 map(_:) 函数将每个元素（也就是 $0），通过 CIImage 的 image 属性扩展转换为 Image 实例。这是将 CIImage 实例的流转换为一个 Image 实例的流。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "Your for-await loop waits for each image in your transformed imageStream before doing something with it.": {
      "zh": "在对得到的图像做点什么之前，你的 for-await 循环会在那里等待转换后的 imageStream 中产生每一个图像。",
      "tips": ""
    },
    "Learn more about working with asynchronous sequences in the Swift Programming Language Guide.": {
      "zh": "你可以在 “Swift Programming Language Guide” 中了解更多关于处理异步序列的信息。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "You use the image from the preview stream to update your data model’s viewfinderImage property. SwiftUI makes sure that any views using this property get updated when the viewfinderImage value changes.": {
      "zh": "你使用从预览流中得到的图像来更新你数据层的 viewfinderImage 属性。当 viewfinderImage 值改变时，SwiftUI 确保任何使用此属性的视图都得到更新。",
      "tips": ""
    },
    "Section 4": {
      "zh": "第四节",
      "tips": ""
    },
    "Viewing the Preview Stream": {
      "zh": "查看预览流",
      "tips": ""
    },
    "See how you can connect your viewfinder view to the processed preview stream.": {
      "zh": "了解如何将你的取景器视图与处理后的预览流连接起来。",
      "tips": ""
    },
    "Your CameraView has a ViewfinderView that it uses to display live video from the camera.": {
      "zh": "你的 CameraView 有一个 ViewfinderView，其用于显示摄像头的实时视频。",
      "tips": ""
    },
    "By binding the the model’s viewfinderImage property to your ViewfinderView, you ensure that the viewfinder updates whenever the view receives a new preview image. Because the preview image updates many times per second, your eyes see it as live video in the viewfinder.": {
      "zh": "通过将 model 的 viewfinderImage 属性绑定到你的 ViewfinderView 上，确保每当视图接收到新的预览图像时，取景器都会更新。 由于预览图像每秒会更新多次，所以你的眼睛会认为在取景器中看到的是实时视频。",
      "tips": ""
    }
  },
  "sample-apps/capturingphotos-captureandsave": {
    "Capturing and Saving a Photo": {
      "zh": "拍摄和保存照片",
      "tips": ""
    },
    "Take photos with the camera, add them to your photo library, and display them in your app.": {
      "zh": "使用摄像头拍照，将照片添加到你的照片库中，并在你的 app 中显示它们。",
      "tips": ""
    },
    "Smile! Click! A lot happens in quick succession when you take a photo. 📸": {
      "zh": "微笑！点击！在拍照时会迅速发生很多事情。",
      "tips": ""
    },
    "Follow the action after you tap or click the shutter button, to investigate what happens from that moment to when the photo shows up in your photo library.": {
      "zh": "随着你点击相机视图或点击快门之后，来探索从这一刻到照片出现在你照片库中所发生的过程。",
      "tips": ""
    },
    "Responding to the Shutter Button": {
      "zh": "响应快门按钮",
      "tips": ""
    },
    "Learn how to handle the shutter button action, and request the camera to take a photo.": {
      "zh": "学习如何处理快门按钮的操作，并请求摄像头拍摄照片。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "When you tap or click the shutter button in your camera view, things start happening!": {
      "zh": "当你点击相机视图或点击快门按钮时，事情就开始发生了！",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "The button springs into action, grabs the model’s camera object, then calls its takePhoto() method. Keep going to find out how it takes a photo!": {
      "zh": "按钮迅速响应，获取模型中的 camera 对象，然后调用它的 takePhoto() 方法。下面我们会解释它是如何能拍摄一张照片的！",
      "tips": ""
    },
    "Capturing a Photo": {
      "zh": "拍摄一张照片",
      "tips": ""
    },
    "When you take a photo, the camera captures image data from its sensor. Learn how to initiate this, and handle the resulting captured photo.": {
      "zh": "当你拍照时，摄像头会从其传感器中捕获图像数据。学习如何发起拍照，并处理捕获到的照片。",
      "tips": ""
    },
    "When you take a photo, you want to capture an image with the highest possible resolution. This contrasts with the preview images, which tend to have a lower resolution to facilitate rapidly updating previews in the viewfinder. Your camera has a special photo output that its takePhoto() method uses to capture high-resolution images of what you see in the viewfinder.": {
      "zh": "当你拍摄照片时，你希望以尽可能高的分辨率捕获图像。这与预览图像形成了对比，预览图像通常具有较低的分辨率，以便在取景器中快速更新预览。 你的摄像头具有一个专门的照片输出，这里的 takePhoto() 方法就使用该输出来捕获在取景器中所见的高分辨率图像。",
      "tips": ""
    },
    "You start the real work of taking the photo by requesting the photo output to capture a photo. If all goes well, this is when you hear a reassuring shutter sound to let you — and anyone nearby — know that you’ve just taken a photo.": {
      "zh": "通过请求照片输出来拍摄照片，你便开始了实际的拍照工作。如果一切顺利，这时你会听到令人放心的快门声音，让你和周围的人都知道你刚刚拍摄了一张照片。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "You might wonder why capturePhoto doesn’t just return the photo. That’s because capturing a photo takes time: the camera may need to focus, or wait for the flash, and then there’s the exposure time. The capturePhoto method is asynchronous, with the captured photo typically arriving a short time after you tap or click the shutter button.": {
      "zh": "你可能会想知道为什么 capturePhoto 方法不直接返回照片。这是因为拍摄照片需要时间：相机可能需要对焦，或者等待闪光灯，以及还有曝光时间。 capturePhoto 方法是异步的，通常在你点击相机视图或点击快门按钮后的短暂时间内就会收到照片。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "After the photo capture has completed, you receive a callback to another method in your camera object: photoOutput(_:didFinishProcessingPhoto:error:). Its first argument receives the captured photo as an instance of AVCapturePhoto.": {
      "zh": "在捕获照片完成后，camera 对象的另一个回调方法：photoOutput(_:didFinishProcessingPhoto:error:) 会被调用。它的第二个参数是一个类型为 AVCapturePhoto 的实例，其就是被捕获的照片。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "Now that you’ve got the captured photo, you add it into the camera’s photo stream. It’s then available to any object in your app waiting for a photo, like the data model.": {
      "zh": "现在你已经获得了照片，并将它添加到 camera 的照片流中。然后你 app 中任何一个等待照片数据的对象（例如数据模型）都可以使用它。",
      "tips": ""
    },
    "Processing and Saving a Photo": {
      "zh": "处理和保存照片",
      "tips": ""
    },
    "Discover how to unpack a captured photo and save it to your photo library.": {
      "zh": "了解如何解包捕获的照片并将其保存到照片库中。",
      "tips": ""
    },
    "Your data model is patiently awaiting newly-captured photos. Just as for preview images, it has a dedicated task for handling the captured photo stream from the camera, using its handleCameraPhotos method.": {
      "zh": "你的数据模型正在耐心地等待新捕获到的照片。就像处理预览图像一样，它也有一个专门的 Task 处理来自 camera 对象的被捕获的照片流，这个 Task 调用 handleCameraPhotos 方法。",
      "tips": ""
    },
    "Tip": {
      "zh": "注释",
      "tips": ""
    },
    "You can learn more about Tasks in the Swift standard library.": {
      "zh": "你可以在 Swift 标准库中了解更多关于 Task 的信息。",
      "tips": ""
    },
    "Each AVCapturePhoto element in the camera’s photoStream may contain several images at different resolutions, as well as other metadata about the image, such as its size and the date and time the image was captured. You have to unpack it to get the images and metadata that you want. The first thing you do in handleCameraPhotos is to convert photoStream into a more useful unpackedPhotoStream, in which each element is an instance of the PhotoData structure that contains the data you want.": {
      "zh": "camera 的 photoStream 中的每个 AVCapturePhoto 元素可能包含有多个不同分辨率的图像，以及关于这个图像的其他元数据，如大小以及图像捕获的日期和时间。 你需要解包它以获取你想要的图像和元数据。在 handleCameraPhotos 中的第一件事就是将 photoStream 转换为一个更有用的 unpackedPhotoStream，其中每个元素都是 PhotoData 结构的实例，其包含你想要的那些数据。",
      "tips": ""
    },
    "To unpack the photoStream, you’ll use the unpackPhoto(_:) function, which takes a captured photo and returns a PhotoData instance that contains a low-resolution image thumbnail as an Image, the size of the image thumbnail, a high-resolution image as Data, and the size of the high-resolution image.": {
      "zh": "你会使用 unpackPhoto(_:) 方法来解包 photoStream，它接受一个捕获的照片作为参数，并返回一个 PhotoData 实例。 该实例包含一个类型为 Image 的低分辨率图像作为缩略图，以及这个缩略图的大小；还有一个类型为 Data 的高分辨率图像，和此图像的大小。",
      "tips": ""
    },
    "You’ll recall that, as an asynchronous stream, photoStream is very much like a Sequence. You can use its compactMap(_:) method to call unpackPhoto(_:) for each photo ($0) in the stream. This transforms the stream of AVCapturePhoto instances into a much more useful stream of PhotoData instances.": {
      "zh": "你可能还记得，作为一个异步流，photoStream 是非常类似于一个普通序列的。你可以使用它的 compactMap(:) 方法来对流中的每个照片（也就是例子中的 $0）调用 unpackPhoto(:)。 这将把 AVCapturePhoto 实例的流转换为一个更有用的 PhotoData 实例的流。",
      "tips": ""
    },
    "The for-await loop now waits for a photoData element to arrive in your unpacked stream before processing it.": {
      "zh": "现在，for-await 循环会等待一个 photoData 元素到达你的 unpackedPhotoStream 中，然后处理它。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "You use the thumbnail image in photoData to update your model’s thumbnailImage property.": {
      "zh": "你使用 photoData 中的缩略图来更新模型的 thumbnailImage 属性。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第七步",
      "tips": ""
    },
    "Call your model’s savePhoto(imageData:) method to save the image data from photoData as a new photo in your photo library.": {
      "zh": "调用你模型的 savePhoto(imageData:) 方法，将 photoData 中的图像数据保存为照片库中的新照片。",
      "tips": ""
    },
    "Step 8": {
      "zh": "第八步",
      "tips": ""
    },
    "The savePhoto(imageData:) method creates a task and passes on the real work of saving the photo data to the photoCollection object by calling its addImage(_:) method. And that’s fine! The data model’s job is to coordinate data flow between the app’s data objects.": {
      "zh": "savePhoto(imageData:) 方法创建了一个 Task，并通过调用 photoCollection 对象的 addImage(_:) 方法将真正保存照片数据的工作委托给它。 这是完全可以的！数据模型的工作之一就是协调 app 数据对象之间的数据流。",
      "tips": ""
    }
  },
  "sample-apps/chooseyourownstory": {
    "Choose Your Own Story": {
      "zh": "选择你自己的故事",
      "tips": ""
    },
    "Provide dynamic navigation between views.": {
      "zh": "提供视图间的动态导航。",
      "tips": ""
    },
    "In this sample, you can write a story with many different paths and outcomes. Your reader can make choices at important points in the narrative, resulting in different experiences based on their responses.": {
      "zh": "在这个示例中，你可以写一段包括多种路径和结果的故事。你的读者可以在关键点处选择，结果会影响故事的不同体验。",
      "tips": ""
    },
    "There are several parts to this app. StoryData contains the story itself, including the text on each page and the choices the reader can make.": {
      "zh": "这个应用程序有几个部分。 StoryData 包含故事本身，包括每页故事描述文本和读者可以选择的选项。",
      "tips": ""
    },
    "StoryView sets up the navigation for the app, and StoryPageView displays the contents of one page of the story.": {
      "zh": "StoryView 设置导航，并使用 StoryPageView 展示故事的内容。",
      "tips": ""
    },
    "You can start in StoryData and write your own narrative, or you can learn about and modify the look and feel of the app in StoryView and StoryPageView.": {
      "zh": "你可以从 StoryData 开始，写你自己的故事，或者你可以在 StoryView 和 StoryPageView 中了解学习和修改应用程序的外观和风格。",
      "tips": ""
    },
    "Create Your Own Story": {
      "zh": "创造你自己的故事",
      "tips": ""
    },
    "Customize the story to create a narrative of your own.": {
      "zh": "自定义故事内容来创建自己的叙事。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "To construct your narrative, the app needs an instance of Story, which takes an array of StoryPage instances. Each page of your story contains some narrative text and an array of choices to select from. That choice takes you to another story page with more choices that take you to another story page, and so on.": {
      "zh": "为了构建故事，应用程序需要一个 Story 实例，它包括一个 StoryPage 数组。每个页面的故事包含故事文本和选项，选项会导向另一个故事页面，以此类推。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "Here’s the text of your first story page. Try changing it to something new, and notice how the app preview changes. When you’re ready, you can edit this text to start creating your story.": {
      "zh": "这是第一个故事页面的文本。试着改变它，并注意，应用程序预览会改变。当你准备好时，编辑文本来开始创建故事。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "Notice the three quotation marks above and below the text? This is a special way to create a String value. You can read and edit your story much more easily with this special syntax because you can include multiple lines and quotation marks in the text.": {
      "zh": "注意到文本上下的三个引号了吗？这是一个特殊的方式来创建字符串值。你可以使用这种特殊的语法来编辑故事，用三个引号包住多行文本。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "In addition to the intro text, each page offers readers some choices for what happens next in the story. The page displays these choices as buttons below the text.": {
      "zh": "除了介绍文本之外，每个页面都有读者可以选择的选项。页面将这些选项显示在文本下面。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实践",
      "tips": ""
    },
    "Try customizing the text of each choice to see how the app preview updates the buttons.": {
      "zh": "尝试自定义每个选项的文本来看应用程序预览如何更新按钮。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "The destination property of the choice is the key to story navigation. The number is the index of the page for the app to display when a reader taps to select that choice. Arrays start counting at 0, so the index of the first page is 0, the second page is 1, and so on.": {
      "zh": "选择的 destination 属性是故事导航的关键。数字是应用程序显示的页面的索引。数组计数从 0 开始，所以第一个页面的索引是 0，第二个页面是 1。以此类推。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "Try changing the destination of one of these choices and then test where the button navigates to in the app preview. Be careful, though. You have 21 story pages, so using an index higher than 20 causes the app to crash due to an index out of range error.": {
      "zh": "尝试修改其中一个选项的目标，然后测试在应用程序预览中按钮导航的页面。不过要注意，我们有 21 个故事页面，因此使用一个大于 20 的索引可能会导致应用程序崩溃。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第七步",
      "tips": ""
    },
    "To add a new page to the story, copy an existing story page, such as this one, and paste it below the last story page in the array.": {
      "zh": "要给故事添加新页面，复制一个现有故事页面，并将其放在故事数组的最后一个页面之后。",
      "tips": ""
    },
    "Try adding a new page and customizing its text and choices. You’re now ready to start writing the adventure!": {
      "zh": "尝试添加一个新页面并自定义它的文本和选项。你现在已经可以开始写故事了!",
      "tips": ""
    },
    "Story Data Model": {
      "zh": "故事数据模型",
      "tips": ""
    },
    "Learn how to structure the story data for your reader’s adventure.": {
      "zh": "了解如何为读者的故事构建数据。",
      "tips": ""
    },
    "You’ll use the custom types defined here to model the story data. Your app uses an instance of the Story type to display a series of story pages, each with some narrative text and a number of choices for the reader.": {
      "zh": "你将使用这里的自定义类型来对故事数据进行建模。您的应用程序使用 Story 类来显示故事页面，每个页面都有故事文本和读者可以选择的选项。",
      "tips": ""
    },
    "The pages property holds an array of StoryPage values, each corresponding to a page of your story.": {
      "zh": "pages 属性包含一个 StoryPage 数组，每个数组元素对应一个故事页面。",
      "tips": ""
    },
    "The StoryPage type contains a text value for the narrative text on the page, and a choices array that contains an array of StoryChoice options that a reader can choose from to navigate to another page.": {
      "zh": "StroyPage 类包含故事文本的值，以及一个选项数组，读者可以选择来导航到另一个页面。",
      "tips": ""
    },
    "The Choice type defines a choice readers can make while reading a story.": {
      "zh": "Choice 类定义读者可以在故事中选择的选项。",
      "tips": ""
    },
    "The text property holds a String that describes the choice readers can make.": {
      "zh": "text 属性包含一个字符串描述读者可以选择的选项。",
      "tips": ""
    },
    "The destination property stores an Int. The value is the index of the page that the choice navigates to.": {
      "zh": "destination 属性存储一个整数。这个值是选项导航到故事页面的索引。",
      "tips": ""
    },
    "Creating a Navigation View": {
      "zh": "创建一个导航视图",
      "tips": ""
    },
    "To manage navigation through the story, the app wraps each story page in a NavigationStack.": {
      "zh": "为了管理故事中的导航，应用程序将每个故事页面包装在 NavigationStack 中。",
      "tips": ""
    },
    "StoryView is the top-level view of your app. When your app runs, this is the first view it displays.": {
      "zh": "StoryView 是应用程序的顶级视图。当应用程序运行时，他是第一个显示的视图。",
      "tips": ""
    },
    "To display and navigate between each story page, you’ll use a NavigationStack. This view acts as a container to display one StoryPageView at a time and transition to the next view when the reader taps a NavigationLink.": {
      "zh": "要显示和导航每个故事页面，你将使用 NavigationStack。将它作为容器一次显示一个 StoryPageView，当读者点击 NavigationLink 时，它会显示下一个视图。",
      "tips": ""
    },
    "The navigation view displays StoryPageView as its content. Notice that you initialize this view with the global variable story from the StoryData file, and you show the first page, with an index of 0.": {
      "zh": "导航视图显示 StoryPageView 作为其内容。要注意，你使用 StoryData 文件中的全局变量初始化这个视图，并显示第一个页面，索引为 0。",
      "tips": ""
    },
    "Displaying a Story Page": {
      "zh": "显示故事页面",
      "tips": ""
    },
    "Explore and modify the story’s user interface (UI) using basic SwiftUI views.": {
      "zh": "使用基本 SwiftUI 视图探索和修改故事的用户界面(UI)。",
      "tips": ""
    },
    "StoryPageView displays your story so readers can navigate by making choices provided on each page.": {
      "zh": "StoryPageView 展示故事，读者可以通过提供的选项来导航。",
      "tips": ""
    },
    "To display a story, the app uses an instance of the Story type that contains all of the story’s data. To change this data, go to the StoryData.swift file and look for the global variable story.": {
      "zh": "为了显示故事，应用程序使用 Story 类中包含故事数据的实例。要改变故事数据，请查看 StoryData.swift 文件并在其中找到全局变量 story。",
      "tips": ""
    },
    "This property stores the index of the current story page.": {
      "zh": "这个属性存储当前故事页面的索引。",
      "tips": ""
    },
    "A VStack arranges content vertically onscreen. At the top is the text of the current page, and at the bottom are the choices the reader can make on the page. When the reader taps to select a choice, the app navigates to another page.": {
      "zh": "VStack 在屏幕上垂直排列内容。在顶部是当前页面的文本，在底部是读者可以选择的选项。当读者选择选项时，应用程序导航到另一个页面。",
      "tips": ""
    },
    "The ScrollView lets you display content that’s bigger than the screen. Because a story page might have a lot of text, you want the reader to be able to scroll through it.": {
      "zh": "ScrollView 使读者能够在屏幕上滚动。因为故事页面可能会有很多文本，你希望读者能够滚动浏览它。",
      "tips": ""
    },
    "The Text view displays the story text from the current page.": {
      "zh": "文本视图显示当前页面的故事文本。",
      "tips": ""
    },
    "The ForEach structure generates views for a collection of things. In this case, the collection is the choices array of the current page in the story. The code within the braces runs once for each choice.": {
      "zh": "ForEach 结构生成集合视图，在这个例子中，集合是当前页面的选项数组，大括号内的代码针对每个选项运行一次。",
      "tips": ""
    },
    "Note": {
      "zh": "注意",
      "tips": ""
    },
    "SwiftUI uses the id argument to tell the choices apart from each other. Because each choice has different text, you can use the text property to identify them.": {
      "zh": "SwiftUI 使用 id 参数来区分选项。因为每个选项有不同的文本，你可以使用 text 属性来区分它们。",
      "tips": ""
    },
    "Step 8": {
      "zh": "第八步",
      "tips": ""
    },
    "The ForEach view passes each item of the choices collection into its body. You can use the choice to create a NavigationLink.": {
      "zh": "ForEach 视图传递每个选项到 body 中。你可以使用选项创建 NavigationLink。",
      "tips": ""
    },
    "A NavigationLink needs two things: a destination and content to display. The destination of the navigation link is the page that the choice navigates to.": {
      "zh": "NavigationLink 需要两个东西：目的地和要显示的内容。导航链接的目的地是选项导航到的页面。",
      "tips": ""
    },
    "Step 9": {
      "zh": "第九步",
      "tips": ""
    },
    "The code between the braces is what the navigation link displays as its content — what the user taps.": {
      "zh": "大括号内的代码是导航链接显示的内容 — 用户点击的内容。",
      "tips": ""
    },
    "Navigation links don’t work if they aren’t inside a navigation view (either a NavigationStack or NavigationSplitView), so you’ll notice that the preview for this view won’t let you navigate to the next page. The StoryView creates the navigation view that contains the StoryPageView. Use the app preview, or the preview for the StoryView, to test your story navigation.": {
      "zh": "如果导航链接不是在一个 NavigationView（如 NavigationStack 或 NavigationSplitView）内，那么它们将不起作用，你可以注意到预览不会导航到下一页。StoryView 创建了 StoryPageView 的导航视图。使用 App 预览，或 StoryView 的预览来测试故事导航。",
      "tips": ""
    },
    "Step 10": {
      "zh": "第十步",
      "tips": ""
    },
    "The most important thing in this label is the Text for displaying the choices. But it’d be nice to match the text alignment with the story page text. To align the text, you’ll use two modifiers: .multilineTextAlignment and frame. Applying the .multilineTextAlignment modifier to the Text view aligns the text to its leading edge.": {
      "zh": "重要的是显示选项的文本，需要与故事页面文本对齐。要对文本进行对齐，你将使用两个修饰符: .multilineTextAlignment 和 frame。应用他们来对文本进行顺序对齐。",
      "tips": ""
    },
    "Step 11": {
      "zh": "第十一步",
      "tips": ""
    },
    "The .frame modifier puts the text inside an invisible frame. By specifying maxWidth: .infinity, you’re telling the frame to expand as wide as it’s allowed, and alignment: .leading aligns the text inside the frame to the leading edge.": {
      "zh": ".frame 修饰符将文本放在不可见的区域中。通过指定 maxWidth: .infinity，你告诉视图可以扩展到最大宽度，alignment: .leading 使文本在区域内顺序对齐。",
      "tips": ""
    },
    "Try removing or changing these modifiers to see how they affect the choice text.": {
      "zh": "尝试删除或者更改这些修饰符来看如何影响选项文本。",
      "tips": ""
    },
    "Step 12": {
      "zh": "第十二步",
      "tips": ""
    },
    "These next three modifiers provide a pleasing visual style to the NavigationLink view for each choice. The .padding modifier adds some space around the link’s contents. The .background modifier applies a gray color with 25 percent opacity, and the .cornerRadius modifer rounds its corners.": {
      "zh": "接下来的三个修饰符为每个选项添加一些美观的视觉样式。 .padding 修饰符为链接的内容添加一些空白边距。 .background 修饰符为背景色应用 25% 的透明度，.cornerRadius 修饰符为圆角。",
      "tips": ""
    },
    "You can experiment with these modifiers to change how the choice links look. For example, try removing or changing the padding, or changing the background color.": {
      "zh": "你可以尝试修改这些修饰符来改变选项链接的样式。例如，尝试删除或者更改填充，或更改背景颜色。",
      "tips": ""
    },
    "Step 13": {
      "zh": "第十三步",
      "tips": ""
    },
    "These two modifiers apply to a view when it’s enclosed in a navigation view. A navigation view provides a navigation bar at the top of the screen that can display a title and a back button, along with other items you can customize, such as extra buttons and text.": {
      "zh": "当视图被包含在 NavigationView 中时，这两个修饰符适用于视图。它提供了导航栏，在屏幕顶部显示标题和返回按钮，以及其他你可以自定义的项目，例如额外按钮和文本。",
      "tips": ""
    },
    "Step 14": {
      "zh": "第十四步",
      "tips": ""
    },
    "You can display the current page number in the navigation bar by setting its title using the .navigationTitle modifier. Because people expect page numbers to begin at 1, but array indices start at 0, you’ll need to add 1 to the pageIndex property.": {
      "zh": "你可以通过使用 .navigationTitle 来在导航栏中显示当前页面的索引。因为人们期望页面的索引从 1 开始，但数组索引始终从 0 开始，所以你需要在 pageIndex 属性中添加 1。",
      "tips": ""
    },
    "Step 15": {
      "zh": "第十五步",
      "tips": ""
    },
    "The .navigationBarTitleDisplayMode modifier controls how the title appears in the navigation bar. Providing .inline as the modifier’s value makes the title smaller in size. You can try the other two possible values — .automatic and .large — to see how they make the app look.": {
      "zh": ".navigationBarTitleDisplayMode 指定如何显示标题。.inline 作为值，让标题变小。尝试其他两种值：.automatic 和 .large 来看看它们如何改变应用程序的样式。",
      "tips": ""
    },
    "Date Planner": {
      "zh": "日期计划",
      "tips": ""
    },
    "Present hierarchical information in a list.": {
      "zh": "在列表中呈现层次化信息。",
      "tips": ""
    }
  },
  "sample-apps/dateplanner": {
    "Date Planner": {
      "zh": "日期规划",
      "tips": ""
    },
    "Present hierarchical information in a list.": {
      "zh": "在列表中呈现层次化信息。",
      "tips": ""
    },
    "Welcome to the Date Planner app. Use this app to organize and plan a series of events, organized by date.": {
      "zh": "欢迎使用 Date Planner 应用程序。使用该应用程序来组织和计划一系列按日期排列的活动。",
      "tips": ""
    },
    "This walkthrough teaches you how to use lists and an observable data model to create dynamic lists of events and tasks. Time to jump in.": {
      "zh": "本次讲解教你如何使用列表和可观察数据模型来创建事件和任务的动态列表。让我们开始吧。",
      "tips": ""
    },
    "App Configuration": {
      "zh": "应用配置",
      "tips": ""
    },
    "Learn how the app shares data with its views by creating a single data object and making it available to the entire view hierachy.": {
      "zh": "了解应用程序如何通过创建一个单一的数据对象，并且让整个视图层次结构可以共享数据。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "To navigate between different views in your app, create a NavigationView as the top-level view in your view hierarchy, inserting the app’s home view. For this app, EventList is that home view and the first view the app displays when it launches.": {
      "zh": "要在你的应用程序中导航到不同视图，创建一个 NavigationView，作为它们的顶层视图，在视图层次结构中插入应用程序的主页视图。对于此应用程序，EventList 是它的主页视图，也就是应用程序启动时显示的第一个视图。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "In wider app configurations, such full-screen landscape on an iPad, SwiftUI displays the NavigationView content as multiple adjacent columns, rather than a single stack. In this layout, your EventList displays in a sidebar column, and its destination content appears in the primary pane.": {
      "zh": "在更加广泛的应用程序配置中，如 iPad 上的全屏，SwiftUI 将内容分为多个相邻的列，而不是单个堆栈。在这种布局中，事件列表显示在侧边栏列，并且目标内容显示在主要视图中。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "Adding a Text view is a useful way to give the second column a placeholder view until a person selects an event in the list. When a person selects an event, the app replaces the placeholder view with an EventDetail view.": {
      "zh": "添加 Text 视图是一种有用的方法来给第二列添加占位视图，直到用户选择列表中的事件。当用户选择某个事件时，应用程序将占位视图替换为 EventDetail 视图。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "The app stores its data using the variable eventData. It’s defined with the @StateObject property wrapper to create an instance of an observable object, EventData. Because this object is observable, SwiftUI watches it to keep track of any changes to its values. Whenever the data changes, SwiftUI automatically updates all of the views that use (or observe) it.": {
      "zh": "应用程序使用变量 eventData 存储其数据。使用 @StateObject 属性包装器定义此对象，以创建一个可观察的对象 EventData。由于该对象是可观察的，因此 SwiftUI 监视它以跟踪任何变更，每当数据发生变化时，更新所有使用（或观察）它的视图。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "To make eventData available to your entire view hierarchy, use the .environmentObject modifier and pass in the eventData instance. Now you can use this data across all of your navigation view’s child views (and their child views as well).": {
      "zh": "要使 eventData 可以在所有的导航视图的子视图上使用，使用 .environmentObject 属性修饰符传入 eventData 实例。现在你可以在所有的导航视图的子视图上使用该数据。",
      "tips": ""
    },
    "Event Model": {
      "zh": "事件模型",
      "tips": ""
    },
    "Your event model holds all of the data needed to visualize and organize events in your list. Here you’ll explore how to structure an Event.": {
      "zh": "你的事件模型保存了需要在列表中呈现和组织事件的所有数据。在这里你将了解如何结构化一个事件。",
      "tips": ""
    },
    "To organize its data, Event planner uses a collection of Event objects, each of which represent a specific event, such as a camping trip or birthday party. By conforming to the Identifiable protocol, you ensure that when you create a list of events, SwiftUI can identify and update each row.": {
      "zh": "为了组织数据，Event planner 使用一个集合，每个事件都代表一次事件，例如一个露营旅行或生日派对。通过符合 Identifiable 协议，你确保 SwiftUI 可以识别和更新每行。",
      "tips": ""
    },
    "The Event type contains all of the information you need to populate an event, including a symbol, color, title, date, and collection of tasks. Each task is a specific to-do item for the event, such as “Get a camping lantern“.": {
      "zh": "Event 类包含你需要填充事件的所有信息，包括符号、颜色、标题、日期和任务集合。每个任务是事件的具体代办事项，例如“拿一个露营灯“。",
      "tips": ""
    },
    "You’ll also notice a list of computed properties for Event. These help people organize the sections of their lists based on the date and the number of tasks to complete.": {
      "zh": "你还会注意到一个计算属性列表。这些帮助人们根据日期和任务数来组织列表的各个部分。",
      "tips": ""
    },
    "For instance, the isPast property checks to see if the date property is less than Date.now, which is the current date and time. The property returns true when the event date is in the past, which allows people to sort any past events into their own category.": {
      "zh": "例如，isPast 属性检查 date 是否小于当前日期和时间。当事件日期是过去时间，该属性返回 true，它允许人们将任何过去的事件分类到自己的类别中。",
      "tips": ""
    },
    "Take a moment to examine some of the other properties defined here. Can you figure out how they might help organize the list of events?": {
      "zh": "花点时间检查一下此处定义的其他属性。你能想到怎样它们会怎么样帮助组织列表的事件呢?",
      "tips": ""
    },
    "Event Task": {
      "zh": "事件任务",
      "tips": ""
    },
    "An event task represents a to-do item for an event. Here, you’ll learn how how to model the tasks.": {
      "zh": "时间任务表示事件的代办事项。在这里，你将了解如何为任务构建模型。",
      "tips": ""
    },
    "An EventTask represents one of a collection of to-do items for an event. Like Event, an EventTask is also Identifiable, which lets SwiftUI manage and update its appearance in a list.": {
      "zh": "EventTask 表示一个事件的代办事项。与 Event 类型一样，EventTask 是 Identifiable 协议，让 SwiftUI 管理和更新它在列表中的外观。",
      "tips": ""
    },
    "EventTask contains properties for text, completion state, and an isNew property. When a person marks a task as completed, you set isCompleted to true, which allows your app to track the remaining tasks for each event.": {
      "zh": "EventTask 包含文本、完成状态和 isNew 属性。当用户将一个任务设为已完成时，你将 isCompleted 设置为 true，它允许你的应用程序跟踪每个事件的剩余任务。",
      "tips": ""
    },
    "Event Data": {
      "zh": "事件数据",
      "tips": ""
    },
    "You use the EventData observable object to populate the data in your event list. Here you’ll learn how to structure and update the data.": {
      "zh": "使用 EventData 可观察对象来填充你的事件列表。在这里你将了解如何结构化和更新数据。",
      "tips": ""
    },
    "This is the EventData type, which stores and modifies all of the events that your app displays in its UI. EventData conforms to the ObservableObject protocol, which means that if any of its published values change, SwiftUI notifies all observers (views using those values) and updates those views automatically.": {
      "zh": "这是 EventData 类型，它将包含所有你显示在 UI 中的事件存储和修改。EventData 符合 ObservableObject 协议，因此如果任何被 @Publish 修饰的值改变，SwiftUI 会通知所有观察者并自动更新它们的视图。",
      "tips": ""
    },
    "EventData contains a property called events that stores a prepopulated array of Event values, such as game night or a doctor’s appointment. By using the @Published property wrapper when defining this property, you instruct SwiftUI to notify all observers and update their views whenever the events array changes. This allows you to add and delete events from the array and see the change instantly in your UI.": {
      "zh": "EventData 包含一个名为 events 的属性，该属性存储预填充的 Event 数组，例如比赛夜或者医生的预约。通过在定义此属性时使用 @Published 属性修饰符，你可以指示 SwiftUI 通知所有观察者并自动更新它们的视图，以便你可以在数组中添加和删除事件并立即看到改变。",
      "tips": ""
    },
    "EventData provides methods for adding and deleting events. In addition, sortedEvents(period:) returns an array of sorted events based on the requested time period. Use this method in EventList to create sections based upon the event’s date, such as Next 7 Days.": {
      "zh": "EventData 提供添加和删除事件的方法。此外，sortedEvents(period:) 返回基于请求的时间段的排序事件数组。在 EventList 中使用该方法根据事件的日期创建分组，例如“接下来 7 天”。",
      "tips": ""
    },
    "The Period enumeration provides each of the time categories that you’ll use to sort the list. The categories are nextSevenDays, nextThirtyDays, future, and past.": {
      "zh": "Period 枚举提供了你将使用来排序列表的各种时间分类。分别是 nextSevenDays（下周）, nextThirtyDays（下月）, future（未来）, 和 past（过去）。",
      "tips": ""
    },
    "Event List": {
      "zh": "活动列表",
      "tips": ""
    },
    "Learn how to construct the primary UI for the app, the event list, using a List view.": {
      "zh": "了解如何使用 List 视图构建应用程序的主列表界面。",
      "tips": ""
    },
    "The EventList view creates a grouped listing of events using a List view.": {
      "zh": "EventList 视图使用 List 视图创建一个分组列表。",
      "tips": ""
    },
    "In DatePlannerApp, the top-level navigation view uses the .environmentObject modifier to pass in an instance of EventData, making it accessible to all of its child views. You can now access that data in this child view by declaring a variable with the @EnvironmentObject property wrapper and giving it the EventData type. You now have access to all of the prepopulated event data to create your list.": {
      "zh": "在 DataPlannerApp 中，最外层导航视图使用 .environmentObject 修饰符传入 EventData 的实例，使其可用于所有子视图。现在你可以在此子视图中访问该数据，并声明一个变量，它的类型是 EventData。现在你可以使用预先填充的数据来创建列表。",
      "tips": ""
    },
    "To make your list, create a List view and use a ForEach loop to iterate over all of the time periods (nextSevenDays, nextThirtyDays, future, and past).": {
      "zh": "要创建列表，创建 List 视图并使用 ForEach 循环迭代所有时间段(下周，下月，未来和过去)。",
      "tips": ""
    },
    "Next, check that the current time period contains at least one event, otherwise, don’t show any data for it.": {
      "zh": "接下来，检查当前时间段至少包含一个事件，否则不显示任何数据。",
      "tips": ""
    },
    "When you know there are events in a section, create a Section view and use ForEach to iterate over all events in that time period. Use the method sortedEvents(period:) from EventData to return the events specific to the section’s time range.": {
      "zh": "当你知道在某个时间段中有事件时，创建 Section 视图并使用 ForEach 迭代所有事件。使用 EventData 的方法 sortedEvents(period:) 来返回特定于时间段的事件。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "Inside the ForEach, create the EventRow views for each event in the time period. To do this, use a NavigationLink, then add an EventRow as the label (the part that you see), and an EventEditor as the destination (the part you navigate to when tapped). The event editor is where you’ll see all the tasks for each event and edit the event details.": {
      "zh": "在 ForEach 内，为该时间段内的每个事件都创建一个 EventRow 视图，然后添加一个 EventRow 作为标签和一个 EventEditor 作为目的地(点击跳转)。你可以在活动编辑器中查看每个活动的所有任务并编辑活动详细信息。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第七步",
      "tips": ""
    },
    "To delete events, add the modifier .swipeActions on the event row and define a button that calls the delete method from EventData. You can now swipe on an event and tap the delete button to remove the current event.": {
      "zh": "要删除事件，为事件行添加 .swipeActions 修饰符并定义一个按钮，它调用 EventData 的 delete 方法。现在你可以在事件行中滑动并点击删除按钮来删除当前事件。",
      "tips": ""
    },
    "Organizing with Grids": {
      "zh": "用网格组织展示数据",
      "tips": ""
    },
    "Display visual content in an arrangement of rows and columns.": {
      "zh": "以网格形式展示内容",
      "tips": ""
    }
  },
  "sample-apps/editinggrids": {
    "To display the views for editing or adding a symbol, simply toggle the associated value to true using a toolbar button.": {
      "zh": "",
      "tips": ""
    },
    "Before diving into SymbolGrid, take a look at an example of the data used to populate it. SymbolDetail is a view that uses a property, symbol, to create an image view using an SF Symbol.": {
      "zh": "",
      "tips": ""
    },
    "After you have an image view, you can use modifiers to change how the view looks and behaves. Modifiers in SwiftUI are methods called on a view one after another, but they are arranged vertically on separate lines in your code to make the code more readable. Try changing the .foregroundColor or .symbolRenderingMode modifiers to see how the preview changes.": {
      "zh": "",
      "tips": ""
    },
    "Editing Grids": {
      "zh": "",
      "tips": ""
    },
    "To add a new symbol, the app displays a sheet when isAddingSymbol is true, and that sheet displays the SymbolPicker view. When you dismiss the sheet, addSymbol adds the selected symbol to the grid.": {
      "zh": "",
      "tips": ""
    },
    "Image Gallery": {
      "zh": "",
      "tips": ""
    },
    "Another feature is an editing mode, allowing you to edit the data in your app. Here you’ll learn how to add editing functionality to a grid, including adding and removing grid items.": {
      "zh": "",
      "tips": ""
    },
    "These views are deeply nested. You have an image view inside of a ZStack, inside of a NavigationLink, inside of a ForEach, inside a LazyVGrid, inside a ScrollView. SwiftUI uses composable view elements as building blocks to create the functionality of a dynamic interface. Take a second to think of how changing the order of these views might change the functionality of the grid.": {
      "zh": "",
      "tips": ""
    },
    "Creating the Navigation for Your App": {
      "zh": "",
      "tips": ""
    },
    "To make it easy for people to move around in your app, you need to provide a way for them to navigate between different views. For Editing Grids, you’ll configure the app so people can tap a symbol in the grid to switch views.": {
      "zh": "",
      "tips": ""
    },
    "Let people edit data that your app displays.": {
      "zh": "",
      "tips": ""
    },
    "There are several places in the body where you’ll see isEditing checked with conditional code. This allows you to show the enclosed UI only if isEditing is true. Using these conditional checks, you can create an editing UI within the same view as the grid itself. Again, because isEditing is a @State variable, SwiftUI updates GridView to automatically display or hide the conditional views when that value changes.": {
      "zh": "",
      "tips": ""
    },
    "Step 6": {
      "zh": "",
      "tips": ""
    },
    "To create a grid, use a LazyVGrid. This is a container that lays out views in a grid shape. However, you also want to nest the LazyVGrid inside a ScrollView, so you can scroll through content if it exceeds the vertical space of the grid view.": {
      "zh": "",
      "tips": ""
    },
    "In Organizing with Grids, you learned how to lay out your app’s interface using a grid of colored rectangles. In this sample, you’ll create a similar grid interface populated with SF Symbols. To build on what you’ve learned, Editing Grids takes your app to the next level by teaching you about two important features in app design: navigating within your app, and making it possible for people to edit data that they store in the app.": {
      "zh": "",
      "tips": ""
    },
    "There are multiple ways to create an Image in SwiftUI. One way is to use the argument systemName, which creates an image using the SF Symbol associated with the string passed in.": {
      "zh": "",
      "tips": ""
    },
    "To create the grid of SF Symbols, you’ll set up SymbolGrid with a variable, symbols, to track a collection of Symbol instances for the various symbols. When you mark this variable with @State, SwiftUI manages the storage for the value. Whenever this state value changes, SwiftUI updates any views using the value (the grid, in this case). For instance, if you deleted a symbol, the corresponding symbol image disappears from the grid.": {
      "zh": "",
      "tips": ""
    },
    "Learn how to create data that is uniquely identifiable in SwiftUI.": {
      "zh": "",
      "tips": ""
    },
    "Explore how to add navigation to your app using a NavigationStack.": {
      "zh": "",
      "tips": ""
    },
    "Step 3": {
      "zh": "",
      "tips": ""
    },
    "Step 4": {
      "zh": "",
      "tips": ""
    },
    "Explore how to add editing functionality to your grid, including the ability to add or delete items.": {
      "zh": "",
      "tips": ""
    },
    "The name property contains a String value that corresponds to an SF Symbol. You use the value of name to create the Image views in your grid.": {
      "zh": "",
      "tips": ""
    },
    "After ForEach, you’ll create image views for each symbol in the grid. Create the image view using the name of the symbol, and wrap the image in a NavigationLink. This turns the view into a button that links to the destination view, SymbolDetail, when tapped or clicked. When this happens, the top-level navigation stack displays SymbolDetail, and provides a link to navigate back to SymbolGrid.": {
      "zh": "",
      "tips": ""
    },
    "This code defines your app, SymbolGridApp. Any time you define an app in SwiftUI, you must also provide at least one view inside WindowGroup of the app body property. This view is known as the top-level view, because it sits on the top of your view hierarchy. You can think of the view hierarchy as a structure that defines the layout of views relative to other views. The top-level view may contain any number of subviews, each of which may contain their own subviews, and so on.": {
      "zh": "",
      "tips": ""
    },
    "Adding an Editing Mode": {
      "zh": "",
      "tips": ""
    },
    "The argument to SymbolPicker ($selectedSymbol) is a special type of value, known as a binding. When you pass a binding value into a subview, that subview can modify its value, but only the parent view stores the actual value. Passing selectedSymbol as an argument allows SymbolPicker to modify the value, which modifies the variable selectedSymbolName stored in SymbolGrid.": {
      "zh": "",
      "tips": ""
    },
    "Creating a Symbol": {
      "zh": "",
      "tips": ""
    },
    "To populate the grid, use ForEach to iterate over each uniquely identifiable Symbol in symbols. ForEach usually requires that you provide an ID for each element of the collection so it’s able to track when specific elements in the collection change. However, since Symbol conforms to Identifiable, this requirement has been fulfilled and you no longer need the id parameter. Because you are using the @State variable symbols as the argument to ForEach, the entire grid updates any time the array changes.": {
      "zh": "",
      "tips": ""
    },
    "Building the Navigation Grid": {
      "zh": "",
      "tips": ""
    },
    "Step 1": {
      "zh": "",
      "tips": ""
    },
    "To arrange several views vertically, you can put them inside of a VStack, which is short for vertical stack. In this VStack, there’s a text view layered on top of the image view with the SF Symbol.": {
      "zh": "",
      "tips": ""
    },
    "When the sheet dismisses, addSymbol inserts the value assigned to selectedSymbol to the symbols array. Because symbols is a @State variable, SwiftUI recognizes the change and updates the grid UI with the new symbol.": {
      "zh": "",
      "tips": ""
    },
    "Retrieve and display images from an asset catalog or a photo library.": {
      "zh": "",
      "tips": ""
    },
    "You populate the grid with many Image views, each created from a Symbol instance such as Symbol(name: \"eyes\"). Because the Symbol type conforms to Identifiable, SwiftUI can uniquely identify each cell of your grid, even if several symbols use the same name value. Adding Identifiable conformance to your data model is a great pattern to follow when using ForEach to populate a grid or list with views.": {
      "zh": "",
      "tips": ""
    },
    "By creating an instance of SymbolGrid inside of your navigation stack, you tell the navigation stack to display SymbolGrid when the app first launches. When a person using your app navigates to another view, SymbolGrid moves down in the view hierarchy to show a different view and its content.": {
      "zh": "",
      "tips": ""
    },
    "To provide navigation functionality in your app, you can create a NavigationStack as your top-level view. The NavigationStack acts as a container that can show any other view. The NavigationStack provides a stack style rather than a column style. This means only a single view displays at any given time.": {
      "zh": "",
      "tips": ""
    },
    "Create a grid of SF Symbols from an array of Symbol values.": {
      "zh": "",
      "tips": ""
    },
    "Learn how to create an image view using an SF Symbol.": {
      "zh": "",
      "tips": ""
    },
    "Defining an Identifiable Type": {
      "zh": "",
      "tips": ""
    },
    "Step 2": {
      "zh": "",
      "tips": ""
    },
    "Now that you have a grid, it’s time to add editing functionality. The first thing to notice here are two @State variables, isAddingSymbol and isEditing. These are Boolean values that, when true, change some of UI of the app to enable you to edit or add photos to the grid.": {
      "zh": "",
      "tips": ""
    },
    "Step 5": {
      "zh": "",
      "tips": ""
    },
    "Your Symbol type contains an id property — a requirement of the Identifiable protocol. To ensure that each item is uniquely identifiable, set the id property to a UUID value.": {
      "zh": "",
      "tips": ""
    },
    "At the bottom of the view, you’ll see two modifiers: navigationTitle, which sets the title of the navigation stack, and navigationBarTitleDisplayMode, which determines how to display the title. In this case, the display mode is inline, meaning the title shows in line with the rest of the toolbar at the top of the view.": {
      "zh": "",
      "tips": ""
    }
  },
  "sample-apps/getstartedwithmachinelearning-createmldataset": {
    "Creating Your Own Machine Learning Dataset": {
      "zh": "创建你自己的机器学习数据集",
      "tips": ""
    },
    "Learn how to create a dataset for your own machine learning model.": {
      "zh": "了解如何为你自己的机器学习模型创建数据集。",
      "tips": ""
    },
    "Collect and organize data for your model": {
      "zh": "收集并整理你的模型需要的数据",
      "tips": ""
    },
    "Tips for creating your own dataset.": {
      "zh": "一些关于创建你自己模型的小提示",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "Computers are great at detecting data patterns when given enough examples. To create a hand pose machine learning (ML) model, you’ll need several images of hands.": {
      "zh": "只要有足够多的例子，计算机就能很好地识别这些数据的形式。要创建手势机器学习 (ML) 模型，你需要多张关于手的图像。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "In Swift Playgrounds, you’ll be able to gather images of hand poses and label them to your game’s moves: Rock ✊, Paper ✋, and Scissors ✌️. These labeled images are the only examples that the machine’s “brain” has ever seen, so make sure they’re representative of what each hand pose looks like.": {
      "zh": "在 Swift Playgrounds 中，你将能够收集手势图像并将它们标记为你的石头剪刀布游戏里面的手势: 石头 ✊，布 ✋和剪刀 ✌️。这些被标记的图像是机器“大脑”见过的唯一例子，所以要确保它们代表了每个手的姿势。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "ML engineers often need to examine their datasets to ensure they always contain the best possible sources to return quality results. This process is called data cleaning, and it’s one of the most important steps in ML since it dramatically affects how your ML model performs.": {
      "zh": "机器学习工程师经常需要检查他们的数据集，确保他们总是包含最好的数据，以保证高质量的结果。这个过程被称为数据清理，它是 ML 中最重要的步骤之一，因为它会极大地影响您的 ML 模型的表现。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实践",
      "tips": ""
    },
    "Clean your dataset to ensure that the image contains a hand pose, that the pose isn’t too close to or far from the camera, that images aren’t mislabeled (like a Rock image accidentally labeled as Scissors), that the dataset doesn’t include any exact duplicate images, and that the dataset contains (roughly) equal amounts of images for each hand gesture.": {
      "zh": "清理你的数据集，确保图像中包含手的姿势，姿势不会离摄像头太近或太远，图像不会被错误标记（如 \"石头 \"图像被意外标记为 \"剪刀 \"），数据集中不包含任何完全重复的图像，并且数据集中每个手势包含的图像数量（大致）相等。",
      "tips": ""
    },
    "Increase the size of your training dataset artificially": {
      "zh": "人为增加训练数据集的大小",
      "tips": ""
    },
    "Automatically add image rotation, translation, and flipping to your training dataset.": {
      "zh": "在训练数据集中自动添加图像旋转、平移和翻转。",
      "tips": ""
    },
    "Adding in these options before a training session creates four new images per option you use. For example, using the .rotate option generates four new images and applies a random rotation angle to the new images.": {
      "zh": "在训练之前添加一些选项，每个选项都会生成四个新图像。例如，使用 .rotate 选项会生成四个新图像，这些新图像会被随机旋转角度。",
      "tips": ""
    },
    "Here, the trainer is augmenting the training data by adding these three options: .rotate, .translate, .horizontallyFlip. When you train a new ML model, the training session automatically uses these augmentations to improve the model’s predictions.": {
      "zh": "在这里，训练器通过添加以下三个选项来增强训练数据：.rotate、.translate 和 .horizontallyFlip。当你训练一个新的 ML 模型时，会自动使用这些增强来改进模型的预测。",
      "tips": ""
    },
    "Collect your own dataset in Swift Playgrounds": {
      "zh": "在 Swift Playgrounds 中收集自己的数据集",
      "tips": ""
    },
    "Now that you’ve learned how to collect datasets for ML models, try it yourself by going to the Swift Playgrounds App to collect images and create a dataset for use with your own personalized ML model!": {
      "zh": "现在，你已经学会了如何收集用于 ML 模型训练的数据集，那么现在你可以亲自尝试一下，到 Swift Playgrounds 应用程序中收集图像并创建一个数据集，并用于创建你自己的个性化 ML 模型！",
      "tips": ""
    },
    "If you don’t plan to use dozens of images to train the model, that’s OK. One way you can increase your training dataset is by using MLImageClassifier.ImageAugmentationOptions.": {
      "zh": "如果你不打算使用几十张图像来训练模型，也没关系。增加训练数据集的一种方法是使用图像增强选项。",
      "tips": ""
    }
  },
  "sample-apps/getstartedwithmachinelearning-debugmlmodel": {
    "Debugging Your Machine Learning Model": {
      "zh": "调试您的机器学习模型",
      "tips": ""
    },
    "Learn how to debug your machine learning model and make improvements in its predictions.": {
      "zh": "学习如何调试你的机器学习模型并改进其预测结果。",
      "tips": ""
    },
    "See what your camera sees by drawing an overlay of nodes": {
      "zh": "通过绘制绘制节点叠加图，洞察你的相机看到了什么",
      "tips": ""
    },
    "Visualize the 2D array of nodes extracted by the Vision framework.": {
      "zh": "将由Vision 框架提取的 2D 节点数组可视化。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "It’s helpful to get more insight into the data that your machine learning (ML) model uses to generate its predictions to understand what your camera “sees”.": {
      "zh": "理解摄像机 \"看到\" 了什么有助于更深入地了解那些机器学习 (ML) 模型用于生成预测而使用的数据",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "To create this visualization, you’ll take the MLMultiArray that Vision extracts from an image frame and transform it into coordinates overlayed on top of your camera’s viewfinder.": {
      "zh": "为了实现这些可视化，你需要使用 Vision 从图片中提取出来的 MLMultiArray，并将其坐标系转换为你的相机取景器界面的坐标系。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "This overlay in your ViewFinderView code to shows the node visualization when showNodes is true.": {
      "zh": "这个在你 ViewFinderView 代码中的 overlay 会在 showNodes 为 true 的时候显示节点可视化。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实践",
      "tips": ""
    },
    "Cover part of your hand with something close by — like a piece of paper, a book, or a piece of cloth — and place your partially-covered hand in front of the camera. What happens with the accuracy of the prediction for that hand pose?.": {
      "zh": "用附近的东西盖住你的手的一部分——比如一张纸、一本书或一块布——然后把你那部分被盖住的手放在相机前，看看手部姿势的预测准确度会怎样?",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "Learn how to handle these low-ranking predictions in the next section!": {
      "zh": "在下一节中了解如何处理这些不太准的预测!",
      "tips": ""
    },
    "Test your ML model": {
      "zh": "测试你的 ML 模型",
      "tips": ""
    },
    "Ensure your machine learning model is identifying the different hand poses by testing it.": {
      "zh": "通过测试确保机器学习模型能够识别不同的手部姿势。",
      "tips": ""
    },
    "You can use DebugModeView to evaluate and debug your ML model.": {
      "zh": "你可以使用 DebugModeView 来评估和调试你的 ML 模型。",
      "tips": ""
    },
    "Show a hand pose to the camera and then slowly transition to a different hand pose. How does the bar chart change?": {
      "zh": "向镜头展示你的手势，然后慢慢转换到一个不同的手势，观察条形图有什么变化？",
      "tips": ""
    },
    "As you debug the model, you’ll discover that some camera conditions — like lighting, angle, and focus — also influence your model’s predictions.": {
      "zh": "在调试模型的过程中，你会发现一些相机条件（如光线、角度和焦距）也会影响模型的预测结果。",
      "tips": ""
    },
    "Your model also might work well for you, but not as well for a friend. This can also be the result of overfitting. For instance, your ML model could better recognize one skin tone over another, causing some hand poses to be more accurately predicted than some in other skin tones. This is known as bias, because it favors one type of information over another.": {
      "zh": "你的模型也可能对你非常有效，但对你的朋友可能就不一样了。这可能是过度拟合的结果。例如，您的 ML 模型可以更好地识别一种肤色而不是另一种肤色，从而导致对某些肤色的手势预测比对其他肤色的预测更准确。这就是所谓的偏见或偏差，因为它偏向于一种信息而不是另一种信息。",
      "tips": ""
    },
    "Your model only affects this app, but what if you were implementing this app on every iPhone around the world? Unfair bias due to overfitting is a serious problem in systems meant for use by everyone. It’s important to think about how to avoid bias when creating your own datasets and training your ML model.": {
      "zh": "你如果以为你的模型只会影响到这个应用那就大错特错了。如果全世界所有 iPhone 上都使用这个应用程序呢？在给所有人使用的系统中，过度拟合造成的不公平偏差和偏见是一个严重的问题。在创建自己的数据集和训练 ML 模型时，你需要考虑如何避免这些偏差和偏见，这一点是无比重要的。",
      "tips": ""
    },
    "Tip": {
      "zh": "提示",
      "tips": ""
    },
    "Remember that ML model development is an iterative process. Create multiple datasets and train more ML models! Only you can decide when your model is good enough for use in your app.": {
      "zh": "请记住，ML 模型开发是一个不停迭代的过程。所以多创建几个数据集，训练更多的 ML 模型！只有你才能决定你的模型究竟需要好到什么程度才能在你的 App 中使用。。",
      "tips": ""
    },
    "Creating Your Own Machine Learning Dataset": {
      "zh": "创建你自己的机器学习数据集",
      "tips": ""
    },
    "Learn how to create a dataset for your own machine learning model.": {
      "zh": "了解如何为你自己的机器学习模型创建数据集。",
      "tips": ""
    },
    "To do this, you’ll visualize the 2D array of nodes generated by the Vision when it interprets image data. The nodes you visualize map to the joints in your fingers and thumb.": {
      "zh": "为了做到这点，你需要可视化由 Vision 框架在解释图片数据的时候生成的 2D 节点阵列。这些你可视化的节点将显示和映射到你手指和拇指的关节上。",
      "tips": ""
    },
    "In this view, you’ll have a camera view and a bar Swift Charts that visualizes in real time how confident your ML model is in its prediction. Remember, an ML model’s prediction accuracy depends on the training data you give it.": {
      "zh": "在这个视图中，你将有一个摄像头视图和一个来自 Swift Charts 的条形图，实时可视化你的机器学习模型在预测中的自信或准确程度。但是你需要记住，机器学习模型的预测精度取决于你给它的训练数据。",
      "tips": ""
    }
  },
  "sample-apps/getstartedwithmachinelearning-recognizegestures": {
    "Recognizing Gestures with Machine Learning": {
      "zh": "通过机器学习识别手势",
      "tips": ""
    },
    "Explore how to transform hand pose images from the camera into readable data your machine learning model can use to predict gestures.": {
      "zh": "探究如何将相机拍摄的手势图像转换为你的机器学习模型可读的数据，并用其预测手势。",
      "tips": ""
    },
    "Explore the fundamentals of machine learning": {
      "zh": "探索机器学习的基本原理",
      "tips": ""
    },
    "Learn the basics of how machine learning uses data to create a classifier model.": {
      "zh": "学习一些如何使用数据创建分类模型的基础机器学习知识。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "Machine learning (ML) is the process of how you can “teach” computers, like your iPad or Mac, to make educated guesses by providing them with lots of examples, commonly referred to as data.": {
      "zh": "机器学习（ML）是你如何\"教\"你的电脑（例如 iPad 或者 Mac）通过提供大量的案例（通常被称作为数据）来作出有依据的猜测的过程。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "Humans are able to see very few examples of hand poses and immediately tell the difference between a rock pose and scissors pose. However, a computer requires many examples of those hand poses to correctly identify them.": {
      "zh": "人类具有一种与生俱来的能力，可以只看几个手势照片的例子就立马分辨出石头手势和剪刀手手势的区别。但是，一台电脑需要非常多的例子才能正确的分辨它们。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "This is because a computer requires lots of data to accurately identify and distinguish meaningful features of hand poses, something that the human brain can do rather effortlessly.": {
      "zh": "这是因为电脑需要非常多的数据才能正确的识别和分辨手势的有意义的特征，而人类则在这方面非常擅长，毫不费力。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "This app uses image classification to recognize different hand poses shown in the camera. Classification is a type of ML algorithm that categorizes examples from a dataset into different groups. You’ll use the MLHandPoseClassifier to classify different hand poses from a stream of images from the camera.": {
      "zh": "这个应用使用了图片分类来识别相机内展示不同的手势图片。分类是一种 ML 算法，这个算法可以将一组数据中的案例分类到不同的组别。你将会使用 MLHandPoseClassifier 来分辨来自相机图像流的不同手势。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "To create an ML model, you need to provide a large amount of data — in this case, images — to the classifier. This process is known as training your ML model, because you’re teaching it how to recognize different things.": {
      "zh": "为了创建一个 ML 模型，你需要提供大量的数据，在这个案例中，你需要给分类器提供大量的图片。这个过程被称之为训练 ML 模型。这个名字的由来是因为你在教你的模型如何识别不同的东西。",
      "tips": ""
    },
    "Learn about ML models": {
      "zh": "了解 ML 模型",
      "tips": ""
    },
    "Learn how a model takes in camera data to generate a prediction.": {
      "zh": "了解模型如何通过相机中的数据进行预测。",
      "tips": ""
    },
    "You can think of an ML model as a machine’s brain and all the knowledge it knows about a certain type of pattern – in this case, hand poses.": {
      "zh": "你可以将一个 ML 模型看作机器的大脑，和它知道关于模型特定模式（在这个例子，是手势）的所有知识。",
      "tips": ""
    },
    "An ML model receives information as input to produce an educated guess of what that information represents. This is known as a prediction.": {
      "zh": "一个 ML 模型接受信息作为输入，然后对信息所表示的内容做出一个有依据的猜测。这个过程被称作为预测。",
      "tips": ""
    },
    "The camera in your app is the machine’s eyes. You can use image data from the camera as input for the HandPoseMLModel. Your ML model uses this data to identify the different types of hand poses.": {
      "zh": "你的应用中的相机是机器的眼睛。你可以将相机中的图片数据作为 HandPoseMLModel 的输入。你的 ML 模型通过这个数据来分辨不同的手势类别。",
      "tips": ""
    },
    "If the model successfully receives an input, you’ll receive an output of a label and the confidence, or probability, of that image.": {
      "zh": "如果模型成功收到了一个输入，你就会获得一个输出。这个输出包含图片的标签（也就是类别）和置信度。",
      "tips": ""
    },
    "Providing readable data to your ML model": {
      "zh": "给你的 ML 模型提供一个可读的数据",
      "tips": ""
    },
    "Use the Vision framework to pass image data into your ML model.": {
      "zh": "使用 Vision 框架将图片数据传递给你的 ML 模型。",
      "tips": ""
    },
    "The Vision Framework makes it easy for your app to convert the camera’s image data into something the ML model can understand.": {
      "zh": "Vision 框架使让转换相机图片数据到 ML 模型可以理解的形式这一过程变得更加简单。",
      "tips": ""
    },
    "Every time your camera’s frame updates, your app gathers VNHumanHandPoseObservations from the frame’s pixel buffer.": {
      "zh": "每次相机帧更新时，应用程序都会从帧的像素缓冲区收集 VNHumanHandPoseObservations。",
      "tips": ""
    },
    "Vision then extracts an MLMultiArray from these observations. An MLMultiArray instance provides location coordinates that (in this case) map to the finger joints, giving your ML model a rich set of hand-position data that it uses to train itself.": {
      "zh": "",
      "tips": ""
    },
    "Debugging Your Machine Learning Model": {
      "zh": "调试机器学习模型",
      "tips": ""
    },
    "Learn how to debug your machine learning model and make improvements in its predictions.": {
      "zh": "学习如何调试机器学习模型并改进其预测。",
      "tips": ""
    },
    "To add ML to your app, you’ll use the Create ML and Core ML frameworks.": {
      "zh": "如果要将 ML 功能加入你的应用，你需要使用到 Create ML 和 Core ML 框架。",
      "tips": ""
    }
  },
  "sample-apps/imagegallery": {
    "Image Gallery": {
      "zh": "图库",
      "tips": ""
    },
    "Retrieve and display images from an asset catalog or a photo library.": {
      "zh": "从资源目录或照片库中检索和显示图片。",
      "tips": ""
    },
    "Welcome to the Image Gallery app. This walkthrough shows how to create a grid of images, complete with photo-picking and -editing functionality.": {
      "zh": "欢迎使用图片库应用。本演示展示了如何创建一个图片网格，同时创建选择照片和编辑图片的功能。",
      "tips": ""
    },
    "This sample is an extension of two simpler implementations: Organizing with Grids and Editing Grids. This walkthrough focuses on solving some common issues after your grid displays images, instead of shapes or SF Symbols.": {
      "zh": "这个示例是两个更简单的实现的扩展：组织网格和编辑网格。本演示着重解决网格显示图片后的一些常见问题，而不是显示形状或 SF Symbols。",
      "tips": ""
    },
    "Larger images can load slowly, which can cause noticeable delays when loading your app’s UI. This sample focuses on unblocking delays by showing progress indicators until each image loads and keeping your app responsive during the loading process.": {
      "zh": "较大的图片加载可能会较慢，这可能会在加载应用程序的用户界面时造成明显的延迟。这个示例着重于在每个图片加载完成前显示加载指示器，以及在加载过程中保持应用程序可响应，来避免阻塞延迟。",
      "tips": ""
    },
    "Sharing App Data": {
      "zh": "共享应用数据",
      "tips": ""
    },
    "Learn how the app passes photo data from DataModel to its view hierarchy.": {
      "zh": "了解应用程序如何从数据模型（DataModel）向其视图层次结构传递照片数据。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "Image Gallery loads a gallery of images when you first launch the app. Because the images are so large, and you don’t want the app to lag when loading them all at the same time, you’ll use asynchronous requests to keep the app responsive even when data retrieval is slow.": {
      "zh": "图片库在你首次启动应用程序时会加载一组图片。由于图片非常大，你不希望应用程序在同时加载所有图片时出现延迟，所以你将使用异步请求来保持应用程序即使在数据检索缓慢时也能保持响应。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "To create dataModel as a state object, apply the @StateObject property wrapper and provide an initial value that conforms to the ObservableObject protocol. SwiftUI manages storage for a state object, and updates all of the child views that use the value when the published values change.": {
      "zh": "要将数据模型（dataModel）创建为状态对象，应用 @StateObject 属性包装器并提供符合 ObservableObject 协议的初始值。SwiftUI 会管理状态对象的存储，并在发布的值更改时更新所有使用该值的子视图。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "NavigationStack passes in the DataModel instance using the .environmentObject modifier, making the observable object available to all of the NavigationStack’s child views. As a result, those views can access the data from dataModel to perform various tasks, such as loading image views asynchronously or updating the grid view when the data changes.": {
      "zh": "NavigationStack 使用 .environmentObject 修饰符传递数据模型（DataModel）实例，使可观察对象（ObservableObject）对 NavigationStack 的所有子视图可用。因此，这些视图可以访问数据模型（dataModel）中的数据来执行各种任务，例如异步加载图像视图或在数据更改时更新网格视图。",
      "tips": ""
    },
    "Modeling an Item": {
      "zh": "建模项目",
      "tips": ""
    },
    "Explore how the Item type models a grid item’s data and adds Identifiable conformance.": {
      "zh": "了解如何使用项目类型（Item）对网格项的数据进行建模并添加 Identifiable 符合性。",
      "tips": ""
    },
    "When you use ForEach to construct a collection view, such as a list or grid, SwiftUI wants to uniquely identify each view so it can find and update them. To make this easier, you can create a model that conforms to Identifiable, which creates an id property requirement.": {
      "zh": "当你使用 ForEach 构造集合视图（如列表或网格）时，SwiftUI 想要唯一标识每个视图，以便它可以找到并更新它们。为了简化这一过程，你可以创建符合 Identifiable 的模型，这一协议要求 id 属性。",
      "tips": ""
    },
    "Your Item contains an id property that SwiftUI uses to uniquely identify the view.": {
      "zh": "你的项目类型（Item）包含 SwiftUI 用来标识视图唯一性的 id 属性。",
      "tips": ""
    },
    "Item also has a url property that the app uses to identify the location of the corresponding image using a path to the file. AsyncImage uses this URL in GridItemView to asynchronously load the image.": {
      "zh": "项目类型（Item）还具有 url 属性，应用程序使用该属性，通过文件路径来标识相应图像的位置。AsyncImage 在 GridItemView 中使用该 URL 来异步加载图像。",
      "tips": ""
    },
    "Data Model: Gathering Image URLs": {
      "zh": "数据模型：收集图像 URL",
      "tips": ""
    },
    "Learn how your app uses a data model to load and store all photo data.": {
      "zh": "了解你的应用程序如何使用数据模型加载和存储所有照片数据。",
      "tips": ""
    },
    "DataModel is an observable object that gathers file URLs from images in your document directory as well as from your bundle resources. It uses these URLs to populate an array of Item instances which display as the content of your grid.": {
      "zh": "数据模型（DataModel）是一个可观察对象（ObservableObject），它从文档目录中的图像以及包资源中收集文件 URL。它使用这些 URL 来填充项目类型（Item）实例数组，这些数组将显示为网格的内容。",
      "tips": ""
    },
    "DataModel publishes an array of item values, each of which correlates to an image in the grid. Because the code marks this value as @Published, any time you add or delete an Item from this array, SwiftUI updates the grid view (and any other views that use this value) to reflect those changes.": {
      "zh": "数据模型（DataModel）发布数组，数组中的每个 item 值与网格中的一个图像相关联。由于代码将此值标记为 @Published，所以每当你从该数组中添加或删除项目类型（Item）时，SwiftUI 都会更新网格视图（以及使用此值的任何其他视图）以反映这些更改。",
      "tips": ""
    },
    "When you initialize DataModel, it searches the document directory for any images you’ve added, gathering their corresponding URLs and appending them to the items array. Your app stores data locally in this directory, so searching here allows you to display any images you added while using the app.": {
      "zh": "初始化数据模型（DataModel）时，它会搜索文档目录以查找你添加的任何图像，收集图像对应的 URL 并将其追加到 items 数组中。你的应用程序会在此目录中本地存储数据，因此在此处搜索将允许你显示使用应用程序时添加的任何图像。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "Similarly, you’ll load all image URLs from the bundle resources directory and add them to items. Bundle resources is the directory of images that are included with the project, as opposed to images that you added yourself.": {
      "zh": "同样地，你将从包资源目录加载所有图像 URL 并将其添加到 items 数组中。包资源是随项目一起配送的图像目录，与你自己添加的图像相对。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "DataModel provides methods for adding and removing items from items. addItem adds a new item at the first index of the array so you can see when new images appear in the view.": {
      "zh": "数据模型（DataModel）为从 items 数组中添加和移除项提供方法。addItem 在数组的第一个索引处添加新项，以便你可以看到视图中出现新的图像。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "removeItem removes an item by finding its index and removing it from the items array. The method also removes the item’s corresponding image file from the document directory, if it exists there. This ensures that the image won’t reload from local app storage the next time you launch the app.": {
      "zh": "removeItem 通过查找索引并从 items 数组中移除它来移除一个项。如果文档目录中存在对应的图像文件，该方法也会将其移除。这确保在下次启动应用程序时图像不会从本地应用程序存储重新加载。",
      "tips": ""
    },
    "Creating a Grid Item": {
      "zh": "创建网格项",
      "tips": ""
    },
    "Find out how to load an image asynchronously from a URL using AsyncImage.": {
      "zh": "了解如何使用 AsyncImage 从 URL 异步加载图像。",
      "tips": ""
    },
    "GridItemView represents a single item of your grid, an image view that displays the photo defined by an Item instance.": {
      "zh": "GridItemView 表示网格的单个项，一个显示由项目类型（Item）实例定义的照片的图像视图。",
      "tips": ""
    },
    "A GridItemView contains properties for item and size. The item property provides the URL to asynchronously load the image, while the size property provides the value for the height and width of the image and its placeholder.": {
      "zh": "GridItemView 包含 item 和 size 属性。item 属性提供异步加载图像的 URL，而 size 属性提供图像及其占位符的高度和宽度的值。",
      "tips": ""
    },
    "In the body of your GridItemView, you’ll create your image view. Since you’ll have a conditional editing UI overlaid on top of your image, wrap the image in a ZStack.": {
      "zh": "在 GridItemView 的主体中，你将创建图像视图。由于你将在图像上面叠加条件编辑 UI，因此请将图像包装在 ZStack 中。",
      "tips": ""
    },
    "You can initialize an AsyncImage with the item.url value to load the image asynchronously. Because you have many images to load when the app first launches, you can load them asynchronously to allow the app to keep running the rest of its code while it waits for the images to return. This prevents any noticable lag in your UI.": {
      "zh": "你可以使用 item.url 值初始化 AsyncImage 以异步加载图像。由于在应用程序首次启动时有许多图像要加载，因此你可以异步加载它们，以允许应用程序在等待图像返回时继续运行其余代码。这可避免 UI 中出现任何明显的延迟或卡顿。",
      "tips": ""
    },
    "AsyncImage contains a content closure that provides an instance of a SwiftUI Image. You’ll use this instance to create your image view. You’ll add the .resizable and .scaledToFill modifiers to scale the image to fill the available space of the view.": {
      "zh": "AsyncImage 包含一个内容闭包，它提供了一个 SwiftUI Image 的实例。你将使用此实例来创建图像视图。你将添加 .resizable 和 .scaledToFill 修饰符来缩放图像以填充视图的可用空间。",
      "tips": ""
    },
    "AsyncImage uses a placeholder to show some content while the image loads. This placeholder uses a SwiftUI ProgressView which displays as a spinning circle.": {
      "zh": "AsyncImage 使用占位符在加载图像时显示一些内容。此占位符使用 SwiftUI 的 ProgressView：旋转着的圆圈。",
      "tips": ""
    },
    "Creating Your Gallery": {
      "zh": "创建相册",
      "tips": ""
    },
    "Learn how to put together a grid view using a series of SwiftUI built-in and composed views.": {
      "zh": "了解如何使用一系列 SwiftUI 内置和组合视图组合网格视图。",
      "tips": ""
    },
    "GridView is where you’ll create your image gallery. If you need to review the basics of creating a grid, check out Color Grid. In this walkthrough, you’ll learn how to implement the grid using a model type, Item, and an observable object, dataModel.": {
      "zh": "GridView 是你创建图片库的地方。如果你需要复习创建网格的基础知识，请查看色块网格（Color Grid）。在本演示中，你将学习如何使用模型类型 Item 和可观察对象 dataModel 来实现网格。",
      "tips": ""
    },
    "To access the app’s dataModel, you define an @EnvironmentObject of type DataModel, which gives you access to the environment object passed into the top-level view of the view hierarchy in ImageGalleryApp.swift.": {
      "zh": "要访问应用程序的 dataModel，你定义一个类型为 DataModel 的 @EnvironmentObject，这使你可以访问位于 ImageGalleryApp.swift 顶层视图的环境对象。",
      "tips": ""
    },
    "The data for populating the grid comes from an array of Item instances (found in dataModel.items), each of which references a single image URL.": {
      "zh": "用于填充网格的数据来自 Item 实例数组（位于 dataModel.items 中），每个实例都引用单个图像 URL。",
      "tips": ""
    },
    "To create the grid, you’ll nest a LazyVGrid inside of a ScrollView, which allows the content of the grid to scroll vertically, if necessary.": {
      "zh": "要创建网格，你将在 ScrollView 内嵌套一个 LazyVGrid，这允许网格的内容在需要时垂直滚动。",
      "tips": ""
    },
    "Your ForEach loop iterates through dataModel.items, and creates a GridItemView based upon each item value in the array. Because each item instance is Identifiable, you don’t need an id parameter when creating your grid views. Instead, SwiftUI uses the id property of each item to uniquely identify it.": {
      "zh": "你的 ForEach 循环遍历 dataModel.items，并根据数组中的每个 item 值创建一个 GridItemView。因为每个 item 实例都是可识别（Identifiable）的，所以在创建网格视图时不需要 id 参数。相反，SwiftUI 使用每个 item 的 id 属性作为唯一标识。",
      "tips": ""
    },
    "To provide relative size information of a parent view to its child views, you can use a GeometryReader. This gives you information on the width and height of the parent view depending on how much screen size is available. You can access this information using the closure value and use it to set the size of a size of a child view.": {
      "zh": "要向子视图提供父视图的相对大小信息，可以使用 GeometryReader。这将为你提供父视图的宽度和高度信息，具体取决于可用的屏幕大小。你可以使用闭包值访问此信息，并使用它来设置子视图的大小。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第七步",
      "tips": ""
    },
    "To simplify the code in GridView, generate each view of the grid using a GridItemView, which handles all of the asynchronous image loading as well as transitions between editing states.": {
      "zh": "为了简化 GridView 中的代码，使用 GridItemView 生成网格的每个视图，它同时也将处理所有的异步图像加载以及状态编辑之间的转场。",
      "tips": ""
    },
    "Step 8": {
      "zh": "第八步",
      "tips": ""
    },
    "To initialize GridItemView, you pass in the current item from the ForEach loop as well as the width of the parent view provided from GeometryReader. GridItem uses geo.size.width as the value for its height and width, which creates a square-shaped grid item.": {
      "zh": "要初始化 GridItemView，你需传入 ForEach 循环中的当前项以及从 GeometryReader 提供的父视图的宽度。GridItem 将 geo.size.width 作为其高度和宽度的值，这将创建一个正方形的网格项。",
      "tips": ""
    },
    "Adding an Image to the Gallery": {
      "zh": "向相册添加图片",
      "tips": ""
    },
    "Explore how to add and edit photos in the gallery.": {
      "zh": "探索如何在相册中添加和编辑照片。",
      "tips": ""
    },
    "To add a new photo to the grid, you’ll use the state value isAddingPhoto. You’ll toggle this value to true whenever you press the Add button (+) in the toolbar.": {
      "zh": "要向网格添加新照片，你将使用状态值 isAddingPhoto。每当你在工具栏中按 Add 按钮（+）时，都会切换此值为 true。",
      "tips": ""
    },
    "To edit your photo grid, you’ll use the state value isEditing. You’ll add a Remove button (X) on top of each image when the value toggles to true.": {
      "zh": "要编辑照片网格，你将使用状态值 isEditing。当该值切换为 true 时，你会在每个图像上方添加 Remove 按钮（X）。",
      "tips": ""
    },
    "The .toolbar modifier contains two toolbar items: one to edit photos in the grid and one to add a new photo. These buttons toggle the state values isEditing and isAddingPhoto, respectively.": {
      "zh": ".toolbar 修饰符包含两个工具栏项：一个用于编辑网格中的照片，一个用于添加新照片。这些按钮分别切换状态值 isEditing 和 isAddingPhoto。",
      "tips": ""
    },
    "When isEditing is true, you’ll show a Remove button (X) on top of the images.": {
      "zh": "当 isEditing 为 true 时，你会在图片上方显示 Remove 按钮（X）。",
      "tips": ""
    },
    "When a person taps the Remove button (X), the code removes the current item from dataModel.items. Because dataModel.items is a published value, this change causes SwiftUI to update the grid view’s appearance and remove the item.": {
      "zh": "当用户点击 Remove 按钮（X）时，代码会从 dataModel.items 中删除当前项。因为 dataModel.items 是一个已发布的值，所以这个更改会导致 SwiftUI 更新网格视图的外观并删除该项。",
      "tips": ""
    },
    "When isAddingPhoto is true, a sheet displays the PhotoPicker modally. In PhotoPicker, selecting a new photo adds the corresponding item to DataModel.items. This causes SwiftUI to update the grid view and add the corresponding image.": {
      "zh": "当 isAddingPhoto 为 true 时，sheet 会以模式方式显示 PhotoPicker。在 PhotoPicker 中，选择新照片会将对应的项添加到 DataModel.items 中。这会导致 SwiftUI 更新网格视图并添加对应的图像。",
      "tips": ""
    },
    "Laying Out Views": {
      "zh": "布局视图",
      "tips": ""
    },
    "Organize, size and align view layouts.": {
      "zh": "组织、调整大小并对齐视图布局。",
      "tips": ""
    }
  },
  "sample-apps/layingoutviews": {
    "Laying Out Views": {
      "zh": "布局视图",
      "tips": ""
    },
    "Organize, size and align view layouts.": {
      "zh": "组织、调整大小和对齐视图布局。",
      "tips": ""
    },
    "When creating an app, one of the first skills to learn is how to lay out your user interface, or UI. When laying out a UI, there are three major things you need to do:": {
      "zh": "当创建一个应用程序时，需要学习的第一个技能就是如何布局用户界面，也就是 UI。当布局一个 UI 时，有三件主要的事情：",
      "tips": ""
    },
    "Organize your views in different configurations using container views.": {
      "zh": "使用不同配置的容器视图来组织你的视图。",
      "tips": ""
    },
    "Fine tune the sizing, spacing, alignment, and positioning of your views.": {
      "zh": "精细调整视图的大小、间距、对齐和定位。",
      "tips": ""
    },
    "Debug your views when something goes wrong.": {
      "zh": "在出现问题时调试视图。",
      "tips": ""
    },
    "In this sample, you’ll learn all of these skills and more. Ready to start your journey into view layout?": {
      "zh": "在这个示例中，你将学习以上所有技能以及更多拓展。准备开始你的视图布局之旅了吗?",
      "tips": ""
    },
    "Organize your views": {
      "zh": "组织视图",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "A view can act as a container that holds and organizes other views, known as subviews. The VStack that holds all of your code is an example of a container view that organizes the two shape subviews vertically.": {
      "zh": "一个视图可以充当容器以容纳和组织其他视图，其被称为子视图。包含你所有代码的 VStack 就是一个垂直组织两个子视图的容器视图的例子。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "Shape views expand to fill the entire space that’s offered by the container view. Because there are two shape views that need to share the space in the VStack equally, their sizes adapt accordingly.": {
      "zh": "形状视图会扩展以填充容器视图提供的所有空间。因为 VStack 中有两个形状视图需要平分空间，它们的大小会相互适应。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "You can also organize your views on top of each other using a ZStack. To stack a circle view on top of a rectangle, the views need to be put into a ZStack.": {
      "zh": "你也可以使用 ZStack 将视图组织在一起。要在矩形视图上面堆叠一个圆形视图，这些视图需要放入一个 ZStack 中。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "If you want to organize a pair of circles horizontally, you can use an HStack.": {
      "zh": "如果你想要水平放置一对圆形，可以使用 HStack。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "You may have noticed that you have stacks that contain other stacks. SwiftUI organizes and tracks the relationships of views using a view hierarchy.": {
      "zh": "你可能已经注意到你有包含其他堆栈的堆栈。SwiftUI 使用视图层次结构来组织和跟踪视图之间的关系。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "There are more containers than just HStack, VStack, and ZStack views. To explore different containers and how to use them to lay out your content, see Picking container views for your content": {
      "zh": "除了 HStack、VStack 和 ZStack 视图，还有更多的容器。要探索不同的容器以及如何使用它们来布局你的内容，请参阅 为你的内容选择容器视图（Picking container views for your content）。",
      "tips": ""
    },
    "Modify and determine view sizes": {
      "zh": "修改和确定视图大小",
      "tips": ""
    },
    "A SwiftUI View determines its size based on the space offered by its container view. That’s why this rectangle is taking up the entire view – because that’s what the parent VStack is doing.": {
      "zh": "一个 SwiftUI 视图根据其容器视图提供的空间来确定其大小。这就是为什么这个矩形占据了整个视图 - 因为这就是父 VStack 正在做的。",
      "tips": ""
    },
    "Tip": {
      "zh": "提示",
      "tips": ""
    },
    "Different views have different space requirements; not all views take up the same amount of space.": {
      "zh": "不同的视图有不同的空间要求；并非所有视图都占用相同的空间量。",
      "tips": ""
    },
    "Note": {
      "zh": "注意",
      "tips": ""
    },
    "Often times you need to add size constraints to images since they can be extremely large.": {
      "zh": "通常需要为图像添加大小约束，因为图像可能非常大。",
      "tips": ""
    },
    "Because all views are unique, different types of views have their own space requirements within a container. This is why the Rectangle view adjusts how much space it takes up, but the Text and Image only take up as much space as they need.": {
      "zh": "因为所有视图都是独特的，所以不同类型的视图在容器中的空间需求也不同。这就是为什么 Rectangle 视图占用其所拥有的空间大小，而 Text 和 Image 只占用它们所需的空间。",
      "tips": ""
    },
    "A view can also maintain a specific size that doesn’t change, like Stepper.": {
      "zh": "一个视图也可以保持特定的大小不变，比如 Stepper。",
      "tips": ""
    },
    "To adjust the amount of space views need, you can specify which view needs to take up more space. The frame(width:height:alignment:) allows you to adjust the size of a view. The frame modifier is setting a specific height and width for the rose image view.": {
      "zh": "要调整视图所需的空间量，可以指定哪个视图需要占用更多空间。frame(width:height:alignment:) 允许调整视图的大小。frame 修饰符正在为 rose 图像视图设置特定的高度和宽度。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第七步",
      "tips": ""
    },
    "Providing fixed values for the width and height limits how adaptive the view can be. 🙃": {
      "zh": "为宽度和高度提供固定值会限制视图的自适应能力。🙃",
      "tips": ""
    },
    "A better way to do this is to give a maximum, minimum, or ideal width and height for a view. This allows the view to resize as necessary based on how much space is available in the container.": {
      "zh": "更好的方法是为视图的宽度和高度提供最大值、最小值或理想值。这允许视图根据容器中可用的空间进行必要的调整大小。",
      "tips": ""
    },
    "Step 8": {
      "zh": "第八步",
      "tips": ""
    },
    "When you use the frame modifer on an Image it only affects the size of the displayed image if you first use the .resizable modifier to indicate that you want the image to be resized as its frame changes.": {
      "zh": "当你对 Image 使用 frame 修饰符时，如果你先使用 .resizable 修饰符来指明你希望图像随着其 frame 的改变而调整大小，它只会影响显示图像的大小。",
      "tips": ""
    },
    "Warning": {
      "zh": "警告",
      "tips": ""
    },
    "Adding resizable after frame causes a compiler error. Applying the frame modifier to the Image actually creates a new view that’s no longer an Image, so it doesn’t have access to the resizable modifier.": {
      "zh": "在 frame 之后添加 resizable 会导致编译错误。应用 frame 修饰符实际上会创建一个不再是 Image 的新视图，所以它无法访问 resizable 修饰符。",
      "tips": ""
    },
    "Step 9": {
      "zh": "第九步",
      "tips": ""
    },
    "Using both can help get a precise size for an image that is not distorted or too large.": {
      "zh": "同时使用两者可以帮助获得具有精确大小的图像，不会变形或过大。",
      "tips": ""
    },
    "Step 10": {
      "zh": "第十步",
      "tips": ""
    },
    "If you want to make the text bigger or different than the default, you can add the font(_:) modifier to your Text view.": {
      "zh": "如果你想让文本变大或与默认不同，可以给 Text 视图添加 font(:) 修饰符。",
      "tips": ""
    },
    "If you add the frame to the Text view, the actual text inside the view doesn’t change — it makes the view holding the text larger. This allows for more text to fit into the view.": {
      "zh": "如果你给 Text 视图添加 frame，实际文本内容不会改变 - 它使文本视图变大。这允许更多文本适应视图。",
      "tips": ""
    },
    "Refine the spacing and alignment of your views": {
      "zh": "调整视图的间距和对齐",
      "tips": ""
    },
    "There are multiple ways to specify alignment in SwiftUI. One way is to specify the alignment inside HStack, VStack, or ZStack. The default alignment for a VStack is centered.": {
      "zh": "在 SwiftUI 中有多种方式来指定对齐。一种方式是在 HStack、VStack 或 ZStack 中指定对齐。VStack 的默认对齐是居中。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实验",
      "tips": ""
    },
    "Try adding in the alignment: .leading parameter to your VStack and see what happens.": {
      "zh": "尝试在你的 VStack 中添加 alignment: .leading 参数,看看会发生什么。",
      "tips": ""
    },
    "Adding the alignment: .leading parameter to your VStack aligns the books to the left edge of the screen. This is because the VStack is the container view and the images and shapes are subviews.": {
      "zh": "在 VStack 中添加 alignment: .leading 参数会使书对齐到屏幕左侧。这是因为 VStack 是容器视图，图像和形状是子视图。",
      "tips": ""
    },
    "A different way to add a row of books aligned to the right edge of the shelf is by adding a VStack and setting its alignment to .trailing.": {
      "zh": "将书对齐到书架右侧的另一种方法是添加 VStack 并将其对齐设置为 .trailing。",
      "tips": ""
    },
    "In vertical stacks, you can only set the horizontal alignment, like .leading or .trailing.": {
      "zh": "在垂直堆栈中，你只能设置水平对齐，如 .leading 或 .trailing。",
      "tips": ""
    },
    "In horizontal stacks you can only set the vertical alignment, like .top or .bottom.": {
      "zh": "在水平堆栈中你只能设置垂直对齐，如 .top 或 .bottom。",
      "tips": ""
    },
    "Another way to align books to the other side of the shelf is to use a frame modifier and specify the alignment.": {
      "zh": "将书对齐到书架另一侧的另一种方法是使用 frame 修饰符并指定对齐方式。",
      "tips": ""
    },
    "By setting the maxWidth to .infinity, you stretch the Image view horizontally until it fills the remaining space. Setting alignment parameter to .trailing makes the frame contents align to the .trailing edge.": {
      "zh": "通过将 maxWidth 设置为 .infinity，你可以水平拉伸 Image 视图直到填满剩余空间。将 alignment 参数设置为 .trailing 会使 frame 内容对齐到 .trailing 边缘。",
      "tips": ""
    },
    "But wait, there’s more! You can also create space in a view with a Spacer.": {
      "zh": "但是等等！你还可以使用 Spacer 在视图中创建空间。",
      "tips": ""
    },
    "Add a yellow background color to the image next to the Spacer to visualize how much space it’s creating.": {
      "zh": "在 Spacer 旁边的图像添加一个黄色背景色，以可视化它创建了多少空间。",
      "tips": ""
    },
    "Adding a Spacer inside an HStack causes the stack to expand to fill in any remaining horizontal space, and pushes the Image view to the .trailing edge.": {
      "zh": "在 HStack 中添加 Spacer 会导致堆栈扩展以填充任何剩余的水平空间，并将 Image 视图推到 .trailing 边缘。",
      "tips": ""
    },
    "The Spacer only fills in the empty space in the HStack. On the contrary, if there is no space available for the spacer, it won’t render.": {
      "zh": "Spacer 只填充 HStack 中的空白空间。相反，如果没有可用的空间供 spacer 使用，它就不会渲染。",
      "tips": ""
    },
    "You just learned about three different ways to align your views. Using the alignment parameter in the container view, adding a frame modifier with the alignment parameter and utilizing a Spacer are all great ways to align your views.": {
      "zh": "你刚才学习了三种不同的方法来对齐你的视图。使用容器视图中的对齐参数、添加具有对齐参数的 frame 修饰符和利用 Spacer 都是用来对齐你的视图的好方法。",
      "tips": ""
    },
    "Different types of views and circumstances require different techniques. To learn more about the size and spacing of views, see Laying out a simple view.": {
      "zh": "不同类型的视图和环境需要不同的技术。要了解更多关于视图大小和间距的信息，请参阅 布局一个简单的视图（Laying out a simple view）。",
      "tips": ""
    },
    "You can also specify the spacing as a parameter for the HStack. This changes the horizontal spacing between every subview inside the HStack.": {
      "zh": "你也可以将间距作为参数指定给 HStack。这会改变 HStack 中每个子视图之间的水平间距。",
      "tips": ""
    },
    "Step 11": {
      "zh": "第 11 步",
      "tips": ""
    },
    "You can also add padding to the .trailing edge the image view to position it further from the edge.": {
      "zh": "你也可以在图像视图的 .trailing 边缘添加填充，将其与边缘隔开。",
      "tips": ""
    },
    "Explore other padding options such as .leading, .top, .bottom, .horizontal, and so on.": {
      "zh": "尝试其他填充选项，如 .leading、.top、.bottom、.horizontal 等。",
      "tips": ""
    },
    "Step 12": {
      "zh": "第 12 步",
      "tips": ""
    },
    "You could add horizontal padding to every row of shelves and books, but that’s a lot of work and not easy to maintain. Instead, apply modifiers to the container view. In this case, the container is the VStack.": {
      "zh": "你可以为每个书架和书籍的行添加水平填充，但这需要很多工作且不易维护。相反，你应该将修饰符应用于容器视图。在本例中，容器是 VStack。",
      "tips": ""
    },
    "By applying the padding modifier to the VStack, you only have to add it once instead of adding it to every subview inside the VStack.": {
      "zh": "通过将填充修饰符应用到 VStack，你只需要添加一次，而不必将其添加到 VStack 内的每个子视图。",
      "tips": ""
    },
    "Step 13": {
      "zh": "第 13 步",
      "tips": ""
    },
    "However, if you want your bookshelf to have a specific width, use a frame instead of padding. Adding a border after the frame helps you visualize the frame.": {
      "zh": "然而,如果你希望书架具有特定的宽度，请使用 frame 而不是填充。在 frame 之后添加边框有助于可视化 frame。",
      "tips": ""
    },
    "Step 14": {
      "zh": "第 14 步",
      "tips": ""
    },
    "Woohoo! Now you have all the tools to create your own views.": {
      "zh": "太棒了！现在你已经掌握了所有创建自己视图的工具。",
      "tips": ""
    },
    "Debugging views": {
      "zh": "调试视图",
      "tips": ""
    },
    "When your SwiftUI views don’t show up as you expect, you’ll need to flex your debugging skills to fix them. Start by looking at the view displayed in the preview — it’s clearly not showing up correctly! 😩 Can you guess what this view is supposed to be?": {
      "zh": "当你的 SwiftUI 视图没有按预期显示时，你需要发挥调试技巧来解决它们。首先看预览中显示的视图 - 它明显没有正确显示出来！😩 你能猜出这个视图应该是什么吗？",
      "tips": ""
    },
    "It’s the queen of hearts playing card (or, it’s supposed to be 😵‍💫). As the name suggests, HalfCard contains half a card. You use two HalfCard instances in a VStack to create this view. Then, flip the bottom HalfCard upside down to form a mirror image of the top HalfCard. By combining the top and bottom halves, you create a full playing card.": {
      "zh": "这是一个红心皇后的扑克牌(或者，应该是一个红心皇后🤔)。顾名思义，HalfCard 包含半张牌。你在 VStack 中使用两个 HalfCard 实例来创建这个视图。然后，将底部的 HalfCard 翻转成顶部 HalfCard 的镜像。通过组合顶部和底部的一半，你可以创建一整张扑克牌。",
      "tips": ""
    },
    "Any code applied to the HalfCard view affects both the top and bottom halves of the card, allowing you to fix issues in both halves at the same time.": {
      "zh": "应用于 HalfCard 视图的任何代码都会影响牌的顶部和底部两半，因此可以同时修复两半中的问题。",
      "tips": ""
    },
    "Adding a border to a view is a great debugging tool because it allows you to see how much space a view occupies. You can use this technique to diagnose lots of issues in your code.": {
      "zh": "向视图添加边框是很好的调试工具，因为它允许你看到视图占用了多少空间。你可以使用这种技术来诊断代码中的许多问题。",
      "tips": ""
    },
    "The first major problem here is that all of the graphics are squished together. Add a frame in HalfCard and set the maxWidth and maxHeight to .infinity. This allows the frame to expand to fill any available space offered by the container, VStack.": {
      "zh": "这里的第一个主要问题是所有图形都被挤在一起。在 HalfCard 中添加 frame 并将 maxWidth 和 maxHeight 设置为 .infinity。这允许 frame 扩展以填充容器 VStack 提供的任何可用空间。",
      "tips": ""
    },
    "Even though the frame expanded, all of the graphics are still squished together. Add another border above the frame modifier. This allows you to see the outline of the VStack before you apply the frame.": {
      "zh": "即使 frame 扩展了，所有的图形仍然挤在一起。在 frame 修饰符上面再添加一个边框。这使你可以看到应用 frame 之前 VStack 的轮廓。",
      "tips": ""
    },
    "You might wonder, why would it make a difference if you apply the border before or after the frame? This is because you actually produce a new view each time you apply a modifier, so the order that you apply them really matters. See Configuring views for more on this.": {
      "zh": "你可能会想，在 frame 之前或之后添加边框有什么区别？这是因为每次应用修饰符实际上会产生一个新的视图，所以应用它们的顺序真的很重要。更多详细信息，请参阅 配置视图（Configuring views）。",
      "tips": ""
    },
    "Look at the difference in the blue and green borders. The blue border surrounds the squished graphics in the VStack, but doesn’t expand into the empty surrounding space of the green frame.": {
      "zh": "看看蓝色和绿色边框的区别。蓝色边框包围着 VStack 中挤在一起的图形，但没有扩展到绿色 frame 周围的空白空间。",
      "tips": ""
    },
    "Can you think of anyway to fix this so the contents of the VStack fill the entire frame?": {
      "zh": "你能想到任何方法来修复这个问题，以便 VStack 的内容填充整个 frame 吗？",
      "tips": ""
    },
    "What if you switched up the order of the overlay and the frame? That would allow you to expand the frame first, which gives you extra space, then apply the overlay where it fits.": {
      "zh": "如果你改变 overlay 和 frame 的顺序会怎样？这将允许你先扩展 frame，这给了你额外的空间，然后应用适应大小的 overlay。",
      "tips": ""
    },
    "Try removing the existing frame and add a new one right below the top-level VStack.": {
      "zh": "尝试删除现有的 frame，并在顶层 VStack 下面添加一个新的。",
      "tips": ""
    },
    "There is just one more thing to fix. By default any content inside the frame is center-aligned. However, the crown at the center of the HalfCard needs to align to the bottom edge of HalfCard.": {
      "zh": "只剩下一件事要修复。默认情况下，frame 内的任何内容都是居中对齐的。然而，HalfCard 中心的皇冠需要对齐到 HalfCard 的底边。",
      "tips": ""
    },
    "Can you figure out a way to make this happen? Remember that you can add a border to visualize how much space your view needs and compare it to how you think the view should behave.": {
      "zh": "你能想到任何办法来实现这一目的吗？记住，你可以添加边框来可视化你的视图需要多少空间，并将其与你认为的视图应该如何表现进行比较。",
      "tips": ""
    },
    "There are two ways to align the crown to the bottom of your HalfCard view. You can add the alignment parameter to the frame– .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .bottom) Or, add a Spacer above the crown.": {
      "zh": "有两种方法可以将皇冠对齐到 HalfCard 视图的底部。你可以在 frame 中添加对齐参数 - .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .bottom) 或者在皇冠上方添加一个 Spacer。",
      "tips": ""
    },
    "Now that you have fixed the alignment in this card, you can remove any borders that you’ve added.": {
      "zh": "现在你已经修复了这张牌中的对齐，可以删除你额外添加的边框。",
      "tips": ""
    },
    "Look at that beautiful playing card! The next time you’re unsure why your views aren’t displaying the way you want them to, don’t forget that you can add a border or background to help you debug issues with your views.": {
      "zh": "看那漂亮的扑克牌！下次当你不确定视图为什么没有按你想要的方式显示时，不要忘记你可以添加边框或背景来帮助调试视图中的问题。",
      "tips": ""
    },
    "Bringing it all together": {
      "zh": "把它们结合在一起",
      "tips": ""
    },
    "Now that you’ve gone through all of the different parts for laying out a view, it’s time to bring them all together to see how you can use it when creating a view for a real app.": {
      "zh": "现在你已经遍历了布局视图的不同部分，是时候把它们结合起来，看看在为真实应用程序创建视图时你可以如何使用它。",
      "tips": ""
    },
    "Start by setting height of your card. There are many different ways to lay out a view and using .frame(minHeight:maxHeight:) is just one way you can set the height.": {
      "zh": "首先设置卡片的高度。有许多不同的方法可以布局视图，使用 .frame(minHeight:maxHeight:) 只是设置高度的一种方式。",
      "tips": ""
    },
    "Setting the minHeight and maxHeight allows the view to scale for different screen sizes.": {
      "zh": "设置 minHeight 和 maxHeight 允许视图根据不同的屏幕尺寸进行缩放。",
      "tips": ""
    },
    "Push the card title to the edge by setting the maximum height to .infinity.": {
      "zh": "通过设置最大高度为 .infinity，可以将卡片标题推到边缘。",
      "tips": ""
    },
    "With the card title aligned, add padding to create space between the title of the view and the edge of the card. By adding padding to the VStack, you are applying padding to every view within the VStack.": {
      "zh": "对齐卡片标题后，添加填充以在标题和卡片边缘之间创建空间。",
      "tips": ""
    },
    "Having a .frame modifier with a maxWidth of .infinity stretches the Text view horizontally and fills the available space. The alignment parameter ensures that any content inside the frame aligns to the leading edge.": {
      "zh": "具有 .frame 修饰符的 Text 视图的 maxWidth 设置为 .infinity 会水平拉伸 Text 视图并填充可用空间。alignment 参数确保 frame 内的任何内容都对齐到 leading 边缘。",
      "tips": ""
    },
    "You want the emojis to be in the middle of the view. To make sure they aren’t squished in the middle of the view, set the maxWidth to infinity.": {
      "zh": "你希望表情符号位于视图的中间。为了确保它们不会在视图中间被挤压，请将 maxWidth 设置为 infinity。",
      "tips": ""
    },
    "To add a gap between the circular buttons and the emojis you need to add padding below the text.": {
      "zh": "要在圆形按钮和表情符号之间添加间隙，需要在文本下方添加填充。",
      "tips": ""
    },
    "You are now on your way to being a SwiftUI view layout expert!": {
      "zh": "你现在在成为 SwiftUI 视图布局专家的路上！",
      "tips": ""
    },
    "Try it out yourself by going to the Swift Playgrounds App to practice laying out views for a journal app!": {
      "zh": "尝试着去 Swift Playgrounds App 练习为日记应用布局视图吧！’",
      "tips": ""
    },
    "Meme Creator": {
      "zh": "Meme 制作器",
      "tips": ""
    },
    "Fetch structured data from a server asynchronously.": {
      "zh": "从服务器异步获取结构化数据。",
      "tips": ""
    },
    "Notice that there are Text and Image views in your VStack. No matter how big the screen you’re using, the Text and Image views take up exactly the amount of space they need depending on the size of the content.": {
      "zh": "请注意，VStack 中有 Text 和 Image 视图。无论使用多大的屏幕，Text 和 Image 视图所占用的空间跟内容的大小完全一样。",
      "tips": ""
    },
    "Views can also resize to fit their content such as Text(“Supercalifragilisticexpialidocious”) or Image(\"myCoolImage\").": {
      "zh": "视图也可以调整大小以适应其内容，如 Text(“Supercalifragilisticexpialidocious”) 或 Image(\"myCoolImage\")。",
      "tips": ""
    },
    "Views are somewhat magical, in that certain view types control how they resize when placed in a container. They can expand to fill the available space, such as Rectangle or other Shape.": {
      "zh": "视图有点神奇，某些视图类型可以控制它们被放置在容器中时如何调整大小。它们可以扩展以填充可用空间，例如 Rectangle 或其他 Shape。",
      "tips": ""
    },
    "Adding a frame to an image can sometimes cause it to look stretched even by adding an ideal width and height. For images, it’s often better to use scaledToFill() or scaledToFit() instead of a frame.": {
      "zh": "即使添加了理想的宽度和高度，在图像上添加 frame 有时会导致图像看起来拉伸。对于图像，使用 scaledToFill() 或 scaledToFit() 通常比使用 frame 更好。",
      "tips": ""
    }
  },
  "sample-apps/memecreator": {
    "Meme Creator": {
      "zh": "",
      "tips": ""
    },
    "Fetch structured data from a server asynchronously.": {
      "zh": "以异步方式从服务器获取结构化数据。",
      "tips": ""
    },
    "Welcome to the Meme Creator app, where you’ll learn to fetch data from the internet to create panda memes.": {
      "zh": "欢迎来到 Meme Creator 应用程序，您将学习从网络中获取数据来创建熊猫备忘录。",
      "tips": ""
    },
    "To create a meme, you’ll load some images from a URL, which could take some time depending on the speed of your internet connection to the server. You’ll use an asynchronous request so that your app can keep doing other things in the background, like responding to user actions, while waiting for the images to load into the UI.": {
      "zh": "为了创建一个备忘，你需要花费一些时间从 URL 中加载多个图片，而这个时间取决于网速。您将使用异步请求，以便您的应用程序可以保持在后台运作，例如响应用户行为。",
      "tips": ""
    },
    "In this walkthrough, you’ll learn how asynchronous data fetching works, and how to use it when retrieving panda images and their corresponding data in JSON format.": {
      "zh": "在这个演示中，您将学习如何异步的获取网络数据，以及在 JSON 格式的数据里获取熊猫图像并正确的使用它们。",
      "tips": ""
    },
    "Sharing App Data": {
      "zh": "分享应用程序数据",
      "tips": ""
    },
    "Explore how the app makes its fetched data available to the entire view hierarchy.": {
      "zh": "探究如何让整个视图层次结构获取到数据。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第 1 步",
      "tips": ""
    },
    "To fetch its data, the app uses an observable object, PandaCollectionFetcher. This is where all of the data fetching occurs.": {
      "zh": "为了获取数据，应用程序使用可观察对象 PandaCollectionFetcher。这是获取所有数据的地方。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第 2 步",
      "tips": ""
    },
    "To share its data, MemeCreator passes in PandaCollectionFetcher as an environment object, making it available to all of the child views of MemeCreator. An environment object must also be an observable object, which enables all views observing its data to update whenever that data changes.": {
      "zh": "为了共享数据，MemeCreator 将 PandaCollectionFetcher 作为一个环境对象传入，使得 MemeCreator 的所有子视图都可以使用它。环境对象也必须是可观察对象，这使得观察其数据的所有视图能够在数据发生变化时进行更新。",
      "tips": ""
    },
    "Creating the Panda Model": {
      "zh": "创建熊猫模型",
      "tips": ""
    },
    "Learn how to model structured JSON data from a data source as a Swift structure.": {
      "zh": "学习如何将 JSON 中的数据以 Swift 结构体的方式变成一个数据模型。",
      "tips": ""
    },
    "This is the Panda model object. It’s structured to mirror the JSON data returned from this URL.": {
      "zh": "这是一个熊猫模型的对象。它的结构与从 URL 返回的 JSON 数据形成映射。",
      "tips": ""
    },
    "Each panda contains a text description as well as an imageUrl, which points to a panda image. This is the data you’ll use to download a panda image.": {
      "zh": "每个熊猫数据都包含文字描述和指向熊猫图像的 imageUrl。您可以使用这些数据下载熊猫图片。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第 3 步",
      "tips": ""
    },
    "A PandaCollection is composed of an array of Panda model objects. This mirrors the format of the JSON data, which enables you to easily decode URLs and descriptive text from your JSON data into a PandaCollection instance.": {
      "zh": "PandaCollection 是由多个 Panda 模型对象组成的数组类型。这与 JSON 的数据格式相匹配，使您可以很容易的将 JSON 数据里的URL和描述文本解码成 PandaCollection 实例。",
      "tips": ""
    },
    "Fetching Panda Data": {
      "zh": "获取 Panda 数据",
      "tips": ""
    },
    "To fetch these images and their metadata, you’ll use an observable object that fetches data asynchronously. You’ll learn more about how to structure asynchronous functions in this walkthrough.": {
      "zh": "为了获取这些图像和它们的元数据，您将以异步的方式，使用可观察对象获取数据。在这个演示中，您将学习如何构建异步函数。",
      "tips": ""
    },
    "PandaCollectionFetcher handles data fetching in your app. It’s an observable object, which allows it to publish changes to its values to all UI elements observing them. In this case, you’ll have an image view that’s waiting for new Panda data so it can update its image and description.": {
      "zh": "PandaCollectionFetcher 在 App 中负责处理数据获取。它是一个可观察对象，这使得它可以将自身值的变化推送到所有观察它们的 UI 元素中。在本例中，刚好有一个图像视图，正在等待新的熊猫数据，以便更新。",
      "tips": ""
    },
    "There are two published values: imageData, a PandaCollection that you populate with JSON data, and currentPanda, a Panda model object that you display in the app’s UI.": {
      "zh": "这里有两个需要 published 的值: imageData(由 JSON 数据填充的 PandaCollection 类型) 和 currentPanda(需要在 App 中展示的熊猫模型数据)。",
      "tips": ""
    },
    "The fetchData function retrieves the JSON data. Notice that it’s marked as async to indicate that the function runs asynchronously. Because it might take a little time to fetch the data from the internet, an async function pauses until the data returns. Meantime, your app’s code continues to run in the background.": {
      "zh": "fetchData 函数用于取回 JSON 数据。请注意，它被标记为 async，这表示它是异步的。因为从互联网获取数据可能需要一点时间，所以异步函数会暂停，直到数据返回。此时，你的代码会在后台持续运行。",
      "tips": ""
    },
    "Tip": {
      "zh": "提示",
      "tips": ""
    },
    "If you didn’t make fetchData asynchronous, the app might experience some lag while it loads images individually.": {
      "zh": "假如您没有异步加载数据，在加载图像时可能会带来一点延迟。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第 4 步",
      "tips": ""
    },
    "The function is also marked throws. This tells you that the function can throw an error when you call it. In MemeCreator, the code handles this error with try? by ignoring any values it throws.": {
      "zh": "该函数还标记为 throws。这告诉您，当您调用该函数时，它可能会抛出错误。在 MemeCreator 中，通过使用 try? 关键字来忽略抛出的任何值值",
      "tips": ""
    },
    "Step 5": {
      "zh": "第 5 步",
      "tips": ""
    },
    "Inside fetchData, check to see if you have a valid URL.": {
      "zh": "在 fetchData 中, 检查 URL 是否有效。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第 6 步",
      "tips": ""
    },
    "Call another async function — URLSession.shared.data(for:) — which passes in a URL request using the URL you’ve defined. This call is also marked await, because this is where the function pauses as it waits for the response from the URL request.": {
      "zh": "调用另一个异步函数 —URLSession.shared.data(for:) —，在这个函数中传入一个您定义的 URL 请求。这个调用被标记为 await 类型，因为这是函数等待 URL 请求响应时暂停的位置。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第 7 步",
      "tips": ""
    },
    "After your data returns, you’ll check the URL response to verify that you didn’t receive an error. This code generates a badRequest error if the response’s status code isn’t equal to 200, indicating a successful request.": {
      "zh": "",
      "tips": "当你的数据返回后, 你可以检查 URL 响应确保没有收到错误。如果响应的状态代码不等于200（表示请求成功），则该代码生成 badRequest 错误。"
    },
    "Step 8": {
      "zh": "第 8 步",
      "tips": ""
    },
    "Finally, decode the JSON data and assign it to the published variable, imageData. Now you have all of the data you need to create panda memes.": {
      "zh": "最后，解码 JSON 数据并将其赋值给 published 变量 imageData。现在您拥有了创建熊猫备忘录所需的所有数据。",
      "tips": ""
    },
    "Creating Asynchronous Images": {
      "zh": "创建异步图像",
      "tips": ""
    },
    "Investigate how to use a URL to load an image asynchronously.": {
      "zh": "研究如何使用 URL 异步加载图像。",
      "tips": ""
    },
    "When you have the JSON data, you can use it to load panda images. To accomplish this, compose your LoadableImage view from AsyncImage, a view that loads an image asynchronously.": {
      "zh": "当您获得JSON数据后，您可以使用它来加载熊猫图像。要实现这一点，可以使用 AsyncImage（一种异步加载图片的视图）组成 LoadableImage 视图。",
      "tips": ""
    },
    "To create an image, LoadableImage needs data about the Panda it’s loading. The metadata supplied here includes the image URL and the description.": {
      "zh": "为了创建图像，LoadableImage 需要加载的数据。这里提供的元数据包括图像URL和描述。",
      "tips": ""
    },
    "Inside the view body, create an AsyncImage and pass in the imageUrl to load the panda image. An AsyncImage view loads asynchronously, so you’ll need to show something in its place while the image loads, and show something else if image loading fails. You’ll handle all of this logic in the following if statement.": {
      "zh": "在视图的层级结构中，创建一个 AsyncImage 并传递 imageUrl 来加载熊猫图片。AsyncImage 视图的加载是异步的，所以你需要在图片加载时显示一些内容，如果图片加载失败则显示其他内容。您将在下面的 if 语句中处理所有这些逻辑",
      "tips": ""
    },
    "When you create an instance of AsyncImage, SwiftUI provides you with phase data, which updates you on the state of image loading. For example, phase.error provides you with errors that occur, while phase.image provides an image, if available. You can use the phase data to show the appropriate UI based on the phase state.": {
      "zh": "当你创建了一个 AsyncImage 的实例, SwiftUI 为你提供了 phase 数据,使您了解图像加载的最新状态。例如，phase.error 提供了错误信息，而 phase.image 提供可用的图像。根据 phase 数据显示相应的 UI 界面。",
      "tips": ""
    },
    "Check to see if any errors occurred while loading the image. If so, you can provide a view that tells the user something went wrong.": {
      "zh": "检查在加载图片时是否发生错误。如果有，您可以提供一个视图，告诉用户出错了。",
      "tips": ""
    },
    "If you haven’t received an image and you don’t have an error, that means the image is loading. To let people know that the image is downloading, use ProgressView to display an animation while the image loads.": {
      "zh": "如果没有收到图像并且没有错误，那意味着图像正在加载。为了让人知道图像正在下载，可使用 ProgressView 的动画来表达这一隐喻。",
      "tips": ""
    },
    "Making the Meme Creator": {
      "zh": "创建熊猫备忘录",
      "tips": ""
    },
    "You’ll use the data from your app to create a meme-generating UI. Explore how to compose this view in this walkthrough.": {
      "zh": "您将使用应用程序中的数据创建一个可生成备忘录的用户界面。在本教程中，您将了解如何构建该视图。",
      "tips": ""
    },
    "MemeCreator is where you bring everything together to make panda memes. As the top-level view of your app, this is where you’ll display the panda image along with tools for adding and editing text.": {
      "zh": "MemeCreator 是您制作熊猫备忘录的地方。作为应用程序的顶层视图，这里将显示熊猫图片以及用于添加和编辑文本的工具。",
      "tips": ""
    },
    "In MemeCreatorApp, you passed in a PandaCollectionFetcher as an environment object to the top level view. Here, you access that environment object by defining a fetcher variable with the @EnvironmentObject property wrapper.": {
      "zh": "在 MemeCreatorApp 中，你将一个 PandaCollectionFetcher 作为环境对象传入顶层视图。在这里，您可以通过 @EnvironmentObject 属性包装器定义一个 fetcher 变量来访问该环境对象。",
      "tips": ""
    },
    "Before you start loading panda images, the fetcher needs to retrieve the JSON data. The .task modifier defines a task to complete when the view first appears. This is where you’ll call fetcher.fetchData() to retrieve the JSON data.": {
      "zh": "在你开始加载熊猫图像之前，fetcher 需要获取 JSON 数据。.task 修饰符定义了当视图第一次显示时需要完成的任务。这是您将调用 fetcher.fetchData() 来获取 JSON 数据的时机。",
      "tips": ""
    },
    "In the closure, you’ll insert try? await before calling fetcher.fetchData(). These words correspond to how you defined fetchData() with async throws. Because the function is asynchronous, await means that you’ll wait for the results of the async function to return, and try followed by a question mark - try? - means you’ll try calling the function, but ignore any error that it throws.": {
      "zh": "在闭包中，您将在调用 fetcher.fetchData() 之前插入 try? await。这些关键字对应于 fetchData() 函数里的 async throws。因为函数是异步的，await 表示等待异步函数返回结果，而 try 后面的问号 - try? - 表示您将尝试调用该函数，但忽略它抛出的任何错误。",
      "tips": ""
    },
    "In the UI for this view, you’ll use LoadableImage to asynchronously load an image based on the data fetcher’s currentPanda. Even if your JSON data hasn’t loaded yet, the app provides a default currentPanda to load as the first image.": {
      "zh": "在该视图的用户界面中，您将使用 LoadableImage 根据数据获取器的 currentPanda 异步加载图片。即使您的 JSON 数据尚未加载，应用程序也会提供默认的 currentPanda 作为第一张图片加载。",
      "tips": ""
    },
    "The image also has a text overlay, which you can add as a modifier. This overlay shows the meme text. The text field uses three state variables, memeText, textSize, and textColor to dynamically change the data of the text field in response to user editing actions. The text field can become focused by passing the @FocusState variable into the .focused modifier.": {
      "zh": "图片还有一个文本叠加，您可以将其添加为修改器。该叠加显示备忘录文本。文本字段使用三个变量 memeText、textSize 和 textColor 来动态改变文本字段的数据，以响应用户的编辑操作。通过将 @FocusState 变量传入 .focused 修饰符，文本字段可以进入聚焦状态。",
      "tips": ""
    },
    "To change the image, you can push a button that retrieves a random Panda from the PandaCollection and sets it as the currentPanda. Because currentPanda is a published value, the LoadableImage view automatically updates to use the latest currentPanda data whenever it changes.": {
      "zh": "要改变图片，您可以按一个按钮从熊猫图库中随机获取一个熊猫并设置为当前熊猫。因为 currentPanda 是一个 published 类型的值，LoadableImage 视图会自动更新使用最新的 currentPanda 数据",
      "tips": ""
    },
    "To add text, use a button that changes the focus state of the text field to true. This automatically inserts the cursor in the text field so you can add text.": {
      "zh": "要添加文本，使用按钮将文本字段的焦点状态更改为 true。这将自动在文本字段中插入光标，以便您添加文本。",
      "tips": ""
    },
    "Step 9": {
      "zh": "第 9 步",
      "tips": ""
    },
    "Finally, you can modify the state variables textSize and textColor using the slider and color picker at the bottom of the UI. These controls modify the values of those state variables to automatically update the meme text appearance.": {
      "zh": "最后，您可以使用用户界面底部的滑块和颜色选择器修改状态变量textSize和textColor。这些控件修改这些状态变量的值，以自动更新备忘录文本外观。",
      "tips": ""
    },
    "Bubble Level": {
      "zh": "泡泡等级",
      "tips": ""
    },
    "Access and display device sensor data by subscribing to notifications.": {
      "zh": "通过订阅通知访问和显示设备传感器数据。",
      "tips": ""
    },
    "Check to see if an image is available. If there is, great — this is the panda image you’ll display using the description as the accessibility text.": {
      "zh": "检查图片是否可用。如果有，很好--这就是您要显示的熊猫图片，使用 description 作为 accessibilityLabel 的文本。",
      "tips": ""
    }
  },
  "sample-apps/organizingwithgrids": {
    "Organizing with Grids": {
      "zh": "",
      "tips": ""
    },
    "Display visual content in an arrangement of rows and columns.": {
      "zh": "",
      "tips": ""
    },
    "Welcome to the Organizing with Grids sample. This sample shows you how to arrange content using a grid view, and how to use a state variable to track the selection of a color in that grid.": {
      "zh": "",
      "tips": ""
    },
    "Configuring the App": {
      "zh": "",
      "tips": ""
    },
    "Learn the basics of building and configuring an app with SwiftUI.": {
      "zh": "",
      "tips": ""
    },
    "Step 1": {
      "zh": "",
      "tips": ""
    },
    "Before diving into the grid, take a look at how this code gets made into an app. Your ColorGridApp follows a set of guidelines created by the App protocol. This allows your project to run and behave just like any other app.": {
      "zh": "",
      "tips": ""
    },
    "Step 2": {
      "zh": "",
      "tips": ""
    },
    "The code marks ColorGridApp with @main, making it the entry point of the program — the code the app starts running first.": {
      "zh": "",
      "tips": ""
    },
    "Step 3": {
      "zh": "",
      "tips": ""
    },
    "When your app runs, it displays whatever content you place in the body property. Notice that this body creates the ContentView. When the app launches, it fills the screen with this view.": {
      "zh": "",
      "tips": ""
    },
    "Step 4": {
      "zh": "",
      "tips": ""
    },
    "When you create a new app, ContentView is configured as your top-level view by default. This is useful because you can go to ContentView to see how an app’s views are put together. However, this view can be renamed, so if you’re unsure what the top-level view of an app is, look here in the body property of the app definition.": {
      "zh": "",
      "tips": ""
    },
    "Creating a Grid": {
      "zh": "",
      "tips": ""
    },
    "Explore how to create and fill the grid view with colored rectangles.": {
      "zh": "",
      "tips": ""
    },
    "This is the ContentView. It creates a grid of rounded rectangles, each a different color. ContentView is a View, so it can contain any number of other views inside of it. The grid is one of those views.": {
      "zh": "",
      "tips": ""
    },
    "To populate the grid with different colors, you’ll use the allColors variable to store an array of color values. The grid iterates over this array and adds a rectangular button for each color in the array.": {
      "zh": "",
      "tips": ""
    },
    "You’ll add any code that defines a view to the view’s body. You’ll define any variables that ContentView needs outside of its body.": {
      "zh": "",
      "tips": ""
    },
    "The first view inside ContentView is a VStack, which arranges its views vertically, with some text above the grid.": {
      "zh": "",
      "tips": ""
    },
    "Step 5": {
      "zh": "",
      "tips": ""
    },
    "The grid might contain more items than it can display at one time, so the code wraps it in a ScrollView to scroll the content vertically, if necessary.": {
      "zh": "",
      "tips": ""
    },
    "Step 6": {
      "zh": "",
      "tips": ""
    },
    "Inside the ScrollView, you create a grid view using LazyVGrid. The grid is “lazy” because it doesn’t create its grid items until they are needed. LazyVGrid takes an argument for columns which determines how many columns show up in the grid.": {
      "zh": "",
      "tips": ""
    },
    "Step 7": {
      "zh": "",
      "tips": ""
    },
    "The value assigned to columnLayout specifies a three-column grid. You can change this value any time you want.": {
      "zh": "",
      "tips": ""
    },
    "Step 8": {
      "zh": "",
      "tips": ""
    },
    "Inside the LazyVGrid, you define each item for the grid to display. To do this, you use a ForEach loop to iterate over the allColors array. By using the color’s name as an identifier, ForEach can find the right element when it needs to update the color’s view.": {
      "zh": "",
      "tips": ""
    },
    "Step 9": {
      "zh": "",
      "tips": ""
    },
    "Each item in the grid is a Button view, and each button has an action (something that happens when you tap it), and a label (text or an image that tells people what the button does, like “Save” to save a file).": {
      "zh": "",
      "tips": ""
    },
    "Step 10": {
      "zh": "",
      "tips": ""
    },
    "The label for the button uses a RoundedRectangle view, and one of the colors from the ForEach loop. You can see this in the foregroundColor(color) modifer.": {
      "zh": "",
      "tips": ""
    },
    "Using a State Variable": {
      "zh": "",
      "tips": ""
    },
    "Investigate how SwiftUI changes the appearance of a view.": {
      "zh": "",
      "tips": ""
    },
    "If you tap a color in the grid, you’ll notice that the text element on top of the grid changes color.": {
      "zh": "",
      "tips": ""
    },
    "You add @State before a variable to tell SwiftUI to manage the storage for a value. When the value changes, SwiftUI updates any parts of the view that use the value. The state variable selectedColor tracks the most recently selected color, which the text at the top of the view uses for its foreground color.": {
      "zh": "",
      "tips": ""
    },
    "The Text view uses selectedColor for its foreground color. Because selectedColor is a state variable, whenever the state changes, SwiftUI changes the color of this text.": {
      "zh": "",
      "tips": ""
    },
    "When you tap a grid element, the selectedColor value changes to that element’s color, which also changes the color of the text.": {
      "zh": "",
      "tips": ""
    },
    "Editing Grids": {
      "zh": "",
      "tips": ""
    },
    "Let people edit data that your app displays.": {
      "zh": "",
      "tips": ""
    }
  },
  "sample-apps/recognizinggestures": {
    "Recognizing Gestures": {
      "zh": "识别手势",
      "tips": ""
    },
    "Update shapes or other content in response to taps, rotations, or other Multi-Touch gestures.": {
      "zh": "当识别到点击、旋转或其他多点触控手势时，更新形状或其他内容。",
      "tips": ""
    },
    "Welcome to Recognizing Gestures. In this sample you’ll learn how to add different gestures to your views, like taps, drags, and touch and hold.": {
      "zh": "欢迎来到识别手势。在本示例中，您将学习如何将不同的手势添加到视图中，例如点击、拖动和触摸并保持。",
      "tips": ""
    },
    "Start by trying out each gesture in the app preview. When you’re ready, dive into the code walkthrough and learn how to add a gesture to your next project.": {
      "zh": "你可以通过在预览窗口尝试各种手势来开始。当你准备好之后，就可以深入代码并在下一个项目中学习如何添加手势了",
      "tips": ""
    },
    "Tap": {
      "zh": "点击",
      "tips": ""
    },
    "Explore how to apply different colors to a rectangle when tapped.": {
      "zh": "探索如何在点击的时候给正方形赋予不同的颜色",
      "tips": ""
    },
    "Step 1": {
      "zh": "",
      "tips": ""
    },
    "In SwiftUI, you can add a gesture directly to a view using a .gesture modifier. Here, you’ll explore how to add a tap gesture to a rectangle view so that it changes color when pressed.": {
      "zh": "在 SwiftUI 中，你可以使用 .gesture 修饰符直接将手势添加到视图中。在这里，你将探索如何将点击手势添加到矩形视图中，以便在按下时更改颜色。",
      "tips": ""
    },
    "Step 2": {
      "zh": "",
      "tips": ""
    },
    "To set up this tap gesture, you need a @State value, color. When you mark the property with @State, SwiftUI updates all views that use this value any time it changes.": {
      "zh": "为了设置这个点击手势，你需要一个用 @State 修饰的值，也就是这里的 color 属性。当你使用 @State 标记属性后，SwiftUI 会在该值变化后更新所有使用了这个值的视图",
      "tips": ""
    },
    "Step 3": {
      "zh": "",
      "tips": ""
    },
    "The color value is set as the foreground color of the rectangle. Whenever this value changes, the color of the rectangle updates.": {
      "zh": "color 变量用于设置矩形的前景色。矩形的颜色会在这个变量变化时更新",
      "tips": ""
    },
    "Step 4": {
      "zh": "",
      "tips": ""
    },
    "This code defines a custom gesture, tapGesture. After you’ve defined a custom gesture, you can attach it to a view using the .gesture modifier.": {
      "zh": "这段代码定义了一个自定义的手势，点击手势。在你定义了自定义手势后，你就可以使用 .gesture 修饰符将其添加到一个视图上",
      "tips": ""
    },
    "Step 5": {
      "zh": "",
      "tips": ""
    },
    "Your custom gesture uses a TapGesture and defines the event handler for when the tap ends. When the tap ends, you assign a random value to color, and the rectangle automatically updates to reflect the new value.": {
      "zh": "你的自定义手势使用了 TapGesture 类，并定义了一个点击结束时的事件处理器。当点击结束时，你会给 color 属性设置一个随机的值，并且矩形会自动更新以反映出 color 属性的新值。",
      "tips": ""
    },
    "Step 6": {
      "zh": "",
      "tips": ""
    },
    "By passing tapGesture into the .gesture modifier, the rectangle responds to taps using your custom gesture definition.": {
      "zh": "通过将 tapGesture 传递给 .gesture 修饰符，矩形会使用你自定义的手势定义来响应点击。",
      "tips": ""
    },
    "Long Press": {
      "zh": "长按",
      "tips": ""
    },
    "Touch and hold to change the shape of a capsule.": {
      "zh": "触摸并保持以更改胶囊的形状。",
      "tips": ""
    },
    "In the LongPressView, you’ll change the height and width of a capsule shape every time you touch and hold on the shape.": {
      "zh": "在 LongPressView 中，你将在每次触摸并保持的时候更改胶囊形状的高度和宽度。",
      "tips": ""
    },
    "To change the capsule’s size, you’ll iterate through an array of size values. Changes to the @State property sizeIndex updates the capsule to a new size in the array.": {
      "zh": "为了改变胶囊的大小，你将遍历一个 size 值的数组。对 @State 属性 sizeIndex 的更改会将胶囊更新为数组中的新大小。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实验",
      "tips": ""
    },
    "Try adding a few sizes of your own. Can you make a really big or really tiny capsule?": {
      "zh": "尝试添加一些自己的尺寸。你能做一个非常大或非常小的胶囊吗？",
      "tips": ""
    },
    "The capsule shape uses the sizes value in the frame modifier to set its width and height based on the sizeIndex. If the index changes, this view automatically updates to reflect the new size it references in the array.": {
      "zh": "胶囊形状使用 frame 修饰符中的 sizes 值来根据 sizeIndex 设置其宽度和高度。如果索引发生变化，这个视图会自动更新以反映出它在数组中引用的新大小。",
      "tips": ""
    },
    "What happens if you set the width’s index to 1 with sizes[1].width? What happens each time you touch and hold on the capsule? Try it before moving on.": {
      "zh": "如果你使用 sizes[1].width 将宽度的索引设置为 1，会发生什么？每次你触摸并保持胶囊时会发生什么？在继续之前试一试。",
      "tips": ""
    },
    "Here you define your custom gesture using a LongPressGesture.": {
      "zh": "这里你使用 LongPressGesture 定义了你的自定义手势。",
      "tips": ""
    },
    "When the long press gesture ends, iterate to the next index in the array. The value increments by 1 until it reaches the last index (sizes.count) before resetting back to 0.": {
      "zh": "当长按手势结束时，sizeIndex 会迭代到数组中的下一个索引。该值增加 1，直到它达到最后一个索引（sizes.count），然后重置为 0。",
      "tips": ""
    },
    "The last step is to apply the long press gesture to the capsule shape using the .gesture modifier. The app calls event handlers from longPressGesture when you touch and hold the capsule.": {
      "zh": "最后一步是使用 .gesture 修饰符将长按手势应用到胶囊形状上。当你触摸并保持胶囊时，应用程序会通过 longPressGesture 调用事件处理器。",
      "tips": ""
    },
    "Drag": {
      "zh": "拖动",
      "tips": ""
    },
    "Learn how to use a drag gesture to move a circle around the screen.": {
      "zh": "学习如何使用拖动手势在屏幕上移动一个圆。",
      "tips": ""
    },
    "In DragView you’ll use a drag gesture to move a circle shape around the view.": {
      "zh": "在 DragView 中，你将使用拖动手势在视图中移动一个圆形。",
      "tips": ""
    },
    "To keep track of the circle’s position, the @State variable offset stores a CGSize value. This doesn’t refer to the circle’s size, but is instead used as a distance vector to represent its offset from its starting position in the view.": {
      "zh": "为了跟踪圆的位置，@State 变量 offset 存储了一个 CGSize 值。这并不是指圆的大小，而是用作距离向量来表示它在视图中的起始位置的偏移量。",
      "tips": ""
    },
    "Here you pass in offset as the value for the circle view’s .offset modifier. Any change to this value causes SwiftUI to update the position of the circle relative to its original location in the view. As your gesture updates offset, the circle moves around the view.": {
      "zh": "这里你将 offset 作为圆视图的 .offset 修饰符的值传入。对该值的任何更改都会导致 SwiftUI 更新圆相对于视图中原始位置的位置。当你的手势更新 offset 时，圆会在视图中移动。",
      "tips": ""
    },
    "Here you define a custom gesture using a DragGesture.": {
      "zh": "这里你使用 DragGesture 定义了一个自定义手势。",
      "tips": ""
    },
    "The system calls the .onChanged event handler any time the position of your drag changes. Each time the handler is called, it assigns a new value to offset using the translation property of the drag value.": {
      "zh": "系统会在拖动位置发生变化时调用 .onChanged 事件处理器。每次调用处理器时，它都会使用拖动值的 translation 属性为 offset 赋一个新值。",
      "tips": ""
    },
    "Try modifying this formula to see what happens to your circle when you drag it. What happens when you remove the -50 (the radius of the circle) from the width and height? What happens if you remove the start location of the width and height?": {
      "zh": "尝试修改这个公式，看看当你拖动它时你的圆会发生什么。当你从宽度和高度中删除 -50（圆的半径）时会发生什么？如果你删除宽度和高度的起始位置会发生什么？",
      "tips": ""
    },
    "To apply the drag gesture to the circle, pass in the dragGesture to the .gesture modifier of the circle.": {
      "zh": "将拖动手势应用到圆上，将 dragGesture 传入到圆的 .gesture 修饰符中。",
      "tips": ""
    },
    "Rotate": {
      "zh": "旋转",
      "tips": ""
    },
    "Experiment rotating a square using two fingers.": {
      "zh": "尝试使用两根手指旋转一个正方形。",
      "tips": ""
    },
    "In RotateView you’ll use a two-finger rotation gesture to rotate a square shape.": {
      "zh": "在 RotateView 中，你将使用双指旋转手势来旋转一个正方形。",
      "tips": ""
    },
    "To set up the rotation gesture, you need a starting angle, rotation. This state property enables you to track the change of rotation, and redraws the view every time it changes.": {
      "zh": "为了设置旋转手势，你需要一个起始角度 rotation。这个状态属性使你能够跟踪旋转的变化，并在每次变化时重新绘制视图。",
      "tips": ""
    },
    "You pass in rotation as the value for the .rotationEffect modifier, enabling the view to update the rotation angle as the value changes.": {
      "zh": "你将 rotation 作为 .rotationEffect 修饰符的值传入，使视图能够在值变化时更新旋转角度。",
      "tips": ""
    },
    "Here you define a custom gesture using a RotationGesture.": {
      "zh": "这里你使用 RotationGesture 定义了一个自定义手势。",
      "tips": ""
    },
    "While you rotate the square, the rotation property constantly updates the value of the @State property, rotation. SwiftUI then detects those changes and tells the square to redraw itself.": {
      "zh": "当你旋转正方形时，rotation 属性不断更新 @State 属性 rotation 的值。SwiftUI 会检测到这些变化，并告诉正方形重新绘制自己。",
      "tips": ""
    },
    "To capture the gesture’s final value, use the onEnded event handler. This updates rotation with the last value from the gesture and draws the square view to perfectly match the angle of your last movement.": {
      "zh": "为了捕获手势的最终值，使用 onEnded 事件处理器。这会使用手势的最后一个值更新 rotation，并绘制正方形视图以完美匹配你最后一次移动的角度。",
      "tips": ""
    },
    "Note": {
      "zh": "注意",
      "tips": ""
    },
    "You could remove this whole section of code, and you might not notice any difference when you rotate the square. However, if you record the exact angles, you might notice a small difference between the final angle of your finger movements and the final angle of the square after it stops rotating.": {
      "zh": "你可以删除这整个代码部分，当你旋转正方形时你可能不会注意到任何不同。然而，如果你记录下确切的角度，你可能会注意到你的手指移动的最终角度和正方形停止旋转后的最终角度之间的微小差异。",
      "tips": ""
    },
    "Step 7": {
      "zh": "",
      "tips": ""
    },
    "The last step required to make this square rotate is to add the .gesture modifier to the square, passing in rotationGesture so it responds to your touch.": {
      "zh": "最后一步是让这个正方形旋转，将 .gesture 修饰符添加到正方形中，传入 rotationGesture 使它响应你的触摸。",
      "tips": ""
    },
    "The rotation gesture is only available on Multi-Touch devices (Magic Mouse, Magic Trackpad, MacBook, or iOS devices), and may not be available in some macOS configurations. For more details, see Using Multi-Touch gestures on your Mac.": {
      "zh": "旋转手势仅适用于多点触摸设备（Magic Mouse、Magic Trackpad、MacBook 或 iOS 设备），并且可能在某些 macOS 配置中不可用。有关更多详细信息，请参阅在 Mac 上使用多点触摸手势。",
      "tips": ""
    },
    "Line Drawing": {
      "zh": "线段绘制",
      "tips": ""
    },
    "Explore how to draw lines onscreen using a drag gesture.": {
      "zh": "探索如何使用拖动手势在屏幕上绘制线条。",
      "tips": ""
    },
    "In SingleLine, you’ll use a drag gesture to draw a line in the view. To do this, you’ll create a Path and redraw it every time you initiate a drag event.": {
      "zh": "在 SingleLine 中，你将使用拖动手势在视图中绘制一条线。为此，你将创建一个 Path，并在每次启动拖动事件时重新绘制它。",
      "tips": ""
    },
    "This drag gesture needs two state properties: one to track the start of the line, and one to track the end of the line.": {
      "zh": "这个拖动手势需要两个状态属性：一个用来跟踪线的起点，一个用来跟踪线的终点。",
      "tips": ""
    },
    "To draw a line, you’ll use a Path, which creates an outline of a shape. First, you’ll move the path to the lineStart value and then you’ll add a line to the lineEnd value. Because each of these values are @State properties, any changes to their data causes SwiftUI to redraw the path and update the view. As a result, you can see the line updating as you drag around the view.": {
      "zh": "为了绘制一条线，你将使用 Path，它创建了一个形状的轮廓。首先，你将把路径移动到 lineStart 的值，然后你将在 lineEnd 的值上添加一条线。因为这些值都是 @State 属性，所以对它们的数据的任何更改都会导致 SwiftUI 重新绘制路径并更新视图。因此，你可以看到当你在视图周围拖动时，线条在更新。",
      "tips": ""
    },
    "This drag gesture example uses a DragGesture, just like the other drag gesture example. However, here you need two event handlers: one that’s called as the drag value changes in .onChanged, and the other that’s called when the drag gesture ends in .onEnded.": {
      "zh": "这个拖动手势示例使用 DragGesture，就像其他拖动手势示例一样。然而，在这里你需要两个事件处理器：一个在 .onChanged 中调用，当拖动值改变时，另一个在 .onEnded 中调用，当拖动手势结束时。",
      "tips": ""
    },
    "When your device detects a drag gesture, lineStart uses the initial location of the drag, and this value remains constant. However, lineEnd updates with a new location for each .onChanged event sent. This allows the line to redraw, making it look like you’re dragging the end of the line wherever you want it to go.": {
      "zh": "当你的设备检测到拖动手势时，lineStart 使用拖动的初始位置，这个值保持不变。然而，lineEnd 会使用每个 .onChanged 事件发送的新位置进行更新。这将会让线条重新绘制，使它看起来像你在拖动线条的末端。",
      "tips": ""
    },
    "The second event handler, .onEnded, captures the last location of your drag and updates the lineEnd property, ensuring your line ends where your touch left the view. After the .onEnded handler recognizes that you’ve stopped drawing, the line stays in place until you start a new drag gesture.": {
      "zh": "第二个事件处理器 .onEnded 会捕获你拖动的最后位置，并更新 lineEnd 属性，确保你的线条在你的触摸离开视图的地方结束。在 .onEnded 处理程序识别到你已经停止绘制之后，线条会保持在原地，直到你开始一个新的拖动手势。",
      "tips": ""
    },
    "To assign the gesture, pass in lineDrawingGesture to the .gesture modifier of your Path.": {
      "zh": "为了让手势生效，将 lineDrawingGesture 传递给 Path 的 .gesture 修饰符。",
      "tips": ""
    },
    "Animating Shapes": {
      "zh": "动画形状",
      "tips": ""
    },
    "Learn how to use shapes and simple animations in SwiftUI.": {
      "zh": "学习如何在 SwiftUI 中使用形状和简单的动画。",
      "tips": ""
    }
  },
  "sample-apps/seismometer": {
    "Seismometer": {
      "zh": "地震仪",
      "tips": ""
    },
    "Present dynamic data in custom views.": {
      "zh": "在自定义视图中呈现动态数据。",
      "tips": ""
    },
    "Welcome to Seismometer.": {
      "zh": "欢迎来到地震仪。",
      "tips": ""
    },
    "You can use your iPad to detect vibrations using its built-in motion sensors. This sample shows how to display vibration information in two formats: a needle and a line graph.": {
      "zh": "你可以使用 iPad 内置的运动传感器来检测震动。这个例子会向你展示如何用两种方式来展示震动：针形图和线形图",
      "tips": ""
    },
    "Try out Seismometer by placing your iPad on a flat surface and then jostling it a bit. Or you can hold your iPad and move it up and down slowly.": {
      "zh": "你可以将你的 iPad 放在一个平坦的平面上，然后稍微推挤一下来体验“地震仪”这个 App。或者，你可以拿着你的 iPad 慢慢地上下移动。",
      "tips": ""
    },
    "Motion Detector": {
      "zh": "",
      "tips": ""
    },
    "You can use the MotionDetector class to observe the motion of your device.": {
      "zh": "你可以使用 MotionDetector 类来观察你的设备的运动。",
      "tips": ""
    },
    "Step 1": {
      "zh": "",
      "tips": ""
    },
    "Step 2": {
      "zh": "",
      "tips": ""
    },
    "A CMMotionManager is the object that you use to get motion data from the sensors in your iPad, such as the accelerometer. It gathers information from the sensors and translates their data into values you can understand.": {
      "zh": "CMotionManager 是你用来从你的 iPad 的传感器中获取运动数据的对象，比如加速度计。它会从传感器中收集信息，并将它们的数据转换成你可以理解的值。",
      "tips": ""
    },
    "Step 3": {
      "zh": "",
      "tips": ""
    },
    "The timer property stores a Timer instance. A timer waits for certain period of time, defined in the updateInterval property, before running some code. The MotionDetector uses the timer to update its pitch, roll, and zAcceleration values at regular intervals.": {
      "zh": "timer 属性存储了一个 Timer 实例。Timer 会在一段时间后——即 updateInterval 属性中定义的时间后，运行一些代码。MotionDetector 使用 timer 来在固定的时间间隔内更新它的 pitch、roll 和 zAcceleration 值。",
      "tips": ""
    },
    "Note": {
      "zh": "注意",
      "tips": ""
    },
    "Choose an update interval that makes sense for your app. For example, you’ll want a short update interval for the seismometers in this project because the interface presents real-time data as you move your iPad around.": {
      "zh": "选择一个对你的 App 来说有意义的更新间隔。例如，你会想要一个短的更新间隔，因为这个项目中的地震仪会在你移动你的 iPad 时实时更新数据。",
      "tips": ""
    },
    "Step 4": {
      "zh": "",
      "tips": ""
    },
    "These three properties store data for the tilt of your device in two dimensions (roll and pitch), as well as its vertical acceleration (zAcceleration).": {
      "zh": "这三个属性存储了你的设备在两个维度上的倾斜（roll 和 pitch），以及它的垂直加速度（zAcceleration）。",
      "tips": ""
    },
    "These properties have a @Published property wrapper, which means that any SwiftUI view that depends on their values automatically updates when the values change. You make a view dependent on a published property by using that value in the view’s code. The NeedleSeismometer and GraphSeismometer samples use these properties to update when the MotionDetector detects changes to the values of roll, pitch, and zAcceleration.": {
      "zh": "这些属性有一个 @Published 属性包装器，这意味着任何依赖于它们值的 SwiftUI 视图在值改变时会自动更新。你可以通过在视图的代码中使用该值来使视图依赖于已发布的属性。NeedleSeismometer 和 GraphSeismometer 示例会使用这些属性来在 MotionDetector 检测到 roll、pitch 和 zAcceleration 值的变化时更新。",
      "tips": ""
    },
    "Step 5": {
      "zh": "",
      "tips": ""
    },
    "This property stores code that runs when the MotionDetector updates its motion data. If you want to execute custom actions when the motion data changes, you can put your own code into onUpdate in your instance of MotionDetector.": {
      "zh": "这个属性存储了 MotionDetector 更新它的运动数据时要运行的代码。如果你想在运动数据改变时执行自定义操作，你可以将你自己的代码放到 MotionDetector 的 onUpdate 中。",
      "tips": ""
    },
    "Step 6": {
      "zh": "",
      "tips": ""
    },
    "This method starts updating the motion detector.": {
      "zh": "这个方法开始更新运动检测器。",
      "tips": ""
    },
    "Step 7": {
      "zh": "",
      "tips": ""
    },
    "Always use isDeviceMotionAvailable to verify that motion data is available before you try to access it.": {
      "zh": "当你在尝试访问它之前，总是使用 isDeviceMotionAvailable 来验证运动数据是否可用。",
      "tips": ""
    },
    "Step 8": {
      "zh": "",
      "tips": ""
    },
    "This method tells the CMMotionManager to start updating motion data.": {
      "zh": "这个方法告诉 CMMotionManager 开始更新运动数据。",
      "tips": ""
    },
    "Step 9": {
      "zh": "",
      "tips": ""
    },
    "This code creates a new timer and schedules it to run. The updateInterval property tells the timer how long to wait between updates, and repeats is set to true so the timer runs forever until you stop it. (If you pass false to repeats, the timer only runs once.) The block of code at the end of the line that reads { _ in is the start of a closure that contains the code run by the timer. The closure calls the updateMotionData() method.": {
      "zh": "这段代码创建了一个新的计时器，并设定了它调用的时机。updateInterval 属性会告诉计时器在更新之间等待多长时间，由于 repeats 被设置为 true，因此计时器会一直运行，直到你停止它（如果你传递 false 给 repeats，计时器只会运行一次。）。 行末尾的代码块 { _ in 计时器会调用的闭包的开始部分。在这个闭包中，代码调用了 updateMotionData() 方法。",
      "tips": ""
    },
    "Step 10": {
      "zh": "",
      "tips": ""
    },
    "The updateMotionData() method does the core work of the motion detector. It’s responsible for updating all published properties with current data from the sensors, as well as calling the code in onUpdate.": {
      "zh": "updateMotionData() 方法完成了是运动检测器的核心工作。它负责使用传感器的当前数据更新所有已发布的属性，以及调用 onUpdate 方法。",
      "tips": ""
    },
    "Step 11": {
      "zh": "",
      "tips": ""
    },
    "The deviceMotion data may not be there in certain conditions. To see if the data exists, try to assign deviceMotion to a variable or constant using if let. If the motion data exists, it’s assigned to data and the code inside the braces runs. Otherwise, it skips the entire if statement.": {
      "zh": "deviceMotion 数据在某些情况下可能不存在。要查看数据是否存在，请尝试使用 if let 将 deviceMotion 分配给变量或常量。如果运动数据存在，它就会被分配给 data，然后花括号内的代码就会运行。否则，它就会跳过整个 if 语句。",
      "tips": ""
    },
    "Step 12": {
      "zh": "",
      "tips": ""
    },
    "A CMDeviceMotion instance represents device motion, stored in data. The CMDeviceMotion class has quite a few properties for describing the input from the motion sensors. Use the attitude property to get the device’s tilt in three directions. You may be familiar with X, Y, and Z axes in 3D space, which relate to pitch, roll, and yaw, respectively.": {
      "zh": "CMDeviceMotion 实例表示设备运动状态，存储在 data 属性中。CMDeviceMotion 类有很多属性来描述运动传感器的输入。使用 attitude 属性来获取设备在三个方向上的倾斜。你可能熟悉 3D 空间中的 X、Y 和 Z 轴，它们分别与 pitch、roll 和 yaw 相关。",
      "tips": ""
    },
    "Step 13": {
      "zh": "",
      "tips": ""
    },
    "Use the userAcceleration property to get the device’s acceleration after accounting for the downward pull of gravity. If your device is still, this number is 0. However, the value changes to a negative number when you lift your iPad upward, or to a positive number when you move your iPad downward.": {
      "zh": "使用 userAcceleration 属性来获取设备在考虑到重力向下拉的情况下的加速度。如果你的设备静止不动，这个数值就是 0。然而，当你将 iPad 向上抬起时，这个值会变成一个负数，或者当你将 iPad 向下移动时，这个值会变成一个正数。",
      "tips": ""
    },
    "Step 14": {
      "zh": "",
      "tips": ""
    },
    "You run the code in onUpdate just as you’d call any function, with a set of parentheses following its name.": {
      "zh": "你可以像调用任何函数一样调用 onUpdate 中的代码，只需要在函数名后面加上一对括号。",
      "tips": ""
    },
    "Step 15": {
      "zh": "",
      "tips": ""
    },
    "The stop() method tells the CMMotionManager class to stop updating its values by calling stopDeviceMotionUpdates(), then it stops the timer by calling invalidate().": {
      "zh": "stop() 方法通过调用 stopDeviceMotionUpdates() 告诉 CMMotionManager 类停止更新它的值，然后它通过调用 invalidate() 停止计时器。",
      "tips": ""
    },
    "Step 16": {
      "zh": "",
      "tips": ""
    },
    "This deinitializer runs when a MotionDetector instance is about to go away. It’s important to clean up here; otherwise the timer continues to run even after the motion detector is gone.": {
      "zh": "这个析构器在 MotionDetector 实例即将消失时运行。在这里做一些善后工作很重要；否则，即使 motion detector 对象消失了，计时器仍然会继续运行。",
      "tips": ""
    },
    "Needle Seismometer": {
      "zh": "指针地震仪",
      "tips": ""
    },
    "Learn how to display a needle that registers the vibration of your device.": {
      "zh": "学习如何显示一个可以记录你的设备振动的指针。",
      "tips": ""
    },
    "The NeedleSeismometer view displays a needle that moves as your device vibrates. It uses the zAcceleration data from a MotionDetector instance to detect vibration, and translates that data into left and right rotation of the needle.": {
      "zh": "NeedleSeismometer 视图显示一个随着你的设备振动而移动的指针。它使用 MotionDetector 实例的 zAcceleration 数据来检测振动，并将这些数据转换为指针的左右旋转。",
      "tips": ""
    },
    "The motionDetector property holds a MotionDetector instance. The motion detector senses changes in your device’s motion and provides that data for use in your code.": {
      "zh": "motionDetector 属性保存一个 MotionDetector 实例。运动检测器会感知你的设备运动的变化，并提供这些数据供你在代码中使用。",
      "tips": ""
    },
    "The property has an @EnvironmentObject property wrapper because this view expects the app to put a motion detector in the environment for it to use.": {
      "zh": "该属性有一个 @EnvironmentObject 属性包装器，因为该视图期望应用程序将一个运动检测器放在环境中供它使用。",
      "tips": ""
    },
    "The seismometer display is a vertical stack (VStack) with a rotating needle, text that displays the raw values from the sensor, and some instructions for people to follow.": {
      "zh": "地震仪显示是一个垂直堆栈（VStack），有一个旋转的指针，一个显示传感器原始值的文本，以及一些人们要遵循的指示。",
      "tips": ""
    },
    "You can use a ZStack to layer views on top of each other. Here, the background view for the gauge goes underneath the needle itself. The background draws a semicircle with marks around its edge. Check out the code in GaugeBackground.swift if you’re curious how that’s done.": {
      "zh": "你可以使用 ZStack 将视图层叠在一起。在这里，仪表盘的背景视图位于指针本身的下方。背景绘制了一个带有标记的半圆。如果你想知道这是怎么做的，请查看 GaugeBackground.swift 中的代码。",
      "tips": ""
    },
    "The needle is just a rectangle with a .frame modifier to give it a narrow, tall shape. It also uses the .foregroundColor modifier to adopt the app’s accent color. Try changing the accent color of this sample to see how it affects the view.": {
      "zh": "指针只是一个矩形，有一个 .frame 修饰符，给它一个狭窄的、高的形状。它还使用 .foregroundColor 修饰符来采用应用程序的强调颜色。尝试更改此示例的强调颜色，看看它如何影响视图。",
      "tips": ""
    },
    "Use the .rotationEffect modifier to rotate the rectangle for the needle, and set the rotationAngle and needleAnchor properties to define the needle’s behavior. You pass in rotationAngle as the first argument, which interprets the motion data to calculate the correct needle angle.": {
      "zh": "使用 .rotationEffect 修饰符来旋转指针的矩形，并设置 rotationAngle 和 needleAnchor 属性来定义指针的行为。你将 rotationAngle 作为第一个参数传入，它会解释运动数据来计算正确的指针角度。",
      "tips": ""
    },
    "By default, rotation happens around the center of a view; however, you can use the needleAnchor property as the second argument so the needle rotates at its base.": {
      "zh": "默认情况下，旋转发生在视图的中心；然而，你可以使用 needleAnchor 属性作为第二个参数，这样指针就会在它的底部旋转。",
      "tips": ""
    },
    "The rotationAngle property returns the amount the needle rotates for a given sensor reading. The rotationEffect property expects an Angle instance, so you can create one using the zAcceleration property of the motion detector. The motion detector represents upward acceleration with a negative number, but you’re multiplying by -1 to make upward acceleration positive, and downward acceleration negative.": {
      "zh": "rotationAngle 属性返回指针在给定传感器读数下旋转的量。rotationEffect 属性期望一个 Angle 实例，所以你可以使用运动检测器的 zAcceleration 属性创建一个。运动检测器用一个负数表示向上的加速度，但是你乘以 -1 来使向上的加速度为正，向下的加速度为负。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实验",
      "tips": ""
    },
    "The amplification constant is useful for controlling the sensitivity of the display. Try changing its value to see how that affects the needle.": {
      "zh": "amplification 常量对于控制显示的灵敏度很有用。尝试更改它的值，看看它如何影响指针。",
      "tips": ""
    },
    "The needleAnchor property defines the point of rotation for the needle as a UnitPoint. A unit point has x and y coordinates like a regular point, but their values only range between 0 and 1.": {
      "zh": "needleAnchor 属性将指针的旋转点定义为 UnitPoint。一个单位点有 x 和 y 坐标，就像一个普通的 point 类型，但它们的值只能取在 0 和 1 之间。",
      "tips": ""
    },
    "A unit point is useful for defining a point inside any view, regardless of its size. This one defines the midpoint of a view (width-wise) at its bottom. Regardless of the view’s size, the point is exactly at that location relative to the view’s width and height.": {
      "zh": "当我们不想关心视图的具体大小的时候，用 unit point 来定义视图内部的点会非常有用。在这里，这个 unit point 定义了视图的中点（宽度方向）在视图底部。无论具体视图的大小是多少，该点都恰好位于相对于视图宽度和高度的固定位置。",
      "tips": ""
    },
    "Without this overlay, you’d get a plain rectangle that rotates at its base. But to make things a little more polished, this overlay adds a small circle at the bottom.": {
      "zh": "如果没有这个 overlay，你就会得到一个在底部旋转的普通矩形。但是为了让矩形看起来更加精致，这个 overlay 在矩形底部添加了一个小圆。",
      "tips": ""
    },
    "You can use an overlay to put content directly on top of a view. The overlay occupies the same area as its parent view. In this overlay, a Spacer pushes a small Circle to the bottom of a VStack so it aligns with the base of the needle.": {
      "zh": "你可以使用 overlay 将内容直接放在视图的顶部。overlay 占据与其父视图相同的区域。在这个 overlay 中，一个 Spacer 将一个小圆推到 VStack 的底部，这样它就与指针的底部对齐了。",
      "tips": ""
    },
    "Graph Seismometer": {
      "zh": "图形化的地震仪",
      "tips": ""
    },
    "Learn how to display the vibration of your device as an animated line graph.": {
      "zh": "学习如何将你的设备的振动显示为一个动画的折线图。",
      "tips": ""
    },
    "The GraphSeismometer view displays a line graph of your device’s vibration. It uses the zAcceleration data from a MotionDetector instance to detect vibration, and translates that data into Y values in the graph; the X values represent time.": {
      "zh": "",
      "tips": "GraphSeismometer 视图显示了你的设备的振动的折线图。它使用 MotionDetector 实例的 zAcceleration 数据来检测振动，并将该数据转换为图表中的 Y 值；X 值表示时间。"
    },
    "This property holds a MotionDetector instance. The motion detector senses changes in your device’s motion and provides that data for you to use in your code.": {
      "zh": "这个属性保存了一个 MotionDetector 实例。它会感知你的设备运动的变化，并为你提供这些数据，以便你在代码中使用。",
      "tips": ""
    },
    "The data property stores the seismometer data you’ll graph in this view as an array of Double values. It includes a @State property wrapper because you want the line graph to update whenever the data changes.": {
      "zh": "data 属性是一个值为 Double 的数组，它会存储地震仪的数据，并提供给你以便在视图中以图形形式呈现。因为你会希当数据变化时折线图也跟着变化，所以这个属性还包括了一个 @State 属性包装器。",
      "tips": ""
    },
    "The maxData property represents the maximum number of data points your graph shows. This is vital, because the seismometer updates 100 times per second, which produces a lot of data, and you don’t want to keep that around forever. When you accumulate enough data, you’ll start deleting the old ones.": {
      "zh": "maxData 属性表示你的图表显示的数据点的最大数量。这是至关重要的，因为地震仪每秒更新 100 次，这会产生大量的数据，而你不希望永远保留这些数据。当你积累了足够的数据，你就会开始删除旧数据。",
      "tips": ""
    },
    "The sensitivity property controls how sensitive the seismometer is to motion. Sensitivity affects the line graph by expanding it vertically. The higher the sensitivity, the larger the peaks and valleys will appear in the graph.": {
      "zh": "sensitivity 属性控制地震仪对运动的敏感度。敏感度会通过在垂直方向上扩展折线图来影响折线图。敏感度越高，图表中的峰值和谷值就会越大。",
      "tips": ""
    },
    "The graphMaxValueMostSensitive property represents the maximum value the graph displays at its most sensitive, and graphMaxValueLeastSensitive represents the maximum value displayed at its least sensitive. Along with sensitivity, these properties control the graph’s display.": {
      "zh": "graphMaxValueMostSensitive 属性表示图表在最敏感时显示的最大值，graphMaxValueLeastSensitive 表示在最不敏感时显示的最大值。这些属性与敏感度一起控制图表的显示。",
      "tips": ""
    },
    "Try changing these values to affect the range of sensitivity of the graph. (Note that graphMaxValueMostSensitive should always be less than graphMaxValueLeastSensitive.)": {
      "zh": "尝试更改这些值以影响图表的敏感度范围。（注意，graphMaxValueMostSensitive 应该始终小于 graphMaxValueLeastSensitive。）",
      "tips": ""
    },
    "This property represents the maximum value of the graph: the one that’s represented by the top edge. The calculation uses the sensitivity properties declared above.": {
      "zh": "这个属性表示图表的最大值：也就是顶部边缘所代表的值。计算使用了上面声明的敏感度属性。",
      "tips": ""
    },
    "The LineGraph.swift file represents the main view of the seismometer. The initializer for LineGraph has four parameters: the data to display, the maximum amount of data in the graph, and the minimum and maximum values corresponding to its bottom and top edges.": {
      "zh": "LineGraph.swift 文件表示地震仪的主视图。LineGraph 的初始化器有四个参数：要显示的数据、图表中的最大数据量，以及对应于其底部和顶部边缘的最小值和最大值。",
      "tips": ""
    },
    "As you explore the seismometer, you’ll notice that the data can contain values outside the minimum and maximum range, but they aren’t displayed because they fall outside the view bounds.": {
      "zh": "当你探索地震仪时，你会注意到数据可能包含在最小值和最大值范围之外的值，但它们不会被显示，因为它们超出了视图边界。",
      "tips": ""
    },
    "These five modifiers configure the line graph display. The .clipped modifier prevents the line from drawing outside its frame. You can use .background to set the background color. By using .accentColor the display can adapt to your app’s theme. Using opacity makes the color less bold.": {
      "zh": "这五个修饰符配置了折线图的显示。.clipped 修饰符防止线条在其框架之外绘制。你可以使用 .background 来设置背景颜色。通过使用 .accentColor，显示可以适应你的应用程序的主题。使用 opacity 使颜色不那么醒目。",
      "tips": ""
    },
    "Try commenting out the .clipped modifier to see what happens with the graph display.": {
      "zh": "尝试注释掉 .clipped 修饰符，看看图表显示会发生什么。",
      "tips": ""
    },
    "You can curve the points of the graph by adding .cornerRadius to the line. Change the number to make the curves broader or narrower. The .padding modifier adds some space around the edges to keep it away from other views.": {
      "zh": "你可以通过在线条上添加 .cornerRadius 来使图表的点变成曲线。更改数字可以使曲线变宽或变窄。.padding 修饰符在边缘周围添加了一些空间，使其远离其他视图。",
      "tips": ""
    },
    "The modifier .aspectRatio gives it a square shape.": {
      "zh": ".aspectRatio 修饰符使其呈正方形。",
      "tips": ""
    },
    "Try changing the number to 2, or 0.3, to see how that affects the display.": {
      "zh": "尝试将数字更改为 2 或 0.3，看看它如何影响显示。",
      "tips": ""
    },
    "The Slider control affects the sensitivity of the graph display. Its first parameter, value: $sensitivity, is a binding to the sensitivity state property.": {
      "zh": "Slider 控件会影响图表显示的敏感度。它的第一个参数 value: $sensitivity 是对敏感度状态属性的绑定。",
      "tips": ""
    },
    "You use bindings to let other views control state properties. In this case, you’re telling the slider it can update the value of sensitivity as the user interacts with it.": {
      "zh": "你可以使用绑定来让其他视图控制状态属性。在当前场景中，你会在用户和滑块交互时告诉它可以更新 sensitivity 变量的值。",
      "tips": ""
    },
    "The next three parameters control features of the slider. in: 0...1: specifies the slider’s range of values, from minimum to maximum. Use the minimumValueLabel and maximumValueLabel parameters to add labels at the left and right ends of the slider, respectively.": {
      "zh": "接下来的三个参数控制滑块的特性。in: 0...1：指定滑块的值范围，从最小值到最大值。minimumValueLabel 和 maximumValueLabel 参数会分别在滑块的左端和右端添加标签。",
      "tips": ""
    },
    "To store a history of motion values to draw the line graph, assign the code inside the braces to the onUpdate property. This tells the motion detector to run that code whenever there’s new data to display. This code takes the latest motion data and adds it to the data array.": {
      "zh": "为了存储绘制折线图所需的运动值历史记录，将大括号内的代码分配给 onUpdate 属性。这会告诉运动检测器在有新数据要显示时运行该代码。该代码会获取最新的运动数据并将其添加到数据数组中。",
      "tips": ""
    },
    "Append the zAcceleration of the device to the data array with every motion detector update. Use zAcceleration to chart up- and downward motion of the device. That makes the graph correspond visually to the movement of the device. When you lift your iPad, the line goes upward on the graph.": {
      "zh": "每次 motion detector 更新时，设备的 zAcceleration 会被追加到 data 数组中。使用 zAcceleration 来绘制设备的上下运动。这使得图表在视觉上与设备的运动相对应。当你抬起 iPad 时，线条在图表上向上移动。",
      "tips": ""
    },
    "Here’s where the maxData property comes into play. After you’ve reached the limit, you’ll drop the first item in the array (the oldest data point) and make a new array out of the result.": {
      "zh": "这里就是 maxData 属性发挥作用的地方。在达到限制后，你将删除数组中的第一个项目（最旧的数据点），并将结果制作成一个新数组。",
      "tips": ""
    },
    "Seismometer Browser": {
      "zh": "地震仪浏览器",
      "tips": ""
    },
    "Learn how the top-level view of the app passes motion data to its child views.": {
      "zh": "学习如何将应用的顶级视图中的运动数据传递给其子视图。",
      "tips": ""
    },
    "The SeismometerBrowser view displays the two options for seismometer display in a list. When you choose a display from the list, the app displays that view. The browser is a container for the other two views, so it also acts as the manager of the MotionDetector instance that gathers motion data from the device.": {
      "zh": "SeismometerBrowser 视图在列表中显示地震仪的两个选项。当你从列表中选择一个显示时，应用会显示该视图。浏览器是其他两个视图的容器，因此它也充当从设备收集运动数据的 MotionDetector 实例的管理器。",
      "tips": ""
    },
    "The detector property holds the MotionDetector instance that’s shared throughout the app. The code annotates the property with @StateObject to indicate that SwiftUI keeps track of its updates. You can share state objects with other views, but this view is its owner.": {
      "zh": "detector 属性保存了在整个应用程序中共享的 MotionDetector 实例。代码使用 @StateObject 以指示 SwiftUI 会跟踪其更新。你可以与其他视图共享该属性，但是该视图是其所有者。",
      "tips": ""
    },
    "To give other views access to the motion detector, you can use the .environmentObject modifier to add it to the app’s environment. Any child view of this view can use it by declaring a property of the same type and annotating it with @EnvironmentObject.": {
      "zh": "为了让其他视图访问运动检测器，你可以使用 .environmentObject 修饰符将其添加到应用程序的环境中。该视图的任何子视图都可以通过声明具有相同类型的属性并使用 @EnvironmentObject 进行注释来使用它。",
      "tips": ""
    },
    "You can use the .onAppear modifier to perform actions when this view first appears. It’s the perfect place to start the motion detector. Use the .onDisappear modifier to stop the detector when the view isn’t visible.": {
      "zh": "你可以使用 .onAppear 修饰符在该视图首次出现时执行操作。这是启动运动检测器的理想位置。使用 .onDisappear 修饰符在视图不可见时停止检测器。",
      "tips": ""
    },
    "Double Extension": {
      "zh": "Double 类型的扩展",
      "tips": ""
    },
    "Investigate using an extension on Double to format text in an easy to read way.": {
      "zh": "探究使用 Double 类型的扩展以便以易于阅读的方式格式化文本。",
      "tips": ""
    },
    "You can use an extension to create custom behaviors for existing types. Declaring extension Double means you’re adding new capabilities to the Double type. When you use a Double value, you can access anything defined in this extension.": {
      "zh": "你可以使用扩展为现有类型创建自定义行为。声明 Double 扩展意味着你正在为 Double 类型添加新功能。当你使用 Double 值时，可以访问在此扩展中定义的任何内容。",
      "tips": ""
    },
    "This method returns a string that describes the value of a Double with a fixed number of digits. You can pass in the number of integer digits and fraction digits you want, or leave those arguments out for the default values of 2.": {
      "zh": "这个方法返回一个字符串，该字符串用固定数量的数字描述 Double 的值。你可以传入你想要的整数位数和小数位数，或者忽略这些参数以使用默认值 2。",
      "tips": ""
    },
    "The formatted() method operates on a number of basic types such as Date, Int, and Double, all of which are commonly represented as strings in an app. Because there are so many ways to format these strings, the formatted() method gives you ways to customize how they’re represented. For example, does a number represent a percentage, a simple value, or maybe a price?": {
      "zh": "formatted() 方法对许多基本类型（如 Date、Int 和 Double）进行操作，所有这些类型在应用程序中通常表示为字符串。因为有很多方法可以格式化这些字符串，所以 formatted() 方法提供了一些方法来自定义它们的表示方式。例如，一个数字表示一个百分比、一个简单的值，或者可能是一个价格？",
      "tips": ""
    },
    "The argument to formatted() is a format style. The .number style gives you a string that describes this Double value as a simple number, as opposed to a percentage or a price.": {
      "zh": "formatted() 的参数是一个 format style 类型。.number 样式为你提供了一个字符串，该字符串将此 Double 值描述为一个简单的数字，而不是一个百分比或价格。",
      "tips": ""
    },
    "The .number style has modifiers much like those for SwiftUI views. For example, the .sign modifier lets you format the number so that it’s always preceded by a sign, even when the number is positive. You can also use the .precision modifier to specify exactly how many digits to use.": {
      "zh": ".number 这种变成风格具有与 SwiftUI 视图相似的修饰符。例如，.sign 修饰符允许你格式化数字，以便即使数字为正数，它也总是以符号开头。你还可以使用 .precision 修饰符来指定要使用的精度。",
      "tips": ""
    },
    "Recognizing Gestures": {
      "zh": "识别手势",
      "tips": ""
    },
    "Update shapes or other content in response to taps, rotations, or other Multi-Touch gestures.": {
      "zh": "当识别到点击、旋转或其他多点触控手势时，更新形状或其他内容。",
      "tips": ""
    },
    "Your device has sensors such as accelerometers and gyroscopes which sense its motion and orientation. The Core Motion framework gives you access to data from these and other sensors.": {
      "zh": "你的设备具有加速度计和陀螺仪等传感器，这些传感器可以感知其运动和方向。Core Motion 框架使你可以访问来自这些和其他传感器的数据。",
      "tips": ""
    }
  },
  "swiftui/animating-views-and-transitions": {
    "Drag the Hikes folder from the downloaded files’ Resources folder into your project’s Views group. Be sure to select “Copy items if needed” and “Create groups” before clicking Finish.": {
      "zh": "将下载文件的资源文件夹中的 Hikes 文件夹拖到您的项目的“Views”组中。在单击“完成”之前，请确保选择“如果需要复制项目”和“创建文件夹”。",
      "tips": ""
    },
    "Familiarize yourself with the new views. They work together to display the hike data loaded into your model.": {
      "zh": "熟悉新视图。它们一起工作，显示加载到您的模型中的徒步旅行数据。",
      "tips": ""
    },
    "SwiftUI includes basic animations with predefined or custom easing, as well as spring and fluid animations. You can adjust an animation’s speed, set a delay before an animation starts, or specify that an animation repeats.": {
      "zh": "SwiftUI 包括具有预定义或自定义缓动的基本动画，以及弹簧和流体动画。你可以调整动画的速度，为动画设置开始前的延迟，或指定动画重复次数。",
      "tips": ""
    },
    "Create a new Swift file called Hike.swift in your project’s Model group using the menu item File > New > File.": {
      "zh": "在项目的 Model 文件夹中，使用菜单项 File > New > File 创建一个名为 Hike.swift 的新 Swift 文件。",
      "tips": ""
    },
    "Switch to using the move(edge:) transition, so that the graph slides in and out from the same side.": {
      "zh": "切换为使用 move(edge:) 过渡，以使图表从同一侧滑入滑出。",
      "tips": ""
    },
    "This keeps your code clean as you expand the custom transition.": {
      "zh": "这样可以在扩展自定义转场时保持代码的整洁。",
      "tips": ""
    },
    "Try turning off animation for the rotation by adding another animation modifier just above the scaleEffect modifier.": {
      "zh": "尝试通过在 scaleEffect 修饰符上方添加另一个动画修饰符来关闭旋转动画。",
      "tips": ""
    },
    "Customize View Transitions": {
      "zh": "自定义视图转场",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Add another animatable change by making the button larger when the graph is visible.": {
      "zh": "当图表可见时，通过使按钮变大来添加另一个动画。",
      "tips": ""
    },
    "Drag the hikeData.json file from the downloaded files’ Resources folder into your project’s Resources group. Be sure to select “Copy items if needed” before clicking Finish.": {
      "zh": "将下载的文件的 Resources 文件夹中的 hikeData.json 文件拖到项目的 Resources 文件夹中。在单击“完成”之前，请确保选择“如有需要复制项目”。",
      "tips": ""
    },
    "By default, views transition on- and offscreen by fading in and out. You can customize this transition by using the transition(_:) modifier.": {
      "zh": "默认情况下，视图会通过淡入淡出的方式在屏幕上显示和消失。你可以使用 transition(:) 修饰符自定义这种转换效果。",
      "tips": ""
    },
    "Speed up the animation a bit, to shorten the time each bar takes to move to its new position.": {
      "zh": "稍微加快动画速度，缩短每个柱子移动到新位置动画所需的时间。",
      "tips": ""
    },
    "Because you’ll never modify hike data after initially loading it, you don’t need to mark it with the @Published attribute.": {
      "zh": "因为你在最初加载后永远不会修改徒步数据，所以不需要使用 @Published 属性标记它。",
      "tips": ""
    },
    "Step 6": {
      "zh": "步骤 6",
      "tips": ""
    },
    "Be sure to use the live preview throughout this tutorial so you can experiment with the results of each step.": {
      "zh": "在本教程中一定要使用实时预览，这样你就可以看到每一步的效果。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实验",
      "tips": ""
    },
    "Change the animation type from easeInOut to spring().": {
      "zh": "将动画类型从 easeInOut 更改为 spring()。",
      "tips": ""
    },
    "Pass a four-second long basic animation to the withAnimation function.": {
      "zh": "将为时四秒的基本动画传递给 withAnimation 函数。",
      "tips": ""
    },
    "In HikeView, change the default value for showDetail to true, and pin the preview to the canvas.": {
      "zh": "在 HikeView 中，将 showDetail 的默认值更改为 true，并将预览固定到画布。",
      "tips": ""
    },
    "Download the starter project and follow along with this tutorial, or open the finished project and explore the code on your own.": {
      "zh": "下载入门项目来跟随本教程操作，或者打开已完成的项目然后自行探索代码。",
      "tips": ""
    },
    "Now the graph appears and disappears by sliding in and out of sight.": {
      "zh": "现在，图表通过滑入滑出的方式出现和消失。",
      "tips": ""
    },
    "Before continuing to the next section, restore the withAnimation function to use the default animation by removing the call’s input parameter.": {
      "zh": "在继续下一节之前，请通过删除调用的输入参数将 withAnimation 函数恢复为使用默认动画。",
      "tips": ""
    },
    "Composing Complex Interfaces": {
      "zh": "",
      "tips": ""
    },
    "Now that you’ve learned how to apply animations to individual views, it’s time to add animations in places where you change your state’s value.": {
      "zh": "既然你已经学会了如何将动画应用到单个视图，现在是时候在更改状态值的地方添加动画了。",
      "tips": ""
    },
    "Load the hikes array into your model object.": {
      "zh": "将 hikes 数组加载到您的模型对象中。",
      "tips": ""
    },
    "You can pass the same kinds of animations to the withAnimation function that you passed to the animation(_:value:) modifier.": {
      "zh": "你可以将与 animation(:value:) 修饰符相同的动画传递给 withAnimation 函数。",
      "tips": ""
    },
    "Step 3": {
      "zh": "步骤 3",
      "tips": ""
    },
    "In this tutorial, you’ll animate a view that contains a graph for tracking the hikes a user takes while using the Landmarks app. Using the animation(_:) modifier, you’ll see just how easy it is to animate a view.": {
      "zh": "在本教程中，你将为一个显示 Landmarks 应用中用户进行徒步旅行的图表视图创建动画。使用 animation(:) 修饰符，你会发现为视图创建动画是多么容易。",
      "tips": ""
    },
    "Step 4": {
      "zh": "步骤 4",
      "tips": ""
    },
    "The animation modifier applies to all animatable changes within the views it wraps.": {
      "zh": "动画修饰符适用于其包装视图中的所有可以执行动画的数值修改。",
      "tips": ""
    },
    "Both of the views affected by the showDetail property — the disclosure button and the HikeDetail view — now have animated transitions.": {
      "zh": "受 showDetail 属性影响的两个视图 - 展开按钮和 HikeDetail 视图 - 现在都有动画过渡。",
      "tips": ""
    },
    "In HikeView.swift, turn on animation for the button’s rotation by adding an animation modifier that begins on changes of the showDetail value.": {
      "zh": "在 HikeView.swift 中，通过添加一个动画修饰符，在 showDetail 值改变时启动按钮旋转的动画。",
      "tips": ""
    },
    "Before you can add animation, you’ll need something to animate. In this section, you’ll import and model hiking data, and then add some prebuilt views for displaying that data statically in a graph.": {
      "zh": "在添加动画之前，你需要有一些内容来执行动画。在本节中，你将导入并建立徒步旅行数据，然后为静态显示数据的图表添加一些预先构建的视图。",
      "tips": ""
    },
    "Section 2": {
      "zh": "第 2 节",
      "tips": ""
    },
    "This makes it possible for you to see the graph in context while you work on the animation in another file.": {
      "zh": "固定预览能够使你在处理另一个文件中的动画时，仍然保持查看固定住的预览。",
      "tips": ""
    },
    "Animate the Effects of State Changes": {
      "zh": "使状态变化的效果动起来",
      "tips": ""
    },
    "Extract the transition that you just added as a static property of AnyTransition, and access the new property in the view’s transition modifier.": {
      "zh": "将刚刚添加的过渡作为 AnyTransition 的静态属性提取，并在视图的过渡修饰符中访问新属性。",
      "tips": ""
    },
    "Add Hiking Data to the App": {
      "zh": "",
      "tips": ""
    },
    "You can see the effect of the animation by switching between elevation, heart rate, and pace in the live preview.": {
      "zh": "你可以通过在实时预览中切换海拔、心率和速度来查看动画效果。",
      "tips": ""
    },
    "Section 3": {
      "zh": "第 3 节",
      "tips": ""
    },
    "When you use the animation(_:) modifier on an equatable view, SwiftUI animates any changes to animatable properties of the view. A view’s color, opacity, rotation, size, and other properties are all animatable. When the view isn’t equatable, you can use the animation(_:value:) modifier to start animations when the specified value changes.": {
      "zh": "当你在可比较的视图上使用 animation(:) 修饰符时，SwiftUI 会为视图的可动画属性的任何更改添加动画。视图的颜色、不透明度、旋转、大小等属性都是可动画的。当视图不可以比较时，你可以使用 animation(_:value:) 修饰符在指定值更改时启动动画。",
      "tips": ""
    },
    "Be sure to unpin the preview before moving on to the next tutorial.": {
      "zh": "在继续下一个教程之前，取消固定预览。",
      "tips": ""
    },
    "Remove both animation modifiers before moving on to the next section.": {
      "zh": "在继续下一部分之前，请删除两个动画修饰符。",
      "tips": ""
    },
    "Switch the animation to a spring animation, with a reduced damping fraction to make the bars hop.": {
      "zh": "将动画切换为弹簧动画，减小阻尼系数，使条形图跳跃。",
      "tips": ""
    },
    "In HikeView.swift, turn on the live preview and experiment with showing and hiding the graph.": {
      "zh": "在HikeView.swift中，打开实时预览并尝试显示和隐藏图表。",
      "tips": ""
    },
    "Observe how the custom animation provides a rippling effect when transitioning between graphs.": {
      "zh": "观察在图表之间过渡时，自定义动画如何展示波纹效果。",
      "tips": ""
    },
    "Slow down the animation to see how SwiftUI animations are interruptible.": {
      "zh": "放慢动画速度，了解 SwiftUI 动画是如何可中断的。",
      "tips": ""
    },
    "Experiment with opening and closing the graph view mid-animation.": {
      "zh": "尝试在动画进行中打开和关闭图形视图。",
      "tips": ""
    },
    "Step 1": {
      "zh": "步骤 1",
      "tips": ""
    },
    "Use the asymmetric(insertion:removal:) modifier to provide different transitions for when the view appears and disappears.": {
      "zh": "使用 asymmetric(insertion:removal:) 修饰符为视图出现和消失时提供不同的过渡动画。",
      "tips": ""
    },
    "Animating Views and Transitions": {
      "zh": "",
      "tips": ""
    },
    "The category view for Landmarks shows a vertically scrolling list of horizontally scrolling landmarks. As you build this view and connect it to your existing views, you’ll explore how composed views can adapt to different device sizes and orientations.": {
      "zh": "Landmarks的类别视图显示一个垂直滚动的水平滚动地标列表。在构建此视图并将其连接到现有视图时，你将探索如何使组合视图适应不同的设备大小和方向。",
      "tips": ""
    },
    "The graph switches between three different sets of data when you click the buttons below the bars. In this section, you’ll use a composed animation to give the capsules that make up the graph a dynamic, rippling transition.": {
      "zh": "当你点击柱子下方的按钮时，图表会在三个不同的数据集之间切换。在本节中，你将使用一个组合动画，为构成图表的胶囊提供动态的波纹过渡效果。",
      "tips": ""
    },
    "Add Animations to Individual Views": {
      "zh": "为单个视图添加动画效果",
      "tips": ""
    },
    "Section 4": {
      "zh": "第 4 节",
      "tips": ""
    },
    "Take SwiftUI for a spin. Try combining different animation effects to see what’s possible.": {
      "zh": "尝试使用 SwiftUI 并结合不同的动画效果，探索其潜力。将各种动画效果组合在一起，看看可以实现什么样的效果。",
      "tips": ""
    },
    "Compose Animations for Complex Effects": {
      "zh": "为复杂效果制作动画",
      "tips": ""
    },
    "Section 5": {
      "zh": "第 5 节",
      "tips": ""
    },
    "Like the Landmark structure, the Hike structure conforms to Codable and has properties that match the keys in the corresponding data file.": {
      "zh": "与 Landmark 结构类似， Hike 结构符合 Codable 并具有与相应数据文件中键匹配的属性。",
      "tips": ""
    },
    "Step 2": {
      "zh": "步骤 2",
      "tips": ""
    },
    "When using SwiftUI, you can individually animate changes to views, or to a view’s state, no matter where the effects are. SwiftUI handles all the complexity of these combined, overlapping, and interruptible animations for you.": {
      "zh": "在使用 SwiftUI 时，你可以单独为视图的变化或视图状态的变化设置动画，无论这些效果设置。SwiftUI 会自动为你处理这些组合、重叠和可中断动画的所有复杂特性。",
      "tips": ""
    },
    "Here, you’ll apply animations to all of the changes that occur when a user taps a button and toggles the showDetail state property.": {
      "zh": "在这里，当用户点击按钮并切换 showDetail 状态属性时，你将针对这个变化应用动画效果。",
      "tips": ""
    },
    "Add a delay to each animation that’s based on the capsule’s position on the graph.": {
      "zh": "根据胶囊在图表上的位置，给每个胶囊动画添加一点延迟。",
      "tips": ""
    },
    "Step 5": {
      "zh": "步骤 5",
      "tips": ""
    },
    "In HikeGraph.swift, define a new ripple animation and apply it to each generated graph capsule.": {
      "zh": "在 HikeGraph.swift 中，定义一个新的波纹动画，并将它应用到每个生成的图表胶囊上。",
      "tips": ""
    },
    "Wrap the call to showDetail.toggle() with a call to the withAnimation function.": {
      "zh": "用 withAnimation 函数包装对 showDetail.toggle() 的调用。",
      "tips": ""
    },
    "Add a transition(_:) modifier to the conditionally visible HikeView.": {
      "zh": "在通过条件判断是否可见的 HikeView 上添加一个 transition(_:) 修饰符。",
      "tips": ""
    }
  },
  "swiftui/building-lists-and-navigation": {
    "Copy the contents of the body property from ContentView into LandmarkDetail.": {
      "zh": "将 ContentView 中 body 属性的内容复制到 LandmarkDetail。",
      "tips": ""
    },
    "Create a new Swift file in your project and name it ModelData.swift.": {
      "zh": "在项目中创建一个新的 Swift 文件，命名为 ModelData.swift。",
      "tips": ""
    },
    "The Landmark data already has the id property required by Identifiable protocol; you only need to add a property to decode it when reading the data.": {
      "zh": "Landmark 数据已经具有 Identifiable 协议所需的 id 属性；你只需在读取数据时添加一个属性来对它进行解码。",
      "tips": ""
    },
    "Compute a locationCoordinate property that’s useful for interacting with the MapKit framework.": {
      "zh": "计算一个与 MapKit 框架交互时有用的 locationCoordinate 属性。",
      "tips": ""
    },
    "In the LandmarkDetail file, pass the required data to your custom types.": {
      "zh": "在 LandmarkDetail 文件中，将需要的数据设置到你的自定义的视图上。",
      "tips": ""
    },
    "To fix the preview, you’ll need to modify the preview provider.": {
      "zh": "要修复预览，你需要修改预览数据提供类。",
      "tips": ""
    },
    "Xcode’s canvas automatically recognizes and displays any type in the current editor that conforms to the PreviewProvider protocol. A preview provider returns one or more views, with options to configure the size and device.": {
      "zh": "Xcode 的画布会自动识别并显示当前编辑器中遵循 PreviewProvider 协议的任何类型。预览提供类返回一个或多个视图，并且可以选择尺寸和预览设备。",
      "tips": ""
    },
    "Use the previewDisplayName(_:) modifier to add the device names as labels for the previews.": {
      "zh": "使用 previewDisplayName(:) 修饰符设置设备名称。",
      "tips": ""
    },
    "Add a method that updates the region based on a coordinate value.": {
      "zh": "添加一个根据坐标值更新区域的方法。",
      "tips": ""
    },
    "Switch back to LandmarkList.swift and remove the id parameter.": {
      "zh": "切换回 LandmarkList.swift 并删除 id 参数。",
      "tips": ""
    },
    "Embed the dynamically generated list of landmarks in a NavigationView.": {
      "zh": "将动态生成的地标列表嵌入 NavigationView。",
      "tips": ""
    },
    "Step 6": {
      "zh": "步骤 6",
      "tips": ""
    },
    "Download the project files to begin building this project, and follow the steps below.": {
      "zh": "下载项目文件来开始构建此项目，并按照以下步骤操作。",
      "tips": ""
    },
    "Modify the text view to use the landmark property’s name.": {
      "zh": "修改文本视图为地标属性的名称。",
      "tips": ""
    },
    "In the previews static property of LandmarkRow_Previews, add the landmark parameter to the LandmarkRow initializer, specifying the first element of the landmarks array.": {
      "zh": "在 LandmarkRow_Previews 的静态属性中，向 LandmarkRow 传入地标数组的第一个元素进行初始化。",
      "tips": ""
    },
    "In the next few steps, you’ll add navigation among your list and detail views.": {
      "zh": "接下来几步，你将在列表和详细视图之间添加导航。",
      "tips": ""
    },
    "Step 8": {
      "zh": "步骤 8",
      "tips": ""
    },
    "You can experiment with different devices to compare the renderings of your views, all from the canvas.": {
      "zh": "你可以尝试使用不同设备比较视图的呈现效果，这些都可以在画布上展示。",
      "tips": ""
    },
    "Starting with the child views, you’ll convert CircleImage, MapView, and then LandmarkDetail to display data that’s passed in, rather than hard-coding each row.": {
      "zh": "从子视图开始，你将让 CircleImage、MapView 和 LandmarkDetail 显示传入的数据，而不是对每行进行硬编码。",
      "tips": ""
    },
    "You make the property private because users of the Landmarks structure care only about the image itself.": {
      "zh": "你将属性设置为私有，因为 Landmarks 结构的使用方只关心图像本身，不需要知道图片名称。",
      "tips": ""
    },
    "Call the navigationTitle(_:) modifier method to set the title of the navigation bar when displaying the list.": {
      "zh": "在显示列表时调用 navigationTitle(_:) 修饰符方法设置导航栏的标题。",
      "tips": ""
    },
    "Create a new SwiftUI view in the Views group named LandmarkRow.swift.": {
      "zh": "在 Views 文件夹中创建一个名为 LandmarkRow.swift 的新 SwiftUI 视图。",
      "tips": ""
    },
    "You can provide the name of any device as it appears in Xcode’s scheme menu.": {
      "zh": "你可以设置 Xcode 方案菜单中显示的任何设备的名称。",
      "tips": ""
    },
    "Finally, call the navigationTitle(_:) modifier to give the navigation bar a title when showing the detail view, and the navigationBarTitleDisplayMode(_:) modifier to make the title appear inline.": {
      "zh": "最后，调用 navigationTitle(:) 修饰符为显示详细视图时的导航栏设置标题，并使用 navigationBarTitleDisplayMode(:) 修饰符使标题显示成行内的样式。",
      "tips": ""
    },
    "When you add the landmark property, the preview stops working, because the LandmarkRow type needs a landmark instance during initialization.": {
      "zh": "当你添加 landmark 属性时，预览会停止工作，因为 LandmarkRow 类型在初始化过程中需要一个地标实例。",
      "tips": ""
    },
    "Complete the dynamically-generated list by returning a LandmarkRow from the closure.": {
      "zh": "通过从闭包返回 LandmarkRow 完成动态生成的列表。",
      "tips": ""
    },
    "In LandmarkRow_Previews, update the landmark parameter to be the second element in the landmarks array.": {
      "zh": "在 LandmarkRow_Previews 中，将地标参数设置为地标数组中的第二个元素。",
      "tips": ""
    },
    "The preview shows the two landmarks rendered in a list style that’s appropriate for iOS.": {
      "zh": "预览显示了适用于 iOS 平台的列表样式，上面呈现了我们传入的两个地标。",
      "tips": ""
    },
    "The first view you’ll build in this tutorial is a row for displaying details about each landmark. This row view stores information in a property for the landmark it displays, so that one view can display any landmark. Later, you’ll combine multiple rows into a list of landmarks.": {
      "zh": "在本教程中，你将构建的第一个视图是一个用于显示每个地标详细信息的行。这个行视图将它需要显示的地标的信息存储在一个属性中，这样通过传入不同的地标数据，一个视图就可以显示任何地标。稍后，你将把多个行视图组合成一个地标列表。",
      "tips": ""
    },
    "When you use SwiftUI’s List type, you can display a platform-specific list of views. The elements of the list can be static, like the child views of the stacks you’ve created so far, or dynamically generated. You can even mix static and dynamically generated views.": {
      "zh": "当你使用 SwiftUI 的 List 类型时，可以显示一个特定平台上的视图列表。列表中的元素可以是静态的，就像你迄今为止创建的堆栈的子视图一样，也可以是动态生成的。你甚至可以将静态和动态生成的视图混合在一起展示。",
      "tips": ""
    },
    "Section 1": {
      "zh": "第 1 节",
      "tips": ""
    },
    "The navigation changes only have an effect when the view is part of a navigation stack.": {
      "zh": "导航更改仅在视图是导航堆栈的一部分时才会生效。",
      "tips": ""
    },
    "Building Lists and Navigation": {
      "zh": "",
      "tips": ""
    },
    "Choose File > New > File to create a new Swift file in your project, and name it Landmark.swift.": {
      "zh": "在项目中创建一个新的Swift文件，命名为 Landmark.swift。",
      "tips": ""
    },
    "Start by changing the current list preview to render at the size of an iPhone SE.": {
      "zh": "首先将当前列表预览更改为以 iPhone SE 的大小呈现。",
      "tips": ""
    },
    "Switch to Landmark.swift and declare conformance to the Identifiable protocol.": {
      "zh": "切换到 Landmark.swift 并声明遵循 Identifiable 协议。",
      "tips": ""
    },
    "If the preview isn’t visible already, show the canvas by choosing Editor > Canvas, and then click Resume.": {
      "zh": "如果预览尚未显示，请选择 Editor > Canvas 显示画布，然后点击 Resume。",
      "tips": ""
    },
    "Inside the list’s closure, wrap the returned row in a NavigationLink, specifying the LandmarkDetail view as the destination.": {
      "zh": "在列表的闭包内部，将 LandmarkRow 包装在 NavigationLink 中，将 LandmarkDetail 视图指定为导航跳转的目标。",
      "tips": ""
    },
    "Create an array of landmarks that you initialize from landmarkData.json.": {
      "zh": "创建一个由 landmarkData.json 初始化的地标数组。",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "To simplify the code, move the previewLayout(_:) call to the outside of the group’s child declarations.": {
      "zh": "为简化代码，将 previewLayout(_:) 调用移到 Group 的子声明之外。",
      "tips": ""
    },
    "You can create groups of existing items by selecting the items to add to the group, and then choosing File > New > Group from Selection in the Xcode menu.": {
      "zh": "你可以先选中多个项目，然后在 Xcode 菜单中选择 File > New > Group from Selection，就能将选择的文件整理到一个文件夹中。",
      "tips": ""
    },
    "Create the List of Landmarks": {
      "zh": "创建地标列表",
      "tips": ""
    },
    "Create a new SwiftUI view named LandmarkDetail.swift.": {
      "zh": "创建一个名为 LandmarkDetail.swift 的新 SwiftUI 视图。",
      "tips": ""
    },
    "ForEach operates on collections the same way as the list, which means you can use it anywhere you can use a child view, such as in stacks, lists, groups, and more. When the elements of your data are simple value types — like the strings you’re using here — you can use \\.self as key path to the identifier.": {
      "zh": "ForEach 与列表一样操作数组，这意味着你可以在任何可以使用子视图的地方使用它，例如堆栈、列表、组等。当你的数据元素是简单的值类型（例如这里使用的字符串）时，可以使用 .self 作为标识符的路径。",
      "tips": ""
    },
    "Create a Landmark Model": {
      "zh": "创建地标数据模型",
      "tips": ""
    },
    "In the Landmarks app, a user can flag their favorite places, and filter the list to show just their favorites. To create this feature, you’ll start by adding a switch to the list so users can focus on just their favorites, and then you’ll add a star-shaped button that a user taps to flag a landmark as a favorite.": {
      "zh": "在 Landmarks 应用中，用户可以标记他们最喜欢的地方，并过滤列表仅显示他们的收藏夹。要创建此功能，你将首先在列表中添加一个开关，以便用户仅关注他们的收藏夹，然后添加一个星形按钮，用户点击以将地标标记为收藏。",
      "tips": ""
    },
    "Add landmark as a stored property of LandmarkRow.": {
      "zh": "添加 landmark 作为 LandmarkRow 的存储属性。",
      "tips": ""
    },
    "Pass Data into Child Views": {
      "zh": "将数据传到子视图",
      "tips": ""
    },
    "Step 3": {
      "zh": "步骤 3",
      "tips": ""
    },
    "This change also affects the build because the detail view has a map view that needs the new parameter. You’ll fix the detail view soon.": {
      "zh": "此更改也会影响编译，因为详细视图中的地图视图需要传入一个地图参数。不过别担心，你将很快修复这个问题。",
      "tips": ""
    },
    "Section 2": {
      "zh": "第 2 节",
      "tips": ""
    },
    "Before moving on, group related files together to make it easier to manage your growing project.": {
      "zh": "在继续之前，请将相关文件分文件夹管理，让项目结构更加清晰。",
      "tips": ""
    },
    "You can create a list that displays the elements of a collection by passing your collection of data and a closure that provides a view for each element in the collection. The list transforms each element in the collection into a child view by using the supplied closure.": {
      "zh": "你可以通过传递数据集合和提供集合中每个元素的视图的闭包来创建显示集合元素的列表。列表使用提供的闭包将集合中的每个元素转换为子视图。",
      "tips": ""
    },
    "Instead of specifying a list’s elements individually, you can generate rows directly from a collection.": {
      "zh": "你可以直接从集合生成行，而不是单独指定列表的元素。",
      "tips": ""
    },
    "In LandmarkList.swift, pass the current landmark to the destination LandmarkDetail.": {
      "zh": "在 LandmarkList.swift 中，将当前地标传给 LandmarkDetail。",
      "tips": ""
    },
    "You add navigation capabilities to a list by embedding it in a NavigationView, and then nesting each row in a NavigationLink to set up a transtition to a destination view.": {
      "zh": "你可以将列表嵌入 NavigationView 中并将每行嵌套在 NavigationLink 中，来实现到详情视图的导航功能。",
      "tips": ""
    },
    "Step 10": {
      "zh": "步骤 10",
      "tips": ""
    },
    "Section 4": {
      "zh": "第 4 节",
      "tips": ""
    },
    "Lists work with identifiable data. You can make your data identifiable in one of two ways: by passing along with your data a key path to a property that uniquely identifies each element, or by making your data type conform to the Identifiable protocol.": {
      "zh": "列表可以处理可识别的数据。你可以通过以下两种方式之一使你的数据可识别：传递一个能够标识数据唯一的属性的关键路径，或使你的数据类型遵循 Identifiable 协议。",
      "tips": ""
    },
    "You mark this property as private because you’ll use it only to create a public computed property in the next step.": {
      "zh": "将此属性标记为私有，因为你只会在下一步中使用它来创建一个公共计算属性。",
      "tips": ""
    },
    "This creates one LandmarkRow for each element in the landmarks array.": {
      "zh": "这会为地标数组中的每个元素创建一个 LandmarkRow。",
      "tips": ""
    },
    "Generate Previews Dynamically": {
      "zh": "动态生成预览",
      "tips": ""
    },
    "Drag the JPG files from the project files’ Resources folder into your project’s asset catalog. Xcode creates a new image set for each image.": {
      "zh": "将下载的项目文件中的 Resources 文件夹中的 JPG 文件拖到项目的资源目录中（Assets.xcassets）。Xcode 会为每个图像创建一个新的图像集合。",
      "tips": ""
    },
    "Switch to the live preview to see the detail view show the correct landmarks when you navigate from the list.": {
      "zh": "切换到实时预览，查看从列表导航时详细视图是否显示正确的地标。",
      "tips": ""
    },
    "With all of the connections established, the preview begins working again.": {
      "zh": "在建立完所有连接后，预览重新开始工作。",
      "tips": ""
    },
    "Next, you’ll simplify the List code by adding Identifiable conformance to the Landmark type.": {
      "zh": "接下来，你将通过向 Landmark 类型添加 Identifiable 协议来简化 List 代码。",
      "tips": ""
    },
    "In LandmarkDetail.swift, add a Landmark property to the LandmarkDetail type.": {
      "zh": "在 LandmarkDetail.swift 中，将 Landmark 属性添加到 LandmarkDetail 类型。",
      "tips": ""
    },
    "Step 7": {
      "zh": "步骤 7",
      "tips": ""
    },
    "Step 5": {
      "zh": "步骤 5",
      "tips": ""
    },
    "Customize the Row Preview": {
      "zh": "自定义行预览",
      "tips": ""
    },
    "Adding Codable conformance makes it easier to move data between the structure and a data file. You’ll rely on the Decodable component of the Codable protocol later in this section to read data from file.": {
      "zh": "遵循 Codable 协议可以使结构体和 json 数据文件之间的转换变得简单。稍后，你将会用到 Codable 协议中的Decodable 组件从文件中读取数据。",
      "tips": ""
    },
    "In MapView.swift, add a coordinate property to MapView and update the preview provider to pass a fixed coordinate.": {
      "zh": "在 MapView.swift 中，向 MapView 添加一个坐标（coordinate）属性，并修改预览提供类传入一个固定坐标。",
      "tips": ""
    },
    "Tip": {
      "zh": "提示",
      "tips": ""
    },
    "In the next few steps you’ll model the image associated with each landmark.": {
      "zh": "接下来的几个步骤中，你将为每个地标关联一个图像。",
      "tips": ""
    },
    "Use the completed project from the previous tutorial and the resources available from this tutorial’s project files to get started.": {
      "zh": "为了有更好的学习效果，建议使用上一个教程已经完成的项目以及本节教程项目文件夹中提供的资源。",
      "tips": ""
    },
    "The code you write in a preview provider only changes what Xcode displays in the canvas.": {
      "zh": "你在预览提供程序中编写的代码只会更改 Xcode 在画布中显示的内容。",
      "tips": ""
    },
    "Change the container from a VStack to a ScrollView so the user can scroll through the descriptive content, and delete the Spacer, which you no longer need.": {
      "zh": "将容器从 VStack 更改为 ScrollView，以便用户可以滚动查看内容描述，删除你不再需要的 Spacer。",
      "tips": ""
    },
    "Even though you’ve fixed the preview logic, the preview fails to update because the build fails. The detail view, which instantiates a circle image, needs an input parameter as well.": {
      "zh": "尽管你已经修复了预览逻辑，但由于编译失败，预览无法更新。因为详细视图（CircleImage）也需要输入参数。",
      "tips": ""
    },
    "Step 11": {
      "zh": "步骤 11",
      "tips": ""
    },
    "Use the previewLayout(_:) modifier to set a size that approximates a row in a list.": {
      "zh": "使用 previewLayout(_:) 修饰符设置预览窗口的大小。",
      "tips": ""
    },
    "In CircleImage.swift, add a stored image property to CircleImage.": {
      "zh": "在 CircleImage.swift 中，向 CircleImage 添加一个名为 image 的存储属性。",
      "tips": ""
    },
    "Replace the default Text view with a List, and provide LandmarkRow instances with the first two landmarks as the list’s children.": {
      "zh": "用 List 替换默认的 Text 视图，并为列表的子视图提供带有前两个地标的 LandmarkRow 实例。",
      "tips": ""
    },
    "Make the List Dynamic": {
      "zh": "让列表根据数据动态变化",
      "tips": ""
    },
    "Embed the existing text view in an HStack.": {
      "zh": "将现有文本视图嵌入到 HStack 中。",
      "tips": ""
    },
    "Put ContentView.swift, CircleImage.swift, and MapView.swift into a Views group, landmarkData.json in a Resources group, and Landmark.swift and ModelData.swift into a Model group.": {
      "zh": "将 ContentView.swift、CircleImage.swift 和 MapView.swift 放入一个 Views 分组，将 landmarkData.json 放入 Resources 分组，将 Landmark.swift 和 ModelData.swift 放入 Model 分组。",
      "tips": ""
    },
    "The list renders properly, but you can’t tap an individual landmark to see that landmark’s detail page yet.": {
      "zh": "列表渲染正常，但你还不能点击单个地标来查看该地标的详细页面。",
      "tips": ""
    },
    "Section 8": {
      "zh": "第 8 节",
      "tips": ""
    },
    "A view’s children inherit the view’s contextual settings, such as preview configurations.": {
      "zh": "视图的子视图会继承视图的上下文设置，例如预览大小设置。",
      "tips": ""
    },
    "The LandmarkDetail view still uses hard-coded details to show its landmark. Just like LandmarkRow, the LandmarkDetail type and the views it comprises need to use a landmark property as the source for their data.": {
      "zh": "LandmarkDetail 视图仍然使用硬编码的方式来展示地标信息。就像 LandmarkRow 一样，LandmarkDetail 类型及其组成的视图需要使用 landmark 属性作为数据源。",
      "tips": ""
    },
    "Create a new SwiftUI view in the Views group named LandmarkList.swift.": {
      "zh": "在 Views 文件夹中创建一个名为 LandmarkList.swift 的新 SwiftUI 视图。",
      "tips": ""
    },
    "Section 5": {
      "zh": "第 5 节",
      "tips": ""
    },
    "Section 6": {
      "zh": "第 6 节",
      "tips": ""
    },
    "From now on, you’ll be able to use collections of Landmark elements directly.": {
      "zh": "从现在开始，你将能够直接使用地标数组进行初始化。",
      "tips": ""
    },
    "Step 2": {
      "zh": "步骤 2",
      "tips": ""
    },
    "Add an onAppear view modifier to the map that triggers a calculation of the region based on the current coordinate.": {
      "zh": "向地图添加一个 onAppear 视图修饰符，该修饰符会在地图视图显示的时候根据当前坐标计算区域。",
      "tips": ""
    },
    "This is a common pattern when building views using SwiftUI. Your custom views will often wrap and encapsulate a series of modifiers for a particular view.": {
      "zh": "这是使用 SwiftUI 构建视图时的常见模式。你的自定义视图通常会包装并封装特定视图的一系列修饰符。",
      "tips": ""
    },
    "You can use a Group to return multiple previews from a preview provider.": {
      "zh": "你可以使用 Group 从预览提供程序返回多个预览。",
      "tips": ""
    },
    "Within the list preview, embed the LandmarkList in a ForEach instance, using an array of device names as the data.": {
      "zh": "在列表预览中，将 LandmarkList 嵌入到一个 ForEach 实例中，将设备名称数组作为数据。",
      "tips": ""
    },
    "Drag landmarkData.json in the downloaded files’ Resources folder into your project’s navigation pane; in the dialog that appears, select “Copy items if needed” and the Landmarks target, and then click Finish.": {
      "zh": "将下载好的 Resources 文件夹中的 landmarkData.json 拖放到项目的导航栏中；在出现的对话框中，选择“Copy items if needed”并且勾选 Landmarks target，然后点击完成。",
      "tips": "这一步的意思是如果有需要将资源文件拷贝到我们项目目录中。"
    },
    "Create a load(_:) method that fetches JSON data with a given name from the app’s main bundle.": {
      "zh": "创建一个 load(_:) 方法，该方法从应用程序的主包（main bundle）中获取指定名称的 JSON 数据。",
      "tips": ""
    },
    "In the first tutorial, you hard-coded information into all of your custom views. Here, you’ll create a model to store data that you can pass into your views.": {
      "zh": "在第一个教程中，你将数据写死在所有自定义视图中。在本节，你将创建一个模型来存储可以传递给视图的数据。",
      "tips": ""
    },
    "With the basic landmark detail view set up, you need to provide a way for users to see the full list of landmarks, and to view the details about each location.": {
      "zh": "在基本地标详细信息视图设置好之后，你需要提供一种途径让用户查看所有地标列表，并查看每个地点的详细信息。",
      "tips": ""
    },
    "You can try out the navigation directly in the preview by switching to live mode. Click the Live Preview button and tap a landmark to visit the detail page.": {
      "zh": "你可以直接在预览中尝试导航，方法是切换到实时模式。点击实时预览按钮，点击一个地标来访问详细页面。",
      "tips": ""
    },
    "Define a Landmark structure with a few properties matching names of some of the keys in the landmarkData.json data file.": {
      "zh": "定义一个 Landmark 结构体，其中包含一些与 landmarkData.json 数据文件中的键名相对应的属性。",
      "tips": ""
    },
    "Next, you’ll manage information about the landmark’s location.": {
      "zh": "接下来，你将管理地标位置的信息。",
      "tips": ""
    },
    "You’ll use this sample data throughout the remainder of this tutorial, and for all that follow.": {
      "zh": "你将在本教程剩余部分和所有后续教程中使用这些示例数据。",
      "tips": ""
    },
    "Next, you’ll add code to the LandmarkList_Previews preview provider to render previews of the list view at different device sizes. By default, previews render at the size of the device in the active scheme. You can change the preview device by calling the previewDevice(_:) modifier method.": {
      "zh": "接下来，你将为 LandmarkList_Previews 添加代码，在不同设备大小上呈现列表视图的预览。默认情况下，预览会以活动方案中的设备大小呈现。你可以通过调用 previewDevice(:) 修饰符方法更改预览设备。",
      "tips": ""
    },
    "Group is a container for grouping view content. Xcode renders the group’s child views as separate previews in the canvas.": {
      "zh": "Group 是对视图内容进行分组的容器。Xcode 在画布中将 Group 的子视图渲染为单独的预览。",
      "tips": ""
    },
    "Remove the two static landmark rows, and instead pass the model data’s landmarks array to the List initializer.": {
      "zh": "删除两个静态地标行，并将模型数据的地标数组作为参数传递给 List 的初始化函数。",
      "tips": ""
    },
    "Section 7": {
      "zh": "第 7 节",
      "tips": ""
    },
    "Add an imageName property to read the name of the image from the data, and a computed image property that loads an image from the asset catalog.": {
      "zh": "添加一个 imageName 属性，用于对应 json 数据中的图像名称，以及一个计算属性 image，用来从资源目录中加载图像。",
      "tips": ""
    },
    "Wrap the returned row in a Group, and add the first row back again.": {
      "zh": "将 LandmarkRow 包裹在 Group 中，并再次设置第一个 landmark 数据进行预览。",
      "tips": ""
    },
    "Change ContentView to instead display LandmarkList.": {
      "zh": "更改 ContentView 来显示 LandmarkList。",
      "tips": ""
    },
    "You’ll create views that can show information about any landmark, and dynamically generate a scrolling list that a user can tap to see a detail view for a landmark. To fine-tune the UI, you’ll use Xcode’s canvas to render multiple previews at different device sizes.": {
      "zh": "你将创建可以显示任何地标信息的视图，并动态生成一个用户可以点击查看地标详细信息的滚动列表。为了微调 UI，你将使用 Xcode 的画布预览不同设备尺寸下的视图。",
      "tips": ""
    },
    "Step 4": {
      "zh": "步骤 4",
      "tips": ""
    },
    "You can customize the returned content from a preview provider to render exactly the previews that are most helpful to you.": {
      "zh": "你可以自定义预览提供类返回的内容，来呈现对你最有帮助的预览。",
      "tips": ""
    },
    "Complete the row by adding an image before the text view, and a spacer after it.": {
      "zh": "在文本视图之前添加一个图片，在文本视图之后添加一个间隔符，完成这一行的构建。",
      "tips": ""
    },
    "Step 9": {
      "zh": "步骤 9",
      "tips": ""
    },
    "The load method relies on the return type’s conformance to the Decodable protocol, which is one component of the Codable protocol.": {
      "zh": "load 方法使用到了 swift 语法中的泛型，返回值遵循 Decodable 协议，它是 Codable 协议的一个组成部分。",
      "tips": ""
    },
    "Create the Row View": {
      "zh": "创建行视图",
      "tips": ""
    },
    "Section 3": {
      "zh": "第 3 节",
      "tips": ""
    },
    "Step 1": {
      "zh": "步骤 1",
      "tips": ""
    },
    "Set Up Navigation Between List and Detail": {
      "zh": "在列表和详情页面之间设置导航",
      "tips": ""
    },
    "Finally, you’ll create an array initialized with landmarks from a file.": {
      "zh": "最后，你将创建一个用 json 文件中的地标初始化的数组。",
      "tips": ""
    },
    "Prepare a detail view using the content you created in the previous tutorial and update the main content view to display the list view instead.": {
      "zh": "使用上一个教程中创建的内容来准备搭建详细视图，并更新主内容视图为列表视图。",
      "tips": ""
    },
    "The preview immediately changes to show the second sample landmark instead of the first.": {
      "zh": "预览会立即刷新显示第二个示例地标。",
      "tips": ""
    },
    "Update the preview provider to pass the image of Turtle Rock.": {
      "zh": "更新预览提供类传入 Turtle Rock 的图像数据。",
      "tips": ""
    },
    "Handling User Input": {
      "zh": "",
      "tips": ""
    },
    "With that fixed, you can build the layout for the row.": {
      "zh": "修复报错后，你就可以开始构建行的布局。",
      "tips": ""
    },
    "Add a coordinates property to the structure using a nested Coordinates type that reflects the storage in the JSON data structure.": {
      "zh": "使用嵌套的 Coordinates 类型，对应 json 数据结构中的嵌套类型，这样可以将 coordinates 属性添加到结构中。",
      "tips": ""
    },
    "The preview displays the text, “Hello, World!”.": {
      "zh": "预览显示文本：“Hello, World!”。",
      "tips": ""
    },
    "The new images join the one for Turtle Rock that you added in the previous tutorial.": {
      "zh": "新图像包含了上一个教程中添加的 Turtle Rock 图像。",
      "tips": ""
    }
  },
  "swiftui/composing-complex-interfaces": {
    "The Landmark.Category case name identifies each item in the list, which must be unique among other categories because it’s an enumeration.": {
      "zh": "Landmark.Category 枚举中的每个case名称用于标识列表中的每一项，因为它是一个枚举，所以在其他类别中必须是唯一的。",
      "tips": ""
    },
    "Complete the Category View": {
      "zh": "",
      "tips": ""
    },
    "You use navigation views along with NavigationLink instances and related modifiers to build hierarchical navigation structures in your app.": {
      "zh": "你可以使用导航视图以及 NavigationLink 实例和相关修饰符在应用中构建分层导航结构。",
      "tips": ""
    },
    "The category item itself is the label for the button, and its destination is the landmark detail view for the landmark represented by the card.": {
      "zh": "类别项作为按钮的标签，其导航目标是卡片所代表地标的地标详细视图。",
      "tips": ""
    },
    "Add the rows and the featured image to the category home page.": {
      "zh": "将行和特色图像添加到类别主页。",
      "tips": ""
    },
    "In CategoryHome.swift, create a modelData environment object.": {
      "zh": "在 CategoryHome.swift 中，创建一个 modelData 环境对象。",
      "tips": ""
    },
    "The landmarkData.json file already includes a category value for each landmark with one of three string values. By matching the names in the data file, you can rely on the structure’s Codable conformance to load the data.": {
      "zh": "landmarkData.json 文件已经为每个地标包含了一个类别，包含了这三个属性。通过匹配数据文件中的名称，你可以依赖结构体的 Codable 协议来加载数据。",
      "tips": ""
    },
    "Step 5": {
      "zh": "步骤 5",
      "tips": ""
    },
    "Create a new custom view called CategoryItem that displays one landmark.": {
      "zh": "创建一个名为 CategoryItem 的新自定义视图，用于显示一个地标。",
      "tips": ""
    },
    "In CategoryHome.swift, add the image of the first featured landmark to the top of the list.": {
      "zh": "在 CategoryHome.swift 中，将第一个特色地标的图片添加到列表顶部。",
      "tips": ""
    },
    "With all of the differently categorized landmarks visible in the view, the user needs a way to reach each section in the app. Use the navigation and presentation APIs to make the category home, the detail view, and favorites list navigable from a tab view.": {
      "zh": "由于视图中显示了所有不同分类的地标，因此用户需要一种方法来访问应用程序中的每个部分。使用导航和演示 API 使类别主页、详细信息视图和收藏夹列表可从选项卡视图导航。",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Create a Category Row": {
      "zh": "创建一个横向滚动显示的类别组",
      "tips": ""
    },
    "Set the edge insets to zero on both kinds of landmark previews so the content can extend to the edges of the display.": {
      "zh": "将两种地标预览的边缘间距设置为零，让内容可以延伸到显示器的边缘。",
      "tips": ""
    },
    "Define a new custom view CategoryRow for holding the contents of a row.": {
      "zh": "定义一个新的自定义视图 CategoryRow 以显示这一行的内容。",
      "tips": ""
    },
    "Step 6": {
      "zh": "步骤 6",
      "tips": ""
    },
    "Text that you pass as the label for a navigation link renders using the environment’s accent color, and images may render as template images. You can modify either behavior to best suit your design.": {
      "zh": "作为导航链接标签的文本会使用环境的强调色进行渲染，而图像可能作为模板图像渲染。您可以根据设计需求修改这两种展示效果。",
      "tips": ""
    },
    "You’ll turn this view into an interactive carousel in a later tutorial. For now, it displays one of the featured landmarks with a scaled and cropped preview image.": {
      "zh": "在后续教程中，你将会把此视图变成一个交互式轮播。现在，它以缩放和裁剪的预览图像显示一个特色地标。",
      "tips": ""
    },
    "In Landmark.swift, add a new isFeatured property.": {
      "zh": "在 Landmark.swift 中，添加一个新的 isFeatured 属性。",
      "tips": ""
    },
    "Composing Complex Interfaces": {
      "zh": "",
      "tips": ""
    },
    "Add properties for the category name and the list of items in that category.": {
      "zh": "添加类别名称和项目列表属性。",
      "tips": ""
    },
    "Reuse parts of the Landmark view you created in Creating and Combining Views to create familiar previews of a landmark.": {
      "zh": "重用您在“创建和组合视图”中创建的Landmark视图的部分内容，以生成熟悉的地标预览。",
      "tips": ""
    },
    "Add a state variable for the tab selection, and give it a default value.": {
      "zh": "添加一个用于表示当前 Tab 的状态变量，并为其设置一个默认值。",
      "tips": ""
    },
    "You can provide a different way to browse the landmarks by creating a view that sorts landmarks by category, while highlighting a featured landmark at the top of the view.": {
      "zh": "你可以提供一种不同的方式来浏览地标，方法是创建一个按类别对地标进行排序的视图，同时在视图顶部突出显示特色地标。",
      "tips": ""
    },
    "Display the name of the category.": {
      "zh": "显示类别的名称。",
      "tips": ""
    },
    "Add a NavigationView to host the different categories.": {
      "zh": "添加一个 NavigationView 来导航到不同的类别。",
      "tips": ""
    },
    "Next, you’ll add a featured landmark to the top of the view. You’ll need more information from the landmark data to do this.": {
      "zh": "接下来，你将在视图顶部添加一个特色地标。为此，你需要从地标数据中获取更多信息。",
      "tips": ""
    },
    "Step 3": {
      "zh": "步骤 3",
      "tips": ""
    },
    "Create a tab view that wraps the LandmarkList, as well as the new CategoryHome.": {
      "zh": "创建一个包装 LandmarkList 以及新的 CategoryHome 的底部标签视图。",
      "tips": ""
    },
    "Step 4": {
      "zh": "步骤 4",
      "tips": ""
    },
    "Like for other landmark properties you’ve added, this Boolean already exists in the data — you just need to declare a new property.": {
      "zh": "与你添加的其他地标属性一样，这个布尔值已经存在于数据中，你只需要声明一个新属性。",
      "tips": ""
    },
    "In the Landmarks app, users can create a profile to express their personality. To give users the ability to change their profile, you’ll add an edit mode and design the preferences screen.": {
      "zh": "在 Landmarks 应用中，用户可以创建一个个人资料以表达自己的个性。为了让用户能够更改个人资料，你将添加一个编辑模式并设计偏好设置屏幕。",
      "tips": ""
    },
    "Pin the preview so you can see the effect of the next step on the CategoryRow.": {
      "zh": "固定预览，以便您可以在 CategoryRow 上看到下一步的效果。",
      "tips": ""
    },
    "The tag(_:) modifier on each of the views matches one of the possible values that the selection property can take so the TabView can coordinate which view to display when the user makes a selection in the user interface.": {
      "zh": "每个视图上的 tag(_:) 修饰符 与 selection 属性可能具有的值之一相匹配，这样 TabView 就可以显示用户在用户界面进行选择的视图。",
      "tips": ""
    },
    "Display the categories in Landmarks using a List.": {
      "zh": "使用 List 显示 Landmarks 中的类别。",
      "tips": ""
    },
    "Section 2": {
      "zh": "第 2 节",
      "tips": ""
    },
    "In CategoryRow.swift, replace the Text that holds the landmark name with the new CategoryItem view.": {
      "zh": "在 CategoryRow.swift 中，用新的 CategoryItem 视图替换包含地标名称的 Text。",
      "tips": ""
    },
    "Add a Category View": {
      "zh": "添加一个类别视图",
      "tips": ""
    },
    "Updating the view preview with a larger sampling of data makes it easier to ensure that the scrolling behavior is correct.": {
      "zh": "使用多数据更新视图预览，可以更容易地确保滚动行为正确。",
      "tips": ""
    },
    "Follow the steps to build this project, or download the finished project to explore on your own.": {
      "zh": "按照以下步骤构建此项目，或者下载完成的项目自行探索。",
      "tips": ""
    },
    "Landmarks displays each category in a row that scrolls horizontally. Add a new view type to represent the row, then display all the landmarks for that category in the new view.": {
      "zh": "地标应用将每个类别以水平滚动的行形式展示。添加一个新的视图类型来代表这一行，然后在新视图中展示该类别下的所有地标。",
      "tips": ""
    },
    "Create a Categories group in your project’s Views group, and create a custom view called CategoryHome to the new group.": {
      "zh": "在项目的 Views 文件夹中创建一个 Categories 分组，并在新文件夹中创建一个名为 CategoryHome 的自定义视图。",
      "tips": ""
    },
    "Section 3": {
      "zh": "第 3 节",
      "tips": ""
    },
    "Start the live preview and try out the new navigation.": {
      "zh": "启动实时预览并尝试新的导航。",
      "tips": ""
    },
    "Step 1": {
      "zh": "步骤 1",
      "tips": ""
    },
    "Start by reading category data from the landmarkData.json file.": {
      "zh": "首先从 landmarkData.json 文件中读取分类数据。",
      "tips": ""
    },
    "Put the category’s items in an HStack, and group that with the category name in a VStack.": {
      "zh": "将类别的项目展示放在一个 HStack 中，并将其与类别名称一起包在一个 VStack 中。",
      "tips": ""
    },
    "Next you’ll modify the app’s main content view to show a tab view that lets the user choose between the category view you just created, and the existing list of landmarks.": {
      "zh": "接下来，你将修改应用的主内容视图，显示一个底部标签视图，让用户在刚刚创建的类别视图和现有的地标列表之间进行选择。",
      "tips": ""
    },
    "In CategoryRow.swift, wrap the existing CategoryItem with a NavigationLink.": {
      "zh": "在 CategoryRow.swift 中，用 NavigationLink 包装现有的 CategoryItem。",
      "tips": ""
    },
    "The category view for Landmarks shows a vertically scrolling list of horizontally scrolling landmarks. As you build this view and connect it to your existing views, you’ll explore how composed views can adapt to different device sizes and orientations.": {
      "zh": "在 Landmarks 应用中，分类视图显示一个垂直滚动的列表，列表中包含水平滚动的地标。在构建这个视图并将其连接到现有视图时，你将探究如何使组合视图适应不同的设备尺寸和方向。",
      "tips": ""
    },
    "Give each tab a label.": {
      "zh": "为每个底部标签添加文本和图标。",
      "tips": ""
    },
    "In ModelData.swift, add a computed categories dictionary, with category names as keys, and an array of associated landmarks for each key.": {
      "zh": "在 ModelData.swift 中，添加一个 categories 字典，以类别名称为键，以每个键的相关地标数组做为值。",
      "tips": ""
    },
    "Update the body of CategoryHome to pass category information to instances of the row type.": {
      "zh": "更新 CategoryHome 的 body，将类别信息传递给每一行。",
      "tips": ""
    },
    "In Landmark.swift, add a Category enumeration and a category property to the Landmark structure.": {
      "zh": "在 Landmark.swift 中，为 Landmark 结构添加一个 Category 枚举和一个 category 属性。",
      "tips": ""
    },
    "Section 4": {
      "zh": "第 4 节",
      "tips": ""
    },
    "Section 1": {
      "zh": "第 1 节",
      "tips": ""
    },
    "Add Navigation Between Sections": {
      "zh": "在不同的部分添加导航",
      "tips": ""
    },
    "Unpin the preview, switch to the ContentView and add an enumeration of the tabs to display.": {
      "zh": "取消固定预览，切换到 ContentView 并添加要显示的底部标签栏的枚举。",
      "tips": ""
    },
    "The category view displays all categories in separate rows arranged in a vertical column for easier browsing. You do this by combining vertical and horizontal stacks, and adding scrolling to the list.": {
      "zh": "分类视图以垂直列表方式显示所有的类别，以便于浏览。你可以通过结合垂直和水平堆栈，并为列表添加滚动来实现这一点。",
      "tips": ""
    },
    "Section 5": {
      "zh": "第 5 节",
      "tips": ""
    },
    "You’ll need access to the categories right now, as well as to other landmark data later.": {
      "zh": "你现在需要访问类别，以及稍后访问其他地标数据。",
      "tips": ""
    },
    "Step 2": {
      "zh": "步骤 2",
      "tips": ""
    },
    "Create a Category List": {
      "zh": "创建一个类别列表",
      "tips": ""
    },
    "Change the navigation appearance of the category items by applying the renderingMode(_:) and foregroundColor(_:) modifiers.": {
      "zh": "通过应用 renderingMode(:) 和 foregroundColor(:) 修饰符来更改类别项目的导航外观。",
      "tips": ""
    },
    "In ModelData.swift, add a new computed features array, which contains only the landmarks that have isFeatured set to true.": {
      "zh": "在 ModelData.swift 中，添加一个新的 features 数组，其中仅包含将 isFeatured 设置为 true 的地标。",
      "tips": ""
    },
    "Give the content some space by specifying a tall frame(width:height:), adding padding, and wrapping the HStack in a scroll view.": {
      "zh": "通过指定一个高度较高的 frame(width:height:)，添加内边距，并将 HStack 包装在滚动视图中，为内容留出一定的空间。",
      "tips": ""
    },
    "Step 7": {
      "zh": "步骤7",
      "tips": ""
    },
    "The view showcases one or more featured landmarks at the top.": {
      "zh": "该视图在顶部展示一个或多个特色地标。",
      "tips": ""
    },
    "Set the title of the navigation bar to Featured.": {
      "zh": "将导航栏的标题设置为精选（Featured）。",
      "tips": ""
    },
    "Working with UI Controls": {
      "zh": "",
      "tips": ""
    }
  },
  "swiftui/creating-a-macos-app": {
    "Add a Picker that controls the zoom value through a binding.": {
      "zh": "添加一个绑定缩放值的选择器。",
      "tips": ""
    },
    "The changes you’ll make in the next few steps improve the layout for the larger display of a Mac.": {
      "zh": "在接下来的几个步骤中，你将进行的更改将会针对 Mac 优化，在更大显示屏上展示界面布局。",
      "tips": ""
    },
    "Run the macOS app and try out the new menu item.": {
      "zh": "运行 macOS 应用程序并尝试新的菜单项。",
      "tips": ""
    },
    "You’ll define content for the menu next.": {
      "zh": "接下来你将定义菜单的内容。",
      "tips": ""
    },
    "Adding the second child view automatically converts the list to use the sidebar list style.": {
      "zh": "给 NavigationView 添加第二个子视图会自动将列表转换为侧边栏列表样式。",
      "tips": ""
    },
    "Like a View structure, a Commands structure requires a computed body property that uses builder semantics, except with commands instead of views.": {
      "zh": "像 View 结构一样，Commands 结构也需要一个使用构建器语义的计算 body 属性，只是它使用的是 commands 而不是 views。",
      "tips": ""
    },
    "This improves the preview, but also ensures that the list never becomes too small as the user resizes the macOS window.": {
      "zh": "这改进了预览效果，也保证了列表在用户调整 macOS 窗口大小时永远不会变得太小。",
      "tips": ""
    },
    "Use a storage key that uniquely identifies the parameter like you would when storing items in UserDefaults, because that’s the underlying mechanism that SwiftUI relies on.": {
      "zh": "在存储键中使用一个唯一标识参数的值，就像在 UserDefaults 中存储项目一样，因为这是 SwiftUI 依赖的底层机制。",
      "tips": ""
    },
    "Step 6": {
      "zh": "步骤 6",
      "tips": ""
    },
    "Wrap the landmark name in a VStack and add the park as secondary information.": {
      "zh": "将地标名称包装在 VStack 中，并将公园添加为次要信息。",
      "tips": ""
    },
    "To ensure that SwiftUI refreshes the map whenever delta changes, you’ll have to alter the way you calculate and apply the region.": {
      "zh": "为确保在 delta 更改时 SwiftUI 刷新地图，您需要更改计算和应用 region 的方式。",
      "tips": ""
    },
    "In the Project navigator, delete the MacLandmarksApp.swift file from the MacLandmarks group. When asked, choose Move to Trash.": {
      "zh": "在项目导航器中，从 MacLandmarks 组中删除 MacLandmarksApp.swift 文件。 当系统询问时，选择移至废纸篓。",
      "tips": ""
    },
    "Run the app and try setting the preferences.": {
      "zh": "运行应用程序并尝试设置偏好。",
      "tips": ""
    },
    "The preview fails because the navigationBarTitleDisplayMode(_:) method isn’t available in macOS.": {
      "zh": "预览失败是因为 navigationBarTitleDisplayMode(_:) 方法在 macOS 中不可用。",
      "tips": ""
    },
    "Run the macOS target and see how the menu operates.": {
      "zh": "运行 macOS 目标并查看菜单的运行方式。",
      "tips": ""
    },
    "You won’t be able to see the toolbar updates until you run the app.": {
      "zh": "在运行该应用程序之前，将看不到工具栏的更新。",
      "tips": ""
    },
    "You now have three files called LandmarkDetail.swift. Each serves the same purpose in the view hierarchy, but provides an experience tailored to a particular platform.": {
      "zh": "现在您有三个名为 LandmarkDetail.swift 的文件。它们在视图层次结构中具有相同的作用，但他们针对特定平台提供了定制的体验。",
      "tips": ""
    },
    "Create a new SwiftUI view called LandmarkSettings that targets only the macOS app.": {
      "zh": "创造一个名为 LandmarkSettings 的新 SwiftUI 视图，它仅针对 macOS 平台。",
      "tips": ""
    },
    "To make use of commands in an app, you have to apply them to a scene, which you’ll do next.": {
      "zh": "要在应用程序中使用命令，你需要将它们应用于一个场景，接下来你将执行这个操作。",
      "tips": ""
    },
    "Choose the WatchLandmarks target to see a watchOS preview of the list.": {
      "zh": "选择 WatchLandmarks 目标来查看列表的 watchOS 预览。",
      "tips": ""
    },
    "Move the favorites Toggle into the menu.": {
      "zh": "将收藏切换开关移动到菜单中。",
      "tips": ""
    },
    "Step 8": {
      "zh": "步骤 8",
      "tips": ""
    },
    "Replace the region state variable, the setRegion method, and the map’s onAppear modifier with a computed region property that you pass to the Map initializer as a constant binding.": {
      "zh": "将 region 状态变量、 setRegion 方法和地图的 onAppear 修饰符替换为计算得出的 region 属性，将其作为常量传递给 Map 进行初始化。",
      "tips": ""
    },
    "Add a FilterCategory enumeration to describe filter states.": {
      "zh": "添加 FilterCategory 枚举来描述过滤器状态。",
      "tips": ""
    },
    "Add an “Open in Maps” button in a ZStack so that it appears on top of the map in the upper-right corner.": {
      "zh": "在 ZStack 中添加“在地图中打开（Open in Maps）”按钮，使它显示在地图的右上角。",
      "tips": ""
    },
    "The detail view displays information about the selected landmark. You created a view like this for the iOS app, but different platforms require different approaches to data presentation.": {
      "zh": "详细视图显示有关所选地标的信息。 在 iOS 应用程序中你已经创建了一个这样的视图，但不同的平台需要不同的数据呈现方法。",
      "tips": ""
    },
    "The pattern for defining focused values resembles the pattern for defining new Environment values: Use a private key to read and write a custom property on the system-defined FocusedValues structure.": {
      "zh": "定义 focused 值的模式类似于定义新的 Environment 值的模式：使用私有键在系统定义的 FocusedValues 结构上读取和写入自定义属性。",
      "tips": ""
    },
    "Add a @FocusedBinding property wrapper to track the currently selected landmark.": {
      "zh": "添加 @FocusedBinding 属性包装器来跟踪当前选定的地标。",
      "tips": ""
    },
    "Create a new custom view in the MacLandmarks group targeting macOS called LandmarkDetail.": {
      "zh": "在针对 macOS 平台的 MacLandmarks 文件夹中，创建一个名为 LandmarkDetail 的新的自定义视图。",
      "tips": ""
    },
    "Add a new SwiftUI view to the WatchLandmarks Extension folder called LandmarkList.swift that targets only WatchLandmarks Extension, and remove the older file’s WatchLandmarks Extension target membership.": {
      "zh": "在 WatchLandmarks Extension 文件夹中添加一个仅针对 WatchLandmarks Extension 的新 SwiftUI 视图，命名为 LandmarkList.swift，并移除旧文件的 WatchLandmarks Extension 目标引用。",
      "tips": ""
    },
    "You typically use a Form to arrange controls in your settings view.": {
      "zh": "你一般可以使用 Form 在设置视图中排列控件。",
      "tips": ""
    },
    "Next, you’ll create a Settings scene that controls the stored zoom value.": {
      "zh": "接下来，您将创建一个 Settings 场景，用于控制存储的缩放值。",
      "tips": ""
    },
    "Update the navigation title to match the state of the filter.": {
      "zh": "更新导航标题来匹配过滤器的状态。",
      "tips": ""
    },
    "Creating a macOS App": {
      "zh": "",
      "tips": ""
    },
    "Section 1": {
      "zh": "第 1 节",
      "tips": ""
    },
    "Add the focusedValue(_:_:) modifier to the NavigationView, providing a binding the value from the landmarks array.": {
      "zh": "将 focusedValue(_:_:) 修饰符添加到 NavigationView，传入地标数组值进行绑定。",
      "tips": ""
    },
    "Continue Command-clicking to select all the items in the Model and Resources folders, as well as Asset.xcassets.": {
      "zh": "继续按住 Command 单击选择 Model 和 Resources 文件夹中的所有项目，以及 Asset.xcassets。",
      "tips": ""
    },
    "Add a button to the menu that toggles the selected landmark’s favorite status, and that has an appearance that changes depending on the currently selected landmark and its state.": {
      "zh": "在菜单中添加一个按钮，用于切换所选地标的收藏状态，并且它的外观会根据当前所选地标及其当前的收藏状态而变化。",
      "tips": ""
    },
    "Copy the iOS detail view contents into the macOS detail view.": {
      "zh": "将 iOS 详情视图的内容复制到 macOS 的详情视图中。",
      "tips": ""
    },
    "Change the HStack holding the park and state to a VStack with leading alignment, and remove the Spacer.": {
      "zh": "将包含公园和州信息的 HStack 更改为对齐方式为 leading 的 VStack，并移除 Spacer。",
      "tips": ""
    },
    "When you let go of the mouse button, the list disappears with no way to get it back. You’ll add a command to fix this.": {
      "zh": "当你松开鼠标按钮时，该列表将会消失且无法恢复。 你将添加一个命令来修复此问题。",
      "tips": ""
    },
    "Delete the navigationBarTitleDisplayMode(_:) modifier and add a frame modifier to the preview so you can see more of the content.": {
      "zh": "删除 navigationBarTitleDisplayMode(_:) 修饰符并为预览设置一个视图大小，方便你可以看到更多内容。",
      "tips": ""
    },
    "This built-in command set includes the command for toggling the sidebar.": {
      "zh": "这个内置的命令集包括用于切换侧边栏的命令。",
      "tips": ""
    },
    "Add a keyboard shortcut for the menu item with the keyboardShortcut(_:modifiers:) modifier.": {
      "zh": "使用 keyboardShortcut(_:modifiers:) 修饰符为菜单中的选项添加键盘快捷键。",
      "tips": ""
    },
    "SwiftUI automatically shows the keyboard shortcut in the menu.": {
      "zh": "SwiftUI 会自动在菜单中显示键盘快捷键。",
      "tips": ""
    },
    "Constrain the ScrollView to a maximum width.": {
      "zh": "将 ScrollView 的最大宽度加以限制。",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Like LandmarkRow, LandmarkList already works on macOS, but could use improvements. For example, you’ll move the toggle for showing only favorites to a menu in the toolbar, where it can be joined by additional filtering controls.": {
      "zh": "与 LandmarkRow 一样，LandmarkList 已经可以在 macOS 上运行，但可以进行改进。 例如，你可以将仅显示收藏夹的开关移动到工具栏中的菜单，可以在那里加入其他过滤控件。",
      "tips": ""
    },
    "This template adds a new macOS app target to the project.": {
      "zh": "此模板将新的 macOS 应用程序目标添加到项目中。",
      "tips": ""
    },
    "This moves the toggle into the toolbar in a platform-specific way, which has the additional benefit of making it accessible no matter how long the list of landmarks gets, or how far down the user scrolls.": {
      "zh": "这样以一种平台特定的方式将切换按钮移动到工具栏中，带来了额外的好处，即无论地标列表有多长，或者用户向下滚动了多远，都能轻松访问它。",
      "tips": ""
    },
    "The shared LandmarkRow view works in macOS, but it’s worth revisiting to look for improvements given the new visual environment. Because this view is used by all three platforms, you need to be careful that any changes you make work across all of them.": {
      "zh": "共享的 LandmarkRow 视图在 macOS 上可以正常工作，但考虑到新的视觉场景，有必要重新审视它寻找值得改进的地方。由于这个视图被三个平台都使用到，你需要确保所做的任何更改都能在所有平台上正常工作。",
      "tips": ""
    },
    "The watchOS app builds again.": {
      "zh": "再次构建 watchOS 应用程序。",
      "tips": ""
    },
    "Notice that the map refreshes whenever you change the zoom level.": {
      "zh": "请注意，只要更改缩放级别，地图就会重新刷新。",
      "tips": ""
    },
    "Go back to LandmarkRow and add an #if condition to prevent the secondary text from appearing in a watchOS build.": {
      "zh": "回到 LandmarkRow ，添加 #if 条件来防止二级文本出现在 watchOS 构建中。",
      "tips": ""
    },
    "Open LandmarkList.swift and add a minimum width.": {
      "zh": "打开 LandmarkList.swift 并添加最小宽度。",
      "tips": ""
    },
    "Add a condition around the commands modifier to omit it for the watchOS app.": {
      "zh": "在 commands 修饰符周围添加条件，以排除 watchOS 应用程序。",
      "tips": ""
    },
    "You’re reading the value here. You’ll set it later in the list view, where the user makes the selection.": {
      "zh": "你在此处读取该值。稍后你将在列表视图中设置它，用户在那里进行选择。",
      "tips": ""
    },
    "You also target iOS because the shared LandmarkList will eventually depend on some of the types you define in this file.": {
      "zh": "你还需要针对 iOS，因为共享的 LandmarkList 最终将依赖于你在此文件中定义的一些类型。",
      "tips": ""
    },
    "When you create an app using the SwiftUI life cycle, the system automatically creates a menu with commonly needed items, like those for closing the front-most window or for quitting the app. SwiftUI lets you add other common commands with built-in behavior, as well as completely custom commands.": {
      "zh": "当你使用 SwiftUI 生命周期创建应用程序时，系统会自动创建一个包含常用选项的菜单，比如用于关闭最前面的窗口或退出应用程序。SwiftUI 还允许您添加具有内置行为的其他常用命令，以及完全自定义的命令。",
      "tips": ""
    },
    "SwiftUI provides both a default main view and its preview provider, just like for an iOS app, enabling you to preview the app’s main window.": {
      "zh": "SwiftUI 提供默认主视图及其预览提供类，就像 iOS 应用程序一样，使你能够直接预览应用程序的主窗口。",
      "tips": ""
    },
    "The first of these is the shared app definition. The others are views that will work on macOS.": {
      "zh": "其中第一个是应用程序的共享入口。 其他的是也能够适用于 macOS 的视图文件。",
      "tips": ""
    },
    "Add a new Swift file called LandmarkCommands.swift and set its targets to include both macOS and iOS.": {
      "zh": "添加一个名为 LandmarkCommands.swift 的 Swift 文件，并将其目标设置为包括 macOS 和 iOS。",
      "tips": ""
    },
    "Using the plain style here makes the button look more like the iOS equivalent.": {
      "zh": "在这里使用 plain 样式会让按钮看起来更像是 iOS 上的按钮。",
      "tips": ""
    },
    "Add a new CommandMenu to your commands called Landmarks.": {
      "zh": "将一个名为 Landmarks 新的 CommandMenu 添加到你的命令选项中 。",
      "tips": ""
    },
    "You perform a look-up here to ensure that you are modifying the landmark stored in the model, and not a copy.": {
      "zh": "在这里进行查找以确保你修改的是存储在模型中的地标，而不是其副本。",
      "tips": ""
    },
    "Step 3": {
      "zh": "步骤 3",
      "tips": ""
    },
    "The preview no longer builds because the LandmarkList uses LandmarkDetail, but you haven’t defined a detail view for the macOS app yet. You’ll take care of that in the next section.": {
      "zh": "预览不再生成，因为 LandmarkList 使用到了 LandmarkDetail，但你还没有为 macOS 应用程序定义 LandmarkDetail。 你将在下一节中解决这个问题。",
      "tips": ""
    },
    "The MapView remains blank unless you start the live preview.": {
      "zh": "除非你开始实时预览模式，否则 MapView 将保持空白。",
      "tips": ""
    },
    "Update the List View": {
      "zh": "更新列表视图",
      "tips": ""
    },
    "The changes you’ll make will work for both macOS and iOS, but will be difficult to accommodate on watchOS. Fortunately, in the previous section you already split the list into a separate file for watchOS.": {
      "zh": "你所做的更改能够适用于 macOS 和 iOS，但很难适应 watchOS。 幸运的是，在上一节中，你已经将列表拆分成了一个针对 watchOS 的独立文件。",
      "tips": ""
    },
    "Section 2": {
      "zh": "第 2 节",
      "tips": ""
    },
    "This improves readability when the user makes the window very wide.": {
      "zh": "当视图窗口非常宽的时候，这样可以提高可读性。",
      "tips": ""
    },
    "Add an @AppStorage property called zoom that takes on the medium zoom level by default.": {
      "zh": "添加一个名为 zoom 的 @AppStorage 属性，默认情况下采用 medium 缩放级别。",
      "tips": ""
    },
    "Return to the MacLandmarks scheme, and in the LandmarkList file that targets iOS and macOS, add a ToolbarItem containing a Menu inside a new toolbar modifier.": {
      "zh": "回到到 MacLandmarks scheme，在针对 iOS 和 macOS 的 LandmarkList 文件中，在新的 toolbar 修饰符中添加一个包含菜单的 ToolbarItem。",
      "tips": ""
    },
    "Step 10": {
      "zh": "步骤 10",
      "tips": ""
    },
    "Finally, consider how your changes work for iOS.": {
      "zh": "最后，考虑你的更改是否可以适用于 iOS。",
      "tips": ""
    },
    "Section 4": {
      "zh": "第 4 节",
      "tips": ""
    },
    "Add a resizable() modifier to the image, and constrain the CircleImage to be a bit smaller.": {
      "zh": "为图像添加一个 resizable() 修饰符，并将 CircleImage 大小设置的小一点。",
      "tips": ""
    },
    "In the previous section, you added a built-in menu command set. In this section, you’ll add a custom command for toggling the favorite status of the currently selected landmark. To know which landmark is currently selected, you’ll use a focused binding.": {
      "zh": "在上一节中，你添加了一个内置菜单命令集。 在本节中，你将添加一个自定义命令来切换当前所选地标的收藏状态。 要知道当前选择了哪个地标，你将使用焦点绑定（focused binding）。",
      "tips": ""
    },
    "Add vertical padding around the contents of the row to give each row a little more breathing room.": {
      "zh": "在行内容周围添加垂直填充，为每行提供更多的空间，让它们看起来更加舒适。",
      "tips": ""
    },
    "Start by adding a macOS target to the project. Xcode adds a new group and set of starter files for the macOS app, along with the scheme needed to build and run the app. You’ll then add some existing files to the new target.": {
      "zh": "首先向项目添加一个 macOS 目标。 Xcode 为 macOS 应用程序添加了一个新的文件夹以及配置好了启动文件，还有编译和运行该应用程序所需的方案。 然后，你将向新目标添加一些现有文件。",
      "tips": ""
    },
    "In LandmarksApp.swift, add the Settings scene to your app, but only for macOS.": {
      "zh": "在 LandmarksApp.swift 中，将 Settings 场景添加到你的应用程序中，但仅适用于 macOS。",
      "tips": ""
    },
    "In LandmarkCommands, extend the FocusedValues structure with a selectedLandmark value, using a custom key called SelectedLandmarkKey.": {
      "zh": "在 LandmarkCommands 中，使用名为 SelectedLandmarkKey 的自定义键，使用 selectedLandmark 值扩展 FocusedValues 结构。",
      "tips": ""
    },
    "In the Project navigator, Command-click to select the following files: LandmarksApp.swift, LandmarkList.swift, LandmarkRow.swift, CircleImage.swift, MapView.swift, and FavoriteButton.swift.": {
      "zh": "在项目导航栏中，按住 Command 单击来选择以下文件：LandmarksApp.swift、LandmarkList.swift、LandmarkRow.swift、CircleImage.swift、MapView.swift 和 FavoriteButton.swift。",
      "tips": ""
    },
    "Step 7": {
      "zh": "步骤 7",
      "tips": ""
    },
    "Step 5": {
      "zh": "步骤 5",
      "tips": ""
    },
    "The changes work well for iOS, so there’s no need to make any updates for that platform.": {
      "zh": "这些更改适用于 iOS，因此无需针对该平台进行任何更新。",
      "tips": ""
    },
    "In the MacLandmarks group, select ContentView.swift, open the Canvas, and click Resume to see the preview.": {
      "zh": "在 MacLandmarks 文件夹中，选择 ContentView.swift，打开 Canvas，然后单击 Resume 查看预览。",
      "tips": ""
    },
    "Add an @AppStorage property that uses the same key as you used in the map view.": {
      "zh": "添加一个 @AppStorage 属性，该属性和你在地图视图中使用的键相同。",
      "tips": ""
    },
    "The minimum row width isn’t appropriate here. Because of this and other changes you’ll make to the list in the next section, the best solution is to create a watch-specific list that omits the width constraint.": {
      "zh": "最小行宽在这里是不合适的。 由于在接下来的部分中还需要进行其他更改，所以最好的解决方案是创建一个特定于 watch 的列表，省略宽度上的约束。",
      "tips": ""
    },
    "Update the Row View": {
      "zh": "更新行视图",
      "tips": ""
    },
    "Import SwiftUI and add a LandmarkCommands structure that conforms to the Commands protocol, with a computed body property.": {
      "zh": "导入 SwiftUI 框架并添加一个符合 Commands 协议的 LandmarkCommands 结构体，其中包含一个计算属性 body。",
      "tips": ""
    },
    "Open LandmarkRow.swift and add a corner radius to the image for a more refined look.": {
      "zh": "打开 LandmarkRow.swift 并为图像添加圆角半径让它的外观更加精致。",
      "tips": ""
    },
    "Choose the Landmarks build target to see what the list looks like for iOS.": {
      "zh": "选择 Landmarks 编译目标来查看 iOS 列表的界面。",
      "tips": ""
    },
    "For the row, using conditional compilation is appropriate because the differences are small.": {
      "zh": "对于行视图来说可以使用条件判断是否需要编译，因为差异很小。",
      "tips": ""
    },
    "Choose File > New > Target. When the template sheet appears, choose the macOS tab, select the App template, and click Next.": {
      "zh": "选择 File > New > Target。 出现模板选择列表时，选择 macOS 选项，选择 App 模版，然后单击下一步。",
      "tips": ""
    },
    "The tag associates a particular landmark with the given item in the ForEach, which then drives the selection.": {
      "zh": "该标签将特定地标与 ForEach 中的给定项目相关联，标识地标是否选中。",
      "tips": ""
    },
    "The menu now contains your new command, but you need to set the selectedLandmark focused binding for it to work.": {
      "zh": "菜单现在包含你的新命令，但你需要设置 selectedLandmark 焦点绑定才能工作。",
      "tips": ""
    },
    "Choose the Landmarks build target, and use the live preview to see that the new filtering works well for iOS as well.": {
      "zh": "选择 Landmarks 构建目标，并使用实时预览查看新过滤是否也适用于 iOS。",
      "tips": ""
    },
    "Step 11": {
      "zh": "步骤 11",
      "tips": ""
    },
    "In this section, you’ll add a system-provided command that lets the user toggle the sidebar, to be able to get it back after dragging it closed.": {
      "zh": "在本节中，你将添加一个系统提供的命令，让用户可以切换侧边栏展开和隐藏，以便在拖动关闭后可以恢复它。",
      "tips": ""
    },
    "Drag the AppIcon.appiconset folder from the downloaded projects’ Resources folder into the MacLandmark’s Asset catalog.": {
      "zh": "将 AppIcon.appiconset 文件夹从下载项目的 Resources 文件夹拖到 MacLandmark 的 Asset 目录中。",
      "tips": ""
    },
    "Because the filter has only a few items, you use the inline picker style to make them all appear together.": {
      "zh": "因为过滤器只有几个选项，所以你使用 inline 样式让它们一起出现。",
      "tips": ""
    },
    "After creating a version of the Landmarks app for watchOS, it’s time to set your sights on something bigger: bringing Landmarks to the Mac. You’ll build upon everything you’ve learned so far, to round out the experience of building a SwiftUI app for iOS, watchOS, and macOS.": {
      "zh": "在为 watchOS 创建 Landmarks 应用程序版本后，是时候将你的目光投向更大的目标了：将 Landmarks 引入到 Mac 上。 你将以迄今为止所学的一切为基础，完善为 iOS、watchOS 和 macOS 构建 SwiftUI 应用程序的体验。",
      "tips": ""
    },
    "Add a second child view to the NavigationView as a placeholder for the second view in wide layouts.": {
      "zh": "将文本视图添加到 NavigationView 的横向布局中，作为的二级视图的占位。",
      "tips": ""
    },
    "Next, you’ll share view, model, and resource files from the iOS app with the macOS target.": {
      "zh": "接下来，你将让  macOS 应用和 iOS 应用程序共享视图、模型和资源文件。",
      "tips": ""
    },
    "Sometimes you can reuse a view across platforms with small adjustments or conditional compilation, but the detail view differs enough for macOS that it’s better to create a dedicated view. You’ll copy the iOS detail view as a starting point, and then modify it to suit the larger display of macOS.": {
      "zh": "有时候，你可以通过进行小的调整或使用条件判断是否参与编译的方式在不同平台间复用视图，但是 macOS 的详细视图差别较大，因此最好创建一个专用视图。你将复制 iOS 详情视图作为起点，然后修改它来适应 macOS 更大的显示屏。",
      "tips": ""
    },
    "Add Preferences with a Settings Scene": {
      "zh": "使用设置场景的方式添加偏好设置",
      "tips": ""
    },
    "Scene modifiers work like view modifiers, except that you apply them to scenes instead of views.": {
      "zh": "场景修改器的工作方式类似于视图修改器，只是你将它们应用于场景而不是视图。",
      "tips": ""
    },
    "Add a Built-in Menu Command": {
      "zh": "添加一个内置的菜单栏选项。",
      "tips": ""
    },
    "Follow the steps to build this project, or download the finished project to explore on your own.": {
      "zh": "按照步骤构建此项目，或下载已完成的项目来自行探索。",
      "tips": ""
    },
    "Add a SidebarCommands command to the body.": {
      "zh": "在 body 中添加 SidebarCommands 命令。",
      "tips": ""
    },
    "Run the macOS app again, and see that you can use the View > Toggle Sidebar menu command to restore the list view.": {
      "zh": "再次运行 macOS 应用程序，可以看到你可以使用“视图（View）”>“切换边栏（Toggle Sidebar）”菜单命令来恢复列表视图。",
      "tips": ""
    },
    "By setting the scheme to My Mac, you can preview, build, and run the macOS app. As you move through the tutorial, you’ll use the other schemes to keep an eye on how other targets respond to changes in shared files.": {
      "zh": "通过将方案设置为“My Mac”，你可以预览、编译和运行 macOS 应用程序。 在学习本教程时，你也会使用其他的编译方案来关注当共享文件发生修改时，其他目标是如何响应的。",
      "tips": ""
    },
    "You’ll replace this in the next step.": {
      "zh": "你将在下一步中替换它。",
      "tips": ""
    },
    "These items define the app’s data model and resources.": {
      "zh": "这些项目定义了应用程序的数据模型和资源。",
      "tips": ""
    },
    "Change the FavoriteButton to use the plain button style.": {
      "zh": "更改 FavoriteButton 的样式为 plain。",
      "tips": ""
    },
    "Set the scheme to MacLandmarks > My Mac.": {
      "zh": "将编译方案设置为 MacLandmarks > My Mac，即在我的 Mac 上运行应用程序。",
      "tips": ""
    },
    "Update filteredLandmarks to take into account the new filter setting, combined with the category of a given landmark.": {
      "zh": "更新 filteredLandmarks，将新的过滤设置与给定地标的类别相结合。",
      "tips": ""
    },
    "Open the LandmarksApp.swift file, and apply LandmarkCommands using the commands(content:) scene modifier.": {
      "zh": "打开 LandmarksApp.swift 文件，并使用 commands(content:) 场景修饰符应用 LandmarkCommands。",
      "tips": ""
    },
    "The content now has the right width, but each row has too much information.": {
      "zh": "内容现在有正确的宽度了，但每一行的信息太多了。",
      "tips": ""
    },
    "Section 5": {
      "zh": "第 5 节",
      "tips": ""
    },
    "Before modifying the row, set up a preview of the list, because the changes you’ll make are driven by how the row looks in context.": {
      "zh": "在修改行之前，设置好列表的预览，因为你所做的更改是需要在列表中展示的。",
      "tips": ""
    },
    "Section 6": {
      "zh": "第 6 节",
      "tips": ""
    },
    "Step 2": {
      "zh": "步骤 2",
      "tips": ""
    },
    "Remove the offset from the circle, and instead apply a smaller offset to the entire VStack.": {
      "zh": "将圆形的偏移量移除，改成给整个 VStack 增加一个较小的偏移量。",
      "tips": ""
    },
    "Create a macOS Detail View": {
      "zh": "创建 macOS 详细信息视图",
      "tips": ""
    },
    "Change the longitude and latitude delta used to construct the region property to a value that depends on zoom.": {
      "zh": "将用于构造 region 属性的经度和纬度差值更改为一个取决于缩放级别的值。",
      "tips": ""
    },
    "In the File inspector, add MacLandmarks to the Target Membership for the selected files.": {
      "zh": "在文件检查器中，给所选择的文件添加 MacLandmarks 目标，让 Mac 工程能够引用这些文件。",
      "tips": ""
    },
    "Select the Assets.xcasset file in the MacLandmarks group and delete the empty AppIcon item.": {
      "zh": "选择 MacLandmarks 组中的 Assets.xcasset 文件并删除空的 AppIcon 项。",
      "tips": ""
    },
    "You’ll start by adding a macOS target to your project, and then reusing views and data you created earlier. With a foundation in place, you’ll add some new views tailored to macOS, and modify others to work better across platforms.": {
      "zh": "你将首先向你的项目添加一个 macOS 目标，然后重用你之前创建的视图和数据。 有了适当的基础，你将添加一些为 macOS 量身定制的新视图，并修改其他视图来更好地跨平台工作。",
      "tips": ""
    },
    "Add a Picker to the menu to set the filter category.": {
      "zh": "在菜单中添加一个 Picker 来设置过滤器类别。",
      "tips": ""
    },
    "In ContentView in the MacLandmarks group, add LandmarkList as the top level view, with constraints on the frame size.": {
      "zh": "在 MacLandmarks 文件夹的 ContentView 中，添加 LandmarkList 作为顶层视图，并限制它的布局大小。",
      "tips": ""
    },
    "Be sure to include MapKit to be able to create the MKMapItem that you send to Maps.": {
      "zh": "请记得引用 MapKit 框架，以便你能够创建 MKMapItem 对象发送到地图 App。",
      "tips": ""
    },
    "In the sheet, enter MacLandmarks as the Product Name. Set the interface to SwiftUI, the life cycle to SwiftUI App, and the language to Swift, and then click Finish.": {
      "zh": "在弹出的窗口中，输入 MacLandmarks 作为产品名称。 界面开发框架设置为 SwiftUI，生命周期设置为 SwiftUI App，语言设置为 Swift，然后点击 Finish。",
      "tips": ""
    },
    "With more room available, you’ll add a new control for filtering the list of landmarks by category.": {
      "zh": "有了更多可用空间，你将添加一个新控件，来按类别筛选地标列表。",
      "tips": ""
    },
    "Return to the MacLandmarks target, run the macOS app, and drag the separator between the list and detail view all the way to the left.": {
      "zh": "返回 MacLandmarks 目标，运行 macOS 应用程序，并将列表和详细视图之间的分隔符一直拖到左侧。",
      "tips": ""
    },
    "The larger display gives you more room for additional features.": {
      "zh": "更大的显示屏也为你提供更多功空间展示功能。",
      "tips": ""
    },
    "Section 7": {
      "zh": "第 7 节",
      "tips": ""
    },
    "By storing the filter state in the list view, the user can open multiple list view windows, each with its own filter setting, to be able to look at the data in different ways.": {
      "zh": "通过在列表视图中存储过滤器状态，用户可以打开多个列表视图窗口，每个窗口都有自己的过滤器设置，这样能够以不同的方式查看数据。",
      "tips": ""
    },
    "Step 4": {
      "zh": "步骤 4",
      "tips": ""
    },
    "You’ll start by adding a control in the MapView that sets the initial zoom to one of three levels: near, medium, or far.": {
      "zh": "你将首先在 MapView 中添加一个控件，用于将初始缩放设置为三个级别之一：近、中或远。",
      "tips": ""
    },
    "Pin the list view preview so that you can see how the row looks in context as you make changes.": {
      "zh": "固定列表视图的预览窗口，让你可以在进行更改时看到行视图在列表中的外观变化。",
      "tips": ""
    },
    "Initialize the List with a binding to the selected value, and add a tag to the navigation link.": {
      "zh": "用选定值的绑定初始化列表，并在导航链接中添加一个标签。",
      "tips": ""
    },
    "Add a macOS Target to the Project": {
      "zh": "将 macOS 目标添加到项目",
      "tips": ""
    },
    "Step 9": {
      "zh": "步骤 9",
      "tips": ""
    },
    "Unfortunately, the watchOS app fails to build because Commands has no watchOS availability. You’ll fix that next.": {
      "zh": "不幸的是，watchOS 应用程序无法构建，因为 Commands 在 watchOS 上不可用。接下来你将解决这个问题。",
      "tips": ""
    },
    "In LandmarkList.swift, add a state variable for the selected landmark and a computed property that indicates the index of the selected landmark.": {
      "zh": "在 LandmarkList.swift 中，为所选地标添加一个状态变量和一个表示所选地标索引的计算属性。",
      "tips": ""
    },
    "Section 3": {
      "zh": "第 3 节",
      "tips": ""
    },
    "Step 1": {
      "zh": "步骤 1",
      "tips": ""
    },
    "Like with the watchOS app, you don’t need the default app structure because you’ll reuse the one you already have.": {
      "zh": "与 watchOS 应用程序一样，你不需要 Xcode 生成的默认的 App 文件，因为你会重复使用主工程中已有的 App 文件。",
      "tips": ""
    },
    "In MapView.swift, add a Zoom enumeration to characterize the zoom level.": {
      "zh": "在 MapView.swift 中，添加一个 Zoom 枚举来表示缩放级别。",
      "tips": ""
    },
    "Users expect to be able to adjust settings for a macOS app using the standard Preferences menu item. You’ll add preferences to MacLandmarks by adding a Settings scene. The scene’s views define the contents of the preferences window, which you’ll use to control the initial zoom level of the MapView. You communicate the value to the map view, and store it persistently, by using the @AppStorage property wrapper.": {
      "zh": "用户希望能够使用标准的偏好菜单调整 macOS 应用的设置。你将通过添加一个 Settings 场景来为 MacLandmarks 添加偏好设置。场景的视图定义了偏好窗口的内容，你将用它来控制 MapView 的初始缩放级别。通过使用 @AppStorage 属性包装器，你可以将值传递给地图视图，并将其持久地存储。",
      "tips": ""
    },
    "This change will be useful in the iOS app.": {
      "zh": "这个修改将会在 iOS 应用程序中生效。",
      "tips": ""
    },
    "Add a filter state variable, defaulting to the all case.": {
      "zh": "添加一个 filter 状态变量，默认设置为 all 包含所有情况。",
      "tips": ""
    },
    "The updates improve the look in macOS, but you also need to consider the other platforms that use the list. Consider watchOS first.": {
      "zh": "这些更改优化了 macOS 的外观，但你还需要考虑使用该列表的其他平台。首先考虑 watchOS。",
      "tips": ""
    },
    "Add a macOS app icon set to match those for the other targets.": {
      "zh": "添加一个 macOS 应用程序图标集合，让 Mac 上也能正确显示 App 图标。",
      "tips": ""
    },
    "To be able to preview and run the app, be sure your Mac is running macOS Monterey or later.": {
      "zh": "为了能够预览和运行应用程序，请确保你的 Mac 运行的是 macOS Monterey 或更高版本。",
      "tips": ""
    },
    "Match the case strings to the Category enumeration in the Landmark structure so that you can compare them, and include an all case to turn filtering off.": {
      "zh": "将 FilterCategory 枚举中的的字符串与 Landmark 结构中的 Category 枚举相匹配，以便你可以比较它们，并包含一个 all 类型来关闭过滤。",
      "tips": ""
    },
    "Enclose everything below MapView in a VStack, and then place the CircleImage and the rest of the header in an HStack.": {
      "zh": "将 MapView 下方的所有内容都包含在 VStack 中，然后将 CircleImage 和头部的其余部分放在 HStack 中。",
      "tips": ""
    },
    "Add a Custom Menu Command": {
      "zh": "添加自定义菜单命令",
      "tips": ""
    },
    "Copy the contents of the old LandmarkList into the new one, but without the frame modifier.": {
      "zh": "将旧 LandmarkList 的内容复制到新的 LandmarkList 中，但不带 frame 修饰符。",
      "tips": ""
    }
  },
  "swiftui/creating-a-watchos-app": {
    "Add the Landmarks List": {
      "zh": "添加地标列表",
      "tips": ""
    },
    "This file holds the Watch-specific app definition. Its name depends on the Xcode project name, but it’s always the first item in the WatchLandmarks Extension group. You’ll reuse the iOS app definition instead, in the next few steps.": {
      "zh": "这个文件包含了针对 Apple Watch 的特定的应用定义，它的名称取决于 Xcode 项目名称，但它始终是 WatchLandmarks Extension 文件夹中的第一项。在接下来的几个步骤中，您将复用 iOS 应用定义。",
      "tips": ""
    },
    "The first time you run the notification scheme, the system asks for permission to send notifications. Select Allow.": {
      "zh": "第一次运行通知方案时，系统会请求发送通知的权限。 选择允许。",
      "tips": ""
    },
    "The LandmarkList that you created for iOS works for your watch app as well, and it automatically navigates to the watch-specific detail view that you just created when compiled for watchOS. Next, you’ll connect the list to the watch’s ContentView, so that it acts as the top level view for the watch app.": {
      "zh": "你为 iOS 创建的 LandmarkList 也适用于你的手表应用程序，它会自动导航到你刚刚专门为 watchOS 手表创建的详细信息视图。 接下来，你会让列表导航到手表的 ContentView，这样能让它充当手表应用程序的顶级视图。",
      "tips": ""
    },
    "In the Project navigator, Command-click to select the following files: LandmarksApp.swift,LandmarkList.swift, LandmarkRow.swift, CircleImage.swift, MapView.swift.": {
      "zh": "在项目导航器中，按住 Command 单击以选择以下文件：LandmarksApp.swift、LandmarkList.swift、LandmarkRow.swift、CircleImage.swift、MapView.swift。",
      "tips": ""
    },
    "Step 6": {
      "zh": "步骤 6",
      "tips": ""
    },
    "Create the Detail View": {
      "zh": "创建详细视图",
      "tips": ""
    },
    "The first of these is the shared app definition. The others are views that the app can display on watchOS with no changes.": {
      "zh": "其中第一个是共享应用程序入口。 其他是应用程序可以在 watchOS 上显示而无需更改的视图。",
      "tips": ""
    },
    "As you can see, the information doesn’t quite fit on the watch screen, but you can fix that by placing the VStack within a scroll view.": {
      "zh": "如你所见，信息不太适合在手表屏幕上显示，但你可以通过将 VStack 放在滚动视图中来解决这个问题。",
      "tips": ""
    },
    "Finally, add a watchOS app icon that matches the iOS app icon you already have.": {
      "zh": "最后，添加一个与你已有的 iOS 应用程序图标相匹配的 watchOS 应用程序图标。",
      "tips": ""
    },
    "Add a title to the back button.": {
      "zh": "给后退按钮添加标题。",
      "tips": ""
    },
    "Select the WatchLandmarks Extension project and navigate to the project’s General tab; select the Supports Running Without iOS App Installation checkbox.": {
      "zh": "选择 WatchLandmarks Extension 项目并点击到项目的 General 页面； 选中支持不需要安装 iOS App 运行（Supports Running Without iOS App Installation）。",
      "tips": ""
    },
    "The watchOS app’s root view displays the default “Hello, World!” message.": {
      "zh": "watchOS 应用程序的根视图显示默认的“Hello, World!” 信息。",
      "tips": ""
    },
    "Step 8": {
      "zh": "步骤 8",
      "tips": ""
    },
    "Add a new custom view to the WatchLandmarks Extension folder named LandmarkDetail.swift.": {
      "zh": "将新的自定义视图添加到名为 LandmarkDetail.swift 的 WatchLandmarks 扩展文件夹。",
      "tips": ""
    },
    "Finish Command-clicking to add resource files loaded by the model: landmarkData.json, hikeData.json, and Assets.xcassets.": {
      "zh": "按住 Command 单击以添加模型加载的资源文件：landmarkData.json、hikeData.json 和 Assets.xcassets。",
      "tips": ""
    },
    "Create a Custom Notification Interface": {
      "zh": "创建一个自定义的通知界面",
      "tips": ""
    },
    "Like LandmarkDetail.swift the content view for the watchOS target has the same name as the one for the iOS target. Keeping names and interfaces the same makes it easy to share files between targets.": {
      "zh": "与 LandmarkDetail.swift 一样，watchOS 目标的内容视图与 iOS 目标的内容视图具有相同的名称。 保持名称和接口相同可以轻松地在目标之间共享文件。",
      "tips": ""
    },
    "Define the LandmarkIndexKey.": {
      "zh": "定义 LandmarkIndexKey。",
      "tips": ""
    },
    "These are identical to the properties you added in Handling User Input.": {
      "zh": "这些与你在处理用户输入教程中添加的属性相同。",
      "tips": ""
    },
    "Change scaleToFill() to scaleToFit() and add padding.": {
      "zh": "将 scaleToFill() 更改为 scaleToFit() 并添加填充。",
      "tips": ""
    },
    "Whenever possible, create an independent watchOS app. Independent watchOS apps don’t require an iOS companion app.": {
      "zh": "尽可能创建一个独立的 watchOS 应用程序。 独立的 watchOS 应用不需要 iOS 配套应用。",
      "tips": ""
    },
    "Creating a macOS App": {
      "zh": "",
      "tips": ""
    },
    "Section 1": {
      "zh": "第 1 节",
      "tips": ""
    },
    "After you grant permission, the Simulator displays a scrollable notification which includes: the app’s icon to help identify the Landmarks app as the sender, the notification view, and buttons for the notification’s actions.": {
      "zh": "在你授予权限后，模拟器会显示一个可滚动的通知，其中包括：应用程序的图标（帮助用户识别是 Landmarks 应用程序的通知）、通知视图和通知操作按钮。",
      "tips": ""
    },
    "This sets the text for the back button to “Landmarks”.": {
      "zh": "这会将后退按钮的文本设置为“Landmarks”。",
      "tips": ""
    },
    "Create previews for the largest (44mm) and smallest (40mm) watch faces.": {
      "zh": "为最大 (44mm) 和最小 (40mm) 表盘创建预览。",
      "tips": ""
    },
    "By testing against the largest and smallest watch faces, you can see how well your app scales to fit on the display. As always, you should test your user interface on all supported device sizes.": {
      "zh": "通过针对最大和最小的表盘进行测试，你可以了解你的应用程序自适应的效果。 和之前一样，你应该在所有支持的设备尺寸上测试你的用户界面。",
      "tips": ""
    },
    "Note": {
      "zh": "笔记",
      "tips": ""
    },
    "When Apple Watch receives a notification, it looks for a scene in your app associated with the notification’s category.": {
      "zh": "当 Apple Watch 收到通知时，它会在你的应用程序中查找与通知类别相关联的场景。",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "This tutorial gives you a chance to apply much of what you’ve already learned about SwiftUI, and — with little effort — migrate the Landmarks app to watchOS.": {
      "zh": "本教程让你有机会应用已经学到的关于 SwiftUI 的很多知识，并且只需很少的努力，就可以将 Landmarks 应用迁移到 watchOS。",
      "tips": ""
    },
    "Configure the test payload to use the LandmarkNear category and to pass along the data expected by the notification controller.": {
      "zh": "配置通知的测试装置，使用 LandmarkNear 类别并传递通知控制器需要的数据。",
      "tips": ""
    },
    "In the Project navigator, delete the first item in the WatchLandmarks Extension folder; When asked, choose Move to trash.": {
      "zh": "在项目导航栏中，删除 WatchLandmarks Extension 文件夹中的第一项； 当询问时，选择移至垃圾箱（Move To Trash）。",
      "tips": ""
    },
    "To create a watchOS app, start by adding a watchOS target to the project. Xcode adds groups and files for the watchOS app to your project, along with the schemes needed to build and run the app.": {
      "zh": "要创建 watchOS 应用程序，首先要将 watchOS 目标添加到项目中。 Xcode 将 watchOS 应用程序的文件夹和文件添加到你的项目，以及编译和运行应用程序所需的方案配置。",
      "tips": ""
    },
    "You’ll start by adding a watchOS target to your project, before copying over the shared data and views you created for the iOS app. With all of the assets in place, you’ll customize the SwiftUI views to display the detail and list views on watchOS.": {
      "zh": "你将首先为项目添加一个 watchOS 目标，然后复制之前为 iOS 应用创建的共享数据和视图。在所有资源就绪后，你将自定义 SwiftUI 视图，以在 watchOS 上显示详细信息和列表视图。",
      "tips": ""
    },
    "This method updates the controller’s properties. After calling this method, the system invalidates the controller’s body property, which updates your navigation view. The system then displays the notification on Apple Watch.": {
      "zh": "这个方法更新控制器的属性。 调用此方法后，系统会使控制器的 body 属性失效，从而更新你的导航视图。 然后系统会在 Apple Watch 上显示通知。",
      "tips": ""
    },
    "Now that the iOS target resources are in place for working on the watch app, you’ll need to create a watch-specific view for displaying landmark details. To test the detail view, you’ll create custom previews for the largest and smallest watch sizes, and make some changes to the circle view so everything fits on the watch face.": {
      "zh": "现在针对 iOS 平台的资源已准备好用于手表应用程序，你需要创建一个特定用于手表的视图来显示地标详细信息。 为了测试详细视图，您将为最大和最小手表尺寸创建自定义预览，并对圆形视图进行一些修改，以使所有内容都适应手表表盘。",
      "tips": ""
    },
    "Step 3": {
      "zh": "步骤 3",
      "tips": ""
    },
    "The map appears off screen, but if you enable live preview, you can scroll down to see it.": {
      "zh": "地图显示在屏幕外，但如果启用实时预览，则可以向下滚动来查看它。",
      "tips": ""
    },
    "The scene only makes sense for watchOS, so add the conditional compilation.": {
      "zh": "该场景仅对 watchOS 有意义，因此添加条件编译。",
      "tips": ""
    },
    "Section 2": {
      "zh": "第 2 节",
      "tips": ""
    },
    "This template adds a new watchOS app to your project, setting the iOS app as its companion.": {
      "zh": "这个模板将新的 watchOS 应用程序添加到你的项目，将 iOS 应用程序设置为它的配套应用。",
      "tips": ""
    },
    "Step 10": {
      "zh": "步骤 10",
      "tips": ""
    },
    "Share Files Between Targets": {
      "zh": "在目标之间共享文件",
      "tips": ""
    },
    "Section 4": {
      "zh": "第 4 节",
      "tips": ""
    },
    "Continue Command-clicking to add the following model files: ModelData.swift, Landmark.swift, Hike.swift, Profile.swift.": {
      "zh": "继续按住 Command 单击添加以下模型文件：ModelData.swift、Landmark.swift、Hike.swift、Profile.swift。",
      "tips": ""
    },
    "In the File inspector, select the WatchLandmarks Extension checkbox in the Target Membership section.": {
      "zh": "在文件检查器（File inspector）中，选中目标列表中的 WatchLandmarks 扩展。",
      "tips": ""
    },
    "Here you reuse the CircleImage view from the iOS project. Because you created a resizable image, the call to scaledToFill() adjusts the circle’s size so that it fills the display.": {
      "zh": "在这里，你复用了 iOS 项目中的 CircleImage 视图。 因为你创建了一个可调整大小的图像，所以调用 scaledToFill() 调整圆的填充模式，使其充满视图。",
      "tips": ""
    },
    "Open NotificationView.swift and create a view that displays information about a landmark, title, and message.": {
      "zh": "打开 NotificationView.swift 并创建一个显示有关地标、标题和消息的信息的视图。",
      "tips": ""
    },
    "Step 7": {
      "zh": "步骤 7",
      "tips": ""
    },
    "Step 5": {
      "zh": "步骤 5",
      "tips": ""
    },
    "You use this key to extract the landmark index from the notification.": {
      "zh": "使用这个键从通知中提取地标索引。",
      "tips": ""
    },
    "Because any notification value can be nil, the preview will display two versions of the notification view. The first just shows the default values when no data is provided, and the second displays the title, message, and location you provide.": {
      "zh": "因为任何通知值都可以为 nil，所以预览会显示两个版本的通知视图。 第一个是未提供数据时显示默认值，第二个显示你提供的标题、消息和位置。",
      "tips": ""
    },
    "Select ContentView.swift in the WatchLandmarks Extension folder.": {
      "zh": "在 WatchLandmarks Extension 文件夹中选择 ContentView.swift。",
      "tips": ""
    },
    "Select the Landmarks-Watch (Notification) scheme, and build and run your app.": {
      "zh": "选择 Landmarks-Watch (Notification) 方案，编译并运行你的应用程序。",
      "tips": ""
    },
    "This scales the circle image to match the display’s width and ensures the landmark name is visible below the circle image.": {
      "zh": "这会缩放圆形图像来适应显示屏的宽度，并确保地标名称在圆形图像下方可见。",
      "tips": ""
    },
    "Drag the AppIcon.appiconset folder from the downloaded projects’ Resources folder into the WatchLandmark’s Asset catalog.": {
      "zh": "将 AppIcon.appiconset 文件夹从下载项目的 Resources 文件夹拖到 WatchLandmark 的 Asset 目录中。",
      "tips": ""
    },
    "After creating a version of the Landmarks app for watchOS, it’s time to set your sights on something bigger: bringing Landmarks to the Mac. You’ll build upon everything you’ve learned so far, to round out the experience of building a SwiftUI app for iOS, watchOS, and macOS.": {
      "zh": "在为 watchOS 创建 Landmarks 应用程序版本后，是时候将你的目光投向更大的目标了：将 Landmarks 引入 Mac。 你将以迄今为止所学的一切为基础，完善为 iOS、watchOS 和 macOS 构建 SwiftUI 应用程序的体验。",
      "tips": ""
    },
    "This turns on view scrolling, but it creates another problem: the circle image now expands to full size, and it resizes other UI elements to match the image size. You’ll need to resize the circle image so that just the circle and landmark name appear onscreen.": {
      "zh": "这会让视图可滚动，但会产生另一个问题：圆形图像现在会扩展到整个屏幕大小，并且会调整其他 UI 元素的大小来匹配图像大小。 你需要调整圆圈图像的大小，以便只有圆圈和地标名称出现在屏幕上。",
      "tips": ""
    },
    "Follow the steps to build this project, or download the finished project to explore on your own.": {
      "zh": "按照步骤编译此项目，或下载完成的项目来自行探索。",
      "tips": ""
    },
    "Be sure to provide the model data as an environment object to the preview. The LandmarksApp already provides this at the app level at run time, just as it does for iOS, but you also have to provide it for any previews that need it.": {
      "zh": "请确保将模型数据作为环境对象提供给预览。 LandmarksApp 已在运行时在应用程序级别提供此功能，就像它在 iOS 平台所做的那样，但是你还是必须要在预览中提供它，让需要的它的视图能够正确预览。",
      "tips": ""
    },
    "In the preview, create an instance of the model data, and use it to pass a landmark object to the LandmarkDetail structure’s initializer. You also need to set the view’s environment object.": {
      "zh": "在预览中，创建模型数据的实例，并使用它将地标对象传递给 LandmarkDetail 结构体来初始化。 你还需要设置视图的环境对象。",
      "tips": ""
    },
    "These properties store values about an incoming notification.": {
      "zh": "这些属性存储消息通知相关的值。",
      "tips": ""
    },
    "You’ll replace this in the next step.": {
      "zh": "你将在下一步中替换它。",
      "tips": ""
    },
    "This method instantiates the notification view that you created earlier.": {
      "zh": "这个方法实例化你之前创建的通知视图。",
      "tips": ""
    },
    "Start the live preview to check out how the app behaves.": {
      "zh": "启动实时预览检查应用程序的行为。",
      "tips": ""
    },
    "In the sheet, enter WatchLandmarks as the Product Name. Set the Interface to SwiftUI, the Life Cycle to SwiftUI App, and the Language to Swift. Select the Include Notification Scene checkbox, and then click Finish.": {
      "zh": "在工作表中，输入 WatchLandmarks 作为产品名称。 将界面框架设置为 SwiftUI，将应用生命周期设置为 SwiftUI 应用程序，并将语言设置为 Swift。 选中包含通知场景，然后单击完成。",
      "tips": ""
    },
    "Select the WatchLandmarks scheme.": {
      "zh": "选择 WatchLandmarks 方案。",
      "tips": ""
    },
    "This makes the symbols you selected in the previous steps available to your watchOS app.": {
      "zh": "这将使你在前面的步骤中选择的符号可用于你的 watchOS 应用程序。",
      "tips": ""
    },
    "Open the NotificationController and add the landmark, title, and message properties.": {
      "zh": "打开 NotificationController 并添加地标、标题和消息属性。",
      "tips": ""
    },
    "Section 5": {
      "zh": "第 5 节",
      "tips": ""
    },
    "Step 2": {
      "zh": "步骤 2",
      "tips": ""
    },
    "With the watchOS target set, you’ll need to share some resources from the iOS target. You’ll reuse the Landmark app’s data model, some resource files, as well as any views that both platforms can display without modification.": {
      "zh": "设置 watchOS 目标后，你需要从 iOS 目标共享一些资源。 你将重用 Landmark 应用程序的数据模型、一些资源文件，以及任何一个无需修改即可在两个平台显示的视图。",
      "tips": ""
    },
    "Add the modelData, landmark, and landmarkIndex properties to to the new LandmarkDetail structure.": {
      "zh": "将 modelData、landmark 和 landmarkIndex 属性添加到新的 LandmarkDetail 结构体中。",
      "tips": ""
    },
    "Creating a watchOS App": {
      "zh": "",
      "tips": ""
    },
    "These items define the app’s data model. You won’t use all aspects of the model, but you need all of the files to successfully compile the app.": {
      "zh": "这些项目定义了应用程序的数据模型。 你不会使用模型的所有数据，但你需要所有文件才能成功编译应用程序。",
      "tips": ""
    },
    "Your version of Landmarks for watchOS is almost complete. In this final section, you’ll create a notification interface that displays landmark information whenever you receive a notification indicating that you are close to one of your favorite locations.": {
      "zh": "你的 watchOS 版本的 Landmarks 应用几乎完成了。在最后这一部分，你将创建一个通知界面，每当收到通知表示你靠近某个喜欢的地点时，它会显示地标信息。",
      "tips": ""
    },
    "Wrap the vertical stack in a scroll view.": {
      "zh": "将垂直堆栈包装在滚动视图中。",
      "tips": ""
    },
    "Return a CircleImage view from the body() method.": {
      "zh": "从 body() 方法返回一个 CircleImage 视图。",
      "tips": ""
    },
    "Embed the circle image in a VStack. Display the landmark name and its information below the image.": {
      "zh": "将圆形图像嵌入到 VStack 中。 在图像下方显示地标名称及其信息。",
      "tips": ""
    },
    "Update the body() method to use these properties.": {
      "zh": "更新 body() 方法来使用这些属性。",
      "tips": ""
    },
    "The payload file simulates data sent from your server in a remote notification.": {
      "zh": "负载文件模拟从你的服务器在远程通知中发送的数据。",
      "tips": ""
    },
    "Select the PushNotificationPayload.apns file, and update the title, body, category, and landmarkIndex properties. Be sure to set category to LandmarkNear. You also delete any keys that are not used in the tutorial, such as the subtitle, WatchKit Simulator Actions, and customKey.": {
      "zh": "选择 PushNotificationPayload.apns 文件，并更新 title 、 body 、 category 和 landmarkIndex 属性。请务必将 category 设置为 LandmarkNear 。你还需要删除教程中未使用的其他的键，例如 subtitle 、 WatchKit Simulator Actions 和 customKey 。",
      "tips": ""
    },
    "This lets you build and run your watchOS app.": {
      "zh": "这使你可以编译和运行 watchOS 应用程序。",
      "tips": ""
    },
    "Add the MapView after a divider.": {
      "zh": "在分隔符之后添加 MapView。",
      "tips": ""
    },
    "Next select all the files, including the app’s entry point, that your watchOS target can share with the existing iOS target.": {
      "zh": "接下来选择 watchOS 平台能够和现有 iOS 平台共享的所有文件，包括应用程序的入口点。",
      "tips": ""
    },
    "Choose File > New > Target. When the template sheet appears, choose the watchOS tab, select the Watch App for iOS App template and click Next.": {
      "zh": "选择  File > New > Target。 在选项列表选择 watchOS 选项，选择 Watch App for iOS App 模板，然后单击 Next。",
      "tips": ""
    },
    "Later, when you create a notification, the system presents your app’s icon to help identify the source of the notification.": {
      "zh": "稍后，当你创建通知时，系统会显示你应用的图标以帮助用户识别通知的来源。",
      "tips": ""
    },
    "Modify ContentView so that it displays the List view.": {
      "zh": "修改 ContentView，使其显示列表视图。",
      "tips": ""
    },
    "Step 4": {
      "zh": "步骤 4",
      "tips": ""
    },
    "Step 9": {
      "zh": "步骤 9",
      "tips": ""
    },
    "Add a watchOS Target": {
      "zh": "添加 watchOS 目标",
      "tips": ""
    },
    "Section 3": {
      "zh": "第 3 节",
      "tips": ""
    },
    "Step 1": {
      "zh": "步骤 1",
      "tips": ""
    },
    "You’re going to want to start with the WatchLandmarks scheme instead, which you choose next.": {
      "zh": "你将要从接下来选择的 WatchLandmarks 方案开始。",
      "tips": ""
    },
    "Update the didReceive(_:) method to parse data from the notification.": {
      "zh": "更新 didReceive(_:) 方法来解析通知中的数据。",
      "tips": ""
    },
    "This file is distinguished from the file with the same name in the iOS project by its target membership — it applies only to the Watch Extension target.": {
      "zh": "此文件通过选择其 Watch 目标来和 iOS 项目中具有相同名称的文件区分开来 —— 它仅仅适用于 Watch Extension 目标。",
      "tips": ""
    },
    "Select the Assets.xcasset file in the WatchLandmarks folder and delete the empty AppIcon item.": {
      "zh": "选择 WatchLandmarks 文件夹中的 Assets.xcasset 文件并删除空的 AppIcon 项。",
      "tips": ""
    },
    "Go to LandmarksApp.swift and add a WKNotificationScene using the LandmarkNear category.": {
      "zh": "转到 LandmarksApp.swift 并使用 LandmarkNear 类别添加 WKNotificationScene。",
      "tips": ""
    },
    "The circle image resizes to fill the display. Unfortunately, this causes clipping. To fix the clipping problem, you’ll embed the image in a VStack and make some additional layout changes so that the circle image fits any watch.": {
      "zh": "圆形图像调整大小来填充视图。 不幸的是，这会导致图片被裁剪。 要解决这个问题，你需要将图像嵌入 VStack 并进行一些额外的布局更改，以便圆形图像适合任何手表。",
      "tips": ""
    },
    "If prompted by Xcode to activate the WatchLandmarks (Complication) scheme, click Cancel.": {
      "zh": "如果 Xcode 提示激活 WatchLandmarks (Complication) 方案，请单击取消。",
      "tips": ""
    },
    "This section only covers how to display the notification after you receive it. It doesn’t describe how to set up or send notifications.": {
      "zh": "本节仅介绍如何在收到通知后显示通知。 不会介绍如何设置或发送通知。",
      "tips": ""
    },
    "First, delete the entry point for the watchOS app. You don’t need it because you’ll reuse the entry point defined in LandmarksApp.swift instead.": {
      "zh": "首先，删除 watchOS 应用程序的入口。 你不需要它，因为你将重用 LandmarksApp.swift 中定义的入口点。",
      "tips": ""
    }
  },
  "swiftui/creating-and-combining-views": {
    "By default, SwiftUI view files declare two structures. The first structure conforms to the View protocol and describes the view’s content and layout. The second structure declares a preview for that view.": {
      "zh": "默认情况下，SwiftUI 视图文件声明两个结构体。第一个结构符合 View 协议，描述了视图的内容和布局。第二个结构声明该视图的预览样式。",
      "tips": ""
    },
    "Create a new Xcode project that uses SwiftUI. Explore the canvas, previews, and the SwiftUI template code.": {
      "zh": "创建一个使用 SwiftUI 框架的新 Xcode 项目。首先试着摸索一下画布、预览部分和 SwiftUI 提供的模板代码。",
      "tips": ""
    },
    "By prefixing a state variable with $, you pass a binding, which is like a reference to the underlying value. When the user interacts with the map, the map updates the region value to match the part of the map that’s currently visible in the user interface.": {
      "zh": "通过在状态变量前加上 $ 前缀，您可以传递一个绑定值，它类似于对原始值的引用。当用户与地图进行交互时，地图会根据界面中看到的地图区域更新它绑定的地区值。",
      "tips": ""
    },
    "Start by adding an image to the project’s asset catalog.": {
      "zh": "首先将图像添加到项目的资源文件目录中。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第 6 步",
      "tips": ""
    },
    "Replace the text view with the image of Turtle Rock by using the Image(_:) initializer, passing it the name of the image to display.": {
      "zh": "使用 Image(_:) 初始化方法将文本视图替换为 Turtle Rock 的图像视图，并将要显示的图像的名称传递给它。",
      "tips": ""
    },
    "Instead of adding more code in this file, you’ll create a custom view that applies a mask, border, and drop shadow to the image.": {
      "zh": "不需要在这个文件中添加更多的代码了，你将创建一个新的自定义视图，这个视图包含一个图片，并且会给图片添加蒙版，边框以及投影。",
      "tips": ""
    },
    "Add the CircleImage view to the stack.": {
      "zh": "将 CircleImage 视图添加到堆栈。",
      "tips": ""
    },
    "Replace the default Text view with a Map view that takes a binding to the region.": {
      "zh": "将默认的 Text 视图替换成带地区绑定的 Map 视图。",
      "tips": ""
    },
    "You use the @State attribute to establish a source of truth for data in your app that you can modify from more than one view. SwiftUI manages the underlying storage and automatically updates views that depend on the value.": {
      "zh": "你可以使用 @State 属性为你的应用程序建立真实的数据来源，随后可以从多个视图中修改这些数据。 SwiftUI 管理底层存储逻辑并且能够自动刷新依赖这些值的视图。",
      "tips": ""
    },
    "Download the project files to begin building this project, and follow the steps below.": {
      "zh": "下载工程文件来开始构建此项目，并按照以下的步骤操作。",
      "tips": ""
    },
    "Customize the location to match the desired layout.": {
      "zh": "调整位置来匹配我们需要的布局。",
      "tips": ""
    },
    "Step 8": {
      "zh": "第 8 步",
      "tips": ""
    },
    "Add your custom MapView to the top of the stack. Set the size of the MapView with frame(width:height:).": {
      "zh": "将你自定义的 MapView 添加到堆栈的顶部。使用 frame(width:height:) 设置 MapView 的大小。",
      "tips": ""
    },
    "When you specify only the height parameter, the view automatically sizes to the width of its content. In this case, MapView expands to fill the available space.": {
      "zh": "当你仅指定了 height 参数时，视图会根据内容的宽度自适应大小。在这种情况下， MapView 会自动扩展填满能够占据的空间。",
      "tips": ""
    },
    "By default, stacks center their contents along their axis and provide context-appropriate spacing.": {
      "zh": "默认情况下，垂直堆栈会将内容居中对齐，并根据内容提供一个合适的默认间距。",
      "tips": ""
    },
    "Next, you’ll add a text view to the stack by dragging a Text view from the library.": {
      "zh": "接下来，将通过从控件库中拖动 Text 视图的方式来将文本视图添加到堆栈中。",
      "tips": ""
    },
    "Use SwiftUI Views From Other Frameworks": {
      "zh": "使用来自其他框架的 swiftUI 视图",
      "tips": ""
    },
    "Create another circle with a gray stroke, and then add it as an overlay to give the image a border.": {
      "zh": "创建另一个带灰色描边的圆形，然后将它作为图片的覆盖层，这样相当于给图片添加边框。",
      "tips": ""
    },
    "Inside the body property, change “Hello, World!” to a greeting for yourself.": {
      "zh": "在 body 属性中，试着修改“Hello, World!”来给自己一个问候吧！",
      "tips": ""
    },
    "Combine Views Using Stacks": {
      "zh": "使用堆栈组合视图",
      "tips": ""
    },
    "In the canvas, click Resume to display the preview.": {
      "zh": "在右边的画布中，点击 Resume 来显示程序的预览效果。",
      "tips": ""
    },
    "Section 1": {
      "zh": "第 1 节",
      "tips": ""
    },
    "Next, add a shadow with a 7 point radius.": {
      "zh": "接下来，添加一个半径为 7 点的阴影。",
      "tips": ""
    },
    "This time, open the inspector by Command-clicking on the Text declaration in the code editor, and then choose “Show SwiftUI Inspector” from the popover. Click the Color pop-up menu and choose Inherited to change the text color to black again.": {
      "zh": "这一次，通过在代码编辑器中按住 Command 键并单击 Text 声明来打开检查器，然后从弹出窗口中选择“Show SwiftUI Inspector”。点击颜色弹出菜单并选择继承（Inspector），这样就能再次将文本颜色更改为黑色。",
      "tips": ""
    },
    "Building Lists and Navigation": {
      "zh": "",
      "tips": ""
    },
    "Enter “Landmarks” as the product name, select “SwiftUI” for the interface and “Swift” for the language, and click Next. Choose a location to save the Landmarks project on your Mac.": {
      "zh": "输入“Landmarks”作为产品名称，界面选择“SwiftUI”，语言选择“Swift”，点击下一步。在 Mac 上选择一个位置来保存 Landmarks 项目。",
      "tips": ""
    },
    "In the template selector, select iOS as the platform, select the App template, and then click Next.": {
      "zh": "在模板选择器中，选择 iOS 作为程序运行的平台，选择 App，然后单击 Next。",
      "tips": ""
    },
    "Use the inspector to change the text to “Turtle Rock”, the name of the first landmark you’ll show in your app.": {
      "zh": "使用检查器将文字更改为“Turtle Rock”，这是在应用中将要显示的第一个地标的名称。",
      "tips": ""
    },
    "Open Xcode and either click “Create a new Xcode project” in Xcode’s startup window, or choose File > New > Project.": {
      "zh": "打开 Xcode，然后在启动窗口中点击 “Create a new Xcode project”，或者点击状态栏中的 File > New > Project。",
      "tips": ""
    },
    "Set up business": {
      "zh": "创业，来来来来来",
      "tips": ""
    },
    "In a moment, you’ll see a map centered on Turtle Rock. You can manipulate the map in live preview to zoom out a bit and see the surrounding area.": {
      "zh": "很快，你会看到以 Turtle Rock 为中心的地图界面。您可以在实时预览中操作地图放大缩小或者查看周围区域。",
      "tips": ""
    },
    "As you change the code in a view’s body property, the preview updates to reflect your changes.": {
      "zh": "每当你修改 body 属性里面的代码，预览界面将会同步更新你的修改。",
      "tips": ""
    },
    "A spacer expands to make its containing view use all of the space of its parent view, instead of having its size defined only by its contents.": {
      "zh": "Spacer 会尽可能的撑开它在父视图里面的空间，而不是由父视图里面的内容决定的。",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Your code is always the source of truth for the view. When you use the inspector to change or remove a modifier, Xcode updates your code immediately to match.": {
      "zh": "视图的修改始终来源于你的代码。当使用检查器更改或删除修饰符时，Xcode 会立即更新你的源代码来匹配你的修改。",
      "tips": ""
    },
    "When you apply a modifier to a layout view like a stack, SwiftUI applies the modifier to all the elements contained in the group.": {
      "zh": "当你将修饰符应用到堆栈等布局视图时，SwiftUI 会将修饰符应用到堆栈中包含的所有元素上。",
      "tips": ""
    },
    "Edit the code by hand to change the padding() modifier to the foregroundColor(.green) modifier; this changes the text’s color to green.": {
      "zh": "手动编辑代码，将 padding() 修饰符改为 foregroundColor(.green) 修饰符；这个操作会将文本的颜色改为绿色。",
      "tips": ""
    },
    "Add an import statement for MapKit.": {
      "zh": "添加一行导入 MapKit 框架的代码",
      "tips": ""
    },
    "To preview and interact with views from the canvas in Xcode, and to use all the latest features described throughout the tutorials, ensure your Mac is running macOS Monterey or later.": {
      "zh": "要在 Xcode 的画布中预览以及和视图交互，还有使用我们这个教程中提到的最新功能，你需要保证 Mac 运行的是 macOS Monterey 或者更高的版本。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第 3 步",
      "tips": ""
    },
    "When previews are in static mode, they only fully render native SwiftUI views. For the Map view, you’ll need to switch to a live preview to see it render.": {
      "zh": "当预览处于静态模式时，它们只会呈现原生 SwiftUI 视图。对于 Map 视图，你需要切换到实时预览模式才能看到它的渲染效果。",
      "tips": ""
    },
    "Customize the Text View": {
      "zh": "自定义文本视图",
      "tips": ""
    },
    "The Circle type is a shape that you can use as a mask, or as a view by giving the circle a stroke or fill.": {
      "zh": "Circle 类型是一种形状，你可以将它用作遮罩，也可以给圆圈添加描边或填充来用作视图。",
      "tips": ""
    },
    "In the Project navigator, select the ContentView.swift file.": {
      "zh": "在项目导航栏中，选择 ContentView.swift 文件。",
      "tips": ""
    },
    "Section 2": {
      "zh": "第 2 节",
      "tips": ""
    },
    "Open the library by clicking the plus button (+) at the top-right of the Xcode window, and then drag a Text view to the place in your code immediately below the “Turtle Rock” text view.": {
      "zh": "点击 Xcode 窗口右上角的加号按钮 (+) 打开组件库，然后将 Text 视图拖到代码中“Turtle Rock”文本视图正下方的位置。",
      "tips": ""
    },
    "Create a private state variable that holds the region information for the map.": {
      "zh": "创建一个私有状态变量，用于保存地图的区域信息。",
      "tips": ""
    },
    "You now have all of the components you need — the name and place, a circular image, and a map for the location.": {
      "zh": "你现在已经准备好了所有需要的视图组件了，名称、地点、一个圆形图片，还有地图。",
      "tips": ""
    },
    "Add a spacer at the bottom of the outer VStack to push the content to the top of the screen.": {
      "zh": "在外层的 VStack 底部添加一个 Spacer，将整体内容推到屏幕的顶部。",
      "tips": ""
    },
    "Step 10": {
      "zh": "第 10 步",
      "tips": ""
    },
    "To lay out the views, Landmarks uses stacks to combine and layer the image and text view components. To add a map to the view, you’ll include a standard MapKit component. As you refine the view’s design, Xcode provides real-time feedback so you can see how those changes translate into code.": {
      "zh": "对于界面布局，Landmarks 使用堆栈的方式来组合以及布局图像和文本组件。因为界面中有地图模块，所以需要添加系统的 MapKit 组件。每当你重新调整界面的设计样式时，Xcode 会提供实时反馈，因此你可以看到这些修改是如何转化成为代码的。",
      "tips": ""
    },
    "Next, you’ll add another text view to the right of the location, this for the park’s state.": {
      "zh": "接下来，你将在公园位置文本的右边添加另一个文本，这是公园所属的州。",
      "tips": ""
    },
    "Section 4": {
      "zh": "第 4 节",
      "tips": ""
    },
    "In the preview, Command-click the greeting to bring up the structured editing popover, and choose “Show SwiftUI Inspector”.": {
      "zh": "在预览界面中，按住 Command 键并点击文字会弹出一个编辑窗口，然后选择“Show SwiftUI Inspector”。",
      "tips": ""
    },
    "Next, you’ll customize the text view using the inspector.": {
      "zh": "接下来，你将使用检查器自定义文本视图。",
      "tips": ""
    },
    "When you import SwiftUI and certain other frameworks in the same file, you gain access to SwiftUI-specific functionality provided by that framework.": {
      "zh": "当你在同一文件中导入 SwiftUI 和某些其他框架时，你可以访问这个框架提供给 SwiftUI 的特定的功能。",
      "tips": ""
    },
    "You can use Xcode’s structured editing support to embed a view in a container view, open an inspector, or help with other useful changes.": {
      "zh": "您可以使用 Xcode 的快速编辑功能， 它可以嵌入视图到当前容器，打开检查器或帮助你进行其他的修改。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第 7 步",
      "tips": ""
    },
    "Step 5": {
      "zh": "第 5 步",
      "tips": ""
    },
    "Add a divider and some additional descriptive text for the landmark.": {
      "zh": "给地标添加分隔线和一些其它的描述。",
      "tips": ""
    },
    "Change the Font modifier to “Title”.": {
      "zh": "选择字体修饰符，修改为“Title”。",
      "tips": ""
    },
    "Finally, use the padding() modifier method to give the landmark’s name and details a little more space.": {
      "zh": "最后，使用 padding() 修饰符方法给地标的名称和细节一些内边距。",
      "tips": ""
    },
    "An app that uses the SwiftUI app life cycle has a structure that conforms to the App protocol. The structure’s body property returns one or more scenes, which in turn provide content for display. The @main attribute identifies the app’s entry point.": {
      "zh": "使用 SwiftUI 框架的应用程序应该具有一个遵循 App 协议的结构体。结构体的 body 属性返回一个或者多个场景（Scene），这些场景提供内容以供显示。 @main 属性标识应用程序的入口。",
      "tips": ""
    },
    "Set the location’s font to subheadline.": {
      "zh": "将位置的字体设置为 subheadline 。",
      "tips": ""
    },
    "Add a call to clipShape(Circle()) to apply the circular clipping shape to the image.": {
      "zh": "添加 clipShape(Circle()) ，将图片裁剪成圆形。",
      "tips": ""
    },
    "To layer the image view on top of the map view, give the image an offset of -130 points vertically, and padding of -130 points from the bottom of the view.": {
      "zh": "要使图片盖在地图之上，你需要给图像提供 -130 单位的垂直偏移，也就是让它往上偏移 130 个单位，并且将它距离底部的间距调整为 -130 单位。",
      "tips": ""
    },
    "Choose File > New > File, select iOS as the platform, select the “SwiftUI View” template, and click Next. Name the new file MapView.swift and click Create.": {
      "zh": "选择 File > New > File，选择 iOS 作为平台，选择“SwiftUI View”模板，点击 Next。将新文件命名为 MapView.swift ，然后点击“创建”。",
      "tips": ""
    },
    "Tip": {
      "zh": "提示",
      "tips": ""
    },
    "Next, you’ll create a new SwiftUI view for your custom image view.": {
      "zh": "接下来，你将创建一个新的 SwiftUI 视图用来自定义图片。",
      "tips": ""
    },
    "Embed the VStack that holds the three text views in another VStack.": {
      "zh": "将包含三个文本视图的 VStack 嵌入到另一个 VStack 中。",
      "tips": ""
    },
    "This completes the image view.": {
      "zh": "这样就完成了这个图片视图",
      "tips": ""
    },
    "Create a Custom Image View": {
      "zh": "创建一个自定义的图片视图",
      "tips": ""
    },
    "This is a new key": {
      "zh": "",
      "tips": ""
    },
    "Replace the Text view’s placeholder text with “Joshua Tree National Park”.": {
      "zh": "将 Text 视图的默认占位文本替换为“Joshua Tree National Park”。",
      "tips": ""
    },
    "In this section, you’ll use a vertical stack to place the title above a horizontal stack that contains details about the park.": {
      "zh": "在本节中，你将使用垂直堆栈将标题放在包含公园信息的水平堆栈上方。",
      "tips": ""
    },
    "Creating and combining views": {
      "zh": "",
      "tips": ""
    },
    "Next you’ll create a map that centers on a given coordinate. You can use the Map view from MapKit to render the map.": {
      "zh": "接下来，你将创建一个以给定坐标为中心的地图。你可以使用 MapKit 中的地图视图来进行渲染展示。",
      "tips": ""
    },
    "When creating a SwiftUI view, you describe its content, layout, and behavior in the view’s body property; however, the body property only returns a single view. You can combine and embed multiple views in stacks, which group views together horizontally, vertically, or back-to-front.": {
      "zh": "创建 SwiftUI 视图时，你会在视图的 body 属性中描述其内容、布局和行为。但是， body 属性只能返回一个视图。因此你可以在堆栈中组合以及嵌入多个视图，这些视图以水平排列、垂直排列或前后堆叠的方式组合在一起。",
      "tips": ""
    },
    "These adjustments make room for the text by moving the image upwards.": {
      "zh": "向上调整图片来为文本腾出空间。",
      "tips": ""
    },
    "In the Project navigator, select LandmarksApp.swift.": {
      "zh": "在左侧的项目导航栏中，点击 LandmarksApp.swift 文件。",
      "tips": ""
    },
    "The popover shows different attributes that you can customize, depending on the type of view you inspect.": {
      "zh": "弹窗会根据你选择的视图类型展示不同的属性供你调整。",
      "tips": ""
    },
    "Find turtlerock@2x.jpg in the project files’ Resources folder; drag it into the asset catalog’s editor. Xcode creates a new image set for the image.": {
      "zh": "在项目文件的 Resources 文件夹中找到 turtlerock@2x.jpg，将它拖到资源目录中。 Xcode 会为图片自动创建一个新的图像集合。",
      "tips": ""
    },
    "Command-click the text view’s initializer to show the structured editing popover, and then choose “Embed in VStack”.": {
      "zh": "按住 Command 键并点击文本视图的初始化方法，然后在弹窗中选择“Embed in VStack”。",
      "tips": ""
    },
    "With the name and location views all set, the next step is to add an image for the landmark.": {
      "zh": "名称和位置视图都设置好后，下一步是为地标添加图像。",
      "tips": ""
    },
    "As you build the Landmarks app, you can use any combination of editors: the source editor, the canvas, or the inspectors. Your code stays updated, regardless of which tool you use.": {
      "zh": "在构建 Landmarks 应用程序时，你可以使用任意组合的编辑器：源代码编辑器、画布或检查器。无论你使用哪种工具修改，你的代码都会保持同步到最新版本。",
      "tips": ""
    },
    "You can continue editing the view while showing a Live Preview.": {
      "zh": "你可以在显示实时预览的同时继续编辑视图。",
      "tips": ""
    },
    "Section 5": {
      "zh": "第 5 节",
      "tips": ""
    },
    "Section 6": {
      "zh": "第 6 节",
      "tips": ""
    },
    "Step 2": {
      "zh": "第 2 步",
      "tips": ""
    },
    "You’re ready to insert the image and modify its display to match the desired design.": {
      "zh": "你已经做好了准备，接下来就是插入图片，然后修改图片成设计的效果。",
      "tips": ""
    },
    "You can customize a view’s display by changing your code, or by using the inspector to discover what’s available and to help you write code.": {
      "zh": "你可以尝试自己修改代码自定义界面展示，或者使用检查器(inspector)来探索有哪些可用的属性。",
      "tips": ""
    },
    "If the canvas isn’t visible, select Editor > Canvas to show it.": {
      "zh": "如果没有看到画布，点击状态栏中的 Editor > Canvas 让画布显示。",
      "tips": ""
    },
    "Switch the border color to white.": {
      "zh": "将边框颜色切换成白色",
      "tips": ""
    },
    "Edit the VStack initializer to align the views by their leading edges.": {
      "zh": "编辑 VStack 初始化方法，让文本居左对齐。",
      "tips": ""
    },
    "In the canvas, Command-click “Joshua Tree National Park”, and choose “Embed in HStack”.": {
      "zh": "在画布中，按住 Command 键并单击“Joshua Tree National Park”，然后选择“Embed in HStack”。",
      "tips": ""
    },
    "Click Live Preview to switch the preview to live mode. You might need to click Try Again or Resume above your preview.": {
      "zh": "单击实时预览将预览切换为实时模式。如果没能成功，你可以点击预览上方的“Try Again”或“Resume”多试几次。",
      "tips": ""
    },
    "To direct the layout to use the full width of the device, separate the park and the state by adding a Spacer to the horizontal stack holding the two text views.": {
      "zh": "要让界面按照整个设备的宽度来布局，你可以通过将 Spacer 插入到两个文本的中间，这样水平方向上的布局就会用间距分隔公园和所属的州。",
      "tips": ""
    },
    "Compose the Detail View": {
      "zh": "将视图整合成详情界面",
      "tips": ""
    },
    "Beyond the title view you created in the previous section, you’ll add text views to contain details about the landmark, such as the name of the park and state it’s in.": {
      "zh": "除了在上一节中创建的标题视图之外，你还将添加包含有关地标的文本视图，例如公园的名称和它所在的州。",
      "tips": ""
    },
    "With the tools you’ve used so far, combine your custom views to create the final design for the landmark detail view.": {
      "zh": "利用你前面使用到的工具，组合你的自定义的视图然后构建最终的地标界面吧。",
      "tips": ""
    },
    "To get started, you’ll create a new custom view to manage your map.": {
      "zh": "首先，您将创建一个新的自定义视图来管理您的地图。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第 4 步",
      "tips": ""
    },
    "To allow the map content to extend to the top edge of the screen, add the ignoresSafeArea(edges: .top) modifier to the map view.": {
      "zh": "为了让地图内容能够扩展到屏幕顶部的边缘，需要将 ignoresSafeArea(edges: .top) 修饰符添加到地图视图。",
      "tips": ""
    },
    "To customize a SwiftUI view, you call methods called modifiers. Modifiers wrap a view to change its display or other properties. Each modifier returns a new view, so it’s common to chain multiple modifiers, stacked vertically.": {
      "zh": "要自定义 SwiftUI 视图，您需要调用被称为修饰符（modifiers）的方法。修饰符用来包装一个视图，它可以更改这个视图的显示或其他属性。每个修饰符都返回一个新视图，因此通常需要垂直堆叠多个修饰符。",
      "tips": ""
    },
    "Step 9": {
      "zh": "第 9 步",
      "tips": ""
    },
    "Click Live Preview to see the rendered map in the composed view.": {
      "zh": "单击实时预览可以在组合视图中查看渲染出来的地图。",
      "tips": ""
    },
    "Section 3": {
      "zh": "第 3 节",
      "tips": ""
    },
    "Step 1": {
      "zh": "第 1 步",
      "tips": ""
    },
    "Notice that Xcode updates your code automatically to reflect the change, removing the foregroundColor(.green) modifier.": {
      "zh": "请注意，在你修改之后 Xcode 会自动更新您的代码，这里它会删除 foregroundColor(.green) 修饰符。",
      "tips": ""
    },
    "This applies the system font to the text so that it responds correctly to the user’s preferred font sizes and settings.": {
      "zh": "这样做会将系统的字体应用到文本上，让他可以跟随用户设置的字体大小和偏好进行调整。",
      "tips": ""
    },
    "This tutorial guides you through building Landmarks — an app for discovering and sharing the places you love. You’ll start by building the view that shows a landmark’s details.": {
      "zh": "本教程将指导你构建 Landmarks —— 一款发现和分享你喜欢的地方的应用程序。首先你将构建一个用来显示地标详情的视图。",
      "tips": ""
    },
    "Choose File > New > File to open the template selector again. In the User Interface section, select “SwiftUI View” and click Next. Name the file CircleImage.swift and click Create.": {
      "zh": "点击状态栏中的 File > New > File 再次打开模版选择窗口。在 User Interface 这一行中选择 “SwiftUI View” 然后点击下一步。将文件命名为“CircleImage.swift”，然后点击“Create”。",
      "tips": ""
    },
    "In the Project navigator, select ContentView.swift.": {
      "zh": "在项目导航栏中，选择 ContentView.swift 文件。",
      "tips": ""
    },
    "Create a New Project and Explore the Canvas": {
      "zh": "创建项目以及认识画布",
      "tips": ""
    },
    "Add a new text view after the location, change the placeholder text to the park’s state, and then set its font to subheadline.": {
      "zh": "在公园位置后面添加一个新的文本视图，将占位文字更改为公园所属的州，然后将它的字体设置为 subheadline 。",
      "tips": ""
    },
    "Finally, move the subheadline font modifier from each Text view to the HStack containing them, and apply the secondary color to the subheadline text.": {
      "zh": "最后，将 subheadline 字体修饰符从内部的文本视图移动到包含他们的父级 HStack，然后将 secondary 颜色应用到 HStack 上。",
      "tips": ""
    }
  },
  "swiftui/drawing-paths-and-shapes": {
    "Drawing Paths and Shapes": {
      "zh": "",
      "tips": ""
    },
    "Users receive a badge whenever they visit a landmark in their list. Of course, for a user to receive a badge, you’ll need to create one. This tutorial takes you through the process of creating a badge by combining paths and shapes, which you then overlay with another shape that represents the location.": {
      "zh": "每当用户访问其列表中的地标时，他们都会收到一个徽章。 当然，要让用户收到徽章，你需要创建一个。 本教程将引导你完成通过组合路径和形状创建徽章的过程，然后你将其与代表该位置的另一个形状叠加。",
      "tips": ""
    },
    "If you want to create multiple badges for different kinds of landmarks, try experimenting with the overlaid symbol, varying the amount of repetition, or changing the various angles and scales.": {
      "zh": "如果你想为不同类型的地标创建多个徽章，请尝试使用叠加符号进行试验，改变重复次数，或更改各种角度和比例。",
      "tips": ""
    },
    "Follow the steps to build this project, or download the finished project to explore on your own.": {
      "zh": "按照步骤构建此项目，或下载完成的项目以自行探索。",
      "tips": ""
    },
    "Create Drawing Data for a Badge View": {
      "zh": "为徽章视图创建绘图数据",
      "tips": ""
    },
    "To create the badge, you’ll start by defining data that you can use to draw a hexagon shape for the badge’s background.": {
      "zh": "要创建徽章，你需要先定义数据，用来绘制徽章背景的六边形形状。",
      "tips": ""
    },
    "Step 1": {
      "zh": "步骤 1",
      "tips": ""
    },
    "With the Views group selected in the navigation pane, choose File > New > File, select Swift File from the iOS Templates sheet, and click Next.": {
      "zh": "在导航窗格中选择 View 文件夹后，选择“File”>“New”>“File”，从“iOS Templates”表中选择“Swift File”，然后单击“Next”。",
      "tips": ""
    },
    "Step 2": {
      "zh": "步骤 2",
      "tips": ""
    },
    "Name the new file HexagonParameters.swift.": {
      "zh": "将新文件命名为 HexagonParameters.swift。",
      "tips": ""
    },
    "You’ll use this structure to define the shape of a hexagon.": {
      "zh": "你将使用这个结构体来定义六边形的数据。",
      "tips": ""
    },
    "Step 3": {
      "zh": "步骤 3",
      "tips": ""
    },
    "Inside the new file, create a structure called HexagonParameters.": {
      "zh": "在新文件中，创建一个名为 HexagonParameters 的结构体。",
      "tips": ""
    },
    "Step 4": {
      "zh": "步骤 4",
      "tips": ""
    },
    "Define a Segment structure to hold the three points that represent one side of the hexagon; import CoreGraphics so you can use CGPoint.": {
      "zh": "定义一个 Segment 结构来保存代表六边形一侧的三个点； 导入 CoreGraphics，以便你可以使用 CGPoint。",
      "tips": ""
    },
    "Each side starts where the previous ends, moves in a straight line to the first point, and then moves over a Bézier curve at the corner to the second point. The third point controls the shape of the curve.": {
      "zh": "每条边都从前一条边结束的点开始，沿直线移动到第一个点，然后通过拐角处的贝塞尔曲线移动到第二个点。 第三点控制曲线的形状。",
      "tips": ""
    },
    "Step 5": {
      "zh": "步骤 5",
      "tips": ""
    },
    "Create an array to hold segments.": {
      "zh": "创建一个数组来存储 Segment。",
      "tips": ""
    },
    "Step 6": {
      "zh": "步骤 6",
      "tips": ""
    },
    "Add data for the six segments, one for each side of the hexagon.": {
      "zh": "为六个部分分别添加数据，每个部分对应六边形的一条边。",
      "tips": ""
    },
    "The values are stored as a fraction of a unit square having its origin in the upper left, with positive x to the right and positive y down. Later, you’ll use these fractions to find the actual points of a hexagon with a given size.": {
      "zh": "这些数值以一个正方形为基准坐标，按照比例设置，正 x 向右，正 y 向下。 待会你将使用这些比例数值来查找具有给定大小的六边形的实际点。",
      "tips": ""
    },
    "Step 7": {
      "zh": "步骤 7",
      "tips": ""
    },
    "Add an adjustment value that lets you tune the shape of the hexagon.": {
      "zh": "添加一个调整值，使你可以调整六边形的形状。",
      "tips": ""
    },
    "Draw the Badge Background": {
      "zh": "绘制徽章背景",
      "tips": ""
    },
    "Use the graphics APIs in SwiftUI to draw a custom badge shape.": {
      "zh": "使用 SwiftUI 中的图形 API 绘制自定义徽章形状。",
      "tips": ""
    },
    "Create another new file with File > New > File, this time selecting SwiftUI View from the iOS Templates sheet. Click Next and then name the file BadgeBackground.swift.": {
      "zh": "使用 File > New > File 创建另一个新文件，这次从 iOS 模板中选择 SwiftUI 视图。 单击下一步，然后将文件命名为 BadgeBackground.swift。",
      "tips": ""
    },
    "In BadgeBackground.swift, add a Path shape to the badge and apply the fill() modifier to turn the shape into a view.": {
      "zh": "在 BadgeBackground.swift 中，将 Path 形状添加到徽章并使用 fill() 修饰符将形状变成视图。",
      "tips": ""
    },
    "You use paths to combine lines, curves, and other drawing primitives to form more complex shapes like the badge’s hexagonal background.": {
      "zh": "你可以使用 Path 来组合直线、曲线和其他绘图基础元素，来组合成更复杂的形状，例如徽章的六边形背景。",
      "tips": ""
    },
    "Add a starting point to the path, assuming a container with size 100 x 100 px.": {
      "zh": "假设容器大小为 100 x 100 像素，将起点添加到 Path。",
      "tips": ""
    },
    "The move(to:) method moves the drawing cursor within the bounds of a shape as though an imaginary pen or pencil is hovering over the area, waiting to start drawing.": {
      "zh": "move(to:) 方法就像一支想要开始绘画的虚拟笔或铅笔悬浮在形状区域内，可以在区域内移动绘画光标。",
      "tips": ""
    },
    "Draw the lines for each point of the shape data to create a rough hexagonal shape.": {
      "zh": "给形状数据的每个点连线来创建一个大致的六边形。",
      "tips": ""
    },
    "The addLine(to:) method takes a single point and draws it. Successive calls to addLine(to:) begin a line at the previous point and continue to the new point.": {
      "zh": "addLine(to:) 方法接受一个点并绘制它。连续调用  addLine(to:) 的从前一个点连线到下一个点，最终形成一个形状。",
      "tips": ""
    },
    "Don’t worry if your hexagon looks a little unusual; that’s because you’re ignoring the curved part of each segment at the shape’s corners. You’ll account for that next.": {
      "zh": "如果你的六边形看起来有点不太对劲，别担心； 那是因为你忽略了线段边角处的弯曲部分。 接下来你会考虑到这一点。",
      "tips": ""
    },
    "Use the addQuadCurve(to:control:) method to draw the Bézier curves for the badge’s corners.": {
      "zh": "使用 addQuadCurve(to:control:) 方法绘制徽章拐角处的贝塞尔曲线。",
      "tips": ""
    },
    "Wrap the path in a GeometryReader so the badge can use the size of its containing view, which defines the size instead of hard-coding the value (100).": {
      "zh": "将 Path 包装在 GeometryReader 中，让徽章可以获取到父视图的大小，这样就不用使用写死 100 来设置大小。",
      "tips": ""
    },
    "Using the smallest of the geometry’s two dimensions preserves the aspect ratio of the badge when its containing view isn’t square.": {
      "zh": "当徽章的父视图不是正方形时，使用 geometry 的两个维度中最小的一个可以保留徽章的长宽比。",
      "tips": ""
    },
    "Scale the shape on the x-axis using xScale, and then add xOffset to recenter the shape within its geometry.": {
      "zh": "使用 xScale 在 x 轴上缩放形状，然后添加 xOffset 让图形重新居中。",
      "tips": ""
    },
    "Step 8": {
      "zh": "步骤 8",
      "tips": ""
    },
    "Replace the solid black background with a gradient to match the design.": {
      "zh": "按照设计效果，用渐变替换纯黑色背景。",
      "tips": ""
    },
    "Step 9": {
      "zh": "步骤 9",
      "tips": ""
    },
    "Apply the aspectRatio(_:contentMode:) modifier to the gradient fill.": {
      "zh": "将 aspectRatio(_:contentMode:) 修饰符应用到渐变视图上。",
      "tips": ""
    },
    "By preserving a 1:1 aspect ratio, the badge maintains its position at the center of the view, even if its ancestor views aren’t square.": {
      "zh": "保持 1:1 的长宽比，徽章能够始终显示在视图的中心位置，即使其父级视图并非正方形。",
      "tips": ""
    },
    "Draw the Badge Symbol": {
      "zh": "绘制徽章图标",
      "tips": ""
    },
    "The Landmarks badge has a custom insignia in its center that’s based on the mountain that appears in the Landmarks app icon.": {
      "zh": "地标应用的徽章在其中心拥有一个定制的图案，其灵感来源于地标应用图标中出现的山峰。",
      "tips": ""
    },
    "The mountain symbol consists of two shapes: one that represents a snowcap at the peak, and the other that represents vegetation along the approach. You’ll draw them using two partially triangular shapes that are set apart by a small gap.": {
      "zh": "这个山峰图标由两个形状组成：一个代表山顶的雪帽，另一个代表沿途的植被。你将绘制两个略带三角形状的图案来完成它们，这两个形状之间有一个小间隙。",
      "tips": ""
    },
    "First you’ll give your app an icon, to establish a look for the badge.": {
      "zh": "首先，你将为你的应用程序提供一个图标，做为 App 的 Logo。",
      "tips": ""
    },
    "Delete the empty AppIcon item from your project’s Asset Catalog, and then drag the AppIcon.appiconset folder from the downloaded projects’ Resources folder into the Asset catalog.": {
      "zh": "从项目的 Asset Catalog 中删除空的 AppIcon，然后将 AppIcon.appiconset 文件夹从下载的项目的 Resources 文件夹直接拖到 Asset 目录中。",
      "tips": ""
    },
    "Xcode recognizes the folder as containing all the size variations of an app icon and creates a corresponding item in the catalog.": {
      "zh": "Xcode 会识别该文件夹包含应用程序图标的所有不同尺寸，并且在目录中创建对应的项。",
      "tips": ""
    },
    "Next, you’ll build the matching badge symbol.": {
      "zh": "接下来，你将构建对应的徽章图标。",
      "tips": ""
    },
    "Create a new custom view called BadgeSymbol for the mountain shape that’s stamped in a rotated pattern in the badge design.": {
      "zh": "创建一个名为BadgeSymbol的新自定义视图，以旋转图案呈现山的形状。",
      "tips": ""
    },
    "Draw the top portion of the symbol using the path APIs.": {
      "zh": "使用 Path API 绘制图标的顶部。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实验",
      "tips": ""
    },
    "Adjust the numeric multipliers associated with the spacing, topWidth, and topHeight constants to see how they influence the overall shape.": {
      "zh": "调整与 spacing、topWidth 和 totopHeight 常量关联的数值的乘数，观察它们如何影响整体形状。",
      "tips": ""
    },
    "Draw the bottom portion of the symbol.": {
      "zh": "绘制符号的底部。",
      "tips": ""
    },
    "Use the move(to:) modifier to insert a gap between multiple shapes in the same path.": {
      "zh": "使用 move(to:) 修饰符在同一路径中的多个形状之间插入间隙。",
      "tips": ""
    },
    "Fill the symbol with the purple color from the design.": {
      "zh": "用紫色来填充图标颜色。",
      "tips": ""
    },
    "Create a new RotatedBadgeSymbol view to encapsulate the concept of a rotated symbol.": {
      "zh": "创建一个新的 RotatedBadgeSymbol 视图来封装旋转图标。",
      "tips": ""
    },
    "Adjust the angle in the preview to test the effect of the rotation.": {
      "zh": "在预览中调整角度，测试旋转效果。",
      "tips": ""
    },
    "Combine the Badge Foreground and Background": {
      "zh": "合并徽章内容和背景",
      "tips": ""
    },
    "The badge design calls for the mountain shape to be rotated and repeated multiple times on top of the badge background.": {
      "zh": "徽章设计要求山形图案在徽章背景上旋转并重复多次。",
      "tips": ""
    },
    "Define a new type for rotation and leverage the ForEach view to apply the same adjustments to multiple copies of the mountain shape.": {
      "zh": "定义一个新的旋转类型，并利用 ForEach 将相同的调整应用于多个山形的副本。",
      "tips": ""
    },
    "Create a new SwiftUI view called Badge.": {
      "zh": "创建一个名为 Badge 的新 SwiftUI 视图。",
      "tips": ""
    },
    "Place BadgeBackground in the body of Badge.": {
      "zh": "将 BadgeBackground 放在 Badge 的主体中。",
      "tips": ""
    },
    "Lay the badge’s symbol over the badge background by placing it in a ZStack.": {
      "zh": "将徽章图案放置在 ZStack 中，将其置于徽章背景之上。",
      "tips": ""
    },
    "As it appears now, the badge symbol is too large compared to the intended design and relative size of the background.": {
      "zh": "根据目前的展示效果，与预期设计及背景相对尺寸相比，徽章图标过大。",
      "tips": ""
    },
    "Correct the size of the badge symbol by reading the surrounding geometry and scaling the symbol.": {
      "zh": "通过读取布局的 geometry 并缩放图案来更正徽章图案的大小。",
      "tips": ""
    },
    "Add a ForEach view to rotate and display copies of the badge symbol.": {
      "zh": "添加 ForEach 视图来旋转和显示徽章图案的副本。",
      "tips": ""
    },
    "A full, 360° rotation split into eight segments creates a sun-like pattern by repeating the mountain symbol.": {
      "zh": "一个完整的 360° 旋转分为八个部分，通过重复山峰图案创建一个类似太阳的图案。",
      "tips": ""
    },
    "To keep the project organized, before moving on to the next tutorial, collect all of the new files that you added in this tutorial into a Badges group.": {
      "zh": "为了使项目结构清晰，在继续下一个教程之前，将你在本教程中添加的所有新文件移动到 Badges 文件夹中。",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Animating Views and Transitions": {
      "zh": "",
      "tips": ""
    },
    "When using SwiftUI, you can individually animate changes to views, or to a view’s state, no matter where the effects are. SwiftUI handles all the complexity of these combined, overlapping, and interruptible animations for you.": {
      "zh": "使用 SwiftUI 时，你可以单独为视图或视图状态的更改设置动画，无论效果在哪里。 SwiftUI 为你处理这些组合、重叠和可中断动画的所有复杂性。",
      "tips": ""
    },
    "Section 1": {
      "zh": "第 1 节",
      "tips": ""
    },
    "Section 2": {
      "zh": "第 2 节",
      "tips": ""
    },
    "Section 4": {
      "zh": "第 4 节",
      "tips": ""
    },
    "Section 3": {
      "zh": "第 3 节",
      "tips": ""
    }
  },
  "swiftui/handling-user-input": {
    "Use an Observable Object for Storage": {
      "zh": "使用可观察对象来存储",
      "tips": ""
    },
    "You can customize the list view so that it shows all of the landmarks, or just the user’s favorites. To do this, you’ll need to add a bit of state to the LandmarkList type.": {
      "zh": "你可以自定义列表视图，使其显示所有地标，或仅显示用户收藏的地标。 要实现这种效果，你需要向 LandmarkList 类型添加一些状态。",
      "tips": ""
    },
    "Step 6": {
      "zh": "步骤 6",
      "tips": ""
    },
    "Use the filtered version of the list of landmarks in the List.": {
      "zh": "将列表修改为使用过滤之后的数据。",
      "tips": ""
    },
    "Use modelData.landmarks as the data when filtering landmarks.": {
      "zh": "筛选地标时使用 modelData.landmarks 作为数据。",
      "tips": ""
    },
    "You use the $ prefix to access a binding to a state variable, or one of its properties.": {
      "zh": "你可以使用 $ 前缀来绑定状态变量或它的某个属性。",
      "tips": ""
    },
    "Change the initial value of showFavoritesOnly to true to see how the list reacts.": {
      "zh": "将 showFavoritesOnly 的初始值更改为 true 查看列表的变化。",
      "tips": ""
    },
    "Because system images are vector based, you can change their color with the foregroundColor(_:) modifier.": {
      "zh": "因为系统图像是基于矢量的，所以你可以使用 foregroundColor(_:) 修饰符更改它们的颜色。",
      "tips": ""
    },
    "To give the user control over the list’s filter, you need to add a control that can alter the value of showFavoritesOnly. You do this by passing a binding to a toggle control.": {
      "zh": "要让用户控制列表的过滤，你需要添加一个控件用来更改 showFavoritesOnly 值。 你可以将这个值绑定到一个开关上。",
      "tips": ""
    },
    "Because you use a binding, changes made inside this view propagate back to the data source.": {
      "zh": "因为使用 @Binding 属性，所以在此视图内所做的更改会传播回数据源。",
      "tips": ""
    },
    "\u0001Step 7": {
      "zh": "步骤 7",
      "tips": ""
    },
    "Users receive a badge whenever they visit a landmark in their list. Of course, for a user to receive a badge, you’ll need to create one. This tutorial takes you through the process of creating a badge by combining paths and shapes, which you then overlay with another shape that represents the location.": {
      "zh": "每当用户访问其列表中的地标时，他们都会收到一个徽章。 当然，要让用户收到徽章，你需要创建一个。 本教程将引导你完成通过组合路径和形状创建徽章的过程，然后你将其与代表该位置的另一个形状叠加。",
      "tips": ""
    },
    "\u0001Step 6": {
      "zh": "步骤 6",
      "tips": ""
    },
    "Add a @State property called showFavoritesOnly with its initial value set to false.": {
      "zh": "添加一个名为 showFavoritesOnly 的 @State 属性，初始值设置为 false。",
      "tips": ""
    },
    "Section 1": {
      "zh": "第 1 节",
      "tips": ""
    },
    "Update the LandmarkRow preview to work with the ModelData object.": {
      "zh": "更新 LandmarkRow 的预览以使用 ModelData 对象。",
      "tips": ""
    },
    "The Landmarks app can now switch between a filtered and unfiltered view of the landmarks, but the list of favorite landmarks is still hard coded. To allow the user to add and remove favorites, you need to add a favorite button to the landmark detail view.": {
      "zh": "Landmarks 应用程序现在可以在过滤和未过滤的地标视图之间切换，但收藏的地标列表仍然是写死的。 要允许用户自己添加和删除收藏夹，你需要在地标详细视图中添加收藏夹按钮。",
      "tips": ""
    },
    "Switch back to LandmarkList.swift and turn on the live preview to verify that everything is working properly.": {
      "zh": "切换回 LandmarkList.swift 并打开实时预览，验证一切是否正常。",
      "tips": ""
    },
    "In LandmarkList.swift, add an @EnvironmentObject property declaration to the view, and an environmentObject(_:) modifier to the preview.": {
      "zh": "在 LandmarkList.swift 中，向视图添加一个 @EnvironmentObject 属性声明，并向预览添加一个 environmentObject(_:) 修饰符。",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Switch back to LandmarkList.swift, and turn on the live preview.": {
      "zh": "切换回 LandmarkList.swift，并打开实时预览。",
      "tips": ""
    },
    "Create a new view called FavoriteButton.swift.": {
      "zh": "创建一个名为 FavoriteButton.swift 的新视图。",
      "tips": ""
    },
    "When you make changes to your view’s structure, like adding or modifying a property, you need to manually refresh the canvas.": {
      "zh": "当你更改视图的结构时，例如添加或修改属性，你需要手动刷新画布。",
      "tips": ""
    },
    "Embed the landmark’s name in an HStack with a new FavoriteButton; provide a binding to the isFavorite property with the dollar sign ($).": {
      "zh": "将新的收藏按钮以及地标的名称嵌入到 HStack 中； 使用符号 $ 对 isFavorite 属性进行绑定。",
      "tips": ""
    },
    "In the Landmarks app, a user can flag their favorite places, and filter the list to show just their favorites. To create this feature, you’ll start by adding a switch to the list so users can focus on just their favorites, and then you’ll add a star-shaped button that a user taps to flag a landmark as a favorite.": {
      "zh": "在 Landmarks 应用程序中，用户可以标记他们最喜欢的地方并且对列表进行过滤仅显示他们的收藏。 要创建此功能，你首先要在列表中添加一个开关，用户可以切换开关展示他的收藏夹，然后你将添加一个星形按钮，用户点击该按钮可将地标标记为收藏。",
      "tips": ""
    },
    "In SwiftUI blocks, you use if statements to conditionally include views.": {
      "zh": "在 SwiftUI 块中，你可以使用 if 语句判断是否显示视图。",
      "tips": ""
    },
    "You’ll first create a reusable FavoriteButton.": {
      "zh": "你将首先创建一个可重用的 FavoriteButton。",
      "tips": ""
    },
    "Step 3": {
      "zh": "步骤 3",
      "tips": ""
    },
    "Begin by enhancing the list to show users their favorites at a glance. Add a property to the Landmark structure to read the initial state of a landmark as a favorite, and then add a star to each LandmarkRow that shows a favorite landmark.": {
      "zh": "首先优化列表，让用户一目了然地看到他们喜欢的地标。 向 Landmark 结构添加一个属性表示是否收藏，然后向每个已收藏的 LandmarkRow 添加一个星星图标。",
      "tips": ""
    },
    "Section 2": {
      "zh": "第 2 节",
      "tips": ""
    },
    "Filter the List View": {
      "zh": "过滤列表视图",
      "tips": ""
    },
    "A binding acts as a reference to a mutable state. When a user taps the toggle from off to on, and off again, the control uses the binding to update the view’s state accordingly.": {
      "zh": "binding 关键词相当于对可变状态的引用。 当用户点击开关从关闭到打开，然后再次关闭时，使用绑定能相应地更新视图的状态。",
      "tips": ""
    },
    "The star is present whenever a landmark’s isFavorite property is true. You’ll see how to modify that property later in this tutorial.": {
      "zh": "每当地标的 isFavorite 属性为 true，星星图标就会显示。 你将在本教程后面看到如何修改该属性。",
      "tips": ""
    },
    "An observable object needs to publish any changes to its data, so that its subscribers can pick up the change.": {
      "zh": "可观察对象对其数据的任何更改都需要发布出去，以便订阅者可以收到更改的消息。",
      "tips": ""
    },
    "A preview fails if any subview requires a model object in the environment, but the view you are previewing doesn’t have the environmentObject(_:) modifier.": {
      "zh": "如果有任何子视图需要环境中的对象，而你正在预览的视图没有传入 environmentObject(_:) 修饰符，则会预览失败。",
      "tips": ""
    },
    "As you navigate from the list to the detail and tap the button, those changes persist when you return to the list. Because both views access the same model object in the environment, the two views maintain consistency.": {
      "zh": "当你从列表导航到详细信息并点击收藏按钮时，这些更改在你返回列表时仍然存在。 因为两个视图访问环境中的同一个模型对象，所以两个视图保持一致。",
      "tips": ""
    },
    "Section 4": {
      "zh": "第 4 节",
      "tips": ""
    },
    "After the spacer, add a star image inside an if statement to test whether the current landmark is a favorite.": {
      "zh": "在 spacer 之后，在 if 语句中添加一个星星图像来标识当前地标是否是收藏。",
      "tips": ""
    },
    "The landmarkData.json file has a key with this name for each landmark. Because Landmark conforms to Codable, you can read the value associated with the key by creating a new property with the same name as the key.": {
      "zh": "landmarkData.json 文件中的每个地标对象都有一个对应的 isFavorite 键。 因为 Landmark 符合 Codable，你可以通过创建与 json 中同名的属性来读取与键关联的值。",
      "tips": ""
    },
    "Step 7": {
      "zh": "步骤 7",
      "tips": ""
    },
    "Step 5": {
      "zh": "步骤 5",
      "tips": ""
    },
    "State is a value, or a set of values, that can change over time, and that affects a view’s behavior, content, or layout. You use a property with the @State attribute to add state to a view.": {
      "zh": "状态是一个值或一组值，可以随时间变化，并影响视图的行为、内容或布局。 你可以使用带有 @State 特性的属性来将状态添加到视图。",
      "tips": ""
    },
    "Open the starting point Xcode project or the project you finished in the previous tutorial, and select Landmark.swift in the Project navigator.": {
      "zh": "打开初始 Xcode 项目或者你在上个教程中完成的项目，然后在项目导航器中选择 Landmark.swift。",
      "tips": ""
    },
    "Update the ContentView preview to add the model object to the environment, which makes the object available to any subview.": {
      "zh": "更新 ContentView 预览，将模型对象添加到环境中，这使得该对象可用于任何子视图。",
      "tips": ""
    },
    "An observable object is a custom object for your data that can be bound to a view from storage in SwiftUI’s environment. SwiftUI watches for any changes to observable objects that could affect a view, and displays the correct version of the view after a change.": {
      "zh": "对于你的数据来说，可观察对象是可自定义的，它可以绑定到 SwiftUI 环境中存储的视图。 SwiftUI 会监听可能影响视图的可观察对象的任何修改，并在可观察对象发生更改后刷新视图，保证显示数据正确。",
      "tips": ""
    },
    "Declare a new model type that conforms to the ObservableObject protocol from the Combine framework.": {
      "zh": "创建一个新的模型类型，使它遵循 Combine 框架中的 ObservableObject 协议。",
      "tips": ""
    },
    "Download the starter project and follow along with this tutorial, or open the finished project and explore the code on your own.": {
      "zh": "下载初始项目并按照本教程进行操作，或者打开完成的项目自己探索代码。",
      "tips": ""
    },
    "Create a Favorite Button for Each Landmark": {
      "zh": "为每个地标创建一个收藏按钮",
      "tips": ""
    },
    "Next, you’ll add the FavoriteButton to the detail view, binding the button’s isSet property to the isFavorite property of a given landmark.": {
      "zh": "接下来，将 FavoriteButton 添加到详情视图，将按钮的 isSet 属性绑定给定地标的 isFavorite 属性。",
      "tips": ""
    },
    "Because you use state properties to hold information that’s specific to a view and its subviews, you always create state as private.": {
      "zh": "因为你使用 @State 属性来保存针对于特定视图及其子视图的状态，所以你需要将属性设置为私有的。",
      "tips": ""
    },
    "To support this, you also need access to the environment’s model data.": {
      "zh": "为此，你还需要访问环境中的模型数据。",
      "tips": ""
    },
    "Add a Control to Toggle the State": {
      "zh": "添加控制显示状态的控件",
      "tips": ""
    },
    "\u0001Step 5": {
      "zh": "步骤 5",
      "tips": ""
    },
    "Use the live preview and try out this new functionality by tapping the toggle.": {
      "zh": "使用实时预览并通过点击切换开关来尝试这个新功能。",
      "tips": ""
    },
    "\u0001Step 4": {
      "zh": "步骤 4",
      "tips": ""
    },
    "Add an isSet binding that indicates the button’s current state, and provide a constant value for the preview.": {
      "zh": "添加一个 isSet 属性表示按钮当前的状态，并为预览视图提供一个常量。",
      "tips": ""
    },
    "Add the @Published attribute to the landmarks array.": {
      "zh": "将 @Published 属性添加到 landmarks 数组。",
      "tips": ""
    },
    "Select LandmarkRow.swift in the Project navigator.": {
      "zh": "在项目文件目录中选择 LandmarkRow.swift。",
      "tips": ""
    },
    "Create a nested ForEach group to transform the landmarks into rows.": {
      "zh": "创建一个嵌套的 ForEach 将地标数据转换为行视图。",
      "tips": ""
    },
    "Compute a filtered version of the landmarks list by checking the showFavoritesOnly property and each landmark.isFavorite value.": {
      "zh": "检查 showFavoritesOnly 属性和每个 landmark.isFavorite 值来决定地标列表的过滤方案。",
      "tips": ""
    },
    "Switch to LandmarkDetail.swift, and compute the index of the input landmark by comparing it with the model data.": {
      "zh": "切换到 LandmarkDetail.swift，通过将传入的 landmark 与 modelData 进行比较来计算地标的索引。",
      "tips": ""
    },
    "Before moving on, return the default value of showsFavoritesOnly to false.": {
      "zh": "在继续之前，将 showsFavoritesOnly 的默认值设置为 false。",
      "tips": ""
    },
    "Select LandmarkList.swift in the Project navigator and revert the preview to show only a single version of the list.": {
      "zh": "在项目文件目录中选择 LandmarkList.swift 并将预览恢复为仅显示单个列表的版本。",
      "tips": ""
    },
    "Click Resume to refresh the canvas.": {
      "zh": "单击 Resume 刷新画布。",
      "tips": ""
    },
    "Add a Toggle view as the first child of the List view, passing a binding to showFavoritesOnly.": {
      "zh": "添加一个开关作为列表视图的第一个子视图，将 showFavoritesOnly 值绑定到开关。",
      "tips": ""
    },
    "Now that you’ve created the ModelData object, you need to update your views to adopt it as the data store for your app.": {
      "zh": "现在你已经创建了 ModelData 对象，你将使用它更新您的视图，它将作为你应用的数据存储。",
      "tips": ""
    },
    "In the project’s navigation pane, select ModelData.swift.": {
      "zh": "在项目的文件列表中，选择 ModelData.swift。",
      "tips": ""
    },
    "Section 5": {
      "zh": "第 5 节",
      "tips": ""
    },
    "Section 6": {
      "zh": "第 6 节",
      "tips": ""
    },
    "Step 2": {
      "zh": "步骤 2",
      "tips": ""
    },
    "Move the landmarks array into the model.": {
      "zh": "将 landmarks 数组移动到模型中。",
      "tips": ""
    },
    "SwiftUI subscribes to your observable object, and updates any views that need refreshing when the data changes.": {
      "zh": "SwiftUI 会订阅你的可观察对象，并在数据更改时更新任何需要刷新的视图。",
      "tips": ""
    },
    "To prepare for the user to control which particular landmarks are favorites, you’ll first store the landmark data in an observable object.": {
      "zh": "为了让用户能够修改喜欢的特定地标数据，首先要将地标数据存储在一个可观察对象中。",
      "tips": ""
    },
    "Mark the User’s Favorite Landmarks": {
      "zh": "标记用户最喜欢的地标",
      "tips": ""
    },
    "Adopt the Model Object in Your Views": {
      "zh": "在你的视图中使用模型对象",
      "tips": ""
    },
    "Drawing Paths and Shapes": {
      "zh": "",
      "tips": ""
    },
    "Update the LandmarksApp to create a model instance and supply it to ContentView using the environmentObject(_:) modifier.": {
      "zh": "更新 LandmarksApp 创建 modelDarta 实例并使用 environmentObject(_:) 修饰符将其提供给 ContentView。",
      "tips": ""
    },
    "As your project grows, it’s a good idea to add hierarchy. Before moving on, create a few more groups.": {
      "zh": "随着项目的增长，我们有必要给文件进行结构化管理。 在继续之前，再创建几个文件夹。",
      "tips": ""
    },
    "Collect the general purpose CircleImage.swift, MapView.swift, and FavoriteButton.swift, into a Helpers group, and the landmark views into a Landmarks group.": {
      "zh": "将 CircleImage.swift、MapView.swift 和 FavoriteButton.swift 放到一个 Helpers 文件夹中，并将地标视图放到一个 Landmarks 文件夹中。",
      "tips": ""
    },
    "The title string that you provide for the button’s label doesn’t appear in the UI when you use the iconOnly label style, but VoiceOver uses it to improve accessibility.": {
      "zh": "当你使用 iconOnly 标签样式时，你为按钮标签提供的标题字符串不会出现在 UI 中，但 VoiceOver 可以使用它来提高可访问性。",
      "tips": ""
    },
    "Step 4": {
      "zh": "步骤 4",
      "tips": ""
    },
    "Add an isFavorite property to the Landmark structure.": {
      "zh": "将 isFavorite 属性添加到 Landmark 结构体中。",
      "tips": ""
    },
    "To combine static and dynamic views in a list, or to combine two or more different groups of dynamic views, use the ForEach type instead of passing your collection of data to List.": {
      "zh": "要在列表中组合静态和动态视图，或者组合两个或多个不同的动态视图组，请使用 ForEach 类型，而不是将数据集合传递给 List。",
      "tips": ""
    },
    "Use landmarkIndex with the modelData object to ensure that the button updates the isFavorite property of the landmark stored in your model object.": {
      "zh": "将 landmarkIndex 与 modelData 对象一起使用，保证按钮更新 modelData 的地标数组其中的一个地标的 isFavorite 属性。",
      "tips": ""
    },
    "The modelData property gets its value automatically, as long as the environmentObject(_:) modifier has been applied to a parent.": {
      "zh": "只要 environmentObject(_:) 修饰符在父级应用，子级的 modelData 属性就会自动获取其值。",
      "tips": ""
    },
    "Update the LandmarkDetail view to work with the ModelData object in the environment.": {
      "zh": "更新 LandmarkDetail 视图的预览以使用环境中的 ModelData 对象。",
      "tips": ""
    },
    "Section 3": {
      "zh": "第 3 节",
      "tips": ""
    },
    "Step 1": {
      "zh": "步骤 1",
      "tips": ""
    },
    "Use the @StateObject attribute to initialize a model object for a given property only once during the life time of the app. This is true when you use the attribute in an app instance, as shown here, as well as when you use it in a view.": {
      "zh": "使用 @StateObject 修饰指定属性，在应用程序的生命周期内仅会初始化一次模型对象。 当你在 App 实例中使用该属性时（如此处所示）以及在子视图中使用它时都是如此。",
      "tips": ""
    },
    "Next, you’ll update the app instance to put the model object in the environment when you run the app in the simulator or on a device.": {
      "zh": "接下来，当你在模拟器或设备上运行应用程序时，你将更新 App 文件将模型对象放入环境中。",
      "tips": ""
    },
    "Handling User Input": {
      "zh": "",
      "tips": ""
    },
    "Create a Button with an action that toggles the isSet state, and that changes its appearance based on the state.": {
      "zh": "创建一个按钮用来切换 isSet 的状态，并且根据状态改变外观。",
      "tips": ""
    }
  },
  "swiftui/interfacing-with-uikit": {
    "To prepare for adding a custom UIPageControl, you need a way to track the current page from within PageView.": {
      "zh": "要准备添加自定义 UIPageControl，你需要一种从 PageView 中跟踪当前页面的方法。",
      "tips": ""
    },
    "Next, you’ll create a custom view to present your UIViewControllerRepresentable view.": {
      "zh": "接下来，你将创建一个自定义视图来呈现你的 UIViewControllerRepresentable 视图。",
      "tips": ""
    },
    "Because SwiftUI calls this method whenever a page switching animation completes, you can find the index of the current view controller and update the binding.": {
      "zh": "因为 SwiftUI 会在页面切换动画完成时调用此方法，所以你可以找到当前视图控制器的索引并更新绑定值。",
      "tips": ""
    },
    "Update the preview provider to pass the required array of views, and the preview starts working.": {
      "zh": "更新预览提供类并传递所需的视图数组，然后预览将会开始工作。",
      "tips": ""
    },
    "Step 6": {
      "zh": "步骤 6",
      "tips": ""
    },
    "Observe that when you swipe from page to page, the value doesn’t change.": {
      "zh": "请注意，当你从一页滑动到另一页时，它的值不会改变。",
      "tips": ""
    },
    "Add an updateUIViewController(_:context:) method that calls setViewControllers(_:direction:animated:) to provide a view controller for display.": {
      "zh": "添加一个调用了 setViewControllers(_:direction:animated:) 的 updateUIViewController(_:context:) 方法来提供用于显示的视图控制器。",
      "tips": ""
    },
    "UIViewRepresentable and UIViewControllerRepresentable types have the same life cycle, with methods that correspond to their underlying UIKit types.": {
      "zh": "UIViewRepresentable 和 UIViewControllerRepresentable 类型具有相同的生命周期，它们具有与其底层 UIKit 类型相对应的方法。",
      "tips": ""
    },
    "Step 8": {
      "zh": "步骤 8",
      "tips": ""
    },
    "With the binding connected in both directions, the text view updates to show the correct page number after each swipe.": {
      "zh": "通过双向连接的绑定，在每次滑动后文本视图会更新显示正确的页码。",
      "tips": ""
    },
    "The preview fails because Xcode can’t infer a type for Page.": {
      "zh": "预览失败，因为 Xcode 无法推断 Page 的类型。",
      "tips": ""
    },
    "Add a makeUIViewController(context:) method that creates a UIPageViewController with the desired configuration.": {
      "zh": "添加一个 makeUIViewController(context:) 方法来创建带有我们需要配置的 UIPageViewController。",
      "tips": ""
    },
    "Interfacing with UIKit": {
      "zh": "",
      "tips": ""
    },
    "Section 1": {
      "zh": "第 1 节",
      "tips": ""
    },
    "A landmark’s feature image, if it exists, has different dimensions than the regular image.": {
      "zh": "地标的特征图像（如果存在）与常规图像具有不同的尺寸。",
      "tips": ""
    },
    "Create a View to Represent a UIPageViewController": {
      "zh": "创建一个视图来表示 UIPageViewController",
      "tips": ""
    },
    "Create the View Controller’s Data Source": {
      "zh": "创建视图控制器的数据源",
      "tips": ""
    },
    "Replace the text box with the page control, switching from a VStack to a ZStack for layout.": {
      "zh": "将文本框替换为 PageControl，将布局从 VStack 切换到 ZStack。",
      "tips": ""
    },
    "Create a nested Coordinator type in PageControl, and add a makeCoordinator() method to create and return a new coordinator.": {
      "zh": "在 PageControl 中创建一个嵌套的 Coordinator 类型，并添加一个 makeCoordinator() 方法来创建并返回一个新的协调器。",
      "tips": ""
    },
    "You can use this coordinator to implement common Cocoa patterns, such as delegates, data sources, and responding to user events via target-action.": {
      "zh": "你可以使用这个协调器来实现常见的 Cocoa 模式，比如委托，数据源以及通过目标 - 动作响应用户事件。",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "This tutorial gives you a chance to apply much of what you’ve already learned about SwiftUI, and — with little effort — migrate the Landmarks app to watchOS.": {
      "zh": "本教程让你有机会应用你已了解的有关 SwiftUI 的大部分知识，并且只需很少的努力即可将 Landmarks 应用程序迁移到 watchOS。",
      "tips": ""
    },
    "This tutorial shows you how to convert the featured landmark from the home screen to wrap instances of UIPageViewController and UIPageControl. You’ll use UIPageViewController to display a carousel of SwiftUI views, and use state variables and bindings to coordinate data updates throughout the user interface.": {
      "zh": "本教程向你展示如何将主屏幕上的特色地标转换成为包装 UIPageViewController 和 UIPageControl 的实例。 你将使用 UIPageViewController 来显示 SwiftUI 视图的轮播，并使用状态变量和绑定来协调整个用户界面的数据更新。",
      "tips": ""
    },
    "Finally, in CategoryHome, replace the placeholder feature image with the new page view.": {
      "zh": "最后，在 CategoryHome 中，将占位图片替换为新的 PageView。",
      "tips": ""
    },
    "Overlay text information about the landmark on the image.": {
      "zh": "在图像上叠加有关地标的文本信息。",
      "tips": ""
    },
    "Test that the value flows through the binding to the PageViewController by changing its initial value.": {
      "zh": "通过更改其初始值来测试该值是否通过绑定流向 PageViewController。",
      "tips": ""
    },
    "Before you continue, prepare a feature card for use as a page.": {
      "zh": "在继续之前，请准备一张功能卡片视图以用作页面。",
      "tips": ""
    },
    "Step 3": {
      "zh": "步骤 3",
      "tips": ""
    },
    "Add the coordinator as the target for the valueChanged event, specifying the updateCurrentPage(sender:) method as the action to perform.": {
      "zh": "添加协调器作为 valueChanged 事件的目标，指定 updateCurrentPage(sender:) 方法作为要执行的操作。",
      "tips": ""
    },
    "Section 2": {
      "zh": "第 2 节",
      "tips": ""
    },
    "Add a button to PageView that makes the page view controller jump to the second view.": {
      "zh": "向 PageView 添加一个按钮，使页面视图控制器跳转到第二个视图。",
      "tips": ""
    },
    "Initialize an array of controllers in the coordinator using the pages array of views.": {
      "zh": "使用 pages 视图数组初始化协调器中的控制器数组。",
      "tips": ""
    },
    "To do this, you’ll declare a @State property in PageView, and pass a binding to this property down to the PageViewController view. The PageViewController updates the binding to match the visible page.": {
      "zh": "为了做到这种效果，你需要在 PageView 中声明一个 @State 属性，并将对该属性的绑定向下传递到 PageViewController 视图。 PageViewController 更新绑定的值来匹配可见页面。",
      "tips": ""
    },
    "SwiftUI manages your UIViewControllerRepresentable type’s coordinator, and provides it as part of the context when calling the methods you created above.": {
      "zh": "SwiftUI 管理你的 UIViewControllerRepresentable 类型的协调器，并在调用你在上面创建的方法时将其作为上下文的一部分提供。",
      "tips": ""
    },
    "Section 4": {
      "zh": "第 4 节",
      "tips": ""
    },
    "Create a PageView group in your project’s Views folder, and add a new Swift file named PageViewController.swift; Declare the PageViewController type as conforming to UIViewControllerRepresentable.": {
      "zh": "在项目的 Views 文件夹中创建一个 PageView 文件夹，并添加一个名为 PageViewController.swift 的新 Swift 文件； 将 PageViewController 类型声明为符合 UIViewControllerRepresentable 协议。",
      "tips": ""
    },
    "Now try out all the different interactions — PageView shows how UIKit and SwiftUI views and controllers can work together.": {
      "zh": "现在尝试一下所有不同的交互效果——PageView 展示了 UIKit 和 SwiftUI 视图和控制器如何协同工作。",
      "tips": ""
    },
    "Step 7": {
      "zh": "步骤 7",
      "tips": ""
    },
    "Step 5": {
      "zh": "步骤 5",
      "tips": ""
    },
    "SwiftUI works seamlessly with the existing UI frameworks on all Apple platforms. For example, you can place UIKit views and view controllers inside SwiftUI views, and vice versa.": {
      "zh": "SwiftUI 可以与所有 Apple 平台上的现有 UI 框架无缝协作。 例如，你可以将 UIKit 视图和视图控制器放置在 SwiftUI 视图中，反之亦然。",
      "tips": ""
    },
    "These two methods establish the relationships between view controllers, so that you can swipe back and forth between them.": {
      "zh": "这两种方法建立视图控制器之间的关系，让你可以在它们之间来回滑动。",
      "tips": ""
    },
    "The page view controller stores an array of Page instances, which must be a type of View. These are the pages you use to scroll between landmarks.": {
      "zh": "页面视图控制器存储一个 Page 实例数组，它必须是 View 类型。 这些是你用来在滚动切换地标的页面。",
      "tips": ""
    },
    "Tip": {
      "zh": "提示",
      "tips": ""
    },
    "Add a Custom Page Control": {
      "zh": "添加自定义页面控件",
      "tips": ""
    },
    "Add another method to PageViewController to make the coordinator.": {
      "zh": "向 PageViewController 添加另一个方法来创建协调器。",
      "tips": ""
    },
    "Because UIControl subclasses like UIPageControl use the target-action pattern instead of delegation, this Coordinator implements an @objc method to update the current page binding.": {
      "zh": "因为像 UIPageControl 这样的 UIControl 子类使用目标-动作模式而不是代理模式，所以这个 Coordinator 实现了一个@objc 方法来更新当前页面绑定。",
      "tips": ""
    },
    "Create a new SwiftUI view file, named PageControl.swift. Update the PageControl type to conform to the UIViewRepresentable protocol.": {
      "zh": "创建一个新的 SwiftUI 视图文件，命名为 PageControl.swift。 更新 PageControl 类使它遵循 UIViewRepresentable 协议。",
      "tips": ""
    },
    "You’re ready to add a custom UIPageControl to your view, wrapped in SwiftUI UIViewRepresentable view.": {
      "zh": "你已准备好将自定义 UIPageControl 添加到你的视图，包装在 SwiftUI UIViewRepresentable 视图中。",
      "tips": ""
    },
    "Add a text view with the currentPage property, so that you can keep an eye on the @State property’s value.": {
      "zh": "添加具有 currentPage 属性的文本视图，以便你可以观察 @State 属性的值。",
      "tips": ""
    },
    "In addition to declaring the @Binding property, you also update the call to setViewControllers(_:direction:animated:), passing the value of the currentPage binding.": {
      "zh": "除了声明 @Binding 属性之外，你还将更新对 setViewControllers(_:direction:animated:) 的调用，传递了 currentPage 的值进行绑定。",
      "tips": ""
    },
    "Follow the steps to build this project, or download the finished project to explore on your own.": {
      "zh": "按照步骤构建此项目，或下载已完成的项目来自行探索。",
      "tips": ""
    },
    "SwiftUI calls this method a single time when it’s ready to display the view, and then manages the view controller’s life cycle.": {
      "zh": "SwiftUI 在准备好显示视图时会调用此方法一次，然后管理视图控制器的生命周期。",
      "tips": ""
    },
    "Return to PageView, turn on live previews, and test out the swipe interactions.": {
      "zh": "返回 PageView，打开实时预览，并测试滑动交互。",
      "tips": ""
    },
    "Remember to use the $ syntax to create a binding to a value that is stored as state.": {
      "zh": "请记住使用 $ 语法设置带 @State 属性的值。",
      "tips": ""
    },
    "For now, you create the UIHostingController that hosts the page SwiftUI view on every update. Later, you’ll make this more efficient by initializing the controller only once for the life of the page view controller.": {
      "zh": "现在，你在每次更新时都创建托管 SwiftUI 视图的 UIHostingController。稍后，将通过仅在页面视图控制器的生命周期内初始化一次控制器来提高效率。",
      "tips": ""
    },
    "Step 2": {
      "zh": "步骤 2",
      "tips": ""
    },
    "In a few short steps, you’ve done a lot — the PageViewController uses a UIPageViewController to show content from a SwiftUI view. Now it’s time to enable swiping interactions to move from page to page.": {
      "zh": "在几个简短的步骤中，你已经完成了很多工作 —— PageViewController 使用 UIPageViewController 来显示来自 SwiftUI 视图的内容。 现在是时候启用滑动交互以从一个页面移动到另一个页面了。",
      "tips": ""
    },
    "Creating a watchOS App": {
      "zh": "",
      "tips": ""
    },
    "Assign the coordinator as the delegate for the UIPageViewController, in addition to the data source.": {
      "zh": "除了数据源之外，还将协调器指定为 UIPageViewController 的委托。",
      "tips": ""
    },
    "To represent UIKit views and view controllers in SwiftUI, you create types that conform to the UIViewRepresentable and UIViewControllerRepresentable protocols. Your custom types create and configure the UIKit types that they represent, while SwiftUI manages their life cycle and updates them when needed.": {
      "zh": "要在 SwiftUI 中展示 UIKit 视图和视图控制器，你可以创建符合 UIViewRepresentable 和 UIViewControllerRepresentable 协议的类。 然后用你自定义的类创建和配置它们所表示的 UIKit 类型，而 SwiftUI 管理它们的生命周期并在需要时更新它们。",
      "tips": ""
    },
    "Next, add the two requirements for the UIViewControllerRepresentable protocol.": {
      "zh": "接下来，添加 UIViewControllerRepresentable 协议的两个要求。",
      "tips": ""
    },
    "Because you’re passing the page count and the binding to the current page, the page control is already showing the correct values.": {
      "zh": "因为你已经将页数和当前定位传递到当前页面，所以页面控件已经显示了正确的值。",
      "tips": ""
    },
    "Track the Page in a SwiftUI View’s State": {
      "zh": "在 SwiftUI 视图的状态中跟踪页面变化",
      "tips": ""
    },
    "A SwiftUI view that represents a UIKit view controller can define a Coordinator type that SwiftUI manages and provides as part of the representable view’s context.": {
      "zh": "表示 UIKit 视图控制器的 SwiftUI 视图可以定义一个 Coordinator 类型，这个视图由 SwiftUI 管理并作为可呈现视图上下文的一部分",
      "tips": ""
    },
    "Experiment": {
      "zh": "实验",
      "tips": ""
    },
    "In PageViewController.swift, conform the coordinator to UIPageViewControllerDelegate, and add the pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted completed: Bool) method.": {
      "zh": "在 PageViewController.swift 中，使协调器符合 UIPageViewControllerDelegate 协议，并添加 pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted completed: Bool) 方法。",
      "tips": ""
    },
    "Add the coordinator as the data source of the UIPageViewController.": {
      "zh": "添加协调器作为 UIPageViewController 的数据源。",
      "tips": ""
    },
    "Declare the @State variable in PageView, and pass a binding to the property when creating the child PageViewController.": {
      "zh": "在 PageView 中声明 @State 变量，并在创建子 PageViewController 时将该属性传进去。",
      "tips": ""
    },
    "Start by adding a currentPage binding as a property of PageViewController.": {
      "zh": "首先为 PageViewController 添加一个 currentPage 绑定属性。",
      "tips": ""
    },
    "SwiftUI calls this makeCoordinator() method before makeUIViewController(context:), so that you have access to the coordinator object when configuring your view controller.": {
      "zh": "SwiftUI 在 makeUIViewController(context:) 之前调用此 makeCoordinator() 方法，这样在配置视图控制器时就可以访问协调器对象。",
      "tips": ""
    },
    "Create a new SwiftUI view file, named PageView.swift, and update the PageView type to declare PageViewController as a child view.": {
      "zh": "创建一个新的 SwiftUI 视图文件，命名为 PageView.swift，并更新 PageView 类，将 PageViewController 声明为子视图。",
      "tips": ""
    },
    "Step 4": {
      "zh": "步骤 4",
      "tips": ""
    },
    "Declare a nested Coordinator class inside PageViewController.": {
      "zh": "在 PageViewController 中声明一个嵌套的 Coordinator 类。",
      "tips": ""
    },
    "Add UIPageViewControllerDataSource conformance to the Coordinator type, and implement the two required methods.": {
      "zh": "将 UIPageViewControllerDataSource 协议添加到 Coordinator 类，并实现两个必需的方法。",
      "tips": ""
    },
    "Next, make the page control interactive so users can tap one side or the other to move between pages.": {
      "zh": "接下来，使页面控件能够进行交互，以便用户可以点击一侧或另一侧以在页面之间移动。",
      "tips": ""
    },
    "Step 9": {
      "zh": "步骤 9",
      "tips": ""
    },
    "Section 3": {
      "zh": "第 3 节",
      "tips": ""
    },
    "Step 1": {
      "zh": "步骤 1",
      "tips": ""
    },
    "Add a computed property to the Landmark structure that returns the feature image, if it exists.": {
      "zh": "将计算属性添加到 Landmark 结构体（如果存在），这个属性返回地标的特征图像 。",
      "tips": ""
    },
    "Important": {
      "zh": "重要的",
      "tips": ""
    },
    "The coordinator is a good place to store these controllers, because the system initializes them only once, and before you need them to update the view controller.": {
      "zh": "协调器是存储这些控制器的好地方，因为系统只初始化它们一次，并且是在你需要它们更新视图控制器之前。",
      "tips": ""
    },
    "Drag the images in the downloaded project files’ Resources directory into your app’s Asset catalog.": {
      "zh": "将下载的项目文件的 Resources 目录中的图像拖到应用程序的 Asset 目录中。",
      "tips": ""
    },
    "Add a new SwiftUI view file, named FeatureCard.swift that displays the landmark’s feature image.": {
      "zh": "添加一个名为 FeatureCard.swift 的新 SwiftUI 视图文件，用于显示地标的特征图像。",
      "tips": ""
    }
  },
  "swiftui/working-with-ui-controls": {
    "Note": {
      "zh": "笔记",
      "tips": ""
    },
    "SwiftUI works seamlessly with the existing UI frameworks on all Apple platforms. For example, you can place UIKit views and view controllers inside SwiftUI views, and vice versa.": {
      "zh": "SwiftUI 可与所有 Apple 平台上的现有 UI 框架无缝协作。 例如，你可以将 UIKit 视图和视图控制器放置在 SwiftUI 视图中，反之亦然。",
      "tips": ""
    },
    "SwiftUI provides storage in the environment for values you can access using the @Environment property wrapper. Access the editMode value to read or write the edit scope.": {
      "zh": "SwiftUI 在环境中提供了存储，你可以使用 @Environment 属性包装器访问这些值。访问 editMode 值以读取或写入编辑范围。",
      "tips": ""
    },
    "The first control in the view is a TextField, which controls and updates a string binding — in this case, the user’s chosen display name. You provide a label and a binding to a string when creating a text field.": {
      "zh": "视图中的第一个控件是 TextField，它控制和更新字符串绑定——在本例中，是用户选择的显示名称。 你在创建文本字段时提供标签和字符串绑定。",
      "tips": ""
    },
    "Add an Edit Mode": {
      "zh": "添加编辑模式",
      "tips": ""
    },
    "Step 5": {
      "zh": "步骤 5",
      "tips": ""
    },
    "Delay Edit Propagation": {
      "zh": "编辑数据延迟保存同步",
      "tips": ""
    },
    "Check Your Understanding": {
      "zh": "",
      "tips": ""
    },
    "Update ProfileSummary to add several badges with varying hues and reasons for earning the badge.": {
      "zh": "更新 ProfileSummary 添加几个具有不同色调和成就描述的徽章。",
      "tips": ""
    },
    "Update the conditional content in ProfileHost to include the profile editor and pass along the profile binding.": {
      "zh": "更新 ProfileHost 中的条件内容，包括个人资料编辑器，并传递个人资料进行绑定。",
      "tips": ""
    },
    "Update the ModelData class to include an instance of the user profile that persists even after the user dismisses the profile view.": {
      "zh": "更新 ModelData 类，类包含一个用户个人资料的实例，该实例在用户关闭个人资料视图后仍然存在。",
      "tips": ""
    },
    "Step 6": {
      "zh": "步骤 6",
      "tips": ""
    },
    "The EditButton controls the same editMode environment value that you accessed in the previous step.": {
      "zh": "EditButton 控制你在上一步中访问的 editMode 值。",
      "tips": ""
    },
    "Add an Environment view property that keys off of the environment’s \\.editMode.": {
      "zh": "添加一个 Environment 视图属性，该属性基于环境的 .editMode。",
      "tips": ""
    },
    "For consistency with the profile summary, you’ll add the profile details in the same order in the editor.": {
      "zh": "为了与个人资料简介保持一致，你将在编辑器中以相同的顺序添加个人资料详细信息。",
      "tips": ""
    },
    "The profile summary takes a Profile value rather than a binding to the profile because the parent view, ProfileHost, manages the state for this view.": {
      "zh": "个人资料摘要接收一个 Profile 值，而不是与个人资料绑定，因为由父视图 ProfileHost 负责管理这个视图的状态。",
      "tips": ""
    },
    "Read the user’s profile data from the environment to pass control of the data to the profile host.": {
      "zh": "从环境中读取用户的偏好设置数据，将数据的控制权传递给偏好设置页面。",
      "tips": ""
    },
    "Apply the onAppear(perform:) and onDisappear(perform:) modifiers to populate the editor with the correct profile data and update the persistent profile when the user taps the Done button.": {
      "zh": "应用 onAppear(perform:) 和 onDisappear(perform:) 修饰符，以在编辑器中填充正确的个人资料数据，并在用户点击“完成”按钮时更新本地化的个人资料。",
      "tips": ""
    },
    "Update ProfileHost to display the new summary view.": {
      "zh": "更新 ProfileHost 显示新的摘要视图。",
      "tips": ""
    },
    "Step 8": {
      "zh": "步骤 8",
      "tips": ""
    },
    "The user profile editor consists primarily of different controls that change individual details in the profile. Some items in the profile, like the badges, aren’t user-editable, so they don’t appear in the editor.": {
      "zh": "用户个人资料编辑器主要由不同的控件组成，这些控件可以更改个人资料中的各个详细信息。个人资料中的一些项目，如徽章，不可供用户编辑，因此它们不会出现在编辑器中。",
      "tips": ""
    },
    "Step 3": {
      "zh": "步骤 3",
      "tips": ""
    },
    "Step 4": {
      "zh": "步骤 4",
      "tips": ""
    },
    "In the Landmarks app, users can create a profile to express their personality. To give users the ability to change their profile, you’ll add an edit mode and design the preferences screen.": {
      "zh": "在 Landmarks 应用程序中，用户可以创建个人资料来表达自己的个性。 为了让用户能够更改他们的个人资料，你需要添加一个编辑模式并设计偏好设置页面。",
      "tips": ""
    },
    "You can see the effect of entering edit mode by running the live preview and tapping the edit button. For now, the Edit mode view is just a static text field.": {
      "zh": "你可以通过运行实时预览并点击编辑按钮来查看进入编辑模式的效果。 目前，编辑模式视图只是一个静态文本字段。",
      "tips": ""
    },
    "Create another view in the Profiles group named ProfileSummary that takes a Profile instance and displays some basic user information.": {
      "zh": "在 Profiles 分组中创建另一个名为 ProfileSummary 的视图，该视图接收一个 Profile 实例并显示一些基本的用户信息。",
      "tips": ""
    },
    "Start by defining a user profile in a new Swift file named Profile.swift that you add to your project’s Model group.": {
      "zh": "首先在一个名为 Profile.swift 的新 Swift 文件中定义一个用户配置文件，将它添加到项目的 Models 目录中。",
      "tips": ""
    },
    "Add the listStyle modifier to pick a list style that better suits the content.": {
      "zh": "添加 listStyle 修饰符以选择更适合内容的列表样式。",
      "tips": ""
    },
    "Add a cancel button to ProfileHost.": {
      "zh": "向 ProfileHost 添加取消按钮。",
      "tips": ""
    },
    "Define the Profile Editor": {
      "zh": "定义个人信息编辑器",
      "tips": ""
    },
    "Finally, add a DatePicker below the season selector to make the landmark visitation goal date modifiable.": {
      "zh": "最后，在季节选择器下方添加一个 DatePicker，使地标参观日期可修改。",
      "tips": ""
    },
    "In CategoryHome.swift, add a user profile button to the navigation bar using the toolbar modifier, and present the ProfileHost view when the user taps it.": {
      "zh": "在 CategoryHome.swift 中，使用 toorbar 修饰符将用户偏好设置按钮添加到导航栏，并在用户点击它时显示 ProfileHost 视图。",
      "tips": ""
    },
    "Section 2": {
      "zh": "第 2 节",
      "tips": ""
    },
    "Follow the steps to build this project, or download the finished project to explore on your own.": {
      "zh": "按照步骤构建此项目，或下载已完成的项目以自行探索。",
      "tips": ""
    },
    "Toggles are controls that are either on or off, so they’re a good fit for Boolean values like a yes or no preference.": {
      "zh": "Toggles 是开关控件，因此它们非常适合布尔值，例如是否打开偏好。",
      "tips": ""
    },
    "The badge’s drawing logic produces a result that depends on the size of the frame in which it renders. To ensure the desired appearance, render in a frame of 300 x 300 points. To get the desired size for the final graphic, then scale the rendered result and place it in a comparably smaller frame.": {
      "zh": "徽章的绘制逻辑产生的结果取决于它呈现的布局框的大小。 为确保理想的外观效果，请在300 x 300点的布局框中进行渲染。然后，缩放渲染结果并将其放置在一个相对较小的框架中，以获得最终图形的期望尺寸。",
      "tips": ""
    },
    "Step 9": {
      "zh": "步骤 9",
      "tips": ""
    },
    "The Landmarks app locally stores some configuration details and preferences. Before the user edits their details, they’re displayed in a summary view that doesn’t have any editing controls.": {
      "zh": "Landmarks 应用程序在本地存储了一些配置细节和偏好设置。在用户编辑个人信息之前，这些信息将显示在一个没有编辑控件的摘要视图中。",
      "tips": ""
    },
    "Create an Edit button that toggles the environment’s editMode value on and off.": {
      "zh": "创建一个编辑按钮，用于打开和关闭环境的 editMode 值。",
      "tips": ""
    },
    "Add a conditional view that displays either the static profile or the view for Edit mode.": {
      "zh": "添加显示静态配置文件或编辑模式视图的条件视图。",
      "tips": ""
    },
    "Section 3": {
      "zh": "第 3 节",
      "tips": ""
    },
    "Otherwise, the old values appear the next time edit mode activates.": {
      "zh": "不这样做的话，旧的值会在下次进入编辑模式时出现。",
      "tips": ""
    },
    "The badge is just a graphic, so the text in HikeBadge along with the accessibilityLabel(_:) modifier make the meaning of the badge clearer to other users.": {
      "zh": "徽章只是一个图形，因此 HikeBadge 中的文本以及 accessibilityLabel(_:) 修饰符能够使其他用户更清楚徽章的含义。",
      "tips": ""
    },
    "The ProfileHost view will host both a static, summary view of profile information and an edit mode.": {
      "zh": "ProfileHost 视图将同时承载个人资料信息的静态摘要视图和编辑模式。",
      "tips": ""
    },
    "Step 1": {
      "zh": "步骤 1",
      "tips": ""
    },
    "Interfacing with UIKit": {
      "zh": "",
      "tips": ""
    },
    "Next, create a new group named Profiles under the Views group, and then add a view named ProfileHost to that group with a text view that displays the username of a stored profile.": {
      "zh": "接下来，在 Views 目录下创建一个名为 Profiles 的新文件夹，然后向该文件夹添加一个名为 ProfileHost 的视图，该视图包含一个文本视图，用于显示存储的个人资料中的用户名。",
      "tips": ""
    },
    "Step 10": {
      "zh": "步骤 10",
      "tips": ""
    },
    "Users need to toggle between viewing or editing their profile details. You’ll add an edit mode by adding an EditButton to the existing ProfileHost, and then creating a view with controls for editing individual values.": {
      "zh": "用户需要在查看或编辑个人资料详细信息之间切换。你将通过向现有的 ProfileHost 添加 EditButton 来添加编辑模式，然后创建一个带有用于编辑各个值的控件的视图。",
      "tips": ""
    },
    "Display a User Profile": {
      "zh": "展示用户个人资料",
      "tips": ""
    },
    "Unlike the Done button that EditButton provides, the Cancel button doesn’t apply the edits to the real profile data in its closure.": {
      "zh": "与 EditButton 提供的 Done 按钮不同，Cancel 按钮不会在其闭包中将编辑应用到原始的偏好数据中。",
      "tips": ""
    },
    "Place a Picker control and its label in a VStack to make the landmark photos have a selectable preferred season.": {
      "zh": "将一个 Picker 控件及其标签放置在一个 VStack 中，使地标照片具有可选择的首选季节。",
      "tips": ""
    },
    "Finish off the profile summary by including a HikeView from Animating Views and Transitions.": {
      "zh": "通过包含一个从 Animating Views and Transitions 教程的 HikeView 来完成偏好设置摘要。",
      "tips": ""
    },
    "Section 4": {
      "zh": "第 4 节",
      "tips": ""
    },
    "Create a new view named ProfileEditor and include a binding to the draft copy of the user’s profile.": {
      "zh": "创建一个名为 ProfileEditor 的新视图，并包含对用户配置文件编辑草稿副本的绑定。",
      "tips": ""
    },
    "Add a toggle that corresponds with the user’s preference for receiving notifications about landmark-related events.": {
      "zh": "添加一个开关，对应用户接收与地标相关事件通知的偏好。",
      "tips": ""
    },
    "Section 1": {
      "zh": "第 1 节",
      "tips": ""
    },
    "Create a new view named HikeBadge in the Hikes folder that composes the Badge from Drawing Paths and Shapes along with some descriptive text about the hike.": {
      "zh": "在 Hikes 文件夹中创建一个名为 HikeBadge 的新视图，该视图由 Drawing Paths and Shapes 教程中的 Badge 以及一些关于远足的描述性文本组成。",
      "tips": ""
    },
    "To use the hike data, you also need to add a model data environment object.": {
      "zh": "要使用远足数据，你还需要添加一个环境中的模型数据对象。",
      "tips": ""
    },
    "To make it so edits don’t take effect until after the user exits edit mode, you use the draft copy of their profile during editing, then assign the draft copy to the real copy only when the user confirms an edit.": {
      "zh": "为了让编辑在用户退出编辑模式后才生效，你可以在编辑过程中使用用户个人资料的草稿副本，然后在用户确认编辑时将草稿副本设置给原始数据。",
      "tips": ""
    },
    "To avoid updating the global app state before confirming any edits — such as while the user enters their name — the editing view operates on a copy of itself.": {
      "zh": "为了避免在确认任何编辑之前更新全局应用状态（例如，在用户输入姓名时），编辑视图将在它自身的副本上修改。",
      "tips": ""
    },
    "Step 2": {
      "zh": "步骤 2",
      "tips": ""
    },
    "Now the edit profile view displays when you tap Edit.": {
      "zh": "现在，当你点击编辑时，会显示编辑配置文件视图。",
      "tips": ""
    },
    "Even though this view doesn’t use a property with the @EnvironmentObject attribute, ProfileSummary, a child of this view, does. So without the modifier, the preview fails.": {
      "zh": "即使此视图不使用具有 @EnvironmentObject 的属性，但 ProfileSummary（这个视图的子视图）需要使用。因此，如果没有这个修饰符，预览将无法进行。",
      "tips": ""
    },
    "Switch to the live preview and try tapping the profile button to examine the profile summary.": {
      "zh": "切换到实时预览，尝试点击个人资料按钮以查看个人资料摘要。",
      "tips": ""
    },
    "Step 7": {
      "zh": "步骤 7",
      "tips": ""
    },
    "Working with UI Controls": {
      "zh": "",
      "tips": ""
    },
    "Select ProfileHost and add the model data as an environment object to the preview.": {
      "zh": "选择 ProfileHost 并将模型数据作为环境对象添加到预览中。",
      "tips": ""
    },
    "You’ll work with a variety of common user interface controls for data entry, and update the Landmarks model types whenever the user saves their changes.": {
      "zh": "你将使用各种常见的用户界面控件进行数据输入，并在用户保存更改时更新地标模型类型。",
      "tips": ""
    }
  },
  "swiftui-concepts/adjusting-the-space-between-views": {
    "Adjusting the space between views": {
      "zh": "调整视图之间的间距",
      "tips": ""
    },
    "Specify the alignment and spacing of your content.": {
      "zh": "指定你内容的对齐和间距。",
      "tips": ""
    },
    "As you define the views that display information, you can adjust the layout by declaring where any extra space should go. Depending on how you want your layout to adapt, you may choose different tools. Some of the tools for managing the space between views are themselves views, like Spacer. There are also view modifiers that affect the space adjacent to a view, like padding(_:_:). In some cases, you affect a layout by providing a non-default value as a parameter of a view or modifier.": {
      "zh": "当定义视图来显示信息时，你可以通过声明额外的间距来调整布局。根据希望布局如何自适应，你可以选择不同的工具。 一些用于管理视图之间间距的工具本身就是视图，例如 Spacer。还有一些视图修饰符可以影响相邻视图的间距，例如 padding(::)。 在某些情况下，可以通过为视图或修饰符的参数提供非默认值来影响布局。",
      "tips": ""
    },
    "Define your content": {
      "zh": "定义你的内容",
      "tips": ""
    },
    "To show some different strategies for changing the spacing between views, this example uses a sequence of train cars. Each train has three views — a front, middle, and rear section — and uses the train car symbols from SF Symbols. These examples use an HStack to show horizontal spacing. The same principles apply on the vertical axis and to other stack and grid views in SwiftUI.": {
      "zh": "为了展示改变视图之间间距的不同方式，这个例子使用了一系列的火车车厢。每个火车有三个视图（前部、中部和后部），每个视图都使用了 SF Symbols 中的火车车厢符号。 这些例子使用一个 HStack 来控制水平间距。相同的原则也适用于垂直方向以及 SwiftUI 中的其他 Stack 和网格视图。",
      "tips": ""
    },
    "Many of these container views include some negative space by default, so set up your content and a PreviewProvider first to see how the defaults look before you customize the spacing.": {
      "zh": "许多这些容器视图都包含一些默认值是负数的间距，因此在自定义间距之前，首先设置你的内容，并且创建一个实现了 PreviewProvider 协议的实例来查看默认样式是什么样的。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "This custom view defines an Image view that displays an SF Symbol of a train car, with a pink background to show the extent of the view.": {
      "zh": "这个自定义视图定义了一个 Image 视图，用于显示一个表示火车车厢的 SF Symbol，并使用粉色背景来显示视图的范围。",
      "tips": ""
    },
    "You can define your own custom views so that you can have similar views in multiple places without having to specify the same modifiers and parameters in each place.": {
      "zh": "你可以自己定义一个视图，这样就可以在多个地方复用相同的视图，而无需在每个地方都重复指定相同的修饰符和参数。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实践",
      "tips": ""
    },
    "Try changing the color of the background(_:ignoresSafeAreaEdges:) to another color, and see the color of the background change on all the train cars.": {
      "zh": "尝试将传入 background(_:ignoresSafeAreaEdges:) 的背景颜色更改为其他颜色，并观察所有火车车厢背景颜色发生的变化。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "Here’s an example of that custom TrainCar view in use. This view declaration only specifies which part of the train it represents. The TrainCar structure defines the Image view with the corresponding symbol and adds a background.": {
      "zh": "这里展示了一个使用自定义 TrainCar 视图的示例。这个视图的声明仅需指定它表示火车的哪个部分。剩下的就由 TrainCar 结构来定义相应符号的 Image 视图，并添加了一个背景。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "This HStack contains three TrainCar views - front, middle, and rear - to form a train. The code doesn’t add any custom space or padding to the HStack or the TrainCar views, but there’s still a little space between the frames of the train cars.": {
      "zh": "这个 HStack 包含了组成火车前中后三个部分的 TrainCar 视图。代码没有给 HStack 或 TrainCar 视图添加任何自定义的间距或填充，但火车车厢之间仍然有一些间距。",
      "tips": ""
    },
    "An HStack, like many of SwiftUI’s built-in collection views, puts some spacing between its subviews by default.": {
      "zh": "HStack 就像 SwiftUI 中许多内置的集合视图一样，默认情况下会在其子视图之间添加一些间距。",
      "tips": ""
    },
    "Customize a container's spacing": {
      "zh": "自定义容器的间距",
      "tips": ""
    },
    "The default spacing of an HStack isn’t right for all layouts. You can specify a constant spacing between a stack’s subviews, spacing that scales with Dynamic Type, or no spacing at all.": {
      "zh": "HStack 的默认间距并不适用于所有布局。你可以指定一个常量作为子视图间的间距，使其随动态类型进行缩放，或者完全没有间距。",
      "tips": ""
    },
    "The spacing parameter of an HStack customizes the spacing between its views. This value of 20 puts 20 points of space between the front and middle TrainCar views and 20 points of space between the middle and rear TrainCar views, instead of the default spacing.": {
      "zh": "HStack 的 spacing 参数可以自定义视图间的间距。这里用 20 取代了默认的间距，在前部和中部，以及中部和后部的 TrainCar 视图之间增加了 20 个点的间距。",
      "tips": ""
    },
    "Because these train cars are SF symbols, their size changes when the current dynamicTypeSize changes. This train’s spacing adjusts proportionally. In this HStack, the value for the spacing parameter is the trainCarSpace property of the ScaledSpacing view.": {
      "zh": "因为这些火车车厢是 SF 符号，所以它们的大小会随着当前 dynamicTypeSize 的变化而改变。这列火车车厢之间的间距也应该按比例调整。 在这个 HStack 中，spacing 参数的值是由 ScaledSpacing 修饰的 trainCarSpace 属性来表示。",
      "tips": ""
    },
    "Adjust the Dynamic Type slider in the Canvas Device Settings to see how the train cars and spacing in the preview change.": {
      "zh": "调整画布设备设置中的 Dynamic Type 滑块，观察预览中火车车厢和间距的变化。",
      "tips": ""
    },
    "The ScaledMetric property wrapper configures the trainCarSpace property to change in proportion to the current body font size.": {
      "zh": "使用 ScaledMetric 属性包装器，可以让 trainCarSpace 属性按当前 body 字体大小成比例地变化。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "Using the value of 0 for the spacing parameter here removes all of the space between the views. In this HStack, the train cars are right next to each other.": {
      "zh": "在这里，将 spacing 参数设置为 0，会删除视图之间的所有间距，在这个 HStack 中，火车车厢彼此紧密相连，没有任何间距。",
      "tips": ""
    },
    "Add padding around subviews": {
      "zh": "在子视图周围添加填充",
      "tips": ""
    },
    "You can add padding to the outer edges of a view to put some space between that view and any neighboring views, or to the edge of a window or scene.": {
      "zh": "你可以在视图的外部边缘添加填充，让该视图和任何相邻视图之间留出一些空间，或者与 windows 或 scene 的边缘保持距离。",
      "tips": ""
    },
    "padding(_:_:) without any parameters puts space around all four edges. The size of the default padding varies, depending on attributes of the view and the environment where the view appears.": {
      "zh": "不带任何参数的 padding(_:_:) 会给周围四个边缘都添加空间。默认填充的大小会根据视图的属性和其出现的环境而变化。",
      "tips": ""
    },
    "This example pads the leading edge of a train car, but not the other edges, by specifying a set that contains only leading.": {
      "zh": "这里通过指定一个只包含 leading 的集合来只填充火车车厢的 leading 边缘。",
      "tips": ""
    },
    "This example defines a specific amount of padding in the length parameter.": {
      "zh": "这个例子给 length 参数指定了一个填充的数值。",
      "tips": ""
    },
    "You can also use a ScaledMetric to adjust the spacing in response to font changes.": {
      "zh": "你也可以使用 ScaledMetric 包装器来根据字体变化调整间距。",
      "tips": ""
    },
    "The effect of the padding modifier depends on which view it modifies.": {
      "zh": "padding 修饰符的效果取决于它修改的是哪个视图。",
      "tips": ""
    },
    "Applying the padding(_:_:) modifier to the stack that contains the TrainCar views puts padding around the edges of the stack instead of between the train cars.": {
      "zh": "将 padding(::) 修饰符应用于包含 TrainCar 视图的 stack 上时，不会在火车车厢上添加填充，而是会在其周围边缘添加填充。",
      "tips": ""
    },
    "Add a view to create space": {
      "zh": "添加一个用来作为间距的视图",
      "tips": ""
    },
    "Besides modifying a content view to create space, you can also create space by adding an invisible view that modifies your layout without displaying any content.": {
      "zh": "除了修改内容视图本身来创建间距外，你还可以通过添加一个什么都不显示的不可见视图来修改布局以达到创建间距的目的。",
      "tips": ""
    },
    "This Spacer() between views pushes the content views as far apart as possible.": {
      "zh": "这个 Spacer() 会在视图之间将它们尽可能地推开。",
      "tips": ""
    },
    "You can specify a minimum width for each Spacer, or let it squish all the way to zero if the adjacent content needs all the space.": {
      "zh": "你可以为每个 Spacer 指定最小宽度，或者如果相邻的内容需要所有的空间，那么可以将其变成零。",
      "tips": ""
    },
    "Change to a landscape orientation in the Canvas Device Settings or choose a different size device for previews to see how the width of the device changes the layout.": {
      "zh": "在画布设备设置中更改为横屏，或选择不同尺寸的设备进行预览，以查看设备宽度如何改变布局。",
      "tips": ""
    },
    "This layout specifies an amount of space that depends on the size of a view by using the opacity modifier to create an invisible version of that view to take up the correct amount of space.": {
      "zh": "这个布局通过使用 opacity 修饰符创建一个不可见的视图，以占据恰当的空间，该空间量取决于视图的大小。",
      "tips": ""
    },
    "A ZStack adapts to the size of its largest view, so the invisible view in this stack creates a visual appearance like padding around the middle train car.": {
      "zh": "ZStack 会根据最大子视图的大小进行调整，因此在这个 stack 中被隐藏的视图会创建一种类似在中部火车车厢周围填充的视觉效果。",
      "tips": ""
    },
    "Section 1": {
      "zh": "第一节",
      "tips": ""
    },
    "Section 2": {
      "zh": "第二节",
      "tips": ""
    },
    "Section 3": {
      "zh": "第三节",
      "tips": ""
    },
    "Section 4": {
      "zh": "第四节",
      "tips": ""
    }
  },
  "swiftui-concepts/choosing-the-right-way-to-hide-a-view": {
    "Choosing the right way to hide a view": {
      "zh": "选择正确的方式来隐藏一个视图",
      "tips": ""
    },
    "Control whether a view exists, and how that affects the overall layout.": {
      "zh": "控制视图是否存在以及它对整体布局的影响。",
      "tips": ""
    },
    "If your design has views that aren’t always relevant, you have a choice about how their absence affects the overall layout. You can lay out all the other content as if the view doesn’t exist, then update the position of the other content when the view becomes visible. Or, you can reserve space for the view regardless of whether it’s visible, so that when it becomes visible, none of the other content needs to move to accommodate it.": {
      "zh": "如果你的设计中有一些视图并不总是相关的，那你可以选择如何处理它们的存在与否对于整体布局的影响。 如果该视图不存在，你就在当它不存在的情况下布局其他内容，然后在该视图变为可见时更新其他内容的位置以适应新的布局。 或者无论一个视图是否可见，你都预留空间给它，这样当它变为可见时，其他内容就无需位置移动以适应它。",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "要实践这段代码的话，请下载项目文件并在 Xcode 中打开示例。",
      "tips": ""
    },
    "Conditionally removing a view": {
      "zh": "有条件地移除一个视图",
      "tips": ""
    },
    "Your design might have a login screen that doesn’t show an error message the first time it appears, but adds an error message after someone mistypes their password. The user name and password fields shouldn’t shift position depending on whether the error message is visible. Use an opacity(_:) modifier with a value of 0 so that the layout accounts for the error message whether or not it’s visible. You can also use this strategy for removing a view that doesn’t affect other views’ placement, like a view inside an overlay(alignment:content:) modifier.": {
      "zh": "你的设计中可能包含一个登录界面，在首次出现时不会显示错误信息，但在用户输错密码后会显示一个错误信息。用户名和密码输入框不应该根据错误信息是否可见而改变其位置。 你可以使用 opacity(_:) 修饰符，并将其值设置为 0，这样无论错误信息是否可见，系统都会考虑到它的存在而进行布局。 你还可以在不影响其他视图位置的情况下，使用这种策略来移除一个视图，比如在 overlay(alignment:content:) 修饰符中的视图。",
      "tips": ""
    },
    "Or, you might have an order Form that displays a second set of address fields if a person chooses not to use the same address for their shipping and billing addresses. For content like address fields that people might need to scroll past, use an if statement to only make room for the content when it’s visible, and shift other content as it appears and disappears.": {
      "zh": "或者你可能有一个表示订单的 Form 视图，如果一个人选择收货和账单地址不相同，就会需要显示第二套输入地址的控件。 对于像地址字段这样的内容，人们可能需要滚动浏览，所以你可以使用 if 语句来仅在它们可见时为其预留空间，并在它们出现和消失时调整其他内容的位置。",
      "tips": ""
    },
    "If you need to reserve space in a layout based on the measurement of a view, but never want to show that view, you can use the hidden() modifier.": {
      "zh": "如果你需要在布局中基于一个视图的尺寸来保留其空间，但又不想显示该视图，你可以使用 hidden() 修饰符。",
      "tips": ""
    },
    "VoiceOver and gesture recognizers also ignore a view that you remove in any of these ways.": {
      "zh": "VoiceOver 和手势识别器也会忽略用以上任何一种方式移除的视图。",
      "tips": ""
    },
    "To show the differences between these approaches, this example uses a sequence of train cars. Each train has three views — a front, middle, and rear section — and uses the train car symbols from SF Symbols. For a long train, the front, middle, and rear car all appear. For a shorter train, the middle car doesn’t appear. The code that defines each train uses a different technique to omit the middle car.": {
      "zh": "为了展示这些方法之间的区别，以下示例使用了一系列火车车厢符号。每个火车有三个视图：前部、中部和后部，并都使用了 SF Symbols 中的符号。 对于一个完整的火车，前部、中部和后部的车厢都会显示。对于短火车，中部车厢不会显示。每个例子都使用了不同的技术来隐藏中部车厢。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "In these examples, the longerTrain property tracks whether to show or hide the middle train car.": {
      "zh": "在例子中，longerTrain 属性用来表示是否隐藏中间的火车车厢符号。",
      "tips": ""
    },
    "In a full app, the data determining whether to hide a view might be a Binding, or an Environment value.": {
      "zh": "在一个实际的 app 中，决定是否隐藏视图的数据可能是一个 Binding 或 Environment 值。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "The first train uses if, a conditional clause, to control the middle car. When longerTrain is true, the middle car is part of the train. When longerTrain is false, the middle car doesn’t exist, and the other cars are closer together.": {
      "zh": "第一个例子使用 if 语句来控制中间的车厢符号是否显示。当 longerTrain 为 true 时，中间的车厢符号会显示成火车的一部分。而当 longerTrain 为 false 时，这个符号不存在，其他符号则会互相接近。",
      "tips": ""
    },
    "You can also use an else clause the same way. The contents of the else clause only exist when the condition is false.": {
      "zh": "您也可以使用 else 子句达到相同的目的。else 子句中的内容只在条件为假时会执行。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "The second train uses the opacity(_:) modifier to control the visibility of the middle car. When longerTrain is true, the middle car is part of the train, and it looks just like the previous conditional example. But when longerTrain is false, the middle car still takes up space in this train.": {
      "zh": "第二个例子则使用 opacity(_:) 修饰符来控制中间的车厢符号是否可见。当 longerTrain 为 true 时，中间车厢符号是火车的一部分，显示效果和之前的例子相同。 但当 longerTrain 为 false 时，这个符号仍然占据中间的空间，但是变为不可见。",
      "tips": ""
    },
    "Use an opacity modifier when you don’t want other content to shift around as the view appears or disappears.": {
      "zh": "当你不希望一个视图的出现或消失会让其他内容发生位置变化时，可以使用 opacity 修饰符。",
      "tips": ""
    },
    "Section 1": {
      "zh": "第一节",
      "tips": ""
    }
  },
  "swiftui-concepts/creating-a-custom-input-control-that-binds-to-a-value": {
    "Creating a custom input control that binds to a value": {
      "zh": "创建一个与特定值绑定的输入控件",
      "tips": ""
    },
    "Provide interactions that are unique to your app with custom controls that bind to a value.": {
      "zh": "通过使用与特定值绑定的自定义控件为你的应用提供独一无二的交互体验。",
      "tips": ""
    },
    "SwiftUI provides input controls like Slider, TextField, and many others that bind to a value and can change the value as a person’s interacts with the control. But every app is different. You may find that you need a custom control that provides behavior unique to your app.": {
      "zh": "SwiftUI 提供了一些与特定值绑定的输入控制组件，例如滑动条，文本输入框等。这些组件的值会随着用户与其交互而改变。但是每个应用都是独一无二的。你可能会发现，你需要一个自定义控件来提供你的应用所特有的交互行为。",
      "tips": ""
    },
    "SwiftUI provides the building blocks you need to create a custom input control for your app. This tutorial walks through an example of one such control, a rating control. The sample app uses this control to let people rate recipes from 1 to 5 stars.": {
      "zh": "SwiftUI 提供了你为你的应用创建自定义输入控件所需要的构建组件。本教程将介绍这样控件的一个例子，也就是一个评级控件。该案例应用通过这个控件让用户给菜谱从 1 到 5 星评分",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "如果要亲自尝试代码，请下载项目文件，并在Xcode中打开案例。",
      "tips": ""
    },
    "Design a custom control": {
      "zh": "设计一个自定义控件",
      "tips": ""
    },
    "Before implementing a custom control, ask yourself what data does the control need, what does it do with that data, and how it does it represent that data visually within the app. The sample app, for instance, needs an Int property that represents the rating of a recipe. The control needs to be able to change the value of this property. And because the control shows the rating of a recipe, it needs to display a set of stars that reflects the rating value; for instance, the control displays five stars when the rating value is 5.": {
      "zh": "在实现一个自定义控件之前，请问问自己这个控件需要什么数据，它用这些数据做什么，以及它如何在应用中直观地展现这些数据。例如，在这个例子中，需要一个 Int 属性来表示一个菜谱的等级。所以控件需要能够改变这个属性的值。并且因为该控件显示了食谱的评级，所以它需要展示一组星星用于反应评级；例如，当评级为 5 时，该控件显示五颗星。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "The sample defines the custom control as a structure named StarRating.": {
      "zh": "这个案例将自定义控件定义为一个叫做 StarRating 的结构体。",
      "tips": ""
    },
    "This structure conforms to the View protocol because the control appears as part of the app’s user interface.": {
      "zh": "这个结构体符合 View 协议，因为这个控件将作为应用用户界面的一部分出现。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "The structure defines a Binding variable named rating, which stores the rating of a recipe.": {
      "zh": "这个结构体定义了一个名为 rating 的 Binding 变量，用来存储对配方的评级。",
      "tips": ""
    },
    "By defining rating as a binding variable, StarRating can read and write the value even though another view is responsible for creating the value.": {
      "zh": "通过将 ratting 定义为一个绑定变量，StarRating 可以读取和写入该值，即使这个值是由另一个视图负责创建的。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "The private constant maxRating stores the highest rating possible that a person can give a recipe.": {
      "zh": "私有常量 maxRating 存储量用户可以给配方的最高评分。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "Note": {
      "zh": "注释",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "The HStack displays the rating stars in a horizontal line.": {
      "zh": "HStack 以水平的方式显示星级。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "Inside the HStack, the control uses a ForEach structure to display the number of stars indicated by the maxRating constant.": {
      "zh": "在 HStack中，使用了一个 ForEach 结构来显示星星，星星的数量与常量 maxRating 一样。",
      "tips": ""
    },
    "ForEach iterates through a collection of data defined as a range of Int instances, 1 to 5.": {
      "zh": "ForEach 遍历了一个由从一到五 Int 实例组成的数据集合。",
      "tips": ""
    },
    "Important": {
      "zh": "重要提示",
      "tips": ""
    },
    "The id parameter is of type ID, which is Hashable. The ForEach structure uses this parameter to identify the data, that is, the integer values 1 through 5. The parameter value is the identity key path \\.self, which specifies an Int instance for each integer. Because Int is hashable, using this key path satisfies the requirements of the ForEach initializer method init(_:id:content:). And because the data is an increasing range of integers that will never have duplicate values, it’s okay to use each integer value as its identifier.": {
      "zh": "id 参数的类型是 ID，它符合 Hashable 协议。ForEach 结构使用这个参数来识别数据，也就是从1到5的整数值。这个参数值是一个用于标识的 Key-Path 表达式 \\.self，它为每个遍历的整数指定了一个 Int 实例。因为 In t是 Hashable 的，使用这个 Key-Path 表达式满足了 ForEach 初始化方法 init(_:id:content:) 的要求。而且因为 ForEach 遍历的数据有永远不会重复，且持续增长，所以使用每个数据的整数值作为它的标识符是可行的。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第七步",
      "tips": ""
    },
    "The control displays a star using an instance of Image.": {
      "zh": "这个控件通过一个 Image 的实例来展示星星图片。",
      "tips": ""
    },
    "The sample displays an image of a star using the initializer method init(systemName:). This method creates an image view that displays a system symbol image. Symbol images like star come from SF Symbols, a library of iconography that you can use in your app.": {
      "zh": "该例子使用初始化方法 init(systemName:) 显示一个星星图像。这个方法创建了一个图像视图，显示一个系统图像符号。像星星这样的符号图像来自 SF Symbols，这是一个你可以在你的应用中随意使用的图标库。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实践",
      "tips": ""
    },
    "Change the symbol from a star to another symbol such as circle.": {
      "zh": "尝试将符号从星星改为其他符号，如圆圈。",
      "tips": ""
    },
    "Step 8": {
      "zh": "第八步",
      "tips": ""
    },
    "The control displays a filled star when the integer value is less than or equal to the rating value and an empty star when the integer value is greater than rating, so the control applies the symbolVariant(_:) modifier to the Image instance.": {
      "zh": "当 value 数值小于或等于 ratting 值时，控件会显示一个填充的星星，当 value 值大于 ratting 值时，会显示一个空的星星，所以控件对 Image 实例应用了 symbolVariant(_:) 修改器来修改图片的填充状态。",
      "tips": ""
    },
    "To determine which SymbolVariants to apply, fill or none, the control uses a ternary conditional operator. This operator takes three parts, which takes the form of question ? answer1 : answer2. For more information, see Ternary Conditional Operator.": {
      "zh": "为了确定应用哪种 SymbolVariants，也就是填充还是不填充，该控件使用了一个三元运算符。这个运算符有三个部分，其形式为 question ? answer1 : answer2。更多信息，请参见三元条件运算符。",
      "tips": ""
    },
    "Step 9": {
      "zh": "第九步",
      "tips": ""
    },
    "The control set the color of the stars using the foregroundColor(_:) view modifier.": {
      "zh": "该控件使用 foregroundColor(_:) 视图修改器来设置星星的颜色。",
      "tips": ""
    },
    "Make the control interactive": {
      "zh": "让控件具有交互性",
      "tips": ""
    },
    "StarRating is able to display a set of stars to indicate the rating of a recipe. For instance, if the recipe’s rating is 4, the control displays four filled stars, followed by one empty star. To make StarRating interactive, it uses the onTapGesture(count:perform:) action.": {
      "zh": "StarRating 能够显示一组星星来表示对一个食谱的评级。例如，如果菜谱的等级是4，该控件就会显示四颗填充的星和一颗空星。为了使 StarRating 具有交互性，我们使用了 onTapGesture(count:perform:) 动作。",
      "tips": ""
    },
    "To make it possible for a person to interact with the rating control, StarRating adds the onTapGesture(count:perform:) action to each Image instance created in the ForEach loop.": {
      "zh": "为了使用户于评分空间交互成为可能，StarRating 给每个在 ForEach 循环中创建的 Image 实例添加了 onTapGesture(count:perform:) 动作。",
      "tips": ""
    },
    "The tap gesture performs the action defined in the closure when a person clicks or taps a star Image instance. The star indicates the rating that StarRating assigns to the recipe. For example, if a person taps the fourth star, the recipe’s rating is set to 4. Tap the fourth star again and StarRating resets the recipe’s rating to 0 or no stars.": {
      "zh": "当一个人点击一个星星 Image 实例时，就会执行在 onTapGesture 的闭包中定义的动作。星星表示了用户通过 StarRating 分配给菜谱的评级。例如，如果一个人点了第四颗星，菜谱的评级就会被设置为 4。再点第四颗星，StarRating 就会将菜谱的评级重置为 0 级。",
      "tips": ""
    },
    "When the integer value isn’t equal to the rating value, the closure sets rating to the integer value, which indicates the new rating that the person assigns to the recipe.": {
      "zh": "当 value 不等于 rating 时，闭包将 rating 设置为 value 的值，这表示用户给菜谱设置了一个新评级。",
      "tips": ""
    },
    "By setting rating to the integer value, StarRating updates its appearance to show filled stars up to the number identified by value, followed by empty stars up to the number identified by maxRating.": {
      "zh": "通过设置 rating 的值，StarRating 更新了它的外观，以显示 value 所确定的填充星星数，和 value 和 maxRating 所确定的空星星数。",
      "tips": ""
    },
    "When the integer value is equal to the rating value, the closure resets the recipe’s rating to no stars by setting rating to 0.": {
      "zh": "当 value 等于 rating 的值时，闭包通过将 rating 设置为 0，以将评级设置为无星。",
      "tips": ""
    },
    "StarRating displays five empty stars to indicate that the recipe has no rating.": {
      "zh": "StarRating 将会显示五个空星，表示该食谱没有评级。",
      "tips": ""
    },
    "Display the custom control in other views": {
      "zh": "在其他视图展示我们的自定义控件",
      "tips": ""
    },
    "StarRating is ready to go. It has the data it needs, it can apply changes to that data, and it can visually represent the current state of the data in the app’s user interface. The next step is to make use of the custom input control.": {
      "zh": "StarRating 控件已经准备好了。它有它所需要的数据，可以展示这些数据的变化，并且它可以在应用的用户界面上直观地表示数据的当前状态。那么下一步就是利用我们的自定义输入控件。",
      "tips": ""
    },
    "In the sample app, StarRating appears under the recipe title that appears in the recipe detail view.": {
      "zh": "在示例应用中，StarRating 会出现在食谱详细视图中的标题下。",
      "tips": ""
    },
    "The structure RegularTitleView is a view that displays the title and subtitle of a recipe along with its rating.": {
      "zh": "结构体 RegularTitleView 是一个显示菜谱的标题和副标题以及其评级的视图。",
      "tips": ""
    },
    "RegularTitleView defines a binding variable that stores a recipe received from another view.": {
      "zh": "RegularTitleView 定义了一个绑定变量，用来存储从另一个视图接收的配方信息。",
      "tips": ""
    },
    "This binding allows the view to read and write data to an instance of Recipe. However, the view isn’t the owner of the recipe. Another view in the sample is responsible for creating and owning the Recipe instance.": {
      "zh": "这种绑定允许视图读取和写入数据 Recipe 实例。然而，该视图并不是该 Recipe 实例的所有者。案例中的另一个视图负责创建并且拥有 Recipe 实例。",
      "tips": ""
    },
    "The view shares a binding to the recipe’s rating property with the custom control StarRating, which allows the control to read and write to that property.": {
      "zh": "视图与自定义控件 StarRating 共享对配方评级属性的绑定，这使控件可以读取和写入该属性。",
      "tips": ""
    },
    "As a person interacts with the StarRating control, SwiftUI redraws the view to reflect the selected rating.": {
      "zh": "当一个人与 StarRating 控件互动时，SwiftUI 会重新绘制视图以反映所选的评级。",
      "tips": ""
    },
    "The dollar sign ($) prefix on the variable name recipe indicates that the call is passing a binding to StarRating.": {
      "zh": "变量名称 recipe 上的美元符号（$）前缀表明，该调用正在向 StarRating 传递一个绑定值。",
      "tips": ""
    },
    "Defining the source of truth using a custom binding": {
      "zh": "使用自定义绑定来定义事实来源",
      "tips": ""
    },
    "Provide an alternative to a state variable by using a custom binding.": {
      "zh": "通过使用自定义绑定提供一个状态变量的替代方案。",
      "tips": ""
    },
    "Change the color of the stars by replacing accentColor with a different color, such as yellow.": {
      "zh": "尝试用不同的颜色（如黄色）替换 accentColor 来改变星星的颜色。",
      "tips": ""
    },
    "Every SwiftUI view must implement body to provide the contents of the view.": {
      "zh": "每个 SwiftUI 视图都必须实现 body 属性以提供视图内容。",
      "tips": ""
    },
    "Like all other SwiftUI views, StarRating implements the required computed property body.": {
      "zh": "像所有其他 SwiftUI 视图一样，StarRating 实现了所需的计算属性 body。",
      "tips": ""
    }
  },
  "swiftui-concepts/defining-the-source-of-truth-using-a-custom-binding": {
    "Defining the source of truth using a custom binding": {
      "zh": "通过自定义绑定定义数据源",
      "tips": ""
    },
    "Provide an alternative to a state variable by using a custom binding.": {
      "zh": "通过使用自定义绑定提供状态变量的替代方案。",
      "tips": ""
    },
    "The most common way to define a source of truth that binds to other views in your app is to declare a state variable using the State property wrapper. However, there may be those rare occasions when the source of truth is dynamic and can’t be defined using the @State attribute. For instance, this sample app needs to retrieve a recipe as the source of truth using the recipe’s id. The app accomplishes this by creating a computed property that returns a custom binding.": {
      "zh": "定义与应用中其他视图绑定的数据源的最常见方式是使用 State 属性包装器声明一个状态变量。然而，在一些罕见的情况下，数据源是动态的，不能用 @State 包装器来定义。例如，这个示例应用需要使用配方的 id 来检索一个配方作为数据源。该应用通过创建一个返回自定义绑定的计算属性来实现这一目的。",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "如果要亲自尝试代码，请下载项目文件，并在Xcode中打开案例。",
      "tips": ""
    },
    "Specifying the source of truth": {
      "zh": "指定数据源",
      "tips": ""
    },
    "This sample app displays the details of a recipe in the custom view DetailView. The view only knows the recipe id, but not the recipe, so it uses the id to retrieve the recipe from the recipe box (a data store that contains all the recipes). Because the view needs to retrieve the recipe, it uses a custom binding as the source of truth of the recipe instead of declaring a state variable for the recipe.": {
      "zh": "这个示例应用将在自定义视图 DetailView 显示食谱详情。由于视图只知道菜谱的 ID，但不知道菜谱本身的内容，所以它需要使用 ID 从菜谱盒（一个包含所有菜谱的数据存储）中检索菜谱。因为视图需要检索菜谱，所以它使用自定义绑定作为配方的数据源，而不是直接给菜谱声明状态变量。",
      "tips": ""
    },
    "Note": {
      "zh": "注释",
      "tips": ""
    },
    "Using a custom binding is a useful feature of SwiftUI, but isn’t always the best option. Limit its use to use cases where using a state variable or object isn’t possible. In most cases, define the source of truth as either a State variable (for state local to the view) or StateObject (for shared data models) to let SwiftUI manage the value or object for you.": {
      "zh": "SwiftUI 中的自定义绑定是一个非常有用的功能，但是它并不永远是最好的选择。请仅在无法使用状态变量和状态对象的时候使用它。在大多数情况下，使用 State 变量（当这个状态仅用于当前视图）或 StateObject（用于被多个视图共享的数据模型）让 SwiftUI 管理你的值和状态。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "To get the recipe value in the DetailView, this sample implements the computed property recipe instead of declaring a state variable.": {
      "zh": "为了在 DetailView 中获得菜谱的具体内容， 这个案例将 recipe 设置为计算属性而不是状态变量。",
      "tips": ""
    },
    "The computed recipe property doesn’t return a Recipe. Instead, it returns a custom Binding of type Recipe. This allows the view to share the recipe as a source of truth with other views.": {
      "zh": "计算属性的 recipe 并不会返回一个 Recipe。相反，它会返回一个绑定类型为 Recipe 的自定义 Binding。这将允许视图将菜谱视为数据源并与其他视图共享。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "A Binding provides read and write access to a value. To provide this access to the recipe value, the computed recipe property uses the init(get:set:) initializer method to create a binding.": {
      "zh": "Binding 能使一个值变得可读和课写。为了使菜谱值可读可写，计算属性 recipe 使用了 init(get:set:) 初始化器来创建一个绑定。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "The binding’s get closure uses recipeId to retrieve a recipe from the data store recipeBox.": {
      "zh": "绑定的 get 闭包使用 recipeId 来从数据库 recipeBox 中获取一个配方。",
      "tips": ""
    },
    "If the recipe no longer exists or can’t be found, the closure returns an empty recipe.": {
      "zh": "如果配方不再存在或无法找到，闭包会返回一个空的配方。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "In the set closure, the binding updates the recipe box with the new recipe value, updatedRecipe.": {
      "zh": "在 set 闭包中，绑定用新的配方值 updateRecipe 来更新菜谱盒。",
      "tips": ""
    },
    "This update happens any time data changes in the binding’s recipe value; for instance, after a person changes the rating of the recipe.": {
      "zh": "当绑定的菜谱值发生任何变化的时候，这个更新就会发生。举个例子，当用户改变了菜谱评分，那么就会更新菜谱。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "DetailView passes recipe to the RecipeDetailView view as a binding value, which allows the detail view to read and write to the recipe value.": {
      "zh": "DetailView 将配方作为一个绑定值传递给 RecipeDetailView 视图，这使得这个详情视图可以读取和写入配方值。",
      "tips": ""
    },
    "Important": {
      "zh": "重要提示",
      "tips": ""
    },
    "Because the computed property recipe returns a Binding, it isn’t necessary to include the dollar sign ($) prefix that’s required when passing a state variable as a binding. For state variables — variables defined with a State property wrapper — the dollar sign ($) prefix tells SwiftUI to pass the projectedValue, which is a Binding.": {
      "zh": "因为计算的属性 recipe 会返回一个绑定，所以没有必要使用在传递状态变量作为绑定时必须的美元符号（$）前缀。对于状态变量--用状态属性包装器定义的变量--美元符号（$）前缀告诉 SwiftUI 传递 projectedValue，其本质是一个 Binding。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "The navigationTitle(_:) modifier accepts a string value not a binding to a string value, so the view passes the recipe binding’s wrappedValue.": {
      "zh": "navigationTitle(_:) 修改器接受的是一个字符串值，而不是对一个字符串值的绑定，所以视图会传递 recipe 绑定的 wrappedValue 值。",
      "tips": ""
    },
    "A wrappedValue is the underlying value referenced by the binding. Since the computed recipe property returns a binding, its wrapped value is the actual recipe value. So recipe.wrappedValue.title gets the wrappedValue of the recipe binding, then it passes the title property of the recipe value to navigationTitle(_:).": {
      "zh": "wrappedValue 是绑定所引用的值。由于计算的配方属性返回一个绑定，它的包装值（也就是所引用的值）就是实际的配方值。所以 recipe.wrappedValue.title 得到了 recipe 绑定的 wrappedValue，然后它将配方的标题传递给 navigationTitle(_:)。",
      "tips": ""
    }
  },
  "swiftui-concepts/driving-changes-in-your-ui-with-state-and-bindings": {
    "Driving changes in your UI with state and bindings": {
      "zh": "通过状态和绑定来改变你的 UI",
      "tips": ""
    },
    "Indicate data dependencies in a view using state, and share those dependencies with other views using bindings.": {
      "zh": "通过状态在视图中来指示数据依赖关系，并通过绑定将这些依赖关系与其他视图共享。",
      "tips": ""
    },
    "The user interface of a SwiftUI app is a composition of views that form a view hierarchy. Each view has a dependency on some data. As that data changes, either due to external events or because of actions taken by a person using the app, SwiftUI automatically updates the view to reflect those changes.": {
      "zh": "SwiftUI应用的用户界面是一组视图的组合，这些视图构成了视图的层次机构。每个视图都依赖于某些数据。当数据发生变化时，无论是由于外部事件还是由于用户在使用应用程序所进行的操作，SwiftUI 都会自动更新视图以反映这些变化。",
      "tips": ""
    },
    "This sample shows examples of using State variables to indicate data dependencies, and sharing data with other views using the Binding property wrapper.": {
      "zh": "这个案例展示了一个使用State变量来指示数据的依赖性，以及使用 Binding 属性包装器与其他视图共享数据的例子。",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "如果要亲自尝试代码，请下载项目文件，并在 Xcode 中打开案例。",
      "tips": ""
    },
    "Separate properties and imperative code from the view": {
      "zh": "从视图中分离属性和指令代码",
      "tips": ""
    },
    "When a view needs to manage more than a single piece of state data, it can be helpful to manage that data in a separate view-specific structure. This approach helps make the declarative interface code of a view more readable by moving properties and imperative code outside of the view. It also helps make unit testing state changes easier to implement.": {
      "zh": "当一个视图需要管理不止一块状态数据时，在一个视图专用的结构中管理这些数据会很有帮助。通过将属性和指令代码移到视图之外，有助于使视图的声明式界面代码更易阅读。此外，还更容易实现关于状态改变的单元测试代码。",
      "tips": ""
    },
    "This sample app displays a collection of cooking recipes. A person using the app can view the details of a recipe and add new ones. To add a recipe, the sample presents the custom view RecipeEditor, which needs three pieces of state data: a recipe, a flag indicating whether to save the changes, and a flag indicating whether to present the RecipeEditor view.": {
      "zh": "这个案例应用展示了一个食谱的集合。使用这个应用的人可以查看食谱的详细说明并添加新的食谱。为了能使用户添加一个食谱，该案例显示了一个自定义视图 RecipeEditor，它需要三块状态数据：一个是食谱，一个用来表示是否保存更改的标志，以及一个表示是否展示 RecipeEditor 视图的标志。",
      "tips": ""
    },
    "The sample app separates its state data and imperative code from RecipeEditor by defining a structure, RecipeEditorConfig.": {
      "zh": "这个案例应用通过定义一个结构，RecipeEditorConfig，将状态数据和指令代码与RecipeEditor分开。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "The structure RecipeEditorConfig stores the state data that the RecipeEditor view needs.": {
      "zh": "结构 RecipeEditorConfig 存储了 RecipeEditor 视图需要的状态数据。",
      "tips": ""
    },
    "To trigger state changes that happen in the RecipeEditor view, RecipeEditorConfig provides mutating functions that update the data to reflect a new state.": {
      "zh": "为了触发发生在 RecipeEditor 视图中的状态变化，RecipeEditorConfig 提供了一些可变方法，用来更新数据以反映新的状态。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "The method presentAddRecipe(sidebarItem:) changes the state of the view to indicate that its editing a new recipe.": {
      "zh": "方法 presentAddRecipe(sidebarItem:) 用来改变视图的状态，表明正在编辑一个新的食谱。",
      "tips": ""
    },
    "Note": {
      "zh": "注释",
      "tips": ""
    },
    "The app calls this method when a person taps the Add Recipe button.": {
      "zh": "当用户点击“Add Recipe”按钮时，应用会调用这个方法。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "This method creates an empty recipe as the recipe to edit.": {
      "zh": "该方法创建了一个空的配方作为要编辑的配方。",
      "tips": ""
    },
    "The static method emptyRecipe() creates a new instance of Recipe, setting its properties to the default values of a new recipe.": {
      "zh": "静态方法 emptyRecipe() 用于创建一个新的配方实例，并将其属性设置为新配方的默认值。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "In addition to the default values that emptyRecipes() sets, presentAddRecipe(sidebarItem:) sets the recipe’s isFavorite and collections properties based on the selected sidebar item.": {
      "zh": "除了 emptyRecipes() 设置的默认值外，presentAddRecipe(sidebarItem:) 还会根据选定的边栏项设置食谱的 isFavorite 和 collections 属性。",
      "tips": ""
    },
    "By setting the isFavorite and collections properties, the new recipe automatically appears in the appropriate list of recipes after saving the recipe.": {
      "zh": "通过设置 isFavorite 和 collections 属性，新配方在保存后会自动出现在相应的配方列表中。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "presentAddRecipe(sidebarItem:) sets the shouldSaveChanges flag to false because the person using the app hasn’t indicated that they want to save the changes yet.": {
      "zh": "presentAddRecipe(sidebarItem:) 会将 shouldSaveChanges 标志设置为 false，因为使用该应用的人还没有表示他们想保存这些变化。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "This method sets the isPresented flag to true to tell SwiftUI to display the editor view.": {
      "zh": "此方法将 isPresented 标志设置为 true，以告诉SwiftUI显示编辑器视图。",
      "tips": ""
    },
    "Keeping reading to learn how the recipe editor appears based on the isPresented value.": {
      "zh": "继续阅读以了解如何通过改变 isPresented 的值显示配方编辑器。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第七步",
      "tips": ""
    },
    "The method presentEditRecipe(_:) is similar to presentAddRecipe(sidebarItem:), but for editing an existing recipe.": {
      "zh": "presentEditRecipe(_:) 方法与 presentAddRecipe(sidebarItem:) 类似，但用于编辑现有配方。",
      "tips": ""
    },
    "Step 8": {
      "zh": "第八步",
      "tips": ""
    },
    "Instead of creating an empty recipe like presentAddRecipe(sidebarItem:) does, presentEditRecipe(_:) receives the recipe to edit as a parameter and sets recipe to the incoming recipe.": {
      "zh": "presentEditRecipe(_:) 不是像是 presentAddRecipe(sidebarItem:) 那样创建一个空配方，而是接收要编辑的配方作为参数，并将 recipe 设置为这个被传入的配方。",
      "tips": ""
    },
    "The RecipeEditorConfig supports two other mutating methods that trigger state changes in the editor while also separating imperative code from declarative interface code: done() and cancel().": {
      "zh": "RecipeEditorConfig 支持另外两个触发编辑器状态变化的可变方法，同时也将指令性代码与声明性界面代码分开：done() 和 cancel()。",
      "tips": ""
    },
    "Step 9": {
      "zh": "第九步",
      "tips": ""
    },
    "The done() method indicates that the editor should save changes made to the recipe, and dismiss the RecipeEditor view.": {
      "zh": "done() 方法表示编辑器应该保存对配方所做的修改，并退出 RecipeEditor 视图。",
      "tips": ""
    },
    "The method sets shouldSaveChanges to true to indicate that the app should save changes made to the recipe. It also sets isPresented to false, which tells SwiftUI to dismiss the editor view.": {
      "zh": "该方法将 shouldSaveChanges 设置为 true，表示应用应该保存对配方的修改。它还将 isPresented 设置为 false，告诉SwiftUI取消显示编辑器视图。",
      "tips": ""
    },
    "Step 10": {
      "zh": "第十步",
      "tips": ""
    },
    "The cancel() method is similar to done(), but it sets shouldSaveChanges to false, telling the app to disregard the changes made to the recipe.": {
      "zh": "cancel() 方法与 done() 方法类似，但它将 shouldSaveChanges 设置为 false，告诉应用无视对配方的修改。",
      "tips": ""
    },
    "The method also sets isPresented to false, which tells SwiftUI to dismiss the editor view.": {
      "zh": "这个方法还将 isPresented 设置为 false，这告诉SwiftUI取消显示编辑器视图。",
      "tips": ""
    },
    "Bind the view to its state data": {
      "zh": "将视图与它的状态数据绑定",
      "tips": ""
    },
    "With a structure in place that contains the data that the recipe editor needs, and methods that change the state of the editor, look at the RecipeEditor view to see how it uses RecipeEditorConfig.": {
      "zh": "有了一个包含配方编辑器所需数据的结构，以及一些改变编辑器状态的方法，是时候看看 RecipeEditor 视图是如何使用 RecipeEditorConfig 的。",
      "tips": ""
    },
    "RecipeEditor is a structure that conforms to the View protocol.": {
      "zh": "RecipeEditor 是一个符合 View 协议的结构。",
      "tips": ""
    },
    "The structure declares the binding variable config of type RecipeEditorConfig, which contains the state data that the view uses to determine its appearance.": {
      "zh": "该结构声明了一个 RecipeEditorConfig 类型的绑定变量 config，它包含了视图用来决定外观的状态数据。",
      "tips": ""
    },
    "Important": {
      "zh": "重要提示",
      "tips": ""
    },
    "The Binding property wrapper provides a two-way, read-write binding to data that the view needs. However, RecipeEditor doesn’t own the data. Instead, another view creates and owns the instance of RecipeEditorConfig that RecipeEditor binds to and uses.": {
      "zh": "Binding 属性包装器为视图所需的数据提供了双向的、可读写的绑定。然而，RecipeEditor 并不拥有这些数据。相反，另一个视图创建并拥有 RecipeEditorConfig 的实例，RecipeEditor 仅仅只是与之绑定并使用其数据。",
      "tips": ""
    },
    "RecipeEditor contains RecipeEditorForm, which displays the input fields needed to edit recipe data.": {
      "zh": "RecipeEditor 包含 RecipeEditorForm，它显示了编辑配方数据所需的输入框。",
      "tips": ""
    },
    "RecipeEditor passes the binding variable config to RecipeEditorForm. It passes the variable as a binding, indicated by prefixing the variable name config with the $ symbol. Because RecipeEditorForm receives config as a binding, the form can read and write data to config.": {
      "zh": "RecipeEditor 把绑定变量 config 传递给了 RecipeEditorForm。通过在变量名 config 前加上 $ 符号，它把这个变量作为一个绑定变量来传递。因为 RecipeEditorForm 接收 config 作为一个绑定变量，所以 RecipeEditorForm 可以向 config 读写数据。",
      "tips": ""
    },
    "The editor displays a Cancel button in its toolbar.": {
      "zh": "编辑器在其工具栏上显示一个取消按钮。",
      "tips": ""
    },
    "When a person taps the Cancel button, its action calls the mutating method cancel() defined in RecipeEditorConfig, which sets shouldSaveChanges to false and isPresented to false.": {
      "zh": "当一个人点击取消按钮时，它会调用 RecipeEditorConfig 中定义的可变方法 cancel()，它将 shouldSaveChanges 设置为 false，isPresented 设置为 false。",
      "tips": ""
    },
    "The editor also displays a Save button that, when a person taps it, calls the mutating done() method, which sets shouldSaveChanges to true and isPresented to false, telling the app to save any changes made to the recipe and dismiss the editor view.": {
      "zh": "编辑器还显示一个保存按钮，当人们点击该按钮时，会调用可变方法 doed()，该方法将 shouldSaveChanges 设置为 true，将 isPresented 设置为 false，告诉应用保存对配方所做的任何修改，并退出编辑器视图。",
      "tips": ""
    },
    "Settings shouldSaveChanges and isPresented in the cancel() and done() methods make the view code easier to read because each button’s action only needs one line of code. The button actions could’ve explicitly set config.saveConfig and config.isPresented, but keeping imperative code in an action to a minimum helps make the declarative interface code of the view more readable and easier to maintain.": {
      "zh": "在 cancel() 和 done() 方法中设置 shouldSaveChanges 和 isPresented 可以使视图代码更容易阅读，因为每个按钮的动作只需要一行代码。按钮动作也可以明确地设置 config.saveConfig 和 config.isPresented 的值，但将按钮动作中的指令性代码保持在最低限度，有助于使视图的声明性界面代码更易读，更容易维护。",
      "tips": ""
    },
    "Create a state variable in another view": {
      "zh": "在另一个视图中创建一个状态变量",
      "tips": ""
    },
    "The RecipeEditor view has a binding to an instance of RecipeEditorConfig. The editor can read and write the data but it doesn’t own the recipe data. Instead, the view ContentListView creates and owns the data, and SwiftUI manages that data for the lifespan of the content list view.": {
      "zh": "RecipeEditor 视图拥有一个对 RecipeEditorConfig 实例的绑定。编辑器可以读取和写入数据，但它并不拥有配方数据。相反，视图 ContentListView 创建并拥有这些数据，SwiftUI在 ContentListView 的生命周期内管理这些数据。",
      "tips": ""
    },
    "ContentListView is a custom view that conforms to the View protocol and displays a list of recipes.": {
      "zh": "ContentListView 是一个符合 View 协议的自定义视图，它显示了一个食谱列表。",
      "tips": ""
    },
    "ContentListView is also responsible for displaying the recipe editor when a person wants to add a recipe, making this view the ideal place to create an instance of RecipeEditorConfig.": {
      "zh": "ContentListView 还负责在人们想要添加食谱时显示食谱编辑器，这使得该视图成为创建 RecipeEditorConfig 实例的理想场所。",
      "tips": ""
    },
    "The view defines the private state variable recipeEditorConfig, of type RecipeEditorConfig.": {
      "zh": "该视图定义了一个私有状态变量 recipeEditorConfig，类型为 RecipeEditorConfig。",
      "tips": ""
    },
    "This view also displays an Add Recipe button in its toolbar.": {
      "zh": "该视图还在其工具栏上显示了一个添加配方按钮。",
      "tips": ""
    },
    "The Add Recipe button appears as a button with a plus sign as its label.": {
      "zh": "添加配方按钮将显示为一个带加号标识的按钮。",
      "tips": ""
    },
    "When a person taps the Add Recipe button, the button’s action calls the mutating method presentAddRecipe(sidebarItem:), which changes the data contained in recipeEditorConfig.": {
      "zh": "当一个人点击添加配方按钮时，该按钮的动作会调用可变方法 presentAddRecipe(sidebarItem:) ，从而改变 recipeEditorConfig 中包含的数据。",
      "tips": ""
    },
    "Recall that presentAddRecipe(sidebarItem:) creates an empty recipe and sets its isFavorite and collections property values based on the selected sidebar item. The method also sets shouldSaveChanges to false and isPresented to true. Keeping this imperative code outside of the view helps make the declarative code of the view easier to understand and maintain.": {
      "zh": "回想一下 presentAddRecipe(sidebarItem:)，它创建了一个空的配方，并根据选定的侧边栏项目设置 isFavorite 和 collection 属性的值。该方法还将 shouldSaveChanges 设置为 false，isPresented 设置为 true。将这些命令式代码放置在视图之外有助于使视图的声明式界面代码更容易理解和维护。",
      "tips": ""
    },
    "After calling presentAddRecipe(sidebarItem:), isPresented is true, which tells SwiftUI to display a sheet that contains the recipe editor.": {
      "zh": "调用 presentAddRecipe(sidebarItem:) 后，isPresented 将设置为 true，这会让SwiftUI显示一个包含食谱编辑器的页面。",
      "tips": ""
    },
    "The Boolean value recipeEditorConfig.isPresented determines whether to present the sheet that contains the RecipeEditor view. When the value changes from false to true, the sheet presents a modal view containing RecipeEditor. When the value changes from true to false, the sheet dismisses the modal view.": {
      "zh": "布尔值 recipeEditorConfig.isPresented 决定了是否呈现包含 RecipeEditor 视图的弹窗。当值从 false 变为 true 时，长弹窗会呈现一个包含 RecipeEditor 的视图。当该值从 true 变为 false 时，长弹窗就会取消该视图。",
      "tips": ""
    },
    "The modifier sheet(isPresented:onDismiss:content:) receives a binding as indicated by the dollar sign ($) prefix. This binding lets the sheet read and write to the property. For instance, when a person dismisses the sheet by swiping it downward, the sheet sets recipeEditorConfig.isPresented to false. This change causes SwiftUI to reinitialize and rebuild the view. And because isPresented is now false, the sheet no longer appears.": {
      "zh": "修饰器 sheet(isPresented:onDismiss:content:) 接收一个由美元符号（$）前缀表示的绑定。这个绑定让长弹窗可以读取和写入其中的属性。例如，当一个人向下轻扫长弹窗时，长弹窗会将 recipeEditorConfig.isPresented 设置为 false。这一变化导致SwiftUI重新初始化并重建视图。由于 isPresented 现在是 false，长弹窗不再出现。",
      "tips": ""
    },
    "The sheet contains RecipeEditor, a custom view that displays a form containing input fields that let a person change the data of a recipe.": {
      "zh": "该长弹窗包含 RecipeEditor，这是一个自定义视图，显示了一个包含一些用于让人改变食谱数据的输入框的表单。",
      "tips": ""
    },
    "RecipeEditor receives a binding to recipeEditorConfig — as indicated by the dollar sign ($) prefix — which makes it possible for the editor to retrieve and make changes to data contained in recipeEditorConfig. This includes changing recipe data and triggering state changes.": {
      "zh": "RecipeEditor 收到了一个与 recipeEditorConfig 的绑定 -- 如美元符号（$）前缀所示 -- 这使得编辑器可以获取和改变 recipeEditorConfig 中包含的数据。这包括改变配方数据和触发状态变化。",
      "tips": ""
    },
    "When the value of isPresented changes from true to false, the sheet calls its onDismiss action, which calls the didDismissEditor method.": {
      "zh": "当 isPresented 的值从 true 变为 false 时，长弹窗就会调用它的 onDismiss 动作，即调用 didDismissEditor 方法。",
      "tips": ""
    },
    "The sheet also calls onDismiss when isPresented changes from true to false in the cancel() and done() methods that RecipeEditorConfig defines. The sheet is able to detect the value change because it has a binding to the recipeEditorConfig.isPresented property.": {
      "zh": "当 isPresented 在 RecipeEditorConfig 定义的 cancel() 和 done() 方法中从 true 变为 false 时，长弹窗也会调用 onDismiss。长弹窗能够检测到这个值的变化，因为它与 recipeEditorConfig.isPresented 属性有一个绑定。",
      "tips": ""
    },
    "This view implements the didDismissEditor method, which saves the changes a person makes to the recipe if recipeEditorConfig.shouldSaveChanges is true; otherwise, the method disregards the changes.": {
      "zh": "这个视图实现了 didDismissEditor 方法，如果r ecipeEditorConfig.shouldSaveChanges 为 true，该方法将保存一个人对配方所做的修改；否则，该方法将不考虑这些修改。",
      "tips": ""
    },
    "RecipeEditorConfig concerns itself with RecipeEditor and only that view, which is why ContentListView implements the didDismissEditor method instead of RecipeEditorConfig. This approach keeps the areas of concern separate.": {
      "zh": "RecipeEditorConfig 与 RecipeEditor 有关，并且仅与该视图有关，这就是为什么 ContentListView 实现了 didDismissEditor 方法，而不是 RecipeEditorConfig。这种方式使关注的领域分开。",
      "tips": ""
    },
    "Creating a custom input control that binds to a value": {
      "zh": "创建一个与值绑定的自定义输入控件",
      "tips": ""
    },
    "Provide interactions that are unique to your app with custom controls that bind to a value.": {
      "zh": "通过绑定到一个值的自定义控件，提供你应用所特有的交互方式。",
      "tips": ""
    },
    "The recipeEditorConfig declaration includes the attribute for the State property wrapper, which tells SwiftUI to create and manage the instance of RecipeEditorConfig. Each time view state changes, that is, data that recipeEditorConfig contains changes, SwiftUI reinitializes the view, reconnects the RecipeEditorConfig instance to the view, and rebuilds the view defined in the computed body property, which reflects the current state of the data. For more information, see Model data.": {
      "zh": "recipeEditorConfig 声明包括State属性包装器，它让SwiftUI创建并管理 RecipeEditorConfig 的实例。每次视图状态发生变化，即 recipeEditorConfig 包含的数据发生变化时，SwiftUI都会重新初始化视图，将 RecipeEditorConfig 实例重新连接到视图，并重新构建计算属性中定义的视图，使其反映数据当前的状态。想要了解更多信息，请参考模型数据。",
      "tips": ""
    },
    "When presentAddRecipe(sidebarItem:) changes the data in recipeEditorConfig, SwiftUI reinitializes the ContentListView instance and reconnects recipeEditorConfig to the instance that it’s managing. SwiftUI then rebuilds the view from its computed body property so that the view reflects the current state of the data.": {
      "zh": "当 presentAddRecipe(sidebarItem:) 更改 recipeEditorConfig 中的数据时，SwiftUI 会重新初始化 ContentListView 实例，并将 recipeEditorConfig 重新连接到它所管理的实例。然后，SwiftUI从其计算属性 body 中重建视图，以使视图反映数据的当前状态。",
      "tips": ""
    }
  },
  "swiftui-concepts/exploring-the-structure-of-a-swiftui-app": {
    "Exploring the structure of a SwiftUI app": {
      "zh": "探索 SwiftUI app 的结构",
      "tips": ""
    },
    "Walk through code that explores the structure of a SwiftUI app.": {
      "zh": "跟着代码逐步探索 SwiftUI app 的结构",
      "tips": ""
    },
    "SwiftUI is a declarative framework that helps you compose the user interface of your app. The principle building blocks that form the structure of a SwiftUI app are the App, Scene, and View protocols. This sample introduces you to these protocols by walking through lines of code, and explaining what’s happening and why.": {
      "zh": "SwiftUI 是一个声明式框架，可帮助您构建应用程序的用户界面。构成 SwiftUI 应用程序结构的主要部分是 App、Scene 和 View protocol（协议）。本示例通过逐行代码去介绍这些协议，以及解释正在发生的事情以及原因。",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "若要尝试代码，下载项目文件并在 Xcode 中打开示例。",
      "tips": ""
    },
    "App structure": {
      "zh": "App 结构体",
      "tips": ""
    },
    "An app structure describes the content and behavior of your app, and each SwiftUI app has one and only one main app structure. This sample defines its app structure in the MyApp.swift file. Let’s take a look at the contents of that file.": {
      "zh": "App 结构描述了 App 内的内容和您 App 的各种行为，每个 SwiftUI App 有且仅有一个主 App 结构。这个示例在 MyApp.swift 文件中定义了它的 App 结构。让我们看一看这个文件里的内容。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第 1 步",
      "tips": ""
    },
    "To access the symbols and features of SwiftUI, the app uses an import declaration to import the SwiftUI framework.": {
      "zh": "为了使用 SwiftUI 的符号和功能，App 使用 import 声明来导入 SwiftUI 框架。",
      "tips": ""
    },
    "Note": {
      "zh": "注释",
      "tips": ""
    },
    "For more information, see Import Declaration in The Swift Programming Language.": {
      "zh": "更多的相关信息，请参阅 The Swift Programming Language 中的 Import Declaration 部分。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第 2 步",
      "tips": ""
    },
    "To indicate the entry point of the SwiftUI app, the sample applies the @main attribute to the app structure.": {
      "zh": "为了标示 SwiftUI app 的入口点，示例项目将 @main 属性应用于 app 结构体。",
      "tips": ""
    },
    "The entry point is responsible for the start up of the app.": {
      "zh": "入口点负责 app 的启动。",
      "tips": ""
    },
    "Important": {
      "zh": "重要提示",
      "tips": ""
    },
    "A SwiftUI app contains one and only one entry point. Attempting to apply @main to more than one structure in the app results in a compiler error.": {
      "zh": "一个 SwiftUI app 包含一个且仅包含一个入口点。尝试将 @main 在 app 内应用到多于一个结构体的位置会导致编译错误。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第 3 步",
      "tips": ""
    },
    "The MyApp structure conforms to the App protocol, and provides the content of the app and its behavior.": {
      "zh": "MyApp 结构体遵循 App 协议，并提供了 App 的内容和这个 App 的行为。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第 4 步",
      "tips": ""
    },
    "The structure implements the computed property body, which is a requirement of the App protocol.": {
      "zh": "该结构体内实现了计算属性 body，这是为了遵循 App 协议。",
      "tips": ""
    },
    "This property returns the contents of your app described as a Scene. A scene contains the view hierarchy that defines the app’s user interface. SwiftUI provides different types of scenes including WindowGroup, Window, DocumentGroup, and Settings.": {
      "zh": "这个属性返回了一个被称为 Scene（场景）的东西，他描述了 app 内的内容。一个 scene（场景）包含了视图层次结构，定义了 app 的用户界面。SwiftUI 提供了不同的 scene（场景），包括 WindowGroup（窗口组），Window（窗口），DocumentGroup（文档组） 和 Settings（设置）。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第 5 步",
      "tips": ""
    },
    "This sample uses a WindowGroup scene to represent the main window that the app displays.": {
      "zh": "这个示例使用了一个 WindowGroup（窗口组）场景来展示应用显示的主窗口。",
      "tips": ""
    },
    "SwiftUI provides platform-specific behaviors for WindowGroup. For instance, in macOS and iPadOS, a person can open more than one window from the group. And in macOS, a person can combine multiple instances of the window group into a set of tabs.": {
      "zh": "SwiftUI 的 WindowGroup 为不同的平台提供了不同的表现方式。例如，在 macOS 和 iPadOS 中，一个用户可以从 group（组）内打开多个 window（窗口）。并且在 macOS 上，可以将多个窗口 group（组）的实体放到一个多标签页集合中。",
      "tips": ""
    },
    "Tip": {
      "zh": "提示",
      "tips": ""
    },
    "If you’re creating a document-based app such as a word processor or text editor, you can use the DocumentGroup scene to open, save, and edit documents. For more information, see Building a Document-Based App with SwiftUI.": {
      "zh": "如果你要创建一个基于文档的 app，例如文字处理器或文本编辑器，你可以使用 DocumentGroup（文档组）scene（场景）来打开，保存，编辑文档。更多的相关信息，请参阅文章 - Building a Document-Based App with SwiftUI（利用 SwiftUI 创建一个基于文档的 App）。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第 6 步",
      "tips": ""
    },
    "The scene contains ContentView, a custom view that creates a view hierarchy that consists of an image and text.": {
      "zh": "scene（场景）包含 ContentView（内容视图），他是一个自定义 view（视图），用于创建一个包含图像和文本的视图层次结构。",
      "tips": ""
    },
    "Keep reading to learn how ContentView composes the view hierarchy.": {
      "zh": "继续阅读以了解 ContentView（内容视图）是如何建立 view hierachy（视图树）的。",
      "tips": ""
    },
    "Content view": {
      "zh": "内容视图",
      "tips": ""
    },
    "In SwiftUI, a scene contains the view hierarchy that an app displays as its user interface. A view hierarchy defines the layout of views relative to other views. In this sample, a WindowGroup scene contains the view hierarchy that ContentView composes using other views.": {
      "zh": "SwiftUI 中，一个 scene（场景）内包含了 app 所显示 UI 的视图层次结构。视图的层次结构定义了该视图相对于其他视图的布局。在这个示例中，一个 WindowGroup（窗口组）scene（场景）包含了视图的层次结构，即 ContentView（内容视图）通过组合其他视图而成。",
      "tips": ""
    },
    "The source code begins by importing the SwiftUI framework.": {
      "zh": "源代码从导入 SwiftUI 框架开始。",
      "tips": ""
    },
    "Without the import declaration, ContentView wouldn’t have access to symbols in SwiftUI.": {
      "zh": "如果没有 import 导入声明，ContentView 将无法访问 SwiftUI 中的相关内容。",
      "tips": ""
    },
    "ContentView is a structure that conforms to the View protocol.": {
      "zh": "ContentView 是遵循 View protocol（协议）的 struct（结构体）。",
      "tips": ""
    },
    "A view defines one or more visual elements that appear somewhere on a screen. A view is typically made up of other views, creating a view hierarchy.": {
      "zh": "view（视图）定义了一个或多个出现在屏幕上的可见元素。view（视图）通常由其他视图构成，最终形成 view hierarchy（视图树）。",
      "tips": ""
    },
    "Implementing body is a common pattern that you see throughout your SwiftUI code; for instance, when a structure conforms to protocols such as App, Scene, and View.": {
      "zh": "在编写 SwiftUI 代码的过程中，在结构体中实现 body（主体）属性，是一种非常常见的模式；例如，当结构体遵循 App，Scene，View 协议时，内部都要实现 body（主体）属性。",
      "tips": ""
    },
    "ContentView contains the SwiftUI-provided view VStack, which arranges subviews vertically.": {
      "zh": "ContentView（内容视图）内包含了 SwiftUI 提供的视图 VStack（垂直堆栈），用于垂直整理子视图。",
      "tips": ""
    },
    "A VStack simultaneously renders any on- or off-screen views it contains. Using VStack is ideal when you have a small number of subviews. However, if your app needs to display many more subviews, consider using LazyVStack, which only renders the views when the app needs to display them onscreen.": {
      "zh": "VStack（垂直堆栈）同时渲染它所包含的任意屏幕上或屏幕外的视图。当你有少量的子视图时，用 VStack（垂直堆栈）是最合适的。然而，如果你的 app 需要展示更多的子视图，考虑使用 LazyVStack（惰性垂直堆栈），他只在 app 需要在屏幕上展示对应视图时才进行渲染。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实践",
      "tips": ""
    },
    "Replace VStack with either HStack or LazyHStack to arrange subviews horizontally.": {
      "zh": "将 VStack（垂直堆栈）替换成 HStack（水平堆栈）或 LazyHStack（惰性水平堆栈），以水平整理子视图。",
      "tips": ""
    },
    "The first subview in VStack is Image, a view that displays an image.": {
      "zh": "VStack（水平堆栈）内第一个子视图是 Image（图像），这个视图用于展示图片。",
      "tips": ""
    },
    "The sample displays an image of a globe using the initializer method init(systemName:). This method creates an image view that displays a system symbol image. Symbol images like globe come from SF Symbols, a library of icons that you can use in your app.": {
      "zh": "示例中使用初始化方法 init(systemName:) 展示了一个地球图片。这个方法创建了一个展示系统符号的图像视图。如展示中的地球，以及其他的符号图片都来自 SF Symbols，这是一个包含丰富 icon（图标）的库，你都可以在你的 app 内使用。",
      "tips": ""
    },
    "ContentView applies the view modifier imageScale(_:) to the image view to scale the image within the view to the relative size Image.Scale.large.": {
      "zh": "ContentView（内容视图）内添加了 imageScale(_:)（可调整图片缩放）视图修饰符，可以将图片缩放到相对大小的尺寸，如 Image.Scale.large。",
      "tips": ""
    },
    "Change Image.Scale.large to another scale size. For a list of sizes, see Image.Scale.": {
      "zh": "将 Image.Scale.large 替换成另外的缩放尺寸。有关尺寸列表，请参阅 Image.Scale。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第 7 步",
      "tips": ""
    },
    "The foregroundColor(_:) modifier adds color to the image view.": {
      "zh": "foregroundColor(_:) 修饰符能给 image view（图像视图）添加颜色。",
      "tips": ""
    },
    "In this sample, ContentView applies the semantic color accentColor, which reflects the accent color of the system or app. To learn more about color representations, see Color.": {
      "zh": "在此示例中，ContentView（内容视图）应用了语义颜色：accentColor（强调色），它反映了系统或 app 的强调色。要了解有关颜色的更多信息，请参阅 Color",
      "tips": ""
    },
    "Step 8": {
      "zh": "第 8 步",
      "tips": ""
    },
    "The second subview of VStack is Text, a view that displays one or more lines of read-only text.": {
      "zh": "VStack（垂直堆栈）的第二个子视图是 Text（文本），该视图能够展示一行或多行只读文本。",
      "tips": ""
    },
    "Replace “Hello, world!” with “Hello, your name!” or other text.": {
      "zh": "将 \"Hello, world\" 替换成 \"Hello, your name!\" 或其他文本。",
      "tips": ""
    },
    "Step 9": {
      "zh": "第 9 步",
      "tips": ""
    },
    "ContentView applies the padding(_:_:) modifier to the VStack, adding a platform-specific default amount of padding — that is, space — to the edges of the VStack view.": {
      "zh": "ContentView（文本视图）将 padding(_:_:)（填充）修饰符应用于 VStack（垂直堆栈），为 VStack 视图的边缘添加了针对不同平台进行调整的默认的 padding（填充），也可以理解成为 VStack 视图的边缘添加了空间。",
      "tips": ""
    },
    "You can specify which edges and amount of padding to apply by providing edges and length parameter values; for example, padding([.bottom, .trailing], 20). Change the padding edges and amount or comment the line of code to see what effect it has on the view.": {
      "zh": "你可以通过提供 edges（边缘）和 length（长度）来指定要应用到的特定边缘和其特定的填充量；例如，padding([.bottom, .trailing], 20)。尝试更改边缘和长度或注释掉代码，看看它对视图的影响。",
      "tips": ""
    },
    "Step 10": {
      "zh": "第 10 步",
      "tips": ""
    },
    "When you run the sample app, it displays the scene that contains the view hierarchy described in ContentView.": {
      "zh": "当你运行示例 App，他会展示 scene（场景），该场景包含 ContentView 里所描述的 view hierachy（视图树）",
      "tips": ""
    },
    "Build and run the sample using Xcode. Then play around with code by following the suggested experiments mentioned in the previous steps.": {
      "zh": "使用 Xcode 编译并运行示例。然后按照前面步骤中提到的建议的实践内容，尝试编写一下代码。",
      "tips": ""
    },
    "Specifying the view hierarchy of an app using a scene": {
      "zh": "使用 scene（场景）指定 app 的 view hierarchy（视图树）",
      "tips": ""
    },
    "A scene contains the view hierarchy of your app.": {
      "zh": "scene（场景）内包含 app 的 view hierachy（视图树）。",
      "tips": ""
    },
    "ContentView implements the computed property body, just like the ‘MyApp’ structure does in the previous section.": {
      "zh": "ContentView（内容视图）内实现了 computed property（计算属性）body，就像前面章节里 MyApp 中的结构体一样。",
      "tips": ""
    },
    "Change the foreground color to another semantic color such as primary or a standard color like teal.": {
      "zh": "将前景色更改为其他 semantic color（语义颜色），例如 primary（基础色）或 teal（蓝绿色）",
      "tips": ""
    }
  },
  "swiftui-concepts/layering-content": {
    "Layering content": {
      "zh": "内容分层",
      "tips": ""
    },
    "Define views in an overlay or background to adapt their layout to the primary content.": {
      "zh": "可以在 overlay 或 background 中定义视图，以使它们的布局适应主要内容。",
      "tips": ""
    },
    "Designs that layer content often specify that some content stays within the bounds of other content, or maintains a specific margin around that content. You can define these relationships between views with overlay and background modifiers. For example, if your design includes a graphic that provides contrast behind some text, you can define a layout so that the graphic adapts its size and position as the text updates. You can wrap text to fit within the width of another view by defining the text in a background or overlay of that other view.": {
      "zh": "设计中内容分层的情况通常需要指定某些内容保持在其他内容的边界内，或者在其周围保持一个特定的边距。你可以使用 overlay 和 background 修饰符定义视图之间的这些关系。 例如，如果你的设计中包含一个用来在某些文本后面提供对比度的图形，那么可以定义一个布局，使得该图形随着文本的更新而自适应其大小和位置。 你可以通过将文本定义在另一个视图的 background 或 overlay 中，使其适应该视图的宽度进行换行。",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "要实践这段代码的话，请下载项目文件并在 Xcode 中打开示例。",
      "tips": ""
    },
    "Define an overlay": {
      "zh": "定义一个 overlay",
      "tips": ""
    },
    "When you arrange content on the z-axis, you can use a ZStack or an overlay or background modifier, like overlay(alignment:content:) or background(_:in:fillStyle:), respectively. A ZStack sizes each view based on the available space, without consideration for the other views in the stack. To specify that the size of some content depends on the size of other content, define this secondary content inside one of the overlay or background modifiers.": {
      "zh": "当你在z轴上排列内容时，可以使用 ZStack、overlay 修饰符（例如 overlay(alignment:content:)）或 background 修饰符 （例如 background(_:in:fillStyle:)）。 对于堆栈中的每个视图，ZStack 是根据可用空间调整其大小，而不会考虑它与其他视图的关系。 如果要指定某些内容的大小是要取决于其他内容大小的话，可以将这些次要内容定义在 overlay 或 background 修饰符中。",
      "tips": ""
    },
    "This example presents a photo with a block of text over the lower portion of the photo. To improve readability of the text without completely obscuring that portion of the photo, there’s a mostly transparent background behind the text. The text wraps to fit within the width of the photo. The text’s background sizes to fit around the text. The CaptionedPhoto view arranges the image and provides the text to a Caption view in the image’s overlay(alignment:content:).": {
      "zh": "这个例子展示了一张照片，照片的下半部分有一块文本。为了在提高文本可读性的同时，又不完全遮挡住照片的这部分内容，文本背后会有一个几乎透明的背景。 文本会自动换行以适应照片的宽度。文本的背景会根据其大小进行调整。CaptionedPhoto 视图会显示照片，并将文本传给一个 Caption 视图，其是在图片的 overlay(alignment:content:) 修饰符中定义的。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "CaptionedPhoto is a custom View that defines the layout of a photo and another custom Caption view, which defines the layout of the caption text that appears on top of the image.": {
      "zh": "CaptionedPhoto 是一个自定义视图，它定义了照片以及另一个自定义 Caption 视图的布局，后者则定义了显示在图片上的标题文本的布局。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "This view defines an assetName property to hold the name of the image asset.": {
      "zh": "这个视图定义了一个 assetName 属性，用于保存图片资源的名称。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "This view also defines a captionText property to contain the caption text that it eventually passes along to the Caption view.": {
      "zh": "这个视图还定义了一个 captionText 属性，用于保存最终传递给 Caption 视图的标题文本。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "This Image view initializer retrieves a photo or graphic by name from your app and displays it.": {
      "zh": "这个 Image 视图的初始化程序，从你 app 中通过传入的名字检索照片或图形，并显示它。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "By default, an Image displays an image at its original size. The resizable(capInsets:resizingMode:) and scaledToFit() modifiers adjust this Image to fit within the available space.": {
      "zh": "默认情况下，Image 视图会以其原始尺寸显示图片。通过使用 resizable(capInsets:resizingMode:) 和 scaledToFit() 修饰符，可以调整 Image 以适应可用空间。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "The Caption custom view defines the text and its background.": {
      "zh": "Caption 自定义视图定义了文本及其背景。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第七步",
      "tips": ""
    },
    "Defining the caption inside overlay(alignment:content:) declares that the caption belongs in front of the image. The size of the primary view limits the size of the overlay(alignment:content:) that modifies the primary view.": {
      "zh": "在 overlay(alignment:content:) 中定义的 Caption 视图位于图片的上方。父视图的大小限制了作用于父视图的 overlay(alignment:content:) 的大小。",
      "tips": ""
    },
    "Specifying an alignment of bottom pushes the overlay(alignment:content:) modifier’s contents to the bottom center of the primary view.": {
      "zh": "通过指定 alignment 参数为 bottom，可以将 overlay(alignment:content:) 修饰符的内容放到父视图的底部中心位置。",
      "tips": ""
    },
    "Note": {
      "zh": "注释",
      "tips": ""
    },
    "An overlay can be smaller than the view it modifies.": {
      "zh": "一个 overlay 可以比它所修改的视图小。",
      "tips": ""
    },
    "Step 8": {
      "zh": "第八步",
      "tips": ""
    },
    "Clipping the view to a RoundedRectangle rounds the corners of the image without changing its size or position.": {
      "zh": "将视图剪切为一个 RoundedRectangle，可以在不改变其大小或位置的情况下，将图片的四个角变为圆角。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实践",
      "tips": ""
    },
    "Change the cornerRadius value to a larger number to see its effect on the photo’s corners.": {
      "zh": "将 cornerRadius 的值更改为较大的数字，以查看其对照片四个角的影响。",
      "tips": ""
    },
    "Step 9": {
      "zh": "第九步",
      "tips": ""
    },
    "This padding(_:_:) puts some space between all four edges of the photo and its containing view.": {
      "zh": "padding(::) 修饰符在照片的四个边缘和其父视图之间添加了一些间距。",
      "tips": ""
    },
    "Delete the padding(_:_:) modifier to see how that changes the layout. The padding modifier also appears twice in the Caption view. Remove each of those as well to see how their absence affects the layout.": {
      "zh": "删除 padding(::) 修饰符来看看布局是如何变化的。padding 修饰符也同样在 Caption 视图中出现了两次。同样地，删除每个修饰符以查看其是如何影响布局的。",
      "tips": ""
    },
    "Define a background": {
      "zh": "定义一个 background",
      "tips": ""
    },
    "The overlay(alignment:content:) on the CaptionedPhoto contains a Caption view to display the caption text.": {
      "zh": "在 CaptionedPhoto 的 overlay(alignment:content:) 修饰符中包含了一个用于显示标题文本的 Caption 视图。",
      "tips": ""
    },
    "The Caption view uses the background(_:in:fillStyle:) modifier to place a shape behind the text that partially obscures any content behind it — in this example, the photo — to provide higher contrast for the text.": {
      "zh": "Caption 视图使用 background(_:in:fillStyle:) 修饰符在文本后面放置了一个形状来遮挡其后面的任何内容（在本例中是照片），以提高文本的对比度。",
      "tips": ""
    },
    "This padding(_:_:) modifier adds some space between the words and the edges of the contrasting background underneath. The structure of the code matches the visual appearance of the view — the padding is between the text and the background.": {
      "zh": "padding(::) 修饰符在文本和背景的四条边之间添加一些间距。代码的结构与视图的外观相匹配 - 间距位于文本和背景之间。",
      "tips": ""
    },
    "Important": {
      "zh": "重要提示",
      "tips": ""
    },
    "Choose carefully how to combine padding with an overlay or background modifier. If you pad the primary view before modifying it with the overlay or background, the system uses the size of the padded primary view to calculate the placement of the secondary view. Apply the padding after the overlay or background to put a little space around the view that includes both layers.": {
      "zh": "在使用 padding 修饰符 与overlay 或 background 修饰符结合时，需要谨慎选择使用的顺序。 如果在使用 overlay 或 background 修饰符之前对主要视图应用 padding 修饰符，系统将使用带有边距的主要视图的大小来计算次要视图的位置。 在 overlay 或 background 修饰符之后应用 padding 的话，会在包含两个图层的视图中留出一些空间。",
      "tips": ""
    },
    "A background modifier like background(_:in:fillStyle:) is similar to an overlay modifier, in that its content bases its size on the size of the view it modifies. However, a background modifier puts its contents behind the view it modifies, rather than in front.": {
      "zh": "和 overlay 修饰符类似，background 修饰符（如 background(_:in:fillStyle:)）的内容大小也基于所修改的视图大小。但是 background 修饰符是将其内容放在所修改的视图的背后，而不是在前面。",
      "tips": ""
    },
    "To provide high contrast whether or not people use Dark Mode, this background(_:in:fillstyle:) modifier uses a custom color with partial opacity.": {
      "zh": "为了无论用户是否使用黑暗模式都提供高对比度，background(_:in:fillStyle:) 修饰符使用了一个具有一定不透明度的自定义颜色。",
      "tips": ""
    },
    "The TextContrast color set in this project’s asset catalog defines separate color values for light and dark appearances.": {
      "zh": "在项目的资源目录中，TextContrast 颜色集分别为不同的外观（明亮和暗黑）定义了颜色值。",
      "tips": ""
    },
    "RoundedRectangle, as a Shape, accepts whatever size its containing view proposes.": {
      "zh": "作为一个形状，RoundedRectangle 接受其父视图提供的任何尺寸。",
      "tips": ""
    },
    "In this case, the background(_:in:fillstyle:) modifier creates that containing view, and any background modifier determines its size from the view it modifies. This results in a RoundedRectangle that is the same size as the padding around the Text view.": {
      "zh": "在这种例子中，background(_:in:fillStyle:) 修饰符创建了包含 RoundedRectangle 的视图，而任何 background 修饰符都会根据它所修饰的视图确定其大小。 这就导致 RoundedRectangle 的大小与 Text 视图周围的padding相同。",
      "tips": ""
    },
    "This additional padding(_:_:) around the background adds space between the outside of the Caption view and the container it appears inside; in this case, CaptionedPhoto is the containing view.": {
      "zh": "在 background 周围添加额外的 padding(::)，会在 Caption 视图的外围和其所在的容器之间增加空间。在这个例子中，CaptionedPhoto 就是容器视图。",
      "tips": ""
    },
    "Section 1": {
      "zh": "第一节",
      "tips": ""
    },
    "The scaled image is the only view at the top level of this body, so the image determines the size of the CaptionedPhoto view. For more information about resizing images, see Fitting images into available space.": {
      "zh": "对 body 属性返回的视图来说，缩放后的 Image 视图使其顶层中唯一的视图，因此它也决定了 CaptionedPhoto 视图的大小。有关调整图片大小的更多信息，请参阅《Fitting images into available space》。",
      "tips": ""
    },
    "Section 2": {
      "zh": "第二节",
      "tips": ""
    }
  },
  "swiftui-concepts/maintaining-the-adaptable-sizes-of-built-in-views": {
    "Maintaining the adaptable sizes of built-in views": {
      "zh": "保持内建视图的可自适应尺寸",
      "tips": ""
    },
    "Keep your app’s view layouts fluid on any device for each type of content your app displays.": {
      "zh": "对于每种在你 app 上显示的内容类型，确保其视图布局可以灵活地适应任何设备。",
      "tips": ""
    },
    "The views you define with SwiftUI either directly contain views that SwiftUI provides, or use other custom views that contain these built-in views. SwiftUI views determine their own size, and understanding how to modify the size of built-in views while preserving their adaptability is the best way to create a fluid layout without complicating your code.": {
      "zh": "你在 SwiftUI 中定义的视图要么直接使用 SwiftUI 内置的视图，要么使用那些包含这些内置视图的其他自定义视图。 而创建灵活布局，并且不会使代码复杂化的最佳方式，就是让 SwiftUI 的视图自己决定其自身的大小，以及需要理解在保持其可自适应的同时如何修改内置视图的尺寸。",
      "tips": ""
    },
    "Text and symbols": {
      "zh": "文本和符号",
      "tips": ""
    },
    "When defining the layout for your app, text and symbols play a central role in conveying information to people – in navigation links, button labels, tables, and more. Text and symbols that display information or label other elements need to have enough space to display their contents.": {
      "zh": "在定义你 app 的布局时，例如在导航链接、按钮标签、表格等向人们传达信息这一方面，文本和符号起到了核心的作用。当文本和符号为了显示信息或标记其他元素时，需要有足够的空间来显示其内容。",
      "tips": ""
    },
    "Text": {
      "zh": "文本",
      "tips": ""
    },
    "A Text view displays read-only text. Its contents could be a short String, like the title of a play or the heading of a section. A Text view could also display a much longer String, like all of the actors’ lines for a scene in the play.": {
      "zh": "Text 视图被用来显示只读的文本。它的内容即可以是像戏剧的名字或章节的标题一样的短字符串，也可以用来显示一段非常长的字符串，比如戏剧中一场戏里所有演员的台词。",
      "tips": ""
    },
    "When you declare a Text view in your layout, give the system semantic information about your text with the Font attribute. The system chooses font faces and sizes so that, for example, a Text with the title font is more prominent than one with body or caption.": {
      "zh": "当你在布局中声明一个 Text 视图时，可以使用 Font 属性来向系统提供关于文本的语义信息。系统会根据这个属性选择字体样式和大小，例如，使用 title 字体的文本就会比使用 body 或 caption 字体的文本更加显眼。",
      "tips": ""
    },
    "A Text view can adjust to some space constraints with line-wrapping or truncation, but it doesn’t change font size to accommodate situations where its ideal size is smaller or larger than the available space.": {
      "zh": "Text 视图可以通过换行或截断来适应一些空间上的限制，但它不会改变字体大小以适应其理想尺寸与可用空间不匹配的情况。",
      "tips": ""
    },
    "For more information about localization, see Preparing views for localization. For guidance about supporting Dynamic Type, see Applying custom fonts to text.": {
      "zh": "想了解更多关于本地化的信息，请参考 \"Preparing views for localization\"。请参考 \"Applying custom fonts to text\" 相关内容，以获取关于支持动态字体的指导",
      "tips": ""
    },
    "Symbols": {
      "zh": "符号",
      "tips": ""
    },
    "Symbols, such as the iconography that SF Symbols provides, can denote common app features, like folders, heart shapes for favorites, or a camera icon to access the camera. Effective symbols streamline your app’s UI, and are easily recognizable by the people who use your app. You can customize their colors and sizes using standard view modifiers provided in SwiftUI. Even though you specify a system or custom symbol in an Image, treat SF Symbols more like text. To adjust the size and weight of a symbol, specify a semantic Font, like title, just like you would for a Text view.": {
      "zh": "就像 SF Symbols 提供了很多图标一样，符号可以用来表示一些常见的 app 功能，例如：文件夹、用来表示收藏的心形形状、或用来访问相机的相机图标。 对于那些使用你 app 的人来说，有效的图标不但能简化界面，还能让人轻松地识别出它。你可以使用 SwiftUI 已经提供的那些视图修饰符来自定义它们的颜色和大小。 尽管你是把系统（例如 SF Symbols）或自定义的符号放在一个 Image 视图里，但在使用上更像是操作文本。 要调整符号的大小和粗细，就得像之前为 Text 视图所做的那样，通过设置 Font 属性来达到目的，例如设置其为 title。",
      "tips": ""
    },
    "The following example uses an HStack to create a row of three Image views that display icons from SF Symbols.": {
      "zh": "以下示例使用了 HStack 创建了一行包含三个 Image 视图的布局，每个视图显示一个来自 SF Symbols 的图标。",
      "tips": ""
    },
    "Labels": {
      "zh": "标签",
      "tips": ""
    },
    "To use both text and a symbol to represent a single element in your app, use a Label. A Label takes care of matching its title and icon sizes and their alignment. The following code defines a Label that combines an SF Symbol of some books, with some text for its title. The Label applies the largeTitle font to both the icon and the title. The titleAndIcon style tells the view to display both its title and icon, overriding any built-in or custom LabelStyle that a containing view might specify.": {
      "zh": "要想在 app 中把文本和符号组合表示成单个界面元素的话，我们可以使用 Label。Label 负责处理标题和图标的大小以及它们的对齐方式。 以下代码定义了一个 Label，它用某个名为 books 的 SF Symbol 符号作为图标，以及若干文字作为标题。这个 Label 将 largeTitle 字体应用到图标和标题上。 titleAndIcon 样式则告诉视图同时显示标题和图标，并且覆盖掉任何内置或父视图可能指定的自定义 LabelStyle 属性。",
      "tips": ""
    },
    "Controls": {
      "zh": "控件",
      "tips": ""
    },
    "Views that people interact with come in discrete sizes, to maintain consistency when several elements of the same type appear together, like in a Settings pane. Controls also need to be large enough for people to accurately click or tap. You can use view modifiers to choose among these sizes. For example, you can use the controlSize(_:) modifier to make a control smaller or larger, or you can use the progressViewStyle(_:) modifier to choose a linear or circular appearance for a progress bar.": {
      "zh": "人们与之交互的视图都具有各自的尺寸，例如在设置面板中，当同一类型的多个界面元素一起出现时要保持其一致性。控件同样也需要足够大，以便人们能够准确地点击或触摸。你可以使用视图修饰符在多个尺寸之间进行选择。 例如，可以使用c ontrolSize(:) 修饰符使控件变小或变大，或可以使用 progressViewStyle(:) 修饰符为进度条选择线性或圆形外观。",
      "tips": ""
    },
    "The following example shows a Picker and a Button with different ControlSize values.": {
      "zh": "以下示例展示了具有不同 ControlSize 值的一个 Picker 和一个 Button。",
      "tips": ""
    },
    "There are general-purpose controls like Menu and Link, and specialized views like EditButton and ColorPicker. Use these views to provide familiar UI elements rather than creating custom controls that you’ll need to maintain. To explore more of these built-in views, see Controls and indicators.": {
      "zh": "系统不但提供了例如 Menu 和 Link 这样的通用控件，也有像是 EditButton 和 ColorPicker 这样的专用视图。使用这些视图来提供令人熟悉的界面元素，而不是创建需要你自己维护的自定义控件。要了解更多关于这些内置视图的内容，请参阅 \"Controls and indicators\"",
      "tips": ""
    },
    "Images and shapes": {
      "zh": "图片和形状",
      "tips": ""
    },
    "Graphical elements, such as images and shapes, can add a level of visual enhancement for your app. These can vary from product images for a shopping app, achievements for a game, or a dynamic background pattern you create by layering and aligning various shapes.": {
      "zh": "像是图片和形状这样的图形元素，可以为你的 app 提升视觉效果。这些可以是某个购物 app 的产品图片、游戏中的成就、或通过叠加和对齐各种形状而创建的动态背景图案。",
      "tips": ""
    },
    "Images": {
      "zh": "图片",
      "tips": ""
    },
    "Display photos and other rich graphics in an Image. By default, an Image displays at the asset’s original size. You can add modifiers like resizable(capInsets:resizingMode:) and scaledToFit() or scaledToFill() to scale it to the available space.": {
      "zh": "你可以使用 Image 来显示照片和其他丰富的图形内容。默认情况下，Image 会显示资源的原始尺寸。 你可以添加像是 resizable(capInsets:resizingMode:)、scaledToFit()或scaledToFill() 这样的修饰符，将其缩放到适合的尺寸。",
      "tips": ""
    },
    "If you’re accessing an image asset from a server, use an AsyncImage to handle the download while keeping your app responsive.": {
      "zh": "如果你要访问服务器上的图片资源，那么为了保持 app 的响应性，请使用 AsyncImage 来处理下载操作。",
      "tips": ""
    },
    "For more information about working with images, see Fitting images into available space.": {
      "zh": "有关使用图像的更多信息，请参阅 \"Fitting images into available space\"。",
      "tips": ""
    },
    "Shapes": {
      "zh": "形状",
      "tips": ""
    },
    "SwiftUI provides several common shapes, and modifiers to change their size, color, or other aspects of their appearance. Use a single shape or a composition of multiple shapes to create a background, border, or other visual element. You can define a shape’s size with a modifier like frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:), or allow it to fill all available space.": {
      "zh": "SwiftUI 提供了几种常见的形状，并提供修改器来改变大小、颜色或外观的其他方面。可以使用单个形状或组合多个形状，来创建背景、边框或其他视觉元素。 你可以使用 frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:) 等修饰器来定义形状的大小，或允许它填充所有可用空间。",
      "tips": ""
    },
    "The following example shows three different shapes. The foregroundColor(_:) on each shape customizes that shape’s fill color. The RoundedRectangle includes values for the cornerRadius and style parameters to define the rounded corners. The HStack provides some default spacing between each shape and, to give each shape a square space to fill, the aspectRatio(_:contentMode:) modifier makes the HStack three times as wide as it is tall.": {
      "zh": "以下示例展示了三种不同的形状。每个形状都用 foregroundColor(_:) 自定义了填充色。RoundedRectangle 为了定义圆角，在初始化方法中指定了 cornerRadius 和 style 参数。 HStack 为每个形状之间提供了默认的间距，并且为了每个形状的填充区域都是正方形，使用了 aspectRatio(:contentMode:) 修饰符使得宽度是高度的三倍。",
      "tips": ""
    },
    "For an example of the rich possibilities of composing shapes, see Drawing Paths and Shapes.": {
      "zh": "有丰富的可能性来组合形状，要了解其有关示例的话，请参阅 \"Drawing Paths and Shapes\"。",
      "tips": ""
    }
  },
  "swiftui-concepts/organizing-and-aligning-content-with-stacks": {
    "Organizing and aligning content with stacks": {
      "zh": "使用各种 Stack 视图来组织和对齐内容",
      "tips": ""
    },
    "Create dynamic alignments that adapt to data and environment changes using stacks.": {
      "zh": "使用 Stack 视图创建能够适应数据和环境变化的动态对齐方式。",
      "tips": ""
    },
    "When you have information to communicate that draws from a changeable data source that includes text and images, it’s important to align the content in a way that can adapt. This tutorial walks through using stacks to align content in rows and columns. It also uses stacks to create graphic elements that help organize information.": {
      "zh": "当你需要传达信息，而这个信息是从一个包含文本和图片的可变数据源中获取时，将这些内容以自适应的方式对齐非常重要。 本教程将会介绍如何使用 Stack 来将内容按行和列进行对齐。同时它还被用来创建图形元素，以帮助组织信息。",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "要实践这段代码的话，请下载项目文件并在 Xcode 中打开示例。",
      "tips": ""
    },
    "Manage related data with a view model": {
      "zh": "使用一个 view model 管理相关数据",
      "tips": ""
    },
    "The first step in defining a view is to identify the data that the view displays. This view layout displays the details of an upcoming event, including the event’s name, date, and location. It also includes an icon indicating the type of event.": {
      "zh": "定义视图的第一步是确定要显示哪些数据。本例子的视图布局显示了即将举行活动的详细信息，包括活动的名称、日期和地点。它还包括一个标明活动类型的图标。",
      "tips": ""
    },
    "To organize that related data into a view model, this sample defines a custom structure.": {
      "zh": "为了将相关数据组织成一个 view model，这个示例定义了一个自定义结构。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "This Event struct defines all the data for the event. The date is a Date value rather than a formatted String so the view can specify the date format. The symbol property is the name of an SF Symbol for the EventTile to display.": {
      "zh": "这个 Event 结构定义了活动所有所需数据。date 属性的类型是 Date，而不是一个被格式化的字符串，这样视图就可以自己指定需要显示的日期格式。 symbol 属性是一个 SF Symbol 符号的名称，用来在 EventTile 视图中显示。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "The EventTile gets all the data for a specific instance from the Event structure in the tile’s event property.": {
      "zh": "EventTile 可以从类型是 Event 的 event 属性中获取一个指定事件的所有数据。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "Define a view with nested stacks": {
      "zh": "定义一个带有嵌套 Stack 的视图",
      "tips": ""
    },
    "After you define a data model, you can create views to display that data, and organize those views with stacks and alignment.": {
      "zh": "在定义了数据模型之后，可以创建各种视图来显示这些数据，更可以配合着 alignment 参数使用各种 Stack 来组织这些视图。",
      "tips": ""
    },
    "A VStack arranges the text in a column, and an HStack aligns the icon with the title text.": {
      "zh": "VStack 将文本按列排列，而 HStack 将图标与标题文本水平对齐。",
      "tips": ""
    },
    "The leading alignment on the VStack overrides the stack’s default center alignment.": {
      "zh": "VStack 的默认对齐方式是 center，这里用 leading 覆盖了它。",
      "tips": ""
    },
    "The Text initializer init(_:format:) formats a date.": {
      "zh": "Text 的初始化方法 init(_:format:) 可以格式化一个日期。",
      "tips": ""
    },
    "This initializer automatically accounts for environment-specific conditions, like the current calendar and locale.": {
      "zh": "该初始化方法会自动处理特定的环境条件，例如当前的日历和语言环境。",
      "tips": ""
    },
    "The title font makes the title text and the gift image more prominent than any content in the default body font.": {
      "zh": "title 字体使得标题文本和礼物图片比使用默认 body 字体的其他内容要更加显眼。",
      "tips": ""
    },
    "The precise font size and weight depend on the environment, including the user’s current Dynamic Type settings.": {
      "zh": "而字体确切的大小和字重则取决于具体的环境，包括用户当前动态类型的设置。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实践",
      "tips": ""
    },
    "Customize this symbol with the techniques in Configuring and displaying symbol images in your UI.": {
      "zh": "使用《Configuring and displaying symbol images in your UI》中介绍的技巧来自定义此符号。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "The firstTextBaseline alignment in the HStack aligns the gift image with the title text.": {
      "zh": "在 HStack 中，使用 firstTextBaseline 对齐方式可以将礼物图片与标题文本对齐。",
      "tips": ""
    },
    "Note": {
      "zh": "注释",
      "tips": ""
    },
    "If you’re arranging text and a symbol that only need to align with each other, it’s better to use a Label. Label aligns its icon to the first baseline of its title by default, and adapts to the context in which it appears.": {
      "zh": "如果你要排列的文本和符号，它们只需要相互对齐，那么最好使用 Label。 Label 默认将其图标与标题的第一基线对齐，并根据出现的上下文进行适应。",
      "tips": ""
    },
    "Add a background with layered shapes": {
      "zh": "添加一个具有多层形状的背景",
      "tips": ""
    },
    "To indicate that all of this information represents a single event, a background(alignment:content:) modifier contains a ZStack of Shape views.": {
      "zh": "为了表明所有这些信息都代表同一个事件，可以使用 background(alignment:content:) 修饰符来添加一个包含多个形状视图的 ZStack 作为背景。",
      "tips": ""
    },
    "This defines a background that adapts to the size of the information the main view displays.": {
      "zh": "这样定义的背景会自适应主视图显示的信息大小。",
      "tips": ""
    },
    "To make the background bigger than the HStack that encloses all the content, this padding(_:_:) modifier adds some space on all four edges of the view.": {
      "zh": "为了使背景比包含了所有内容的 HStack 更大，这个 padding(::) 修饰符的作用是在视图的四个边缘再添加一些空间。",
      "tips": ""
    },
    "This second use of the same padding(_:_:) modifier on the main content adds space for the stripe at the top of the view, in addition to the space defined by the previous padding(_:_:) modifier.": {
      "zh": "除了前一个 padding(::) 修饰符添加的空间之外，这里对主内容又使用了一次 padding(_:_:) 修饰符，这次是在顶部添加了显示条纹所需要的空间。",
      "tips": ""
    },
    "A background(alignment:content:) modifier bases its size on the size of the view it modifies, and puts its contents behind that view.": {
      "zh": "background(alignment:content:) 修饰符所产生的内容大小是基于所修改的视图大小，并将其内容放置在该视图的后面。",
      "tips": ""
    },
    "This top-aligned ZStack layers the brighter stripe Rectangle over the Rectangle that fills the background of the EventTile.": {
      "zh": "这个以顶部对齐的 ZStack，将颜色较亮的条纹矩形，放在了那个作为 EventTile 背景而被填充的矩形上面。",
      "tips": ""
    },
    "The stack’s alignment puts the stripe at the top of the EventTile.": {
      "zh": "这个 stack 的对齐方式将条纹放置在了 EventTile 的顶部。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "This frame(width:height:alignment:) modifier specifies the height of the stripe, leaving its width dependent on its containing view.": {
      "zh": "frame(width:height:alignment:) 修饰符指定了条纹的高度，并让其宽度依赖于父视图。",
      "tips": ""
    },
    "Specifying a frame on a decorative Shape like this stripe is a common pattern.": {
      "zh": "对于像是这种条纹一样的装饰性形状，在其上设置 frame 属性是一种常见的模式。",
      "tips": ""
    },
    "Specifying frames on text and controls may interfere with the sizing behavior and usability of those views. To learn best practices for adjusting the size of various views, see Maintaining the adaptable sizes of built-in views.": {
      "zh": "在文本和控件上设置 frame 属性可能会妨碍这些视图在调整尺寸时的行为和可用性。 要了解有关调整各种视图大小的最佳实践，请参阅《Maintaining the adaptable sizes of built-in views》。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "Step 7": {
      "zh": "第七步",
      "tips": ""
    },
    "Clipping the final view with clipShape(_:style:) and the RoundedRectangle shape applies the rounded corners only to the outermost edges, rather than rounding the corners of each view.": {
      "zh": "对最终生成的视图使用 clipShape(_:style:) 修饰符，并设置 RoundedRectangle 形状进行剪裁，会让圆角仅应用于最外层，而不是每个视图都会生成圆角。",
      "tips": ""
    },
    "This avoids rounding the bottom corners of the stripe Rectangle.": {
      "zh": "这样的话，条纹矩形底部的两个角就不会是圆角了。",
      "tips": ""
    },
    "Section 1": {
      "zh": "第一节",
      "tips": ""
    },
    "Three different parts of the EventTile view need to use the height of the top stripe, so it’s also a property outside of the body.": {
      "zh": "EventTile 视图的三个不同部分都需要使用到顶部条纹的高度，因此也把这个高度定义成一个实例属性。",
      "tips": ""
    },
    "This is the only constant that specifies a dimension in this layout. All the other dimensions of this view depend on the data in the Event and semantic values in modifiers, such as font(_:).": {
      "zh": "这是此布局中唯一一个关于尺寸的常量。此视图所有其他和尺寸有关的设置都取决于 Event 中的数据和修饰符中的值，例如font(_: )。",
      "tips": ""
    },
    "Section 2": {
      "zh": "第二节",
      "tips": ""
    },
    "Section 3": {
      "zh": "第三节",
      "tips": ""
    },
    "Applying the teal foregroundColor(_:) to the stack specifies the color for both of the Rectangle views in the stack.": {
      "zh": "通过把 teal 传递给 foregroundColor(_:)，会把这个颜色一并作用于 stack 所包含的这两个矩形上。",
      "tips": ""
    }
  },
  "swiftui-concepts/scaling-views-to-complement-text": {
    "View layout": {
      "zh": "视图布局",
      "tips": ""
    },
    "Scaling views to complement text": {
      "zh": "将视图进行缩放以补足文本",
      "tips": ""
    },
    "Construct a layout that adapts to font styles, Dynamic Type, and varying string lengths.": {
      "zh": "为了适配字体样式、动态类型和不同长度的字符串而构建一个布局",
      "tips": ""
    },
    "When composing a view that includes text, it’s important to define other elements relative to that text, like a symbol or padding, so the view adapts to the text’s size.": {
      "zh": "当构建一个包含文本的视图时，相对文本本身来说，更重要的是定义其它像是符号或边距这样的元素，以便视图能够适配文本的大小。",
      "tips": ""
    },
    "The symbol and padding can adapt as the text content changes for localizations, Dynamic Type sizes, or to display a different phrase.": {
      "zh": "当文本内容因为本地化、动态类型大小或显示了一段不同短语而发生变化时，符号和边距可以进行适应调整。",
      "tips": ""
    },
    "Section 1": {
      "zh": "第一节",
      "tips": ""
    },
    "Associate content with the text": {
      "zh": "将内容与文本关联起来",
      "tips": ""
    },
    "This example coordinates a name and a symbol to represent a single item with a Label. It also defines a Capsule in a background(alignment:content:) modifier, to maintain a consistent margin around the Label.": {
      "zh": "以下示例将一个标题和符号合并起来用一个 Label 表示成单个对象。它还在调用 background(alignment:content:) 修饰符的地方传入了一个 Capsule 形状，，以使标签周围的边距保持一致。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第一步",
      "tips": ""
    },
    "To make KeywordBubble reusable, the label’s text and symbol name are properties of the view. When another view uses a KeywordBubble, that other view specifies the text and symbol to display.": {
      "zh": "为使 KeywordBubble 可重用，把标签的文本和符号名称都声明成该视图的属性。当另一个视图要使用 KeywordBubble 时，该视图可以指定要显示的文本和符号。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第二步",
      "tips": ""
    },
    "Label is a built-in view that arranges the text and the symbol, the main content of this view. Label adjusts the symbol’s size and aligns the two pieces of content, so you don’t have to manually align the Text with an Image.": {
      "zh": "Label 是一个用于排列文本和符号的内置视图，这两个是其主要内容。Label 会自动调整符号的大小并对齐这两块内容，因此你无需手动将 Text 与一个 Image 对齐。",
      "tips": ""
    },
    "The name parameter retrieves a system image to display. To look up the names of available system images, download the SF Symbols app.": {
      "zh": "symbol 参数用来获取一个要显示的系统图片。要查找可用的系统图片名称，你可以下载 SF Symbols 这个 app。",
      "tips": ""
    },
    "Step 3": {
      "zh": "第三步",
      "tips": ""
    },
    "A Label applies the same font to both the text and image. An image that displays an SF Symbol uses font information to determine its size and position.": {
      "zh": "Label 会对文本和图片应用相同的字体。一个显示 SF Symbol 符号的图片使用字体信息来确定其大小和位置。",
      "tips": ""
    },
    "Experiment": {
      "zh": "实践",
      "tips": ""
    },
    "Try some other Font.TextStyle values, like Font.TextStyle.largeTitle or Font.TextStyle.caption to see how the sizes of the word and the leaf symbol change.": {
      "zh": "让我们尝试一些其他的 Font.TextStyle 值，如 Font.TextStyle.largeTitle 或 Font.TextStyle.caption，来看看标题和叶子符号的大小如何变化。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第四步",
      "tips": ""
    },
    "Using the padding(_:_:) modifier without any arguments creates a view that adds a default amount of space on all four edges of the view that it modifies.": {
      "zh": "在不提供参数的情况下，使用 padding(_:_:) 修饰符会给所创建视图的四个边缘上添加默认的间距空间。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第五步",
      "tips": ""
    },
    "The Capsule shape provides a rounded rectangle that expands to fill its container. The fill(_:style:) modifier specifies the color of the capsule, and opacity(_:) gives the capsule a bit of transparency.": {
      "zh": "Capsule 形状提供了一个圆角矩形，它会扩展并填充其容器。fill(_:style:) 修饰符用于指定其填充色，而 opacity(_:) 则给它添加了一点透明度。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第六步",
      "tips": ""
    },
    "To specify that the capsule belongs behind the text and symbol, the code defines the capsule inside a background(alignment:content:) modifier.": {
      "zh": "为了把这个形状放到文本和符号的下面，把定义它的代码放到 background(alignment:content:) 修饰符的 content 参数中。",
      "tips": ""
    },
    "The capsule’s size includes the padding around the Label because the background modifier is after the padding modifier.": {
      "zh": "由于 background 修饰符位于 padding 修饰符之后，所以胶囊的大小包含了标签四周的填充空间。",
      "tips": ""
    },
    "Section 2": {
      "zh": "第二节",
      "tips": ""
    },
    "Preview a custom view in Xcode": {
      "zh": "在 Xcode 中预览自定义视图",
      "tips": ""
    },
    "Xcode provides a Canvas where you can preview layouts as your code changes. To see a preview of a custom SwiftUI view, implement the PreviewProvider protocol. The Canvas can display several variants of your view so you can see how it adapts to different environments.": {
      "zh": "Xcode 提供了一个名为 Canvas 的窗口，它可以让你在代码更改时预览布局。要预览一个自定义 SwiftUI 视图的话，需为这个视图实现 PreviewProvider 协议。 Canvas 可以显示你这个视图的多个变体，以便可以看到它如何适应不同的环境。",
      "tips": ""
    },
    "You can see a live preview of a SwiftUI View in Xcode side by side with the code that defines it.": {
      "zh": "在 Xcode 中，你可以在定义一个 SwiftUI 视图的代码旁边，实时预览这个视图。",
      "tips": ""
    },
    "To preview a custom view, implement the PreviewProvider protocol by defining a static previews property.": {
      "zh": "要预览自定义视图，需实现 PreviewProvider 协议，并定义一个名为 previews 的静态属性。",
      "tips": ""
    },
    "To verify whether your view works with a range of inputs, configure more than one preview, and define static data to display in each preview.": {
      "zh": "为了验证你的视图是否适用于各种输入，可以配置多个视图以供预览，并为每个视图定义要显示的静态数据。",
      "tips": ""
    },
    "The keywords array defines two String values of different lengths. The previews property defines both of these in a VStack to display how the KeywordBubble view adapts to the text length.": {
      "zh": "keywords 数组包含了两个不同长度的字符串。previews 属性则用这两个字符串生成了两个 KeywordBubble 视图，并把它们放到了一个 VStack 中，以展示 KeywordBubble 视图如何适应不同长度的文本。",
      "tips": ""
    },
    "This line defines the KeywordBubble view, and provides the text and image for it.": {
      "zh": "这行代码定义了 KeywordBubble 视图，并为其提供了文本和图片。",
      "tips": ""
    },
    "Try replacing leaf with the name of another SF Symbol. For more information about customizing the appearance of SF Symbols, see SF Symbols in the Human Interface Guidelines.": {
      "zh": "请尝试用另外一个 SF Symbol 符号的名字替换当前的 leaf。要了解更多关于自定义 SF Symbols 外观的信息，请参考人机界面指南中的 SF Symbols 部分。",
      "tips": ""
    },
    "To verify how your view looks with the full range of Dynamic Type text sizes, choose Variants > Dynamic Type Variants in the Xcode Canvas view.": {
      "zh": "要验证你的视图在所有动态类型文本大小下的外观，请在 Xcode 的 Canvas 窗口中选择 \"Variants > Dynamic Type Variants\"。",
      "tips": ""
    },
    "Section 3": {
      "zh": "第三节",
      "tips": ""
    },
    "Adjust dimensions with ScaledMetric": {
      "zh": "使用 ScaledMetric 调整尺寸",
      "tips": ""
    },
    "The default values for dimensions such as the padding on this view, or the width and height of a frame aren’t always going to work for your layout. In many cases, you can design a small set of values to use across a range of environments. But there are over one hundred combinations of Dynamic Type settings and Font.TextStyle options, so choosing a specific value for each isn’t really practical. When you need to provide a numeric value that adapts to the environment’s effective font size, use the ScaledMetric property wrapper.": {
      "zh": "对于像是视图上的填充、宽度和高度等这样维度的默认值，并不总是适用于你的布局。许多情况下，你可以设计一小组值，让其在各种环境中使用。 但是，动态类型的设置值和 Font.TextStyle 的选项之间有超过一百种组合，因此为每个组合选择特定的值并不实际。当你需要提供一个能根据环境的实际字体大小自适应的数值时，可以使用 ScaledMetric 属性包装器。",
      "tips": ""
    },
    "Look at the KeywordBubbleDefaultPadding preview for the AX 5 text size. With the default padding, the tip of the leaf symbol collides with the edge of the Capsule shape.": {
      "zh": "查看 KeywordBubbleDefaultPadding 在 AX 5 文本大小下的预览。因为使用默认值来填充四周，所以叶子符号的尖尖头已经与 Capsule 形状的边缘产生碰撞。",
      "tips": ""
    },
    "To keep the content inside the bubble at large text sizes without adding too much padding for small text sizes, define a custom padding metric that scales with the text size.": {
      "zh": "为了让内容在大文字尺寸下保持在形状内部，而在小文字尺寸下又不必增加过多的填充值，可以定义一个随文字尺寸缩放的自定义填充值。",
      "tips": ""
    },
    "This paddingWidth variable provides a value of 14.5 for content in a DynamicTypeSize.large Dynamic Type environment. With the ScaledMetric property wrapper, the value is proportionally larger or smaller, according to the current value of dynamicTypeSize.": {
      "zh": "为内容在 DynamicTypeSize.large 动态类型环境下，定义一个名为 paddingWidth 的变量并把其值设置成 14.5。使用 ScaledMetric 属性包装器，该值将根据 dynamicTypeSize 的当前值按比例变大或变小。",
      "tips": ""
    },
    "For more information about using ScaledMetric to scale dimensions in proportion to text, see Applying custom fonts to text.": {
      "zh": "有关使用 ScaledMetric 按比例缩放尺寸以适应文本的更多信息，请参阅 \"Applying custom fonts to text\"。",
      "tips": ""
    },
    "The Label uses the Font.TextStyle.title style to define the text size.": {
      "zh": "使用 Font.TextStyle.title 样式来定义文本的大小",
      "tips": ""
    },
    "Specifying Font.TextStyle.title for the textStyle parameter indicates that this metric scales with, or is relative to, the title style.": {
      "zh": "设置 Font.TextStyle.title 作为 textStyle 参数的值，表示此度量按照 title 样式进行缩放，或者说以 title 样式为基础进行计算。",
      "tips": ""
    },
    "The padding(_:) modifier adds a specific amount of space, in points, around the label on all four edges. Because paddingWidth is a ScaledMetric, padding(_:) adds more space when the Label uses a larger text size.": {
      "zh": "padding(_:) 修饰符用指定值（以点为单位）设置标签四周的填充空间。由于 paddingWidth 是一个 ScaledMetric，当标签使用更大的文本大小时，padding(_:) 会被设置更大的填充值。",
      "tips": ""
    },
    "With the ScaledMetric variable padding, all the Dynamic Type variants now have padding between the leaf symbol and the edge of the Capsule shape in the background.": {
      "zh": "因为使用了 ScaledMetric 变量来设置边距，所以现在在所有的动态类型变体中，叶子符号和形状的边缘之间总会有填充空间。",
      "tips": ""
    }
  },
  "swiftui-concepts/specifying-the-view-hierarchy-of-an-app-using-a-scene": {
    "Note": {
      "zh": "注释",
      "tips": ""
    },
    "To experiment with the code, download the project files and open the sample in Xcode.": {
      "zh": "下载项目文件并在 Xcode 中打开示例，以尝试代码。",
      "tips": ""
    },
    "Refactor the code to use custom scenes": {
      "zh": "重构代码以使用 custom scenes（自定义场景）",
      "tips": ""
    },
    "A scene contains the view hierarchy of your app.": {
      "zh": "scene（场景）包含了 app 的 view hierachy（视图树）。",
      "tips": ""
    },
    "Let’s look at the view hierarchy the sample defines for macOS.": {
      "zh": "让我们看看示例中为 macOS 定义的 view hierarchy（视图树）。",
      "tips": ""
    },
    "The iPhone version of the app displays a scene with a tabbed user interface, while the Mac version displays a scene with split view interface. The Mac app also displays the secondary scene Settings when you select the Preferences item under the app menu.": {
      "zh": "iPhone 版本的 app 显示了一个带有 tabbed user interface（选项卡式用户界面）的 scene（场景），而 Mac 版本显示了一个带有 split view interface（分割视图界面）的 scene（场景）。当你在 Mac app 菜单下选择 Preferences（偏好设置）项时，还会显示 secondary scene（次要场景）Settings（设置）。",
      "tips": ""
    },
    "Step 5": {
      "zh": "第 5 步",
      "tips": ""
    },
    "To describe the scene that displays on iOS devices, the sample includes the custom scene MyScene, which is a structure that conforms to the Scene protocol.": {
      "zh": "为了描述在 iOS 设备上显示的 scene（场景），示例包含了一个自定义 scene（场景） MyScene，这个结构体遵循了 Scene protocol（场景协议）。",
      "tips": ""
    },
    "To compile the first view hierarchy for iOS, the sample uses a platform conditional compilation block that tells the Swift compiler to compile the code only when the target platform is iOS.": {
      "zh": "为了在 iOS 上编译第一个 view hierarchy（视图树），示例内使用了 platform conditional compilation block（平台条件编译块），它告诉 Swift 编译器只在目标平台为 iOS 时才编译这部分代码。",
      "tips": ""
    },
    "Unlike the previous hierarchy, the root node of this hierarchy is the custom view, AlternativeContentView.": {
      "zh": "不像之前的 hierarchy（视图树），这个 hierarchy（视图树）的根节点是一个自定义视图 AlternativeContentView。",
      "tips": ""
    },
    "Specifying the view hierarchy of an app using a scene": {
      "zh": "使用 scene（场景）指定 app 的 view hierarchy（视图树）",
      "tips": ""
    },
    "However, after refactoring the code, the MyApp structure is easier to read and maintain.": {
      "zh": "然而，在重构代码之后，MyApp 结构体更易读，更易维护。",
      "tips": ""
    },
    "Each of these views apply the tabItem(_:) modifier, which tells the TabView the image and text to display in each tab.": {
      "zh": "这些视图都应用了 tabItem(_:)（选项卡项）修饰符，它告诉 TabView 在每个选项卡中显示的图像和文本。",
      "tips": ""
    },
    "The source code in the MyApp structure does the job of defining view hierarchies different versions of the sample app, but the code is lengthy making it difficult to maintain. One improvement that can help make the code more readable and easier to maintain is to use custom scenes. A custom scene is one that you compose from other scenes.": {
      "zh": "MyApp 结构体内的代码起到了定义不同示例 app 版本的 view hierarchies（视图树）的作用，但是代码冗长，难以维护。我们可以使用 custom scenes（自定义场景）使代码更易读，更易维护。custom scene（自定义场景）是由其他场景组成的场景。",
      "tips": ""
    },
    "Keep your app’s view layouts fluid on any device for each type of content your app displays.": {
      "zh": "使你的 app 的视图布局，内容，在任何设备上都能流畅显示。",
      "tips": ""
    },
    "Step 6": {
      "zh": "第 6 步",
      "tips": ""
    },
    "The root node of the view hierarchy is TabView, a container view that provides tabs that people can use to switch between different subviews.": {
      "zh": "view hierarchy（视图树）的根结点是 TabView，它是一个视图容器，提供了 tabs（选项卡），用户可以使用它们在不同的子视图之间切换。",
      "tips": ""
    },
    "Create custom scenes": {
      "zh": "创建自定义场景",
      "tips": ""
    },
    "Experiment": {
      "zh": "实践",
      "tips": ""
    },
    "Here’s the view hierarchy discussed in the previous section.": {
      "zh": "这是上一节中讨论的 view hierarchy（视图树）。",
      "tips": ""
    },
    "A structure that conforms to Scene must implement the computed property body, just like structures that conform to the App protocol do.": {
      "zh": "遵循 Scene protocol（场景协议）的结构体必须实现 computed property body（计算属性 - 主体），如同符合 App protocol（应用程序协议）的结构体。",
      "tips": ""
    },
    "Define another view hierarchy": {
      "zh": "定义另一个 view hierarchy（视图树）",
      "tips": ""
    },
    "The code for this scene is the same code from the MyApp structure, discussed in the Define another view hierarchy section.": {
      "zh": "在这个 scene（场景）内的代码和在 Define another view hierarchy（定义另一个视图树）章节中讨论的 MyApp 结构体内的代码是一样的。",
      "tips": ""
    },
    "Here’s how the scenes appear when you run the app on iPhone and Mac.": {
      "zh": "以下是在 iPhone 和 Mac 上运行 app 时的场景。",
      "tips": ""
    },
    "The computed body property can return one or more primary and secondary scenes.": {
      "zh": "computed body property（计算的 body 属性）可以返回一个或多个主要场景和次要场景。",
      "tips": ""
    },
    "The MyApp structure implements the computed property body, which returns a scene.": {
      "zh": "MyApp struct（结构体）实现了 body computed property（计算属性），该属性返回一个 scene（场景）。",
      "tips": ""
    },
    "A conditional compilation block tells the Swift compiler to conditionally compile the code block depending on the value of one or more compilation conditions. For more information about conditional compilation blocks, see Compiler Control Statements": {
      "zh": "conditional compilation block（条件编译块）告诉 Swift 编译器根据一个或多个编译条件来编译代码块。有关条件编译块的更多信息，请参阅 Compiler Control Statements（编译器控制语句）。",
      "tips": ""
    },
    "For macOS, the sample includes another custom scene, MyAlternativeScene, which is another structure that conforms to Scene.": {
      "zh": "对于 macOS，该示例包含另一个自定义场景 - MyAlternativeScene，这是另一个遵循 Scene（场景协议）的结构体。",
      "tips": ""
    },
    "This approach can make the implementation of computed property body more difficult to maintain.": {
      "zh": "这种实现方法使计算属性 body 变得难以维护。",
      "tips": ""
    },
    "It too implements the computed body property.": {
      "zh": "他也实现了 computed body property（计算属性 - 主体）。",
      "tips": ""
    },
    "The sample defines the other view hierarchy in a WindowGroup scene.": {
      "zh": "示例定义了 WindowGroup scene（窗口组场景）中的其他 view hierarchy（视图树）。",
      "tips": ""
    },
    "Step 8": {
      "zh": "第 8 步",
      "tips": ""
    },
    "Step 3": {
      "zh": "第 3 步",
      "tips": ""
    },
    "This sample uses a journaling app as an example. To describe the view hierarchy of the app’s user interface, the MyApp structure declares a scene and its contents. Let’s take a look at the structure and its scene.": {
      "zh": "此示例以一个日记 app 作为例子。为了描述 app 用户界面的 view hierarchy（视图树），MyApp struct（结构体）声明了一个 scene（场景）及其内容。让我们看看这个 struct 和它的 scene。",
      "tips": ""
    },
    "The Settings scene is only available in macOS.": {
      "zh": "设置场景（Settings scene）仅在 macOS 中可用。",
      "tips": ""
    },
    "Step 4": {
      "zh": "第 4 步",
      "tips": ""
    },
    "The TabView contains two subviews, ContentView and SettingsView.": {
      "zh": "TabView（标签页视图）包含了两个子视图，ContentView（内容视图）和 SettingsView（设置视图）。",
      "tips": ""
    },
    "Maintaining the adaptable sizes of built-in views": {
      "zh": "维护自适应尺寸的视图",
      "tips": ""
    },
    "The sample defines the view hierarchy using a WindowGroup scene that contains a TabView. In turn, the TabView contains two subviews: ContentView and SettingsView.": {
      "zh": "示例内利用 WindowGroup scene 定义了 view hierarchy（视图树），其中包含了 TabView（标签页视图）。TabView 内也包含了两个子视图，ContentView（内容视图） 和 SettingsView（设置视图）。",
      "tips": ""
    },
    "SwiftUI provides building blocks that help you create the user interface of your app. One of those building blocks is Scene, which contains a view hierarchy that defines the user interface of your app. You can specify your app’s view hierarchy in a scene that SwiftUI provides, or you can create a custom scene. This tutorial walks you through both approaches.": {
      "zh": "SwiftUI 提供了 building blocks（构建块）来帮助你创建 app 的用户界面。其中之一就是 Scene，它包含了定义你 app 用户界面的 view hierachy（视图树）。你可以在 SwiftUI 提供的 scene（场景）指定你 app 的 view hierachy，也可以创建一个自定义的 scene。本教程将引导你完成这两种方法。",
      "tips": ""
    },
    "The root node of the previous view hierarchy is the container view, TabView.": {
      "zh": "前面提到的 view hierarchy（视图树）的根节点是一个叫 TabView（标签页视图）的容器视图。",
      "tips": ""
    },
    "Both are custom views. ContentView displays a list of journal entries, and SettingsView displays other views that let people edit the settings for the app, such as the account associated with the journal.": {
      "zh": "两个视图都是自定义视图。ContentView（内容视图）展示了日记 app 记录的列表，同时 SettingsView（设置视图）展示了能够让用户编辑 app 内设置的视图，如设置与日记关联的账户。",
      "tips": ""
    },
    "Add a scene to the app": {
      "zh": "在 app 内添加 scene（场景）。",
      "tips": ""
    },
    "The sample uses the secondary scene Settings to provide a Settings menu item that’s available in the app menu, which is a common feature of Mac apps.": {
      "zh": "示例中使用了 secondary scene（次要场景）的 Settings（设置），它提供了一个在 app 菜单中可用的 Settings menu（设置菜单项），这在 Mac app 中非常常见。",
      "tips": ""
    },
    "Step 1": {
      "zh": "第 1 步",
      "tips": ""
    },
    "In this sample, body returns the primary scene WindowGroup, which describes the view hierarchy of the sample’s main window.": {
      "zh": "在此示例中，body 返回了主场景 WindowGroup（窗口组），他描述了示例主窗口的 view hierarchy（视图树）。",
      "tips": ""
    },
    "The entry point and MyApp structure are responsible for the start up of the app. Each SwiftUI app has one and only one entry point and main app structure.": {
      "zh": "entry point（入口点）和 MyApp 结构体负责 app 的启动。每个 SwiftUI app 有且只有一个 entry point 和一个 main app struct（主 app 结构体）。",
      "tips": ""
    },
    "With two separate view hierarchies defined, the sample must specify which one to use based on the target platform.": {
      "zh": "在定义了两个单独的 view hierarchies（视图树）后，示例 app 内的代码必须根据不同的平台来指定所使用的内容。",
      "tips": ""
    },
    "Before refactoring the MyApp structure to use the custom scenes, the code is fairly long and complex.": {
      "zh": "在重构 MyApp 结构体以使用自定义 scenes（场景）之前，我们先看看代码，它似乎有点冗长且复杂。",
      "tips": ""
    },
    "The computed body property includes the secondary scene Settings. This scene is only available in macOS, so it’s placed inside a platform conditional compilation block.": {
      "zh": "computed body property（计算主体属性）包含了 secondary scene（次要场景） Settings（设置）。此 scene（场景）仅在 macOS 中可用，所以它被放置在了一个 platform conditional compilation block（平台条件编译块）内。",
      "tips": ""
    },
    "The sample defines an entry point using the @main attribute and the structure MyApp, which conforms to the App protocol.": {
      "zh": "该示例使用 @main 属性定义了 app entry point（app 的入口），以及一个遵循 App protocol（App 协议）的结构体 MyApp。",
      "tips": ""
    },
    "The WindowGroup scene is one of the more commonly used scenes. It provides platform-specific behaviors for your app, such as supporting multiple windows in macOS and iPadOS. For more information about this scene as well as other scenes that SwiftUI provides, see Scenes.": {
      "zh": "WindowGroup scene（窗口组场景）是最常用的场景之一。它为你的 app 在不同平台做了针对性的优化，例如在 macOS 和 iPadOS 上支持多窗口。更多有关此 scene（场景）或其他 SwfitUI 提供的场景，请参阅 Scenes（场景）。",
      "tips": ""
    },
    "Step 2": {
      "zh": "第 2 步",
      "tips": ""
    },
    "The Settings scene contains the custom view, SettingView, which displays app settings in a window that the Settings menu item provides.": {
      "zh": "Settings scene（设置场景）包含了一个自定义视图 - SettingsView（设置视图），它在 Settings menu item（设置菜单项）所提供的窗口中显示 app 的设置。",
      "tips": ""
    },
    "Change the code so that the sample uses MyScene in macOS and MyAlternativeScene in iOS.": {
      "zh": "尝试更改代码，在 macOS 中使用 MyScene，而在 iOS 中使用 MyAlternativeScene。",
      "tips": ""
    },
    "The implementation of body uses the same code from the MyApp structure, covered in the Add a scene to the app section of this tutorial.": {
      "zh": "body（主体）内的实现使用了与 MyApp 结构体相同的代码，在本教程的 Add a scene to the app（在 app 中添加场景）章节中有所介绍。",
      "tips": ""
    },
    "The sample app runs on multiple devices including iPhone and Mac. But the view hierarchy described in the previous section doesn’t look quite right in macOS. So the sample declares another view hierarchy that takes advantage of features specific to the Mac.": {
      "zh": "示例 app 可以运行在多设备上，包括 iPhone 和 Mac。但是在之前章节的 view hierarchy（视图树）在 macOS 上看起来并不是非常的好。因此，在示例中声明了另一个 view hierarchy，以便能够较好的适配 Mac，并利用其中的特性。",
      "tips": ""
    },
    "With the MyScene and MyAlternativeScene in place, the final step is to refactor the code in the MyApp structure so that it uses the custom scenes.": {
      "zh": "在完成 MyScene 和 MyAlternativeScene 后，最后一步就是重构 MyApp 结构体内的代码，以使用自定义场景。",
      "tips": ""
    },
    "Step 7": {
      "zh": "第 7 步",
      "tips": ""
    },
    "The app uses a separate platform conditional to compile the scenes that the Mac app uses.": {
      "zh": "该 app 使用了一个单独的 platform conditional（平台条件编译）来编译 Mac app 所使用的 scenes（场景）。",
      "tips": ""
    },
    "When the sample app runs, it displays the view hierarchy described in the WindowGroup scene, which is a tab interface with two tabs: Journal and Settings.": {
      "zh": "当示例 app 运行时，他将显示 WindowGroup scene（窗口组场景）描述的 view hierarchy（视图树），这是一个带有日记和设置两个标签的标签页。",
      "tips": ""
    }
  },
  "visionos/adding-3d-content-to-your-app": {
    "Adding 3D content to your app": {
      "zh": "为 App 增添 3D 内容",
      "tips": ""
    },
    "Add depth and dimension to your visionOS app and discover how to incorporate your app’s content into a person’s surroundings.": {
      "zh": "在你的 visionOS App 中添加“深度”——这个第三个维度（ z 轴），以及了解如何将你的应用程序融入到用户的周围环境中。",
      "tips": "译者注： depth ，这里翻译成“深度”，即为空间深度，也叫纵深。是物体在空间距离下，产生的视觉焦点，并导致所有物体围绕这个焦点聚拢的聚焦方式。通俗讲就是人在一副画面中感觉到的强烈的远近对比。所以，用户通过纵深来营造画面的立体感。"
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "A device with a stereoscopic display lets people experience 3D content in a way that feels more real. Content appears to have real depth, and people can view it from different angles, making it seem like it’s there in front of them.": {
      "zh": "立体显示可以让人感受到更真实的 3D 内容。 3D 内容增添让人感觉更加真实的视觉深度，用户可以从不同角度观看，仿佛这些内容真的就在他们的面前。",
      "tips": ""
    },
    "When building an app for visionOS, think about ways you might add depth to your app’s interface. The system provides several ways to display 3D content, including in your existing windows, in a volume, and in an immersive space. Choose the options that work best for your app and the content you offer.": {
      "zh": "在构建 visionOS 应用程序，就要考虑在你的应用程序中添加深度（ z 轴）这个纬度。系统提供了多种方式展示 3D 内容，包括在已有的 2D 窗口( window )，立体窗口( volume )，或者虚拟空间( ImmersiveSpace )。 根据你 App 中内容选择最适合展示方式。",
      "tips": ""
    },
    "Add depth to traditional 2D windows": {
      "zh": "在二维平面窗口添加深度（ z 轴）维度",
      "tips": ""
    },
    "Windows are an important part of your app’s interface. With visionOS, apps automatically get materials with the visionOS look and feel, fully resizable windows with spacing tuned for eyes and hands input, and access to highlighting adjustments for your custom controls.": {
      "zh": "二维平面窗口( window )是应用程序界面的重要组成部分。 visionOS 系统下的应用软件界面可自动获得 visionOS 系统风格元素，并且可紧紧跟随用户手和眼的移动，灵活地调整窗口的大小，同时突出显示你的自定义控件。",
      "tips": ""
    },
    "Incorporate depth effects into your custom views as needed, and use 3D layout options to arrange views in your windows.": {
      "zh": "根据需求在你的自定义视图中添加 深度效应，并使用下面这些 3D 布局选项在你的二维平面窗口( window )中摆设视图( view )。",
      "tips": ""
    },
    "Apply a shadow(color:radius:x:y:) or visualEffect(_:) modifier to the view.": {
      "zh": "使用 shadow(color:radius:x:y:) 或者 visualEffect(_:) 修改视图( view )显示外观，使其更具有深度效果。",
      "tips": ""
    },
    "Lift or highlight the view when someone looks at it using a hoverEffect(_:isEnabled:) modifier.": {
      "zh": "使用 hoverEffect(_:isEnabled:) 方法，使视图( view )能够以突出移动或高亮的方式响应用户视线关注。",
      "tips": ""
    },
    "Lay out views using a ZStack.": {
      "zh": "使用 ZStack 在 Z 轴(深度维度)布局视图( view )。",
      "tips": ""
    },
    "Animate view-related changes with transform3DEffect(_:).": {
      "zh": "使用 transform3DEffect(_:) ，为视图( view )变化添加 3D 动画效果。",
      "tips": ""
    },
    "Rotate the view using a rotation3DEffect(_:axis:anchor:anchorZ:perspective:) modifier.": {
      "zh": "使用 rotation3DEffect(_:axis:anchor:anchorZ:perspective:) 来旋转视图。",
      "tips": ""
    },
    "In addition to giving 2D views more depth, you can also add static 3D models to your 2D windows. The Model3D view loads a USDZ file or other asset type and displays it at its intrinsic size in your window. Use this in places where you already have the model data in your app, or can download it from the network. For example, a shopping app might use this type of view to display a 3D version of a product.": {
      "zh": "另外，你也可以在二维平面窗口( window )添加静态 3D 模型，来为 2D 视图( view )增加视觉深度。 Model3D 视图类型可以加载 USDZ 文件，或者以 Asset 方式加载，并在窗口( window )以文件的固有尺寸展示。通过这种方式展示 3D 内容，前提是你已经有了可展示的模型数据，模型数据可以是放在 App 本地，或者通过网络加载。例如，电商类的 App 可以使用 Model3D 类型视图来展示商品的 3D 效果。",
      "tips": ""
    },
    "Display dynamic 3D scenes using RealityKit": {
      "zh": "使用 RealityKit 展示动态的 3D 场景",
      "tips": ""
    },
    "RealityKit is Apple’s technology for building 3D models and scenes that you update dynamically onscreen. In visionOS, use RealityKit and SwiftUI together to seamlessly couple your app’s 2D and 3D content. Load existing USDZ assets or create scenes in Reality Composer Pro that incorporate animation, physics, lighting, sounds, and custom behaviors for your content. To use a Reality Composer Pro project in your app, add the Swift package to your Xcode project and import its module in your Swift file. For for information, see Managing files and folders in your Xcode project.": {
      "zh": "RealityKit 是苹果为构建 3D 模型，以及在屏幕中动态更新场景，而开发的框架。在 visionOS 系统中，可以同时使用 RealityKit 和`SwiftUI 将 App 中 2D 和 3D 内容丝滑的融合起来。加载现有的 USDZ Assets，或者使用 Reality Composer Pro，为你的 App 内容，创建一个富有动画，符合物理特性，有光影效果，音效，和自定义行为的场景。以 Swift Package 方式将 Reality Composer Pro project 添加关联到你的 Xcode 项目中，然后在你的 Xcode 项目 Swift 代码中，使用 import ModuleName 方式引用。(和使用和苹果其他 Framework 一样，用 ModuleName 来引用)。更多关于怎样管理项目文件，请参照 Managing files and folders in your Xcode project 。",
      "tips": "译者推荐：更多关于 Creating 3D Content with Reality Composer 文档 和  Meet Reality Composer Pro 视频。"
    },
    "When you’re ready to display 3D content in your interface, use a RealityView. This SwiftUI view serves as a container for your RealityKit content, and lets you update that content using familiar SwiftUI techniques.": {
      "zh": "使用 RealityView 在用户界面中展示 3D 内容。这个 SwiftUI 就像是一个盛放 RealityKit 内容(就是 3D 内容)的容器，接下来你可以使用熟悉的 SwiftUI 技术更新 3D 内容。",
      "tips": ""
    },
    "The following example shows a view that uses a RealityView to display a 3D sphere. The code in the view’s closure creates a RealityKit entity for the sphere, applies a texture to the surface of the sphere, and adds the sphere to the view’s content.": {
      "zh": "下面的示例代码展示了在视图( view )中使用 RealityView 展示一个 3D 球体。在视图( view )的闭包中创建一个表面光滑的 RealityKit 球体，然后把球体添加到视图( view )中。",
      "tips": ""
    },
    "When SwiftUI displays your RealityView, it executes your code once to create the entities and other content. Because creating entities is relatively expensive, the view runs your creation code only once. When you want to update the state of your entities, change the state of your view and use an update closure to apply those changes to your content. The following example uses an update closure to change the size of the sphere when the value in the scale property changes:": {
      "zh": "当 SwiftUI 要显示 RealityView 时，它只会执行一次闭包的代码来创建实体和其他内容。因为 3D 实体创建相当的消耗性能，所以视图( view )只会执行一次创建代码。当需要更新 3D 实体显示状态时，那么就改变相应视图( view )的显示状态，并通过更新闭包来实现显示内容的变化。下面的示例代码，在更新闭包中，通过改变模型的 transform.scale 属性来改变球体的大小：",
      "tips": ""
    },
    "For information about how to create content using RealityKit, see RealityKit.": {
      "zh": "更多关于如何使用 RealityKit 创建 3D 内容的，请参照 RealityKit 。",
      "tips": ""
    },
    "Respond to interactions with RealityKit content": {
      "zh": "如何响应与 RealityKit 内容的交互",
      "tips": ""
    },
    "To handle interactions with the entities of your RealityKit scenes:": {
      "zh": "处理与 RealityKit 场景里实体的交互：",
      "tips": ""
    },
    "Attach a gesture recognizer to your RealityView and add the targetedToAnyEntity() modifier to it.": {
      "zh": "创建手势识别器 TapGesture ，然后通过 targetedToAnyEntity() 修改手势识别器参数，并将手势识别器添加到 RealityView 上。",
      "tips": ""
    },
    "Attach an InputTargetComponent to the entity or one of its parent entities.": {
      "zh": "在实体或者父实体中添加 InputTargetComponent 实例。",
      "tips": ""
    },
    "Add collision shapes to the RealityKit entities that support interactions.": {
      "zh": "给 RealityKit 实体添加触摸形状，让它支持交互。",
      "tips": ""
    },
    "The targetedToAnyEntity() modifier provides a bridge between the gesture recognizer and your RealityKit content. For example, to recognize when someone drags an entity, specify a DragGesture and add the modifier to it. When the specified gesture occurs on an entity, SwiftUI executes the provided closure.": {
      "zh": "targetedToAnyEntity() 修改器是链接手势识别器和 RealityKit 内容的桥梁。例如，创建 DragGesture 手势，通过手势修饰符设置参数和响应闭包，然后把手势添加到实体上，这样实体就可以响应用户的拖拽。当实体有了手势识别器， SwiftUI 执行提供的响应闭包中的代码。",
      "tips": ""
    },
    "The following example adds a tap gesture recognizer to the sphere view from the previous example. The code also adds InputTargetComponent and CollisionComponent components to the shape to allow the interactions to occur. If you omit these components, the view doesn’t detect the interactions with your entity.": {
      "zh": "下面的示例代码是在前面的例子的基础上给 SphereView 添加手势识别器。同时也在模型中添加 InputTargetComponent 和相应触摸形状的 CollisionComponent ，这样实体便能够进行交互。如果不添加这些组件，视图( view )不会把交互事件分发到相应的实体上。",
      "tips": ""
    },
    "Display 3D content in a volume": {
      "zh": "在三维立体窗口( volume )中展示 3D 内容",
      "tips": ""
    },
    "A volume is a type of window that grows in three dimensions to match the size of the content it contains. Windows and volumes both accommodate 2D and 3D content, and are alike in many ways. However, windows clip 3D content that extends too far from the window’s surface, so volumes are the better choice for content that is primarily 3D.": {
      "zh": "三维立体窗口( volume )是一种有三个维度窗口(即 volumetric window)，它符合显示 3D 内容需求。二维平面窗口( window )和三维立体窗口( volume )均可容纳 2D 和 3D 内容，而且它们有许多相似之处。然而，二维平面窗口( window )会把超出显示区域太多的 3D 内容剪切掉，所以，对于以显示 3D 为主的内容，三维立体窗口( volume )是更好的选择。",
      "tips": ""
    },
    "To create a volume, add a WindowGroup scene to your app and set its style to volumetric. This style tells SwiftUI to create a window for 3D content. Include any 2D or 3D views you want in your volume. You can also add a RealityView to build your content using RealityKit. The following example creates a volume with a static 3D model of some balloons stored in the app’s bundle:": {
      "zh": "在App中添加 WindowGroup Scene，并将 windowStyle 设置为 volumetric ，这样就创建了一个三维立体窗口( volume )。这种 windowStyle 指定 SwiftUI 创建一个显示 3D 内容的 window 。三维立体窗口( volume )既可以包含 2D 视图，也可以包含 3D 视图。所以，你可以使用 RealityKit 创建 RealityView 实例，来构造 App 内容。下面的例子代码，使用应用包( App Bundle )中的 balloons 静态 3D 模型为内容创建一个三维立体窗口( volume )：",
      "tips": ""
    },
    "Windows and volumes are a convenient way to display bounded 2D and 3D content, but your app doesn’t control the placement of that content in the person’s surroundings. The system sets the initial position of each window and volume at display time. The system also adds a window bar to allow someone to reposition the window or resize it.": {
      "zh": "使用二维平面窗口( window )和三维立体窗口( volume )展示有限的 2D 和 3D 内容是一种很便捷的方式，但是同时，你就不能在控制你要显示的内容在用户周围环境中的位置。系统会在要显示二维平面窗口( window )和三维立体窗口( volume )的时候设置其初始位置。系统也会为其添加一个工具栏( window bar )，以便用户移动或者缩放窗口。",
      "tips": ""
    },
    "For more information about when to use volumes, see Human Interface Guidelines > Windows.": {
      "zh": "了解更多关于“什么情况下使用三维立体窗口( volume )”，参照 Human Interface Guidelines > Windows",
      "tips": ""
    },
    "Display 3D content in a person’s surroundings": {
      "zh": "在用户周围环境中的展示 3D 内容",
      "tips": ""
    },
    "When you need more control over the placement of your app’s content, add that content to an ImmersiveSpace. An immersive space offers an unbounded area for your content, and you control the size and placement of content within the space. After receiving permission from the user, you can also use ARKit with an immersive space to integrate content into their surroundings. For example, you can use ARKit scene reconstruction to obtain a mesh of furniture and nearby objects and have your content interact with that mesh.": {
      "zh": "当你需要定义 App 内容所要展示的位置，那么就使用 ImmersiveSpace 展示相应内容。沉浸式空间( immersive space )提供无限区域来展示你的 3D 内容，并且在这个空间里你可以控制 3D 内容的大小和位置。在获得用户许可后，你还可以将 ARKit 与沉浸式空间( immersive space )结合使用，将内容整合到用户周围的环境中。例如，你可以使用 ARKit 场景重建来获取家具和附近物体的三维网格结构，并让你的内容与该三维网格结构进行相互融合。",
      "tips": ""
    },
    "An ImmersiveSpace is a scene type that you create alongside your app’s other scenes. The following example shows an app that contains an immersive space and a window:": {
      "zh": "ImmersiveSpace 是一种特定类型的 Scene ，可以和 App 中其他的 Scene 一起创建。下面的例子展示了包含了沉浸式空间( immersive space )和普通窗口( window )的 App 的代码：",
      "tips": ""
    },
    "If you don’t add a style modifier to your ImmersiveSpace declaration, the system creates that space using the mixed style. This style displays your content together with the passthrough content that shows the person’s surroundings. Other styles let you hide passthrough to varying degrees. Use the immersionStyle(selection:in:) modifier to specify which styles your space supports. If you specify more than one style, you can toggle between the styles using the selection parameter of the modifier.": {
      "zh": "如果在创建 ImmersiveSpace 时没有制定类型，系统会默认创建一个 mixed 类型的空间。这个类型会将你的内容和贯穿用户周围环境的内容融合在一起展示。其他沉浸类型会不同程度的隐藏周围环境内容。调用 immersionStyle(selection:in:) 指定你的空间支持什么沉浸类型。如果指定了多个样式，则可以使用修改器的 selection 参数在样式之间切换。",
      "tips": ""
    },
    "Warning": {
      "zh": "警告",
      "tips": ""
    },
    "Be mindful of how much content you include in immersive scenes that use the mixed style. Content that fills a significant portion of the screen, even if that content is partially transparent, can prevent the person from seeing potential hazards in their surroundings. If you want to immerse the person in your content, configure your space with the full style. For more information, see, Creating fully immersive experiences in your app.": {
      "zh": "请注意一下在沉浸式场景( immersive scenes )中有多少内容使用 mixed 类型。因为如果 3D 内容占满屏幕很大一部分的，即使可以看见部分周围环境，也可能使用户完全无法看到周围环境中的潜在危险。如果想让用户完全沉浸在你的内容中，请使 full 配置你的空间。如需了解更多信息，请参阅 Creating fully immersive experiences in your app 。",
      "tips": ""
    },
    "Remember to set the position of items you place in an ImmersiveSpace. Position SwiftUI views using modifiers, and position a RealityKit entity using its transform component. SwiftUI places the origin of a space at a person’s feet initially, but can change this origin in response to other events. For example, the system might shift the origin to accommodate a SharePlay activity that displays your content with Spatial Personas. If you need to position SwiftUI views and RealityKit entities relative to one another, perform any needed coordinate conversions using the methods in the content parameter of RealityView.": {
      "zh": "记得在 ImmersiveSpace 中设置实体的位置。 SwiftUI 中，通过相应的修改器 position(x:y:) 、 position(_:CGPoint) 设置视图的位置，对于 RealityKit 实体，则是通过设置 transform 相关的属性，来设置实体的位置。SwiftUI 会以用户所站的位置作为空间原点初始位置，但是原点位置可以随其他事件而改变。例如，当需要同时展示有用户虚拟角色的 SharePlay Activity 和 你的 3D 内容时，系统会平移你的空间原点的位置。如果需要对 SwiftUI 视图和 RealityKit 实体进行相对定位，请使用 RealityView 和 RealityViewContent 的参数和方法来实现所需的坐标转换。",
      "tips": "译者注：这里将 Spatial Personas 翻译为“用户虚拟角色”，是用户的拟真形象，是苹果的一项新技术。更多关于 SharePlay activity 和 Spatial Personas，可以通过 Design spatial SharePlay experiences 视频了解。"
    },
    "To display your ImmersiveSpace scene, open it using the openImmersiveSpace action, which you obtain from the SwiftUI environment. This action runs asynchronously and uses the provided information to find and initialize your scene. The following example shows a button that opens the space with the solarSystem identifier:": {
      "zh": "在 SwiftUI 环境中，通过 openImmersiveSpace 方法，显示你的 ImmersiveSpace Scene。系统会异步执行这个方法，并通过已有的信息初始化你的 Scene 。下列实例代码展示了点击按钮，通过 solarSystem 的唯一标识符打开这个虚拟空间。",
      "tips": ""
    },
    "When an app presents an ImmersiveSpace, the system hides the content of other apps to prevent visual conflicts. The other apps remain hidden while your space is visible but return when you dismiss it. If your app defines multiple spaces, you must dismiss the currently visible space before displaying a different space. If you don’t dismiss the visible space, the system issues a runtime warning when you try to open the other space.": {
      "zh": "当应用程序展示一个虚拟空间—— ImmersiveSpace 时，系统为了防止视觉冲突会隐藏其他 App 的内容。当你的虚拟空间展示着的时候，其他应用程序会一直被隐藏着，直到用户退出了你的虚拟空间，其他应用程序才会恢复显示。当你没有退出当前显示的虚拟空间，而去打开另一个虚拟空间，系统就会抛出一个运行时的错误。",
      "tips": ""
    }
  },
  "visionos/adopting-best-practices-for-privacy": {
    "Adopting best practices for privacy and user preferences": {
      "zh": "遵循隐私和用户偏好的最优做法",
      "tips": ""
    },
    "Minimize your use of sensitive information and provide a clear statement of what information you do use and how you use it.": {
      "zh": "尽可能少地使用隐私信息，向用户提供清晰的说明，明确告知您所使用的信息及其使用方式。",
      "tips": ""
    },
    "Overview": {
      "zh": "概览",
      "tips": ""
    },
    "To protect user privacy, the system handles camera and sensor inputs without passing the information to apps directly. Instead, the system enables your app to seamlessly interact with a user’s surroundings and to automatically receive input from the user. For example, the system handles the eye- and hand-position data needed to detect interactions with your app’s content. Similarly, the system provides a way to automatically alter a view’s appearance when someone looks at it, without your app ever knowing what the user is looking at.": {
      "zh": "为保障用户隐私，系统会直接处理摄像头和传感器所输入的信息，而非传给应用程序。系统的这种设计让您的应用能够与用户的周遭环境无缝互动，并自动接收用户输入的信息。例如，系统会处理眼睛和手部的位置数据，这对于检测用户与您应用内容的互动来说至关重要。类似地，您的应用无需知晓用户的具体注视点，系统就能在用户看向某个视图时自动改变其展示效果。",
      "tips": ""
    },
    "In the few cases where you actually need access to hand position or information about the user’s surroundings, the system requires you to obtain authorization from the user first.": {
      "zh": "在极少数情况下，如果您真的需要获取用户手部位置或周围环境信息，系统会要求您必须先获得用户的授权。",
      "tips": ""
    },
    "Important": {
      "zh": "重要信息",
      "tips": ""
    },
    "It’s your responsibility to protect any data your app collects, and to use it in responsible and privacy-preserving ways. Don’t ask for data that you don’t need, be transparent about how you use the data you acquire, and respect the choices of the person whose data it is.": {
      "zh": "保护您的应用所收集的任何数据，并以负责任和尊重隐私的方式使用这些数据是您的责任。不要从用户处获取任何您不需要的数据，对于如何使用您所获取的数据要保持公开透明，并尊重数据所有者的选择。",
      "tips": ""
    },
    "For information about how to specify the privacy data your app uses, see Describing data use in privacy manifests. For general information about privacy, see Protecting the User’s Privacy.": {
      "zh": "关于如何在隐私清单中明确您的应用所使用的隐私数据，详见“隐私数据使用说明”。有关隐私保护政策的更多信息，请参阅“保护用户隐私”。",
      "tips": ""
    },
    "Adopt the system-provided input mechanisms": {
      "zh": "采用系统提供的输入机制",
      "tips": ""
    },
    "On Apple Vision Pro, people use their eyes and hands to interact with the items they see in front of them. Where they look determines where the system applies focus, and a tap gesture with either hand generates a touch event on that focused item. The system can also detect when someone’s fingers interact with virtual items in the person’s field of vision. When you adopt the standard UIKit and SwiftUI event-handling mechanisms, you get all of these interactions automatically.": {
      "zh": "在 Apple Vision Pro 上，用户会通过眼睛和手与他们所见到的物体交互。他们的视线所在之处决定了系统的聚焦点，任何一只手的轻触手势都会在所聚焦物体上产生一个触摸事件。系统还能检测用户的手指何时与其视野中的虚拟物品发生交互。当您采用标准的 UIKit 和 SwiftUI 事件处理机制时，这些交互都能被自动捕捉和处理。",
      "tips": ""
    },
    "For most apps, the system-provided gesture recognizers are sufficient for responding to interactions. Although you can get the position of someone’s hands with ARKit, doing so isn’t necessary for most apps. Collect hand-position data only when the system doesn’t offer what you need. For example, you might use hand-position data to attach 3D content to the person’s hands. Some other things to remember about hand-position data:": {
      "zh": "对于大部分应用来说，系统内置的手势识别功能已足以应对用户的交互。尽管通过 ARKit 可以获取用户手部的位置信息，但这对于多数应用来说并非必需。建议您只在系统提供的功能无法满足特定需求时，才向用户收集手部位置数据。举例来说，您可能会利用手部位置数据将 3D 内容附加到用户的手上。在处理手部位置数据时，还有以下几点需要注意：",
      "tips": ""
    },
    "People can deny your request for access to hand-position data. Be prepared to handle situations where the data isn’t available.": {
      "zh": "用户可能会拒绝您访问手部位置数据的请求。您需要准备好处理数据不可用的情况。",
      "tips": ""
    },
    "You must present an immersive space to access hand data. When you open an immersive space, the system hides other apps.": {
      "zh": "您必须提供一个沉浸式空间来访问手部数据。当您启动一个沉浸式空间时，系统会隐去其他应用。",
      "tips": ""
    },
    "For information about how to handle the standard-system events, see the SwiftUI and UIKit documentation.": {
      "zh": "关于如何处理标准系统事件的更多信息，请参阅 SwiftUI 和 UIKit 的文档。",
      "tips": ""
    },
    "Provide clear messaging around privacy-sensitive features": {
      "zh": "在提供涉及隐私的功能时，请明确提供清晰的声明信息。",
      "tips": ""
    },
    "The following ARKit features require you to provide a usage description string in your app’s Info.plist file:": {
      "zh": "在使用以下 ARKit 功能时，需要您在应用的 Info.plist 文件中提供提供字符串来描述使用目的：",
      "tips": ""
    },
    "World-tracking data": {
      "zh": "世界追踪数据",
      "tips": ""
    },
    "Hand-tracking data": {
      "zh": "手部追踪数据",
      "tips": ""
    },
    "Other privacy-sensitive technologies in visionOS also require you to supply usage description strings. For example, you provide usage descriptions for the Core Location features you adopt. These strings communicate why your app needs the data, and how you plan to use the data to help the person using your app. The first time you request authorization to use the technology, the system prompts the person to grant or deny access to your app. The system includes your usage-description string in the dialog it displays.": {
      "zh": "在 visionOS 中，其他和隐私相关的技术也需要您提供使用描述字符串。例如，你需要为应用中使用 Core Location 功能的原因提供使用说明。这些字符串应该能清楚地说明您的应用为何需要这些数据，以及您计划如何使用这些数据来帮助用户使用产品。当您首次请求使用某项技术的授权时，系统会提示用户是否授权您的应用使用。系统显示的对话框中将会包含您的使用描述字符串。",
      "tips": ""
    },
    "For information about requesting access to ARKit data, see ARKit. For guidance on how to craft good messages around privacy-friendly features, see Human Interface Guidelines.": {
      "zh": "有关请求访问 ARKit 数据的信息，请参阅 ARKit 文档。有关如何撰写隐私友好的撰写良好信息的指南，请参阅“人机界面指南”。",
      "tips": ""
    }
  },
  "visionos/adopting_the_system_player_interface_in_visionos": {
    "Adopting the system player interface in visionOS": {
      "zh": "在 visionOS 中采用系统播放器界面",
      "tips": ""
    },
    "Provide an optimized viewing experience for watching 3D video content.": {
      "zh": "为观看 3D 视频内容提供优化的观看体验。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "The recommended way to provide a video playback interface for your visionOS app is to adopt AVPlayerViewController. Using this class makes it simple to provide the same playback user interface and features found in system apps like TV and Music. It also provides essential system integration to deliver an optimal viewing experience whether you’re playing standard 2D content or immersive 3D video with spatial audio. This article describes best practices for presenting the player in visionOS and covers the options the player provides to customize its user interface to best fit your app.": {
      "zh": "为你的 visionOS 应用提供视频播放界面的推荐方法是采用 AVPlayerViewController。使用此类可以轻松提供与系统应用（如电视和音乐）相同的播放界面和功能。它还提供了必要的系统集成，无论你是播放标准的 2D 内容还是带有空间音频的沉浸式 3D 视频，都能提供最佳的观看体验。本文介绍了在 visionOS 中展示播放器的最佳实践，并涵盖了播放器提供的自定义界面选项，以最适应你的应用。",
      "tips": ""
    },
    "Note": {
      "zh": "备注",
      "tips": ""
    },
    "In addition to providing the system playback interface, you can also use AVPlayerViewController to present a media-trimming experience similar to QuickTime Player in macOS. See Trimming and exporting media in visionOS for more information.": {
      "zh": "除了提供系统播放界面，你还可以使用 AVPlayerViewController 提供类似于 macOS 中 QuickTime Player 的媒体剪辑体验。更多信息，请参考 visionOS 中修剪和导出媒体。",
      "tips": ""
    },
    "Explore presentation options": {
      "zh": "探索展示方式",
      "tips": ""
    },
    "Use AVPlayerViewController to play video in windowed environments in visionOS. It automatically adapts its user interface to best fit its presentation. For example, when you present it nested inside another view, it displays an inline user interface:": {
      "zh": "使用 AVPlayerViewController 在 visionOS 的窗口环境中播放视频，它会自动调整其用户界面以适应当前展示方式。例如，当你将其嵌套在另一个视图中时，它会显示一个内嵌用户界面：",
      "tips": ""
    },
    "When you present the player inline, it only displays standard 2D video. To play 3D content, present it fullscreen.": {
      "zh": "当你以内嵌方式展示播放器时，它仅支持标准 2D 视频。如要播放 3D 内容，请使用全屏展示。",
      "tips": ""
    },
    "Present the player in full-screen mode by setting it as the exclusive root view of your app, or by presenting it using the fullScreenCover(item:onDismiss:content:) modifier. In full-screen mode, the player presents a more content-forward design that dims the environment by default to provide more suitable viewing. This provides a streamlined viewing experience for both 2D and 3D content.": {
      "zh": "将播放器设置为应用的唯一根视图，或使用 fullScreenCover(item:onDismiss:content:) 修饰符，可以以全屏模式展示播放器。在全屏模式下，播放器呈现出一种更加偏内容导向的设计，默认会调暗环境光线，以提供更合适的观看效果。这为欣赏 2D 和 3D 内容提供了优化的观看体验。",
      "tips": ""
    },
    "Display supporting metadata": {
      "zh": "显示相关元数据",
      "tips": ""
    },
    "The user interface displays a title view above the transport bar when the current player item contains title and subtitle metadata. When playing live-streaming content, the title view may also display a badge to indicate the content state to the viewer.": {
      "zh": "在当前播放项目包含标题和副标题元数据时，用户界面会在播放栏上方显示标题视图。当播放实时内容时，标题视图还可能显示一个徽章，向观众提示内容状态。",
      "tips": ""
    },
    "The title view displays the values of an asset’s commonIdentifierTitle and iTunesMetadataTrackSubTitle metadata items, when available. If your media doesn’t provide embedded metadata, you can add supplemental metadata to display by creating instances of AVMetadataItem. The table below lists the metadata values the player user interface supports.": {
      "zh": "标题视图会显示媒体元数据项 commonIdentifierTitle 和 iTunesMetadataTrackSubTitle 的值（如可用）。如果你的媒体不提供嵌入的元数据，则可以通过创建 AVMetadataItem 的实例来补充元数据。下表列出了播放器用户界面支持的元数据值。",
      "tips": ""
    },
    "Metadata": {
      "zh": "元数据",
      "tips": ""
    },
    "Identifier": {
      "zh": "标识符",
      "tips": ""
    },
    "Type": {
      "zh": "类型",
      "tips": ""
    },
    "Title": {
      "zh": "标题",
      "tips": ""
    },
    "commonIdentifierTitle": {
      "zh": "commonIdentifierTitle",
      "tips": ""
    },
    "String": {
      "zh": "字符串",
      "tips": ""
    },
    "Subtitle": {
      "zh": "副标题",
      "tips": ""
    },
    "iTunesMetadataTrackSubTitle": {
      "zh": "iTunesMetadataTrackSubTitle",
      "tips": ""
    },
    "Artwork": {
      "zh": "作品",
      "tips": ""
    },
    "commonIdentifierArtwork": {
      "zh": "commonIdentifierArtwork",
      "tips": ""
    },
    "Data": {
      "zh": "数据",
      "tips": ""
    },
    "Description": {
      "zh": "描述",
      "tips": ""
    },
    "commonIdentifierDescription": {
      "zh": "commonIdentifierDescription",
      "tips": ""
    },
    "Genre": {
      "zh": "类型",
      "tips": ""
    },
    "quickTimeMetadataGenre": {
      "zh": "quickTimeMetadataGenre",
      "tips": ""
    },
    "Content rating": {
      "zh": "内容分级",
      "tips": ""
    },
    "iTunesMetadataContentRating": {
      "zh": "iTunesMetadataContentRating",
      "tips": ""
    },
    "In an app that defines a simple structure to hold string and data items, you can map its values to their appropriate metadata identifiers and build an array of metadata items:": {
      "zh": "在一个使用简单结构体来保存字符串和数据的应用中，你可以将这些值映射到相应的元数据标识符，并生成元数据项数组：",
      "tips": ""
    },
    "To apply the metadata to the current player item, set the array of metadata items as the value of the player item’s externalMetadata property:": {
      "zh": "若要将元数据应用于当前播放项，将元数据项数组赋值给播放项目的 externalMetadata 属性：",
      "tips": ""
    },
    "Only the title and subtitle values display in the title view. The player presents the other supported metadata values in its Info tab, which the section below describes.": {
      "zh": "标题视图中仅显示标题和副标题。播放器在其“信息”选项卡中显示其他支持显示的元数据值，文章的以下部分将对此进行介绍。",
      "tips": ""
    },
    "Display custom informational views": {
      "zh": "显示自定义信息视图",
      "tips": ""
    },
    "The visionOS player UI can display one or more content tabs in the user interface to show supporting information or related content. By default, the player presents an Info tab when an asset contains embedded metadata or when you set external metadata on the player item, as the Display supporting metadata section above describes.": {
      "zh": "visionOS 播放器 UI 可以在用户界面中显示一个或多个内容选项卡，以显示附属信息或相关内容。当媒体包含内嵌元数据或在播放器项目上设置了外部元数据时，播放器会如上面的“显示相关元数据”章节所述，默认显示“信息”选项卡。",
      "tips": ""
    },
    "Your app can also present custom tabs to show supporting content. You define your tab content as standard SwiftUI views, wrap them in a UIHostingController, and set them as the customInfoViewControllers property. The player UI uses the title property of the hosting controller to display as the tab title in the interface, so set this value before setting it on the player view controller.": {
      "zh": "你的应用还可以通过展示自定义选项卡以显示相关内容。你可以使用标准 SwiftUI 视图定义选项卡内容，将它们包装在 UIHostingController 中，然后将它们设置为 customInfoViewControllers 属性。播放器 UI 将托管控制器的 title 属性显示为选项卡界面标题，因此请先设置好此值，再在播放器视图控制器上设置托管控制器。",
      "tips": "Hosting controller 译为“托管控制器”。"
    },
    "Present actions in the Info tab": {
      "zh": "在“信息”选项卡中显示操作",
      "tips": ""
    },
    "The player UI presents an Info tab when the asset it displays provides embedded or external metadata. The tab’s view displays the metadata details, and it may show up to two UIAction controls along its trailing edge:": {
      "zh": "当播放器 UI 显示的资源提供内嵌或外部元数据时，它会显示一个“信息”选项卡。选项卡视图会显示元数据详情，并且沿右侧边缘显示最多两个 UIAction 控件：",
      "tips": ""
    },
    "Customize the actions the view presents by setting a value for the player view controller’s infoViewActions property. When playing nonlive content, this property contains a single-element array that presents an action to play the content from the beginning. You can replace the default value (if present), add an additional action, or set this property value to an empty array to display no actions. The example below shows how to add a Add to Favorites action to the view:": {
      "zh": "通过设置播放器视图控制器的 infoViewActions 属性来自定义视图所显示的操作。当播放非实时内容时，此属性默认为一个单元素数组，用于存放从头播放视频的操作。你可以替换默认值（如存在）、添加其他操作，或将此属性设置为空数组从而不显示任何操作。下面的示例演示了如何向视图添加“添加到收藏夹”操作：",
      "tips": ""
    },
    "Display actions contextually": {
      "zh": "根据上下文情景来显示操作",
      "tips": ""
    },
    "You can use the visionOS player UI to present controls contextually, which your app displays for a specific range of time in the content and then dismiss. A common use for this type of control is a skip button that displays during the title sequence of a movie or TV show. People can tap the button to bypass the introduction and quickly skip to the main content.": {
      "zh": "你可以让 visionOS 播放器 UI 根据情景来显示控件，应用会在一定时间内在视频内容中显示控件，然后隐藏。此类控件的常见用途是在电影或电视节目的片头序列中显示跳过按钮，用户可以点击此按钮绕过介绍并快速跳转到主要内容。",
      "tips": ""
    },
    "AVPlayerViewController provides a contextualActions property you can use to specify one or more actions to present. The player displays them along the bottom-trailing side of the screen. The following code example shows a simple implementation of an action that seeks the player forward to the time of the main content:": {
      "zh": "AVPlayerViewController 提供了一个 contextualActions 属性，用于指定显示一个或多个操作。播放器在画面的底部靠右显示这些操作。下面的代码示例演示了一个简单的操作，该操作将播放器向前快进到主要内容的开始时间：",
      "tips": ""
    },
    "When you set a value for the contextualActions property, the player presents the controls immediately. To present them only during a relevant section of the content, observe the player timing by adding a periodic or boundary time observer. The following example defines a periodic time observer that fires every second during normal playback. In each invocation, it evaluates the new time to determine whether it falls within the presentation range. If it does, the example sets the skip action as the contextual actions value; otherwise, it clears the value by setting it to an empty array.": {
      "zh": "当你为 contextualActions 属性赋值后，播放器会立即显示对应的控件。如需要仅在与内容相关的部分显示操作，请通过添加周期性或边界性时间观察器来监视播放时间。以下示例定义了一个周期性时间观察器，该观察器在视频播放期间每秒钟触发一次。在每次触发时，它都会评估当前播放时间，以确认它是否在显示范围内。如果是，则该示例将跳过设置为当前情景的操作；否则，它将通过将值设置为空数组来清除所有操作。",
      "tips": ""
    }
  },
  "visionos/analyzing-the-performance-of-your-visionos-app": {
    "Analyzing the performance of your visionOS app": {
      "zh": "",
      "tips": ""
    },
    "Use the RealityKit Trace template in Instruments to evaluate and improve the performance of your visionOS app.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "To maintain the sense of immersion on Apple Vision Pro, the system attempts to provide the device displays with up-to-date imagery at a constant rate and respond to interactions with minimum latency. Any visual choppiness or delay in responsiveness interferes with the spatial experience. Higher power consumption over extended periods of time, or extreme power consumption over shorter periods of time, can trigger thermal mitigations that also impact the quality of the experience. It’s important to minimize your app’s use of system resources to ensure your app performs well on the platform. Many of the same best practices and optimization procedures you use developing for other Apple platforms apply when developing for visionOS as well. For more information about optimizing your app on other platforms, see Improving your app’s performance.": {
      "zh": "",
      "tips": ""
    },
    "To get useful information specific to rendering bottlenecks, high system power use, and other issues that effect the responsiveness of your visionOS app, profile your app with the RealityKit Trace template in Instruments. This template helps you identify:": {
      "zh": "",
      "tips": ""
    },
    "Complex content or content with frequent updates that cause the render server to miss deadlines and drop frames.": {
      "zh": "",
      "tips": ""
    },
    "Content and tasks that result in high system power use.": {
      "zh": "",
      "tips": ""
    },
    "Long running tasks on the the main thread that interfere with efficient processing of input events.": {
      "zh": "",
      "tips": ""
    },
    "Tasks running on other threads that don’t complete in time to sync back to the main thread for view hierarchy updates.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "You can profile using a real device or a simulator, but to get the most accurate and actionable information, use a real device. Software and hardware differences between a simulator on your Mac and a real device prevent you from relying on timing information. Simulated devices are useful for quick iteration and improving performance aspects that aren’t based on time.": {
      "zh": "",
      "tips": ""
    },
    "Open a new trace document": {
      "zh": "",
      "tips": ""
    },
    "To create a new trace document:": {
      "zh": "",
      "tips": ""
    },
    "Select your app’s scheme and a visionOS run destination from the Xcode project window.": {
      "zh": "",
      "tips": ""
    },
    "Choose Product > Profile.": {
      "zh": "",
      "tips": ""
    },
    "Choose RealityKit Trace template": {
      "zh": "",
      "tips": ""
    },
    "Select the Choose button.": {
      "zh": "",
      "tips": ""
    },
    "Alternatively, launch Instruments and choose a target app from the template selection dialog.": {
      "zh": "",
      "tips": ""
    },
    "The RealityKit Trace template includes the following instruments:": {
      "zh": "",
      "tips": ""
    },
    "Captures frame render times and lifespans for frames the visionOS render server generates. This instrument indicates when frames miss rendering deadlines and provides average CPU and GPU render rates.": {
      "zh": "",
      "tips": ""
    },
    "Captures comprehensive timing information from the entire render pipeline including rendering, commits, animations, physics, and spatial systems. This instrument identifies potential bottlenecks in your app’s process or in the render server as a result of your app’s content and indicates areas of moderate and high system power usage that require optimization.": {
      "zh": "",
      "tips": ""
    },
    "Captures and displays Runloop execution details.": {
      "zh": "",
      "tips": ""
    },
    "Profiles running threads on all cores at regular intervals for all processes.": {
      "zh": "",
      "tips": ""
    },
    "Captures and displays periods of time when the main thread is unresponsive.": {
      "zh": "",
      "tips": ""
    },
    "Records Metal app events.": {
      "zh": "",
      "tips": ""
    },
    "Consider adding other instruments to your trace for specific investigations. For example, you can use the Thermal State instrument to record device thermal states to check if thermal pressures are throttling performance.": {
      "zh": "",
      "tips": ""
    },
    "Profile your workflows": {
      "zh": "",
      "tips": ""
    },
    "Click the record button at the top left of the window to start capturing profile data. Perform the actions in your app that you want to investigate. When you complete the actions, click the record button again to stop recording.": {
      "zh": "",
      "tips": ""
    },
    "To investigate performance issues or analyze system power impact, profile your app in isolation to understand your app’s impact on system performance and ensure you get the most actionable information. For apps that run alongside other apps, profile your app again with those other apps running to understand how people experience your app in conjunction with other apps.": {
      "zh": "",
      "tips": ""
    },
    "Inspect frame rendering performance": {
      "zh": "",
      "tips": ""
    },
    "To maintain a smooth visual experience, the system tries to render new frames for the Apple Vision Pro at 90 frames per second (FPS). The system renders at other frame rates depending on the content it displays and the current surroundings. Each frame has a deadline for rendering based on the target frame rate. Not meeting these deadlines results in dropped frames. This creates a poor spatial experience overall. People tend to notice it in the visual performance of Persona and SharePlay experiences, video playback, and scrolling. The RealityKit Frames instrument displays the time spent rendering each frame in the Frames section of its timeline:": {
      "zh": "",
      "tips": ""
    },
    "When you zoom out, you can identify areas with a high number of frame drops or with frames running close to the rendering deadline. The timeline uses green to identify frames that complete rendering before the deadline, orange for frames that complete rendering close to the deadline, and red for frames that don’t complete rendering that the renderer drops. Dropped frames contribute to a poor spatial experience, but frames that complete close to their rendering deadline indicate performance problems too. Hold the Option key and drag to zoom into a frame, or group of frames, to see their lifespan broken down in stages:": {
      "zh": "",
      "tips": ""
    },
    "This provides you with insight into which portion of the rendering pipeline to investigate further. This timeline also includes sections that visualize the Average CPU Frame Time and Average GPU Frame Time to indicate the type of processing that computes the frames. A region of the timeline without a frame block indicates a period of time without changes to a person’s surroundings or app updates. The render server avoids computing new frames to send to the compositor during these periods which helps optimize power use.": {
      "zh": "",
      "tips": ""
    },
    "Monitor system power usage": {
      "zh": "",
      "tips": ""
    },
    "When thermal levels rise to levels that trigger thermal mitigations in the system, performance degrades and negatively impacts the responsiveness of your app. Optimize for power to avoid this negative impact. The timeline for the RealityKit Metrics instrument includes a System Power Impact section to identify areas of high power usage in your app:": {
      "zh": "",
      "tips": ""
    },
    "If the timeline displays green, the tool considers your app’s impact on system power low enough to sustain. Regions that display orange or red indicate the system power usage could cause thermal levels to rise and trigger thermal mitigations. This decreases the availability of system resources, which can cause visual interruptions and responsiveness issues.": {
      "zh": "",
      "tips": ""
    },
    "If the render server can’t maintain the target frame rate of 90 FPS due to thermal pressure, it might reduce its frame rate in half. When this occurs, all frames in the frames track show up as missing their rendering deadlines. Other factors can cause reduced frame rate, including the complexity and frequency of the content the system is processing. Use the Thermal State instrument to determine if thermal conditions are causing the rate limiting or if it’s due to other factors.": {
      "zh": "",
      "tips": ""
    },
    "Identify bottlenecks": {
      "zh": "",
      "tips": ""
    },
    "The Bottlenecks section of the timeline for the RealityKit Metrics instrument contains markers that indicate high overhead in your app or the render server that contribute to dropped frames and high system power use. When you encounter either of these issues, check if the timeline identifies bottlenecks you can address. Double-click on any of the markers to display more information in the detail area at the bottom of the instruments window. If the detail area is hidden, choose View > Detail Area > Show Detail Area to reveal it. The render server encounters bottlenecks in either the CPU or GPU. The instrument categorizes bottlenecks by their severity and type.": {
      "zh": "",
      "tips": ""
    },
    "To filter the bottlenecks listed in the detail area to a particular time period, drag inside the timeline to select the region. To see an outline view of the bottlenecks organized by severity and type, select Summary: RealityKit Bottlenecks from the menu at the top left of the detail area. Click the arrow button to the right of the severity or type in the outline view to show the list of bottlenecks in that category.": {
      "zh": "",
      "tips": ""
    },
    "When you select a specific bottleneck, the extended detail provides recommendations for you to address the bottleneck – choose View > Show Extended Detail to reveal the extended detail if it’s hidden.": {
      "zh": "",
      "tips": ""
    },
    "Explore the metrics that relate to bottlenecks": {
      "zh": "",
      "tips": ""
    },
    "The trace provides additional information you can use to identify changes to make in your app to address these bottlenecks. Click the expansion arrow for the RealityKit Metrics instrument timeline to reveal graphs specific to each major category of work. Use the metrics associated with these graphs to determine which RealityKit feature has the biggest impact on high CPU frame times in the app process or in the render server. When interpreting these graphs, lower indicates better performance and power. The metrics represent values from all apps running, so profile with just your app running when trying to optimize for these metrics.": {
      "zh": "",
      "tips": ""
    },
    "Metrics related to the cost of 3D RealityKit rendering in the render server. This includes the number of draw calls, triangles, and vertices from all apps.": {
      "zh": "",
      "tips": ""
    },
    "Metrics related to UI content rendering costs in the render server. This includes the total number of render passes, offscreen render passes, and translucent UI meshes from all apps.": {
      "zh": "",
      "tips": ""
    },
    "Metrics related to the costs of entity commits in the app and the render server. This includes the number of RealityKit entities shared with the render server from all apps, as well as the number of updates received from all apps over certain intervals.": {
      "zh": "",
      "tips": ""
    },
    "Metrics related to the cost of RealityKit animations in the app and the render server. This includes the number of skeletal animations, across all apps.": {
      "zh": "",
      "tips": ""
    },
    "Metrics related to the cost of RealityKit physics simulations, collisions, and hit testing in the app process and render server. This includes the number of rigid body counts and colliders in use, as well as the type of physics shapes that the UI and other 3D content use, across all apps.": {
      "zh": "",
      "tips": ""
    },
    "Metrics related to the costs of spatial algorithms in the render server. This includes the number of custom anchors, across all apps.": {
      "zh": "",
      "tips": ""
    },
    "Tip": {
      "zh": "",
      "tips": ""
    },
    "The graphs for some sections combine several individual metrics. The heading indicates this by displaying a graph count. Click on the bottom of the timeline’s heading and drag down to display individual graphs for each metric. For example, the 3D Render Timeline might display 13 Graphs in the heading; expanding that timeline exposes individual graphs for 3D Mesh Draw Calls, 3D Mesh Triangles, 3D Mesh Vertices, and the 10 additional metrics.": {
      "zh": "",
      "tips": ""
    },
    "The timeline for your app’s process helps summarize information from the instruments about your process and the work the render server completes for your process.": {
      "zh": "",
      "tips": ""
    },
    "Choose an option from the pop-up in the timeline header to show different graphs in the timeline:": {
      "zh": "",
      "tips": ""
    },
    "Time each thread spends waiting or busy.": {
      "zh": "",
      "tips": ""
    },
    "Time the main thread is unresponsive.": {
      "zh": "",
      "tips": ""
    },
    "CPU usage and lifecycle status.": {
      "zh": "",
      "tips": ""
    },
    "Overhead attributed to RealityKit systems.": {
      "zh": "",
      "tips": ""
    },
    "When you select the timeline for your app’s process, you can choose instrument summaries and profile data to display in the detail area from the popup-button at its top-left:": {
      "zh": "",
      "tips": ""
    },
    "To filter the information in the detail area by time, select periods of time in the timeline above.": {
      "zh": "",
      "tips": ""
    },
    "Detect delays on the main thread": {
      "zh": "",
      "tips": ""
    },
    "Select Hangs in your app’s process timeline to identify times in the trace that might have interaction delays. Use the RealityKit Metrics and Time Profiler summaries to better understand the work your app is doing. Choose the following options from the detail area pop-up menu:": {
      "zh": "",
      "tips": ""
    },
    "Shows information from the Time Profiler instrument to determine what your app is doing during a hang.": {
      "zh": "",
      "tips": ""
    },
    "RealityKit System CPU times: Shows minimum, maximum, and average times the CPU spends on various RealityKit system operations.": {
      "zh": "",
      "tips": ""
    },
    "Optimize any 3D render updates, hit testing, and collision work you find. For more information about addressing hangs in your app, see Improving app responsiveness.": {
      "zh": "",
      "tips": ""
    },
    "Manage audio overhead": {
      "zh": "",
      "tips": ""
    },
    "Use the Audio Playback section of your process’s timeline to identify areas of high audio overhead. The system defaults to using spatial audio for your app when running on visionOS. It processes information in real time about your position, surroundings, and the current location of audio sources to generate an immersive audio experience. If you include too many concurrent audio sources that require the system to adapt audio sources to their location within a large space, the increased demand on system resources can lead to delays in the audio output.": {
      "zh": "",
      "tips": ""
    },
    "To reduce the spatial audio work, limit:": {
      "zh": "",
      "tips": ""
    },
    "The number of concurrently playing audio sources": {
      "zh": "",
      "tips": ""
    },
    "The number of moving audio sources": {
      "zh": "",
      "tips": ""
    },
    "The size of the soundstage": {
      "zh": "",
      "tips": ""
    },
    "Consider creating a pool of audio players to limit the maximum number of players your app uses. Place players on stationary entities, instead of moving entities, when appropriate. Initializing several audio players at the same time causes a high overhead that affects other aspects of the system, such as rendering performance. Consider the other tasks the system completes during these allocations and space them out over time. For more information, see Create a great spatial playback experience.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/bringing-your-app-to-visionos": {
    "Bringing your existing apps to visionOS": {
      "zh": "将现有应用移植到 visionOS",
      "tips": ""
    },
    "Build a version of your iPadOS or iOS app using the visionOS SDK, and update your code for platform differences.": {
      "zh": "使用 visionOS SDK 为你的 iPadOS 或 iOS 应用构建一个新版本，并更新代码以适应平台差异。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "If you have an existing app that runs in iPadOS or iOS, you can build that app against the visionOS SDK to run it on the platform. Apps built specifically for visionOS adopt the standard system appearance, and they look more natural on the platform. Updating your app is also an opportunity to add elements that work well on the platform, such as 3D content and immersive experiences.": {
      "zh": "如果你有一个在 iPadOS 或 iOS 上运行的应用，你可以使用 visionOS SDK 构建该应用程序，以便在该平台上运行。为 visionOS 专门构建的应用采用标准系统外观，在该平台上看起来更自然。同时，更新应用也是添加在该平台上吸引眼球的元素（如 3D 内容和沉浸式体验）的好机会。",
      "tips": ""
    },
    "In most cases, all you need to do to support visionOS is update your Xcode project’s settings and recompile your code. Depending on your app, you might need to make additional changes to account for features that are only found in the iOS SDK. While most of the same technologies are available on both platforms, some technologies don’t make sense or require hardware that isn’t present on visionOS devices. For example, people don’t typically use a headset to make contactless payments, so apps that that use the ProximityReader framework must disable those features when running in visionOS.": {
      "zh": "在大多数情况下，你只需更新 Xcode 的项目设置并重新编译代码即可支持 visionOS。根据你的应用，你可能需要进行其他更改，以解决那些仅在 iOS SDK 中支持的功能。虽然在两个平台上多数技术都是通用的，有些技术在 visionOS 设备上并不合理，或者需要的硬件并不存在。例如，用户通常不使用头戴式设备进行电子支付，因此使用 ProximityReader 框架的应用在 visionOS 中运行时必须禁用这些功能。",
      "tips": ""
    },
    "Note": {
      "zh": "备注",
      "tips": ""
    },
    "If you use ARKit in your iOS app to create an augmented reality experience, you need to make additional changes to support ARKit in visionOS. For information on how to update this type of app, see Bringing your ARKit app to visionOS.": {
      "zh": "如果你在 iOS 应用中使用了 ARKit 来实现增强现实体验，则需要进行额外的更改才能在 visionOS 中支持 ARKit。有关如何更新此类应用，请参阅将 ARKit 应用移植到 visionOS。",
      "tips": ""
    },
    "Add visionOS as a supported destination for your app": {
      "zh": "将 visionOS 添加为应用的支持终端（supported destination）",
      "tips": ""
    },
    "The first step to updating your app is to add visionOS as a supported destination. In your project’s settings, select your app target and navigate to the General tab. In Supported Destinations, click the Add (+) button to add a new destination and select the Apple Vision option. Adding this option lets you build your app specifically for the visionOS SDK.": {
      "zh": "更新应用的第一步是将 visionOS 添加为支持终端。在你的项目设置中，选择应用目标并导航到 General 选项卡。在 Supported Destinations 选项中，单击添加 （+） 按钮以添加新的终端，并选择 Apple Vision 选项。添加该选项后，你就可以专门为 visionOS SDK 构建应用了。",
      "tips": ""
    },
    "When you add Apple Vision as a destination, Xcode makes some one-time changes to your project’s build settings. After you add the destination, you can modify your project’s build settings and build phases to customize the build behavior specifically for visionOS. For example, you might remove dependencies for the visionOS version of your app, or change the set of source files you want to compile.": {
      "zh": "当第一次 Apple Vision 添加为终端时，Xcode 会对项目的构建设置进行一些一次性更改。添加终端后，你可以修改项目的构建设置和构建阶段，以定制针对 visionOS 的构建行为。例如，你可以移除 visionOS 版应用的依赖项，或更改要编译的源文件集。",
      "tips": ""
    },
    "For more information about how to update a target’s configuration, see Customizing the build phases of a target.": {
      "zh": "有关如何更新目标配置的更多信息，请参阅自定义目标的构建阶段。",
      "tips": ""
    },
    "Clean up code that uses deprecated APIs": {
      "zh": "清理使用了废弃 API 的代码",
      "tips": ""
    },
    "Fix any deprecation warnings in the iOS version of your code before you build for visionOS. Apple marks APIs as deprecated when they are no longer relevant or a suitable replacement exists. When you compile code that calls deprecated APIs, the compiler generates warnings and often suggests replacements for you to use instead. visionOS removed many deprecated symbols entirely, turning these deprecation warnings into missing-symbol errors on the platform. Make changes in the iOS version of your app to see the original deprecation warning and replacement details.": {
      "zh": "在为 visionOS 构建之前，修复 iOS 版本代码中的任何弃用警告。当 API 不再适用或存在合适的替代品时，Apple 就会将其标记为废弃。当你编译调用已废弃 API 的代码时，编译器会生成警告，并经常建议你使用替代品。visionOS 完全删除了许多已废弃的符号，这些废弃警告也因此变成了该平台上的符号缺失错误。请在 iOS 版本的应用查看原始的弃用警告和替换详情。",
      "tips": ""
    },
    "In addition to individual symbols, the following frameworks are deprecated in their entirety in both iOS and visionOS. If your app still uses these frameworks, stop using them immediately. The reference documentation for each framework includes information about how to update your code.": {
      "zh": "除个别符号外，以下框架在 iOS 和 visionOS 中均已被完全弃用。如果你的应用仍在使用这些框架，请立即停止使用。每个框架的参考文档都包含有关如何修改代码的详情。",
      "tips": ""
    },
    "Accounts": {
      "zh": "Accounts",
      "tips": ""
    },
    "Address Book": {
      "zh": "Address Book",
      "tips": ""
    },
    "Address Book UI": {
      "zh": "Address Book UI",
      "tips": ""
    },
    "Assets Library": {
      "zh": "Assets Library",
      "tips": ""
    },
    "GLKit": {
      "zh": "GLKit",
      "tips": ""
    },
    "iAd": {
      "zh": "iAd",
      "tips": ""
    },
    "Newsstand Kit": {
      "zh": "Newsstand Kit",
      "tips": ""
    },
    "NotificationCenter": {
      "zh": "NotificationCenter",
      "tips": ""
    },
    "OpenGL ES": {
      "zh": "OpenGL ES",
      "tips": ""
    },
    "Isolate features that are unavailable in visionOS": {
      "zh": "隔离 visionOS 中不可用的功能",
      "tips": ""
    },
    "The iOS SDK includes many frameworks that don’t apply to visionOS, either because they use hardware that isn’t available or their features don’t apply to the platform. Move code that uses these frameworks to separate source files whenever possible, and include those files only in the iOS version of your app.": {
      "zh": "iOS SDK 包含许多不适用于 visionOS 的框架，这可能是因为框架使用的硬件不可用，也可能是因为框架功能功能不适用于该平台。尽可能将使用这些框架的代码移到独立的源文件中，并只在 iOS 版本的应用中包含这些文件。",
      "tips": ""
    },
    "When you can’t isolate the code to separate source files, use conditional statements such as the ones below to offer a different code path for visionOS and iOS. The following example shows how to configure conditional statements to execute separate code paths in visionOS and iOS:": {
      "zh": "如果无法将代码隔离到单独的源文件中，可使用条件语句（如下面的语句）为 visionOS 和 iOS 提供不同的代码路径。下面的示例展示了如何配置条件语句，以便在 visionOS 和 iOS 中执行不同的代码路径：",
      "tips": ""
    },
    "The following frameworks are available in the iOS SDK but not in the visionOS SDK.": {
      "zh": "以下框架在 iOS SDK 中可用，但在 visionOS SDK 中不可用。",
      "tips": ""
    },
    "ActivityKit": {
      "zh": "ActivityKit",
      "tips": ""
    },
    "AdSupport": {
      "zh": "AdSupport",
      "tips": ""
    },
    "AppClip": {
      "zh": "AppClip",
      "tips": ""
    },
    "AutomatedDeviceEnrollment": {
      "zh": "AutomatedDeviceEnrollment",
      "tips": ""
    },
    "BusinessChat": {
      "zh": "BusinessChat",
      "tips": ""
    },
    "CarKey": {
      "zh": "CarKey",
      "tips": ""
    },
    "CarPlay": {
      "zh": "CarPlay",
      "tips": ""
    },
    "Cinematic": {
      "zh": "Cinematic",
      "tips": ""
    },
    "ClockKit": {
      "zh": "ClockKit",
      "tips": ""
    },
    "CoreLocationUI": {
      "zh": "CoreLocationUI",
      "tips": ""
    },
    "CoreMediaIO": {
      "zh": "CoreMediaIO",
      "tips": ""
    },
    "CoreNFC": {
      "zh": "CoreNFC",
      "tips": ""
    },
    "CoreTelephony": {
      "zh": "CoreTelephony",
      "tips": ""
    },
    "DeviceActivity": {
      "zh": "DeviceActivity",
      "tips": ""
    },
    "DockKit": {
      "zh": "DockKit",
      "tips": ""
    },
    "ExposureNotification": {
      "zh": "ExposureNotification",
      "tips": ""
    },
    "FamilyControls": {
      "zh": "FamilyControls",
      "tips": ""
    },
    "FinanceKit": {
      "zh": "FinanceKit",
      "tips": ""
    },
    "FinanceKitUI": {
      "zh": "FinanceKitUI",
      "tips": ""
    },
    "ManagedSettings": {
      "zh": "ManagedSettings",
      "tips": ""
    },
    "ManagedSettingsUI": {
      "zh": "ManagedSettingsUI",
      "tips": ""
    },
    "Messages": {
      "zh": "Messages",
      "tips": ""
    },
    "MLCompute": {
      "zh": "MLCompute",
      "tips": ""
    },
    "NearbyInteraction": {
      "zh": "NearbyInteraction",
      "tips": ""
    },
    "OpenAL": {
      "zh": "OpenAL",
      "tips": ""
    },
    "ProximityReader": {
      "zh": "ProximityReader",
      "tips": ""
    },
    "RoomPlan": {
      "zh": "RoomPlan",
      "tips": ""
    },
    "SafetyKit": {
      "zh": "SafetyKit",
      "tips": ""
    },
    "ScreenTime": {
      "zh": "ScreenTime",
      "tips": ""
    },
    "SensorKit": {
      "zh": "SensorKit",
      "tips": ""
    },
    "ServiceManagement": {
      "zh": "ServiceManagement",
      "tips": ""
    },
    "Social": {
      "zh": "Social",
      "tips": ""
    },
    "Twitter": {
      "zh": "Twitter",
      "tips": ""
    },
    "WidgetKit": {
      "zh": "WidgetKit",
      "tips": ""
    },
    "WorkoutKit": {
      "zh": "WorkoutKit",
      "tips": ""
    },
    "Some frameworks have behavioral changes that impact your app in visionOS, and some frameworks disable features when the required hardware is unavailable. To help you avoid using APIs for missing features, many frameworks offer APIs to check the availability of those features. Continue to use those APIs and take appropriate actions when the features aren’t available. In other cases, be prepared for the framework code to do nothing or to generate errors when you use it.": {
      "zh": "有些框架的行为变化会影响你的 visionOS 应用，有些框架会在所需硬件在当前平台不可用时禁用功能。为了帮助你避免使用缺失功能的 API，许多框架都提供了检查功能可用性的 API。继续使用这些 API，并在功能不可用时采取适当的措施。而在使用没有检查可用性的框架时，请做好框架代码失效或报错的准备。",
      "tips": ""
    },
    "ARKit. This framework requires you to use different APIs for iOS and visionOS. For more information, see Bringing your ARKit app to visionOS.": {
      "zh": "ARKit。此框架要求你为 iOS 和 visionOS 使用不同的 API。有关详细信息，请参阅将 ARKit 应用移植到 visionOS。",
      "tips": ""
    },
    "AutomaticAssessmentConfiguration. The framework returns an error if you try to start a test in visionOS.": {
      "zh": "AutomaticAssessmentConfiguration。如果你尝试在 visionOS 中启动测试，该框架会返回错误。",
      "tips": ""
    },
    "AVFoundation. Capture interfaces aren’t available in visionOS. Use availability checks to determine which services are present.": {
      "zh": "AVFoundation。截屏接口在 visionOS 中不可用。请使用可用性检查来确定哪些服务可用。",
      "tips": ""
    },
    "CallKit. You may continue to offer Voice-over-IP (VoIP) services, but phone number verification, call-blocking, and other cellular-related services are unavailable.": {
      "zh": "CallKit。你可以继续提供 Voice-over-IP (VoIP) 服务，但电话号码验证、呼叫阻断和其他蜂窝相关服务不可用。",
      "tips": ""
    },
    "ClockKit. The APIs of this framework do nothing in visionOS.": {
      "zh": "ClockKit。该框架的 API 在 visionOS 中不起作用。",
      "tips": ""
    },
    "CoreHaptics. visionOS plays audio feedback instead of haptic feedback.": {
      "zh": "CoreHaptics。visionOS 使用音频反馈而非触觉反馈。",
      "tips": ""
    },
    "CoreLocation. You can request someone’s location using the standard location service, but most other services are unavailable. Use availability checks to determine which services are present. The Always authorization level is unavailable and automatically becomes When in Use authorization.": {
      "zh": "CoreLocation。 你可以使用标准定位服务请求某人的位置，但大多数其他服务都不可用。请使用可用性检查确认哪些服务可用。“始终”授权级别不可用，会自动变为“使用中”授权。",
      "tips": ""
    },
    "CoreMotion. Barometer data is unavailable, but most other sensors are available. Use availability checks to determine which sensors you can use.": {
      "zh": "CoreMotion。 气压计数据不可用，但大多数其他传感器可用。使用可用性检查来确认哪些传感器可以使用。",
      "tips": ""
    },
    "HealthKit and HealthKitUI. Health data is unavailable. Use availability checks to determine when information is available.": {
      "zh": "HealthKit 和 HealthKitUI。健康数据不可用。使用可用性检查确认信息何时可用。",
      "tips": ""
    },
    "MapKit. User-tracking features that involve heading information aren’t available.": {
      "zh": "MapKit。涉及航向信息的用户跟踪功能不可用。",
      "tips": ""
    },
    "MediaPlayer. Some APIs are unavailable in visionOS.": {
      "zh": "MediaPlayer。某些 API 在 visionOS 中不可用。",
      "tips": ""
    },
    "MetricKit. You can gather on-device diagnostic logs and generate reports, but you can’t gather metrics.": {
      "zh": "MetricKit。你可以收集设备上的诊断日志并生成报告，但无法收集指标。",
      "tips": ""
    },
    "MusicKit. Some APIs are unavailable in visionOS.": {
      "zh": "MusicKit。某些 API 在 visionOS 中不可用。",
      "tips": ""
    },
    "NearbyInteraction. The framework does nothing in visionOS. Use availability checks to determine when services are present.": {
      "zh": "NearbyInteraction。该框架在 visionOS 中不起作用。使用可用性检查来确认服务是否存在。",
      "tips": ""
    },
    "PushToTalk. Push to Talk services are unavailable. Check for errors when creating a PTChannelManager.": {
      "zh": "PushToTalk。一键通话服务不可用。请检查创建 PTChannelManager 时的错误。",
      "tips": ""
    },
    "SafariServices. A link that presents a SFSafariViewController now opens a new scene in the Safari app.": {
      "zh": "SafariServices。显示 SFSafariViewController 的链接会在 Safari 应用程序中打开一个新场景。",
      "tips": ""
    },
    "UIKit. The system reports a maximum of two simultaneous touch inputs — one for each of the person’s hands. All system gesture recognizers handle these inputs correctly, including for zoom and rotation gestures that require multiple fingers. If you have custom gesture recognizers that require more than two fingers, update them to support only one or two touches in visionOS.": {
      "zh": "UIKit。 系统最多可同时反馈两个触控输入 - 双手各一个。所有系统手势识别器都能正确处理这些输入，包括需要多手指操作的缩放和旋转手势。如果你有需要两个手指以上的自定义手势，请在 visionOS 中将其更新为只有一个或两个触控的手势。",
      "tips": ""
    },
    "VisionKit. The DataScannerViewController APIs are unavailable, but other features are still available.": {
      "zh": "VisionKit。 DataScannerViewController API 不可用，但其他功能仍然可用。",
      "tips": ""
    },
    "WatchConnectivity. The framework supports connections only between an iPhone and Apple Watch. Use availability checks to determine when services are available.": {
      "zh": "WatchConnectivity。该框架仅支持 iPhone 与 Apple Watch 之间的连接。使用可用性检查确认服务何时可用。",
      "tips": ""
    },
    "For additional information about how to isolate code to the iOS version of your app, see Running code on a specific platform or OS version.": {
      "zh": "有关如何将代码隔离到 iOS 应用版本的更多信息，请参阅在特定平台或操作系统版本上运行代码。",
      "tips": ""
    },
    "Update your interface to take advantage of visionOS features": {
      "zh": "更新界面以更好地利用 visionOS 功能",
      "tips": ""
    },
    "After your existing code runs correctly in visionOS, look for ways to improve the experience you offer on the platform. In visionOS, you can display content using more than just windows. Think about ways to incorporate the following elements into your interface:": {
      "zh": "当你的现有代码在 visionOS 中正常运行后，请设法改善你在该平台上提供的体验。在 visionOS 中，你可以使用窗口之外的方式来显示内容。请考虑如何将以下元素融入你的界面：",
      "tips": ""
    },
    "Depth. Many SwiftUI and UIKit views use visual effects to add depth. Look for similar ways to incorporate depth into your own custom views.": {
      "zh": "深度。许多 SwiftUI 和 UIKit 视图都使用视觉效果来增加深度。请寻找类似的方法，将深度元素融入进你的自定义视图中。",
      "tips": ""
    },
    "3D content. Think about where you might incorporate 3D models and shapes into your content. Use RealityKit to implement your content, and a RealityView to present that content from your app. See Adding 3D content to your app.": {
      "zh": "3D 内容。想想在哪些内容中可以加入 3D 模型和形状。使用 RealityKit 实现你的内容，并使用 RealityView 从你的应用中展示这些内容。请参阅在应用中添加 3D 内容。",
      "tips": ""
    },
    "Immersive experiences. Present a space to immerse someone in your app’s content. Spaces let you place content anywhere in a person’s surroundings. You can also create fully immersive experiences that display only your app’s content. See Creating fully immersive experiences in your app.": {
      "zh": "沉浸式体验。显示一个空间，让用户沉浸在你的应用内容中。空间可以让你将内容呈现在用户周围的任何地方。你还可以创建只显示当前应用内容的完全沉浸式体验。请参阅在应用中创建完全沉浸式体验。",
      "tips": ""
    },
    "Interactions with someone’s surroundings. Use ARKit to facilitate interactions between your content and the surroundings. For example, detect planar surfaces to use as anchor points for your content. See ARKit.": {
      "zh": "与周围环境的互动。使用 ARKit 可促进你的内容与周围环境之间的互动。例如，检测平面以用作内容的锚点。请参阅 ARKit。",
      "tips": ""
    },
    "If you built your interface using UIKit, you can still load iOS storyboards into your app, but you can’t customize your interface for visionOS or include 3D content. To include visionOS content in your app, programmatically add your SwiftUI views using UIHostingController or UIViewRepresentable. Alternatively, migrate the relevant parts of your interface to SwiftUI. Moving your interface to SwiftUI gives you less code to maintain and makes it easier to validate that your interface does what you want.": {
      "zh": "如果你使用 UIKit 构建了界面，你仍可将 iOS 故事板加载到你的应用中，但无法为 visionOS 定制界面或包含 3D 内容。要在应用中包含 visionOS 内容，请使用 UIHostingController 或 UIViewRepresentable 以编程方式添加 SwiftUI 视图。又或者，将界面的相关部分迁移到 SwiftUI。将界面迁移到 SwiftUI 会减少需要维护的代码，并更容易验证你的界面是否按你的需求运行。",
      "tips": ""
    },
    "For information about mixing SwiftUI and UIKit content, see UIKit integration in SwiftUI. For guidance on how best to incorporate depth and 3D elements in your interface, see Human Interface Guidelines.": {
      "zh": "关于同时使用 SwiftUI 和 UIKit 内容的更多信息，请参阅 SwiftUI 中的 UIKit 集成。有关如何最好地在界面中融入深度和 3D 元素的指南，请参阅人机界面指南。",
      "tips": ""
    },
    "Update your app’s assets": {
      "zh": "更新应用的素材资源",
      "tips": ""
    },
    "Add vector-based or high-resolution images to your project specifically to support visionOS. In visionOS, people can view your app’s content at different angles and different distances, so image pixels rarely line up with screen pixels. Vector-based images work best because they maintain their detail and crispness at any size. For bitmap-based images, use high-resolution images (@2x or better) to ensure your images retain detail at different sizes.": {
      "zh": "在你的项目中添加基于矢量或高分辨率的图像，以专门支持 visionOS。在 visionOS 中，用户可以从不同角度和不同距离观看应用的内容，因此图像像素很少与屏幕像素对齐。基于矢量的图像效果最佳，因为它们在任何尺寸下都能保持细节和清晰度。对于位图图像，请使用高分辨率图像（@2x 或更高），以确保图像在不同尺寸下都能保持细节。",
      "tips": ""
    },
    "For more information about designing images for your app, see Images in Human Interface Guidelines.": {
      "zh": "有关为应用设计图像的详细信息，请参阅人机界面指南中的图像章节。",
      "tips": ""
    },
    "Decide whether to port your app at all": {
      "zh": "决定是否移植应用",
      "tips": ""
    },
    "In some cases, it might not make sense to port your app for visionOS. For example, don’t port the following types of apps:": {
      "zh": "在某些情况下，将应用移植到 visionOS 可能并不合理。例如，请勿移植以下类型的应用：",
      "tips": ""
    },
    "Apps that act as containers for app extensions. This includes apps where the primary purpose is to deliver custom keyboard extensions, device drivers, sticker packs, SMS and MMS message filtering extensions, call directory extensions, or widgets.": {
      "zh": "作为应用扩展信息容器的应用。这包括了主要目的是提供自定义键盘扩展、设备驱动程序、贴纸包、短信和彩信过滤扩展、通话目录扩展或小组件的应用。",
      "tips": ""
    },
    "Movement-based apps. This includes apps that follow a person’s location changes, such as apps that offer turn-by-turn directions or navigation. It also includes apps that track body movements.": {
      "zh": "基于运动的应用。这包括了追踪用户位置变化的应用程序，如提供转弯指示或导航的应用程序。也包括了追踪身体运动的应用程序。",
      "tips": ""
    },
    "Selfie or photography apps. This includes apps where the primary purpose is to capture images or video from the device’s cameras.": {
      "zh": "自拍或摄影类应用。这包括以通过设备摄像头捕捉图像或视频为主要目的的应用程序。",
      "tips": ""
    },
    "If your app uses an unsupported feature but can function without it, you can still bring your app to visionOS. Remove features that aren’t available and focus on bringing the rest of your content to the platform. For example, if you have an app that lets people write down notes and take pictures to include with those notes, disable the picture-taking ability in visionOS but let people add text and incorporate images they already have.": {
      "zh": "如果你的应用使用了不支持的功能，但在没有该功能的情况下也能正常运行，你仍然可以将应用移植到 visionOS 中。移除不支持的功能，并专注于将其他内容移植到该平台。例如，如果你有一款应用可以让用户写下笔记并拍照放在笔记中，那么你可以在 visionOS 中禁用拍照功能，但允许用户添加文字并整合已有的图片。",
      "tips": ""
    }
  },
  "visionos/bringing-your-arkit-app-to-visionos": {
    "Bringing your ARKit app to visionOS": {
      "zh": "将 ARKit 应用移植到 visionOS",
      "tips": ""
    },
    "Update an iPadOS or iOS app that uses ARKit, and provide an equivalent experience in visionOS.": {
      "zh": "更新使用了 ARKit 的 iPadOS 或 iOS 应用，并在 visionOS 中提供相同的体验。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "If you use ARKit to create an augmented reality experience on iPhone or iPad, you need to rethink your use of that technology when bringing your app to visionOS. ARKit plays a crucial role in delivering your content to the display in iPadOS and iOS. In visionOS, you use ARKit only to acquire data about the person’s surroundings, and you do so using a different set of APIs.": {
      "zh": "如果你使用 ARKit 在 iPhone 或 iPad 上创建增强现实体验，那么在将你的应用移植到 visionOS 时，你需要重新考虑对该技术的使用。在 iPadOS 和 iOS 中，ARKit 在向显示屏交付内容方面发挥着至关重要的作用。而在 visionOS 中，你只能使用 ARKit 来获取有关用户周围环境的数据，而且使用的是一套不同的 API。",
      "tips": ""
    },
    "In visionOS, you don’t need a special view to display an augmented reality interface. Build windows with your app’s content using SwiftUI or UIKit. When you display those windows, visionOS places them in the person’s surroundings for you. If you want to control the placement of any 2D or 3D content in the person’s surroundings, build your content using SwiftUI and RealityKit.": {
      "zh": "在 visionOS 中，你不需要一个特殊的视图来显示增强现实界面。你只需使用 SwiftUI 或 UIKit 构建包含应用内容的窗口。当你显示这些窗口时，visionOS 会为你将它们放置在用户的周围环境中。如果你想控制用户的周围环境中任意 2D 或 3D 内容的位置，请使用 SwiftUI 和 RealityKit 构建你的内容。",
      "tips": ""
    },
    "When migrating your app to visionOS, reuse as much of your app’s existing content as you can. visionOS supports most of the same technologies as iOS, so you can reuse project assets, 3D models, and most custom views. Don’t reuse your app’s ARKit code or any code that relies on technologies visionOS doesn’t support.": {
      "zh": "在将应用迁移到 visionOS 时，请尽可能多地复用应用的当前内容。visionOS 支持与 iOS 相同的大多数技术，因此你可以重复使用项目素材、3D 模型和大多数自定义视图。但不要复用应用的 ARKit 代码或任何依赖于 visionOS 平台不支持技术的代码。",
      "tips": ""
    },
    "For general guidance on how to port apps to visionOS, see Bringing your existing apps to visionOS.": {
      "zh": "有关如何将应用移植到 visionOS 的一般指导，请参阅将现有应用移植到 visionOS。",
      "tips": ""
    },
    "Adopt technologies available in both iOS and visionOS": {
      "zh": "采用 iOS 和 visionOS 兼容的技术",
      "tips": ""
    },
    "To create a single app that runs in both iOS and visionOS, use technologies that are available on both platforms. While ARKit in iOS lets you create your interface using several different technologies, the preferred technologies in visionOS are SwiftUI and RealityKit. If you’re not currently using RealityKit for 3D content, consider switching to it before you start adding visionOS support. If you retain code that uses older technologies in your iOS app, you might need to re-create much of that code using RealityKit when migrating to visionOS.": {
      "zh": "要创建一个既可在 iOS 又可以在 visionOS 中运行的应用，请使用两个平台上兼容的技术。iOS 中的 ARKit 可让你使用多种不同的技术创建界面，而 visionOS 中的首选技术是 SwiftUI 和 RealityKit。如果你目前没有使用 RealityKit 来制作 3D 内容，请考虑在开始添加 visionOS 支持之前切换到 RealityKit。如果你的 iOS 应用中保留了使用旧技术的代码，那么在迁移到 visionOS 时，你可能需要使用 RealityKit 重新创建其中的大部分代码。",
      "tips": ""
    },
    "If you use Metal to draw your app’s content, you can bring your code to visionOS to create content for 2D views or to create fully immersive experiences. You can’t use Metal to create 3D content that integrates with the person’s surroundings. This restriction prevents apps from sampling pixels of the person’s surroundings, which might contain sensitive information. For information on how to create a fully immersive experience with Metal, see Drawing fully immersive content using Metal.": {
      "zh": "如果你使用 Metal 绘制应用的内容，你可以将代码移植到 visionOS，为 2D 视图创建内容或创建完全沉浸式体验。你不能使用 Metal 创建与用户周围环境相融合的 3D 内容。这一限制可防止应用对用户周围环境的像素进行采样，因为这些像素可能包含敏感信息。有关如何使用 Metal 创建完全沉浸式体验的信息，请参阅使用 Metal 绘制完全沉浸式内容。",
      "tips": ""
    },
    "Convert 3D assets to the USDZ format": {
      "zh": "将 3D 素材转换为 USDZ 格式",
      "tips": ""
    },
    "The recommended format for 3D assets in iOS and visionOS is USDZ. This format offers a compact single file for everything, including your models, textures, behaviors, physics, anchoring, and more. If you have assets that don’t use this format, use the Reality Converter tool that comes with Xcode to convert them for your project.": {
      "zh": "iOS 和 visionOS 中 3D 素材的推荐格式是 USDZ。这种格式为所有内容（包括模型、纹理、行为、物理、锚点等）提供了一个紧凑的单一文件。如果你的素材不使用这种格式，请使用 Xcode 自带的 Reality Converter 工具为你的项目进行转换。",
      "tips": ""
    },
    "When building 3D scenes for visionOS, use Reality Composer Pro to create your scenes that incorporate your USDZ assets. With Reality Composer Pro, you can import your USD files and edit them in place, nondestructively. If your iOS app applies custom materials to your assets, convert those materials to shader graphs in the app.": {
      "zh": "在为 visionOS 构建 3D 场景时，请使用 Reality Composer Pro 创建包含 USDZ 素材的场景。使用 Reality Composer Pro，你可以导入你的 USD 文件，并进行无损的原装编辑。如果你的 iOS 应用为你的素材添加了自定义材质，请在应用中将这些材质转换为着色器图形。",
      "tips": ""
    },
    "Although you can bring models and materials to your project using USDZ files, you can’t bring custom shaders you wrote using Metal. Replace any custom shader code with MaterialX shaders. Many digital content creation tools support the MaterialX standard, and let you create dynamic shaders and save them with your USDZ files. Reality Composer Pro and RealityKit support MaterialX shaders, and incorporate them with your other USDZ asset content. For more information about MaterialX, see https://materialx.org.": {
      "zh": "虽然你可以使用 USDZ 文件将模型和材质移植到项目，但你无法移植使用了 Metal 编写的自定义着色器。请使用 MaterialX 着色器替换任何自定义着色器代码。许多数字内容创建工具都支持 MaterialX 标准，可让你创建动态着色器并将其与 USDZ 文件一起保存。Reality Composer Pro 和 RealityKit 均支持 MaterialX 着色器，并将它们与其他 USDZ 素材内容结合在一起。有关 MaterialX 的更多信息，请参阅 https://materialx.org。",
      "tips": ""
    },
    "Update your interface to support visionOS": {
      "zh": "更新界面以支持 visionOS",
      "tips": ""
    },
    "In visionOS, you manage your app’s content, and the system handles the integration of that content with the person’s surroundings. This approach differs from iOS, where you use a special ARKit view to blend your content and the live camera content. Bringing your interface to visionOS therefore means you need to remove this special ARKit view and focus only on your content.": {
      "zh": "在 visionOS 中，你负责管理应用的内容，而系统会负责处理这些内容与用户周围环境的整合。这是与 iOS 不同的一点：在 iOS 中，你使用特殊的 ARKit 视图将你的内容与实时摄像头内容融合在一起。因此，将你的界面移植到 visionOS 意味着你需要移除这个特殊的 ARKit 视图，并只专注于你的内容。",
      "tips": ""
    },
    "If you can display your app’s content using SwiftUI or UIKit views, build a window with those views and present it from your visionOS app. If you use other technologies to incorporate 2D or 3D content into the person’s surroundings, make the following substitutions in the visionOS version of your app.": {
      "zh": "如果你可以使用 SwiftUI 或 UIKit 视图来显示应用的内容，那么就用这些视图构建一个窗口，并从你的 visionOS 应用中将其呈现出来。如果你使用其他技术将 2D 或 3D 内容融入用户周围的环境，请在你的应用的 visionOS 版本中进行以下替换。",
      "tips": ""
    },
    "If you create your AR experience using:": {
      "zh": "如果你使用了以下框架创建 AR 体验：",
      "tips": ""
    },
    "Update to:": {
      "zh": "更新为：",
      "tips": ""
    },
    "RealityKit and ARView": {
      "zh": "RealityKit 和 ARView",
      "tips": ""
    },
    "RealityKit and RealityView": {
      "zh": "RealityKit 和 RealityView",
      "tips": ""
    },
    "SceneKit and ARSCNView": {
      "zh": "SceneKit 和 ARSCNView",
      "tips": ""
    },
    "SpriteKit and ARSKView": {
      "zh": "SpriteKit 和 ARSKView",
      "tips": ""
    },
    "RealityKit or SwiftUI": {
      "zh": "RealityKit 或 SwiftUI",
      "tips": ""
    },
    "A RealityView is a SwiftUI view that manages the content and animations you create using RealityKit and Reality Composer Pro. You can add a RealityView to any of your app’s windows to display 2D or 3D content. You can also add the view to an ImmersiveSpace scene, which you use to integrate your RealityKit content into the person’s surroundings.": {
      "zh": "RealityView 是一种 SwiftUI 视图，用于管理使用 RealityKit 和 Reality Composer Pro 创建的内容和动画。你可以将 RealityView 添加到应用的任何窗口中，以显示 2D 或 3D 内容。你还可以将视图添加到 ImmersiveSpace 场景中，用来将 RealityKit 内容整合到用户的周围环境中。",
      "tips": ""
    },
    "Note": {
      "zh": "注意",
      "tips": ""
    },
    "You can load iOS storyboards into a visionOS app, but you can’t customize your interface for visionOS or include 3D content. If you want to share interface files between iOS and visionOS, adopt SwiftUI views or create your interface programmatically.": {
      "zh": "你可以将 iOS 故事板加载到 visionOS 应用中，但不能为 visionOS 定制界面或加入 3D 内容。如果你想在 iOS 和 visionOS 之间共享界面文件，请采用 SwiftUI 视图或以编程方式创建界面。",
      "tips": ""
    },
    "For more information about how to use RealityView and respond to interactions with your content, see Adding 3D content to your app.": {
      "zh": "有关如何使用 RealityView 以及如何响应与内容交互的更多信息，请参阅在应用中添加 3D 内容。",
      "tips": ""
    },
    "Replace your ARKit code": {
      "zh": "替换 ARKit 代码",
      "tips": ""
    },
    "ARKit provides different APIs for iOS and visionOS, and the way you use ARKit services on the platforms is also different. In iOS, you must use ARKit to put your content onscreen, and you can also use it to manage interactions between your content and a person’s surroundings. In visionOS, the system puts your content onscreen, so you only use ARKit to manage interactions with the surroundings. Because of this more limited usage, some apps don’t need ARKit at all in visionOS.": {
      "zh": "ARKit 为 iOS 和 visionOS 提供了不同的 API，在这两个平台上使用 ARKit 服务的方式也有所不同。在 iOS 中，你需要使用 ARKit 将内容投至屏幕上，也可以用它来管理内容与用户周围环境之间的交互。而在 visionOS 中，系统会将内容投至屏幕，因此你仅使用 ARKit 管理与周围环境的交互。由于这种使用方式比较有限，有些应用在 visionOS 中完全不需要 ARKit。",
      "tips": ""
    },
    "The only time you use ARKit in visionOS is when you need one of the following services:": {
      "zh": "只有在需要以下服务时，你才会在 visionOS 中使用 ARKit：",
      "tips": ""
    },
    "Plane detection": {
      "zh": "平面检测",
      "tips": ""
    },
    "Image tracking": {
      "zh": "图像追踪",
      "tips": ""
    },
    "Scene reconstruction": {
      "zh": "场景重建",
      "tips": ""
    },
    "Hand tracking": {
      "zh": "手部追踪",
      "tips": ""
    },
    "World tracking and device-pose prediction": {
      "zh": "世界追踪和设备姿态预测",
      "tips": ""
    },
    "Use plane detection, image tracking, and scene reconstruction to facilitate interactions between your app’s virtual content and real-world items. For example, use plane detection to detect a tabletop on which to place your content. Use world tracking to record anchors that you want to persist between launches of your app. Use hand tracking if your app requires custom hands-based input.": {
      "zh": "使用平面检测、图像追踪和场景重建来促进应用的虚拟内容与现实世界物品之间的交互。例如，使用平面检测来检测放置内容的桌面。使用世界追踪来记录在应用重启时需要保存的锚点。如果你的应用需要基于手的自定义输入，使用手部追踪。",
      "tips": ""
    },
    "To start ARKit services in your app, create an ARKitSession object and run it with the data providers for each service. Unlike ARKit in iOS, services in visionOS are independent of one another, and you can start and stop each one at any time. The following example shows how to detect horizontal and vertical planes. Data providers deliver new information using an asynchronous sequence.": {
      "zh": "要在应用中启动 ARKit 服务，请创建一个 ARKitSession 对象，并与每个服务的数据提供源一起运行。与 iOS 中的 ARKit 不同，visionOS 中的服务彼此独立，你可以随时启动或停止单个服务。下面的示例展示了如何检测水平和垂直平面。数据提供源使用异步序列传递新的信息。",
      "tips": ""
    },
    "If you use the world-tracking data provider in visionOS, ARKit automatically persists the anchors you add to your app’s content. You don’t need to persist these anchors yourself.": {
      "zh": "如果你使用了 visionOS 中的世界追踪数据提供源，ARKit 会自动保存你添加到应用内容中的锚点。你无需自己保存这些锚点。",
      "tips": ""
    },
    "For more information about how to use ARKit, see ARKit.": {
      "zh": "有关如何使用 ARKit 的更多信息，请参阅 ARKit。",
      "tips": ""
    },
    "Isolate ARKit features not available in visionOS": {
      "zh": "隔离在 visionOS 中不可用的 ARKit 功能",
      "tips": ""
    },
    "If your app uses ARKit features that aren’t present in visionOS, isolate that code to the iOS version of your app. The following features are available in iOS, but don’t have an equivalent in visionOS:": {
      "zh": "如果你的应用使用了 visionOS 中没有的 ARKit 功能，请将该代码隔离到 iOS 版本的应用中。以下功能在 iOS 中可用，但在 visionOS 中没有相应的功能：",
      "tips": ""
    },
    "Face tracking": {
      "zh": "面部追踪",
      "tips": ""
    },
    "Body tracking": {
      "zh": "身体追踪",
      "tips": ""
    },
    "Geotracking and placing anchors using a latitude and longitude": {
      "zh": "地理追踪和使用经纬度放置锚点",
      "tips": ""
    },
    "Object detection": {
      "zh": "物体检测",
      "tips": ""
    },
    "App Clip Code detection": {
      "zh": "应用剪辑代码检测",
      "tips": ""
    },
    "Video frame post-processing": {
      "zh": "视频帧后处理",
      "tips": ""
    },
    "Although whole body tracking isn’t available in visionOS, you can track the hands of the person wearing the device. Hand gestures are an important way of interacting with content in visionOS. SwiftUI handles common types of interactions like taps and drags, but you can use custom hand tracking for more complex gestures your app supports.": {
      "zh": "虽然 visionOS 中不提供全身追踪功能，但可以追踪佩戴设备用户的双手。在 visionOS 中，手势是与内容交互的重要方式。SwiftUI 可处理常见类型的交互，如点击和拖动，但你也可以使用自定义手势追踪来实现应用支持的复杂手势。",
      "tips": ""
    },
    "If you use ARKit raycasting in iOS to detect interactions with objects in the person’s surroundings, you might not need that code in visionOS. SwiftUI and RealityKit handle both direct and indirect interactions with your app’s content in 3D space, eliminating the need for raycasting in many situations. In other situations, you can use the features of ARKit and RealityKit to manage interactions with your content. For example, you might use ARKit hand tracking to determine where someone is pointing in the scene, and use scene reconstruction to build a mesh you can integrate into your RealityKit content.": {
      "zh": "如果你在 iOS 中使用 ARKit 射线来检测与用户周围环境中的物体的交互，那么你可能不需要在 visionOS 中使用该代码。SwiftUI 和 RealityKit 可在 3D 空间中处理与应用内容的直接和间接交互，因此在很多情况下都无需进行射线检测。在其他情况下，你可以使用 ARKit 和 RealityKit 的功能来管理与内容的交互。例如，你可以使用 ARKit 的手部追踪功能来确定用户在场景中的指向，然后使用场景重建功能来构建一个网格，并将其集成到 RealityKit 内容中。",
      "tips": ""
    }
  },
  "visionos/capturing-video-from-your-visionos-device": {
    "Capturing video from Apple Vision Pro for 2D viewing": {
      "zh": "",
      "tips": ""
    },
    "Record high-quality video of your visionOS app and its surroundings for app previews.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Use short videos and screenshots of your visionOS app to showcase your user interface, highlight functionality, and demonstrate usage. Help people understand what to expect from an immersive experience by recording content from the device that includes your app and its surroundings.": {
      "zh": "",
      "tips": ""
    },
    "The system renders content with spacial effects and optimizations for viewing during immersive experiences. To produce high-resolution content for people to view on 2D displays, the system needs to render without these effects and drop some optimizations. Use Developer Capture in Reality Composer Pro to notify the system to reconfigure rendering, and capture up to 60 seconds of high-resolution video, including sound, from Apple Vision Pro.": {
      "zh": "",
      "tips": ""
    },
    "Pair your Apple Vision Pro to Xcode": {
      "zh": "",
      "tips": ""
    },
    "Before capturing video from your device, pair it to a Mac that has Xcode and the visionOS SDK installed. For instructions on pairing your device, see Running your app in Simulator or on a device.": {
      "zh": "",
      "tips": ""
    },
    "Prepare to capture your app and its surroundings": {
      "zh": "",
      "tips": ""
    },
    "Select a well-lit location that is free from clutter. Avoid including objects that might get in the way of your app‘s windows and 3D content or distract the audience. Include enough detail in the scene to provide context and anchoring points. Consider your surroundings and avoid material that you don’t have permission to capture. This can include people, screens, branded products, logos, artwork, and other intellectual property.": {
      "zh": "",
      "tips": ""
    },
    "Use the version of your app that you intend to share with your audience. Build and install your app using a release configuration. This configuration enables code optimizations for better runtime performance and disables the generation of debugging information. Debug configurations typically disable code optimizations and might include UI you donʼt intend to share. Don’t use them to record video for previews you intend to share. Build schemes manage the build configuration Xcode uses during build actions, for more information see Customizing the build schemes for a project.": {
      "zh": "",
      "tips": ""
    },
    "Plan the tasks you intend to capture ahead of time and keep them short and focused. Launch the app and get the app into the state you need before you begin the capture. Reduce unnecessary processing overhead on the visionOS device by quiting other apps and avoiding background tasks.": {
      "zh": "",
      "tips": ""
    },
    "Record your capture": {
      "zh": "",
      "tips": ""
    },
    "To begin capturing video from the device:": {
      "zh": "",
      "tips": ""
    },
    "Launch Reality Composer Pro. Choose Open Developer Tool > Reality Composer Pro from the Xcode menu.": {
      "zh": "",
      "tips": ""
    },
    "Choose File > Developer Capture to bring up the Developer Capture dialog.": {
      "zh": "",
      "tips": ""
    },
    "Select the device to capture from the pop-up menu.": {
      "zh": "",
      "tips": ""
    },
    "If you see the message “Preparing, wait for the device to be ready”. You can click the info button that appears to the right of the popup menu for more information.": {
      "zh": "",
      "tips": ""
    },
    "Click the record button to begin the countdown timer.": {
      "zh": "",
      "tips": ""
    },
    "Clicking the record button starts a countdown. When the countdown reaches 0, the capture session begins. As the capture process happens, the video changes because the system reconfigures to render content for viewing in 2D. You might notice reduced responsiveness from the device during the session as it devotes more processing to render and capture the video.": {
      "zh": "",
      "tips": ""
    },
    "Perform the interactions you want to record on the device. Keep relevant content centered and in frame. The aspect ratio of the video you capture crops content that appears at the sides of an experience. Keep your head stable, and use slow, steady movement to transition the focus of the device when necessary. Small movements get amplified and might be jarring to the audience.": {
      "zh": "",
      "tips": ""
    },
    "Click the record button again from your Mac to end the capture session. The session ends on its own if the elapsed time exceeds 60 seconds.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "To begin a capture, the device must have a stable connection to your Mac and start at low power and thermal levels to stay below thresholds necessary to achieve consistent frame rates. When capturing multiple sessions, you might need to wait between each session.": {
      "zh": "",
      "tips": ""
    },
    "Review the captured video file": {
      "zh": "",
      "tips": ""
    },
    "Each recording session creates a QuickTime Movie file (.mov) and saves it to the desktop of your Mac. The file includes video captured at 30 FPS using 10-bit HEVC in HDTV Rec. 709 color space with system audio recorded in 32-bit floating-point linear PCM.": {
      "zh": "",
      "tips": ""
    },
    "Review the video to make sure that it includes all the content you planned and it doesn’t include any unexpected elements. Ensure that the transitions and animations are smooth and frame rates are consistent.": {
      "zh": "",
      "tips": ""
    },
    "You might want to use additional video-editing tools to trim, edit, and apply post-processing, such as stabilization, to the video to create a high-quality preview. Select frames from the video you capture to use as screenshots.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/checking-whether-your-app-is-compatible-with-visionos": {
    "Checking whether your existing app is compatible with visionOS": {
      "zh": "检查现有应用是否与 visionOS 兼容",
      "tips": ""
    },
    "Determine whether your existing iOS or iPadOS app runs as is in visionOS or requires modifications to handle platform differences.": {
      "zh": "确认你现有的 iOS 或 iPadOS 应用能否原封不动地在 visionOS 中正常运行，还是需要进行修改以处理平台差异。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "visionOS runs compatible iPad and iPhone apps to provide continuous access to existing content right away. visionOS supports most of the same technologies as iOS, so many apps built to run on iPad or iPhone can run unmodified on visionOS devices. When a compatible app runs in visionOS, it retains the same appearance it had in iPadOS or iOS, and its content appears in a window in the person’s surroundings.": {
      "zh": "visionOS 支持大多数与 iOS 相同的技术，因此许多专为在 iPad 或 iPhone 上运行而开发的应用都可以不经修改地在 visionOS 设备上运行。当兼容的应用在 visionOS 中运行时，它将保留在 iPadOS 或 iOS 中的外观，并且其内容会显示在用户周围环境的窗口中。",
      "tips": ""
    },
    "If you have an app in the iOS App Store, try downloading it and running it on Apple Vision Pro. If you run into issues, use Xcode to identify and fix them. If you built your app using the iOS SDK, Xcode 15 and later automatically adds a Designed for iPad runtime destination to your project. Use this destination to run your app and test its compatibility in visionOS. You can test most of your app’s core functionality in Simulator, but some features are available only on a device.": {
      "zh": "如果你在 iOS App Store 上发布了一款应用，请尝试下载并在 Apple Vision Pro 上运行。如果遇到问题，请使用 Xcode 进行识别和修复。如果你使用 iOS SDK 构建了应用，Xcode 15 及更高版本会自动将“专为 iPad 设计”运行时目标添加到您的项目中。使用此目标运行你的应用并测试其在 visionOS 中的兼容性。你可以在模拟器中测试应用的大部分核心功能，但有些功能仅在设备上可用。",
      "tips": ""
    },
    "Determine whether a missing feature impacts your app": {
      "zh": "确认缺失的功能是否会影响你的应用",
      "tips": ""
    },
    "visionOS contains most of the same technologies as iPadOS and iOS, but there are some differences. In some cases, a feature you use in your app might not be available because of hardware differences or because of differences in how people use a visionOS device. As part of your testing, consider the impact of any missing features on your app’s overall experience. Whenever possible, work around missing features by disabling them or providing alternate ways to access the same content.": {
      "zh": "visionOS 包含与 iPadOS 和 iOS 相同的大部分技术，但也存在一些差异。在某些情况下，由于硬件差异或人们使用 visionOS 设备的方式不同，你在应用中使用的某项功能可能无法使用。在测试的过程中，请考虑任何缺失功能对整体应用体验的影响。尽可能通过禁用缺失功能或提供访问相同内容的方法来替代缺失的功能。",
      "tips": ""
    },
    "The following features aren’t available in compatible iPad and iPhone apps in visionOS. Use framework APIs to determine when the features are available.": {
      "zh": "以下功能在兼容 visionOS 的 iPad 和 iPhone 应用中不可用。请使用框架 API 来确认这些功能何时可用。",
      "tips": ""
    },
    "Core Motion services": {
      "zh": "核心运动服务",
      "tips": ""
    },
    "Barometer and magnetometer data": {
      "zh": "气压计和磁力计数据",
      "tips": ""
    },
    "All location services except the standard service": {
      "zh": "除标准服务外的所有定位服务",
      "tips": ""
    },
    "HealthKit data": {
      "zh": "HealthKit 数据",
      "tips": ""
    },
    "Video or still-photo capture": {
      "zh": "视频或静态照片捕获",
      "tips": ""
    },
    "Camera features like auto-focus or flash": {
      "zh": "自动对焦或闪光灯等相机功能",
      "tips": ""
    },
    "Rear-facing (selfie) cameras": {
      "zh": "前置（自拍）摄像头",
      "tips": ""
    },
    "In some cases, a framework or feature behaves differently when your app runs in visionOS. Be prepared to handle these differences when your app runs in visionOS.": {
      "zh": "在某些情况下，当你的应用在 visionOS 中运行时，框架或功能的行为会有所不同。当你的应用在 visionOS 中运行时，请准备好处理这些差异。",
      "tips": ""
    },
    "AirPlay. visionOS hides AirPlay sharing buttons in system interfaces, and you can’t use AirPlay features from compatible apps.": {
      "zh": "AirPlay。visionOS 隐藏了系统界面中的 AirPlay 共享按钮，并且你无法使用兼容应用中的 AirPlay 功能。",
      "tips": ""
    },
    "App extensions. visionOS doesn’t load App Clips, device drivers, device activity monitors, keyboard extensions, Messages app extensions, photo-editing app extensions, SMS and call-reporting extensions, or widgets.": {
      "zh": "应用扩展。VisionOS 不会加载 App Clips、设备驱动程序、设备活动监视器、键盘扩展、信息应用扩展、照片编辑应用扩展、短信和通话报告扩展或小组件。",
      "tips": ""
    },
    "Apple Watch features. visionOS ignores watchOS apps and WatchKit extensions in your iOS or iPadOS app. The Watch Connectivity framework is unavailable. Face sharing in ClockKit does nothing in visionOS.": {
      "zh": "Apple Watch 功能。VisionOS 会忽略 iOS 或 iPadOS 应用中的 watchOS 应用和 WatchKit 扩展。Watch Connectivity 框架不可用。ClockKit 中的面部共享在 visionOS 中不起作用。",
      "tips": ""
    },
    "Audio and video. visionOS doesn’t support Picture in Picture or AV routing features. Check the availability of video features before using them. Be prepared for audio playback to stop automatically when your app moves to the background.": {
      "zh": "音频和视频。visionOS 不支持画中画或 AV 路由功能。在使用视频功能前，请检查其可用性。请准备好在应用移至后台时会自动停止音频播放。",
      "tips": ""
    },
    "Classroom features. Starting a test with Automatic Assessment Configuration reports an error.": {
      "zh": "课堂功能。使用自动评估配置启动测试时会报错。",
      "tips": ""
    },
    "Cellular telephony. Cellular services are unavailable. You can still implement Voice-over-IP (VoIP) services using CallKit and Core Telephony.": {
      "zh": "蜂窝电话。蜂窝网络服务不可用。你仍可使用 CallKit 和 Core Telephony 实施 IP语音（VoIP）服务。",
      "tips": ""
    },
    "Device management. Calls to the ManagedSettings and ManagedSettingsUI frameworks do nothing.": {
      "zh": "设备管理。调用 ManagedSettings 和 ManagedSettingsUI 框架没有效果。",
      "tips": ""
    },
    "Game controllers. visionOS delivers game controller events only when someone is looking at the app. To require a game controller as an input device for your app, add the GCRequiresControllerUserInteraction key with the visionOS value to your app’s Info.plist.": {
      "zh": "游戏控制器。visionOS 只有在有人正在查看应用时才会发送游戏控制器事件。如要将游戏控制器作为应用的输入设备，请将带有 visionOS 值的 GCRequiresControllerUserInteraction 键添加到应用的 Info.plist 中。",
      "tips": ""
    },
    "Handoff. visionOS doesn’t attempt to hand off user activities to other devices.": {
      "zh": "接力。visionOS 不会尝试将用户活动移交给其他设备。",
      "tips": ""
    },
    "Haptics. visionOS plays sounds instead of haptics.": {
      "zh": "触感反馈。visionOS 播放声音而非触觉。",
      "tips": ""
    },
    "HomeKit. You can’t add accessories using a QR code from a visionOS device.": {
      "zh": "HomeKit。你无法使用二维码从 visionOS 设备添加配件。",
      "tips": ""
    },
    "Metrics. You can use MetricKit to gather on-device diagnostic logs and generate reports, but you can’t gather metrics.": {
      "zh": "指标。你可以使用 MetricKit 收集设备上的诊断日志并生成报告，但无法收集指标。",
      "tips": ""
    },
    "Multi-Touch. The system reports a maximum of two simultaneous touch inputs — one for each of the person’s hands. All system gesture recognizers handle these inputs correctly, including for zoom and rotation gestures that require multiple fingers. If you have custom gesture recognizers that require more than two points of interaction, update them to support only one or two touches in visionOS.": {
      "zh": "多点触控。系统最多可同时报告两个触摸输入--用户的双手。所有系统手势识别器都能正确处理这些输入，包括需要多个手指的缩放和旋转手势。如果你的自定义手势识别器需要两个以上的交互点，请将其更新为在 visionOS 中仅支持一或两个触控。",
      "tips": ""
    },
    "Parental controls. Calls to the FamilyControls framework do nothing.": {
      "zh": "家长控制。调用 FamilyControls 框架不执行任何操作。",
      "tips": ""
    },
    "PencilKit. visionOS doesn’t report touches of type UITouch.TouchType.pencil, but it does report other types of touches.": {
      "zh": "PencilKit。visionOS 不会报告 UITouch.TouchType.pencil 类型的触摸，但会报告其他类型的触摸。",
      "tips": ""
    },
    "Push to Talk. Calls to the Push to Talk framework do nothing.": {
      "zh": "一键通话。调用 Push to Talk 框架不执行任何操作。",
      "tips": ""
    },
    "Safari Services. Links that present an SFSafariViewController open a Safari scene instead.": {
      "zh": "Safari 服务。显示 SFSafariViewController 的链接会打开 Safari 场景。",
      "tips": ""
    },
    "ScreenTime. Calls to the Screen Time framework do nothing.": {
      "zh": "屏幕时间。调用 Screen Time 框架不执行任何操作。",
      "tips": ""
    },
    "Sensor-related features. Calls to the SensorKit framework do nothing.": {
      "zh": "传感器相关功能。调用 SensorKit 框架不执行任何操作。",
      "tips": ""
    },
    "Social media. Calls to the Social framework do nothing.": {
      "zh": "社交媒体。调用 Social 框架时不执行任何操作。",
      "tips": ""
    },
    "System interfaces. Authorization prompts, Sign in with Apple prompts, and other system-provided interfaces run asynchronously outside of your app’s process. Because these interfaces don’t run modally in your app, your app might not receive immediate responses.": {
      "zh": "系统界面。授权提示、“使用 Apple 登录”提示和其他系统提供的界面会在应用进程之外异步运行。由于这些界面不在你的应用中以强制模式运行，因此你的应用可能无法收到即时响应。",
      "tips": ""
    },
    "Vehicle features. The system doesn’t call your app’s CarPlay code. Calls you make using CarKey do nothing.": {
      "zh": "车辆功能。系统不会调用你应用的 CarPlay 代码。你的 CarKey 调用不执行任何操作。",
      "tips": ""
    },
    "Vision. Data scanners do nothing in VisionKit.": {
      "zh": "视觉。数据扫描仪在 VisionKit 中不执行任何操作。",
      "tips": ""
    },
    "The version of ARKit in iOS is incompatible with the one in visionOS and visionOS can’t display windows that contain ARKit views. For information about how to bring an ARKit app to visionOS, see Bringing your ARKit app to visionOS.": {
      "zh": "iOS 中的 ARKit 版本与 visionOS 中的版本不兼容，因此 visionOS 无法显示包含 ARKit 视图的窗口。有关如何将 ARKit 应用移植到 visionOS 的信息，请参阅将 ARKit 应用移植到 visionOS。",
      "tips": ""
    },
    "For details about how to handle missing features in your code, see Making your existing app compatible with visionOS.": {
      "zh": "有关如何处理代码中缺失功能的详细信息，请参阅使现有应用与 visionOS 兼容。",
      "tips": ""
    },
    "Test specific scenarios before uploading your app": {
      "zh": "在上传应用之前测试特定场景",
      "tips": ""
    },
    "The following App Store features for iOS continue to work when your app runs in visionOS:": {
      "zh": "当你的应用在 visionOS 中运行时，以下适用于 iOS 的 App Store 功能将继续有效：",
      "tips": ""
    },
    "In-app purchases and subscriptions": {
      "zh": "应用内购买和订阅",
      "tips": ""
    },
    "App capabilities and entitlements": {
      "zh": "应用权限和授权",
      "tips": ""
    },
    "On-demand resources": {
      "zh": "按需资源",
      "tips": ""
    },
    "App thinning": {
      "zh": "应用精简",
      "tips": ""
    },
    "When you use app thinning to optimize your app for different devices and operating systems, the App Store selects the resources and content that offer the best fit for visionOS devices. It then removes any other resources to create a streamlined installation of your app. When you export your app from Xcode 15 or later, you can test the thinning support using the visionOS virtual thinning target.": {
      "zh": "当你使用应用精简功能为不同的设备和操作系统优化你的应用时，App Store 会选择最适合 visionOS 设备的资源和内容。然后，它会移除任何其他资源，以创建一个精简的应用安装包。当你从 Xcode 15 或更高版本导出应用时，可以使用 visionOS 虚拟精简目标来测试应用精简功能。",
      "tips": ""
    },
    "When you’re ready to distribute your app, create an archive and export it using the Ad-Hoc or Development distribution method. During the export process, Xcode creates an appropriately signed app for you to distribute to your testers. For more information, see Distributing your app to registered devices.": {
      "zh": "当你准备分发应用时，请创建一个存档，然后使用“Ad-Hoc”或“Development”分发方法导出。在导出过程中，Xcode 会创建一个经过适当签名的应用，供你分发给测试人员。详细信息请参阅将应用分发到已注册设备。",
      "tips": ""
    },
    "Update your app information in App Store Connect": {
      "zh": "在 App Store Connect 中更新应用信息",
      "tips": ""
    },
    "The App Store makes compatible iPad and iPhone apps available in visionOS automatically after you sign the updated Apple Developer Program License Agreement. If you don’t want your app to run on Apple Vision Pro, change your app’s availability in App Store Connect.": {
      "zh": "在你签署更新的 Apple Developer Program License Agreement 后，App Store 会自动在 visionOS 中提供兼容的 iPad 和 iPhone 应用。如果你不想让你的应用在 Apple Vision Pro 上运行，请在 App Store Connect 中更改应用的可用性。",
      "tips": ""
    },
    "Select your app in App Store Connect.": {
      "zh": "在 App Store Connect 中选择你的应用。",
      "tips": ""
    },
    "Navigate to the Pricing and Availability information.": {
      "zh": "导航至定价和可用性信息。",
      "tips": ""
    },
    "Disable the “Make this app available on Apple Vision Pro” option.": {
      "zh": "禁用“在 Apple Vision Pro 上提供此应用”选项。",
      "tips": ""
    },
    "When you remove your app’s availability for Apple Vision Pro, the App Store stops making your iOS app available for visionOS. People who already downloaded your iOS app can still run it in visionOS, but they can’t download it again. This setting doesn’t affect the version of your app built using the visionOS SDK.": {
      "zh": "当你移除应用在 Apple Vision Pro 上的可用性后，App Store 就会停止提供适用于 visionOS 的 iOS 应用。已经下载过你的 iOS 应用的用户仍然可以在 visionOS 中运行它，但他们无法再次下载。此设置不会影响使用 visionOS SDK 构建的应用版本。",
      "tips": ""
    }
  },
  "visionos/configuring-your-app-icon": {
    "Configuring your app icon": {
      "zh": "",
      "tips": ""
    },
    "Add app icon variations to represent your app in places such as Settings, search results, and the App Store.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Every app has a distinct app icon that communicates the app’s purpose and makes it easy to recognize throughout the system. Apps require multiple variations of the app icon to look great in different contexts. Xcode can help generate these variations for you using a single high-resolution image, or you can configure your app icon variations by using an app icon’s image set in your project’s asset catalog. visionOS and tvOS app icons are made up of multiple stacked image layers you configure in your project’s asset catalog.": {
      "zh": "",
      "tips": ""
    },
    "Create an app icon": {
      "zh": "",
      "tips": ""
    },
    "When you create your project from a template, it automatically includes a default asset catalog (Assets.xcassets) that contains the AppIcon. If you don’t have a default asset catalog or existing AppIcon or you want to provide an alternate, you can add an app icon to an asset catalog manually:": {
      "zh": "",
      "tips": ""
    },
    "In the Project navigator, select an asset catalog.": {
      "zh": "",
      "tips": ""
    },
    "Click the Add button (+) at the bottom of the outline view.": {
      "zh": "",
      "tips": ""
    },
    "In the pop-up menu, choose OS variant > OS variant App Icon. Xcode creates a new app icon set or image stack with the name AppIcon.": {
      "zh": "",
      "tips": ""
    },
    "Specify app icon variations": {
      "zh": "",
      "tips": ""
    },
    "Variations of your app icon appear throughout the system in places like the Home View, Settings, and search results. In Xcode 14 and later, for iOS, macOS or watchOS apps, you can generate all variations of your icon using a single 1024×1024 pixel image or provide variations for all sizes. Although using a single size is the default behavior for new apps or new icons in the asset catalog, you might need all sizes in order to include detail in larger variants and simplify as app size decreases. If you have an existing project that provides multiple variants, consider providing a single size when that is all your icon requires.": {
      "zh": "",
      "tips": ""
    },
    "For each platform your app supports, choose between using a single size and providing all sizes in the Asset Catalog:": {
      "zh": "",
      "tips": ""
    },
    "In the Asset Catalog, select the icon.": {
      "zh": "",
      "tips": ""
    },
    "To view and edit attributes, select Inspectors > Attributes from Xcode’s View menu.": {
      "zh": "",
      "tips": ""
    },
    "Select Single Size or All Sizes from the pop-up menu for the platform you want to change.": {
      "zh": "",
      "tips": ""
    },
    "For each platform your app supports, add a single image that Xcode can use to generate your icon variations, or add an image for each icon variation of an icon set in the Asset Catalog:": {
      "zh": "",
      "tips": ""
    },
    "From the Finder, drag image variations of the app icon to the image wells in the detail area of the Asset Catalog in Xcode that match their resolutions and use cases. visionOS and tvOS app icons combine a stack of multiple image layers to create a sense of depth. For tvOS apps, the asset catalog contains an App Icon & Top Shelf Image folder with the different app icon and launch image sets.": {
      "zh": "",
      "tips": ""
    },
    "For general design guidance, see App icons. For platform-specific design guidance:": {
      "zh": "",
      "tips": ""
    },
    "visionOS": {
      "zh": "",
      "tips": ""
    },
    "iOS": {
      "zh": "",
      "tips": ""
    },
    "macOS": {
      "zh": "",
      "tips": ""
    },
    "tvOS": {
      "zh": "",
      "tips": ""
    },
    "watchOS": {
      "zh": "",
      "tips": ""
    },
    "Configure the layers of an image stack": {
      "zh": "",
      "tips": ""
    },
    "By default, visionOS and tvOS app icons are constructed with three layers. This is the maximum number of layers visionOS icons support but you can use up to five layers when constructing tvOS icons. To add a layer, Click the Add button (+), choose OS variant > OS variant App Icon Layer. To remove a layer, select the layer and click the Remove button (-).": {
      "zh": "",
      "tips": ""
    },
    "Add images to each layer by dragging them from the Finder into the image wells in the detail area of the Asset Catalog in Xcode. For information on the use of layers, see App icons visionOS and tvOS.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "You can use Parallax Previewer app or Parallax Exporter plug-in to create and preview Layer Source Representation (.lsr and .xlsr) files that you can import into your Asset Catalog in Xcode. Save your file in the LSR file format to import a tvOS icon into Xcode, and save in the XLSR file format to import a visionOS icon. Download these from the Apple Design Resources site.": {
      "zh": "",
      "tips": ""
    },
    "Specify an App Store icon": {
      "zh": "",
      "tips": ""
    },
    "If you distribute your app through the App Store, you must provide app icon imagery to use in the App Store. In the Project navigator, select an asset catalog and add icon images to the appropriate image wells in an app icon set or image stack. The App Store image well location varies by platform.": {
      "zh": "",
      "tips": ""
    },
    "Platform": {
      "zh": "",
      "tips": ""
    },
    "App Store icon location": {
      "zh": "",
      "tips": ""
    },
    "Drag an icon image to the iOS 1,024pt image well.": {
      "zh": "",
      "tips": ""
    },
    "iMessage": {
      "zh": "",
      "tips": ""
    },
    "For the iOS target, drag an icon image to the iOS 1,024pt image well in the AppIcon set. For the iMessage Extension target, drag an icon to the Messages App Store image well in the iMessage App Icon set.": {
      "zh": "",
      "tips": ""
    },
    "Sticker Pack": {
      "zh": "",
      "tips": ""
    },
    "Drag an icon image to the iOS 1,024pt image well and the Messages App Store image well.": {
      "zh": "",
      "tips": ""
    },
    "Drag an icon image to the App Store - 2x image well.": {
      "zh": "",
      "tips": ""
    },
    "Drag images to the image wells for the layers of your App Icon - App Store stack in the App Icon & Top Shelf Image folder. The App Store generates an icon from the layers of the image stack.": {
      "zh": "",
      "tips": ""
    },
    "Drag images to the image wells for the layers of your visionOS App Icon stack. The App Store generates an icon from the layers of the image stack.": {
      "zh": "",
      "tips": ""
    },
    "For the iOS target, drag an icon image to the iOS 1,024pt image well. For the WatchKit App target, drag an icon image to the watchOS image well.": {
      "zh": "",
      "tips": ""
    },
    "Change the default app icon set": {
      "zh": "",
      "tips": ""
    },
    "If you don’t create your project from a template, or you want to change your default app icon set, specify which one to use in your target’s build settings.": {
      "zh": "",
      "tips": ""
    },
    "In the Project navigator, select the project and in the project editor, select the target.": {
      "zh": "",
      "tips": ""
    },
    "In the App Icons and Launch Images section of the General pane, choose the app icon set from the App Icons Source pop-up menu.": {
      "zh": "",
      "tips": ""
    },
    "If you don’t select the Include all app icon assets option, Xcode only includes the app icon set you specify in the App Icons Source pop-up menu when it builds your app. You might leave this option unselected if you want to use a different icon for the Debug and Release builds of your app without including the Debug icon in your Release app bundle. You can specialize the app icon for the Debug and Release configurations by modifying the Primary App Icon Set Name build setting in the Build Settings tab.": {
      "zh": "",
      "tips": ""
    },
    "Xcode also includes any additional app icon sets you specify under the Alternate App Icon Sets build setting. Include any icon sets your app can select using setAlternateIconName(_:completionHandler:) or use in App Store product pages.": {
      "zh": "",
      "tips": ""
    },
    "For information on configuring tests that use icons in App Store Connect, see Product Page Optimization.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/configuring_your_app_for_media_playback": {
    "Configuring your app for media playback": {
      "zh": "",
      "tips": ""
    },
    "Configure apps to enable standard media playback behavior.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "When you build media playback apps for iOS, tvOS, and visionOS, you need to do additional configuration to enable the expected playback behavior. Configuring the audio experience and background operations helps ensure that your app’s audio works as intended. It also enables advanced features like AirPlay streaming and Picture in Picture playback on supported platforms.": {
      "zh": "",
      "tips": ""
    },
    "Configure the audio session": {
      "zh": "",
      "tips": ""
    },
    "Apple platforms, other than macOS which primarily leaves control to an app, provide an audio experience that the operating system manages. This enables the OS to provide a seamless audio experience to people as they switch between apps and receive high-priority audio requests such as phone or FaceTime calls.": {
      "zh": "",
      "tips": ""
    },
    "Your app uses an AVAudioSession to configure its audio behavior semantically, for example to have a primary purpose of playback or recording. You delegate the management of those details to the audio session, which ensures that the operating system can best manage a person’s audio experience.": {
      "zh": "",
      "tips": ""
    },
    "Your app automatically has an audio session that the system configures with this default behavior:": {
      "zh": "",
      "tips": ""
    },
    "Audio playback in your app silences other background audio": {
      "zh": "",
      "tips": ""
    },
    "Support for audio playback but not audio recording": {
      "zh": "",
      "tips": ""
    },
    "Ring/Silent switch set to silent mode in iOS silences app audio": {
      "zh": "",
      "tips": ""
    },
    "Locked device in iOS silences app audio": {
      "zh": "",
      "tips": ""
    },
    "The default audio session provides useful behavior, but typically doesn’t provide the experience and features you need when building a playback app. To add the required behavior, configure your app’s audio session category.": {
      "zh": "",
      "tips": ""
    },
    "An audio session category defines the general audio behavior your app requires. AVFoundation defines several audio session categories you can use, but the one most relevant for media playback apps is playback. This category indicates that media playback is a central feature of your app. When you specify this category, the system doesn’t silence your app’s audio when someone sets the Ring/Silent switch to silent mode in iOS only. Enabling this category means your app can play background audio if you’re using the Audio, AirPlay, and Picture in Picture background mode as explained in the section below.": {
      "zh": "",
      "tips": ""
    },
    "Use an AVAudioSession object to configure your app’s audio session. An audio session is a singleton object you use to set the audio session category, mode, and other settings. To configure the audio session for optimized playback of movies:": {
      "zh": "",
      "tips": ""
    },
    "To enable this category, activate the audio session using the setActive(_:options:) method.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "You can activate the audio session at any time after setting its category, but it’s recommended to defer this call until your app begins audio playback. Deferring the call ensures that you don’t prematurely interrupt any other background audio that may be in progress.": {
      "zh": "",
      "tips": ""
    },
    "Setting the category is the minimal interaction with an audio session, but other configuration options and features are available. For example, in visionOS, you customize a user’s spatial audio experience by configuring the audio session. For more information, see AVAudioSession.": {
      "zh": "",
      "tips": ""
    },
    "Configure the background modes": {
      "zh": "",
      "tips": ""
    },
    "The system requires you to enable certain capabilities to perform some background operations. A common capability that playback apps require is playing background audio. With this capability enabled, your app’s audio continues when people switch to another app or lock their iOS device. Your app also needs this capability to enable advanced playback features like AirPlay streaming and Picture in Picture playback on supported platforms.": {
      "zh": "",
      "tips": ""
    },
    "Use Xcode to configure this capability:": {
      "zh": "",
      "tips": ""
    },
    "Select your app’s target in Xcode and select the Signing & Capabilities tab.": {
      "zh": "",
      "tips": ""
    },
    "Click the + Capability button and add the Background Modes capability to the project.": {
      "zh": "",
      "tips": ""
    },
    "In the Background Modes interface, select the Audio, AirPlay, and Picture in Picture option under its list of background modes.": {
      "zh": "",
      "tips": ""
    },
    "With this mode enabled and your audio session configured, your app is ready to play background audio. In iOS, when you enable this option, your app can stream its content over AirPlay, and in iOS and tvOS it can use Picture in Picture playback.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/controlling_the_transport_behavior_of_a_player": {
    "Controlling the transport behavior of a player": {
      "zh": "",
      "tips": ""
    },
    "Play, pause, and seek through a media presentation.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "AVFoundation provides comprehensive support for playing media assets, including local and remote file-based media and also media streamed with HTTP Live Streaming. The framework models its media assets using the AVAsset class, which provides a consistent interface to load and inspect your media, regardless of its type or location. Use an AVPlayer object to play media assets in the form of AVPlayerItem objects, which model the dynamic state of an asset such as its currentTime().": {
      "zh": "",
      "tips": ""
    },
    "Understanding how to effectively use AVPlayer is essential for anyone building a custom player UI or otherwise requiring programmatic control of playback.": {
      "zh": "",
      "tips": ""
    },
    "Observe playback readiness": {
      "zh": "",
      "tips": ""
    },
    "When you create a player item, it starts with a status of AVPlayerItem.Status.unknown, which means the system hasn’t attempted to load its media for playback. Only when you associate the item with an AVPlayer object does the system begin loading an asset’s media.": {
      "zh": "",
      "tips": ""
    },
    "To know when the player item is ready for playback, observe the value of its status property. Add this observation before you call the player’s replaceCurrentItem(with:) method, because associating the player item with a player is the system’s cue to load the item’s media:": {
      "zh": "",
      "tips": ""
    },
    "When the player item reaches a AVPlayerItem.Status.readyToPlay state, present or enable your playback UI. Alternatively, if a failure occurs, show the appropriate status in the player.": {
      "zh": "",
      "tips": ""
    },
    "Control the playback rate": {
      "zh": "",
      "tips": ""
    },
    "A player provides the play() and pause() methods as its primary means of controlling its playback rate. When a player item is ready for playback, call the player’s play() method to request that playback begins at the defaultRate, which has an initial value of 1.0 (the natural rate). By default, a player automatically waits to start playback until it has sufficient media data available to minimize stalling. You can determine whether a player is in a paused, waiting to play, or playing state by observing its timeControlStatus value:": {
      "zh": "",
      "tips": ""
    },
    "Observe changes to the rate property by observing notifications of type rateDidChangeNotification. Observing this notification is similar to key-value observing the rate property, but provides additional information about the reason for the rate change. Retrieve the reason from the notification’s userInfo dictionary using the rateDidChangeReasonKey constant:": {
      "zh": "",
      "tips": ""
    },
    "Seek through the media timeline": {
      "zh": "",
      "tips": ""
    },
    "You can seek through a media timeline in several ways using the methods of AVPlayer and AVPlayerItem. The most common way is to use the player’s seek(to:) method, passing it a destination CMTime value. Call this method in an asynchronous context:": {
      "zh": "",
      "tips": ""
    },
    "You can call this method a single time to seek to the location, but you can also call it continuously such as when you use a Slider view.": {
      "zh": "",
      "tips": ""
    },
    "The seek(to:) method is a convenient way to quickly seek through your presentation, but it’s tuned for speed rather than precision. This means the actual time to which the player seeks may differ slightly from the time you request. If you need to implement precise seeking behavior, use the seek(to:toleranceBefore:toleranceAfter:) method, which lets you indicate the tolerated amount of deviation from your target time (before and after). For example, if you need to provide sample-accurate seeking behavior, specify tolerance values of zero:": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/creating-a-performance-plan-for-visionos-app": {
    "Creating a performance plan for your visionOS app": {
      "zh": "",
      "tips": ""
    },
    "Identify your app’s performance and power goals and create a plan to measure and assess them.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Performance tuning is an important part of the development process, regardless of platform. Performance tuning means making your app run as efficiently as possible, so it does more work in less time and with fewer system resources. Efficiency is especially important on devices that can support multiple apps in an immersive experience. Apps that consume too many resources, can push the device beyond thermal limits. When this occurs, the system takes steps to cool down to a more acceptable level. This can have a noticeable visual impact and be disorienting for the wearer.": {
      "zh": "",
      "tips": ""
    },
    "As you start development, set aggressive goals and evaluate progress throughout the development cycle. Automate the collection of performance metrics as much as possible and look at data over time to see if performance is improving or declining. When you detect a significant decrease in performance, take immediate steps to correct it. When you start fine-tuning early in development, you have more time to make needed changes to algorithms and approaches.": {
      "zh": "",
      "tips": ""
    },
    "For more information on performance tuning, see Improving your app’s performance.": {
      "zh": "",
      "tips": ""
    },
    "Set performance and power targets": {
      "zh": "",
      "tips": ""
    },
    "Performance isn’t a single metric that you measure and improve. Typically, you choose several metrics and set goals for each of them. For example, consider:": {
      "zh": "",
      "tips": ""
    },
    "Make sure your app launches quickly; this is your first chance to make a good impression.": {
      "zh": "",
      "tips": ""
    },
    "Your interface needs to respond quickly to interactions, even while doing other work. Minimize the time it takes to start tasks. For example, make sure audio and video start without noticeable delays.": {
      "zh": "",
      "tips": ""
    },
    "For an immersive experience with realtime rendering, it’s important to maintain consistently high frame rates. Help maintain these rates by avoiding unnecessary changes that result in more frequent updates to the shared render server. Measure things like update rates, stalls, and hangs in both the render server and your app. Only render the content you need, and optimize the textures and other resources you use during drawing.": {
      "zh": "",
      "tips": ""
    },
    "When the device begins to reach thermal limits, the system reduces CPU or GPU usage and performance degrades over time. Avoid this thermal ceiling by prioritizing and spreading out work, limiting the number of simultaneous threads your app maintains, and turning off hardware-related features like Core Location when you don’t need them.": {
      "zh": "",
      "tips": ""
    },
    "Make the app do as much as possible using the smallest amount of hardware resources. Minimize task-based overhead.": {
      "zh": "",
      "tips": ""
    },
    "Use as little free memory as possible. Don’t allocate or deallocate memory during critical operations, which might make your app appear slow.": {
      "zh": "",
      "tips": ""
    },
    "After you choose the metrics you want, set realistic goals and prioritize them, so you know which ones matter the most. Performance tuning often involves making tradeoffs between competing goals. For example, if you reduce CPU usage by caching computed data or pre-load assets to improve responsiveness, you increase your app’s memory usage. Make these kinds of tradeoffs carefully, and always measure the results of any changes to learn whether they were successful. In some cases, you might find the sacrifice isn’t worthwhile.": {
      "zh": "",
      "tips": ""
    },
    "Consider how people will use your app. If your app runs in the Shared Space, consider more conservative targets and goals for system resources. If you expect people to use your app for longer periods of time, factor this extended use into your targets and goals when choosing metrics.": {
      "zh": "",
      "tips": ""
    },
    "Identify the code flows and user scenarios to test": {
      "zh": "",
      "tips": ""
    },
    "After you choose the metrics to collect, decide which portions of your app to test. Choose features that are repeatable, measurable, and reliable to test. Repeatable automated tests allow you to compare the results and know the comparisons represent the exact same task. Focus on places where your app executes code, but don’t ignore places where your app hands off data to the system and waits. If your app spends a significant amount of time waiting for information, consider eliminating the requests altogether or batching them to achieve better performance.": {
      "zh": "",
      "tips": ""
    },
    "Focus your tuning efforts on the parts of your app that people use the most, or that have the most impact on overall system performance, including:": {
      "zh": "",
      "tips": ""
    },
    "User-facing workflows": {
      "zh": "",
      "tips": ""
    },
    "Key algorithms": {
      "zh": "",
      "tips": ""
    },
    "Task that allocate or deallocate memory": {
      "zh": "",
      "tips": ""
    },
    "Background and network-based tasks": {
      "zh": "",
      "tips": ""
    },
    "Custom Metal shaders": {
      "zh": "",
      "tips": ""
    },
    "Choose actions that people perform frequently or that correspond to important features. For example, if your app lets someone add a new contact, test the workflow for creating the contact, editing the contact, and saving the results. Test your app with a particular feature enabled and disabled to determine whether the feature is solely responsible for any performance impacts. Choose lightweight workflows such as how your app performs at idle time, and also heavyweight workflows, for example, ones that involve user interactions and your app’s responses. For launch times, gather metrics for both hot and cold launches — that is, when the app is already resident in memory and when it is not.": {
      "zh": "",
      "tips": ""
    },
    "Consider thermal and environmental factors": {
      "zh": "",
      "tips": ""
    },
    "Consider how environmental factors impact your app. The characteristics of your physical environment can affect system load and thermals of the device. Consider the effect that ambient room temperature, the presence of other people, and the number and type of real-world objects can have on the your app‘s algorithms. Try to test in different settings to get an idea of whether you need to optimize for these scenarios or not.": {
      "zh": "",
      "tips": ""
    },
    "Use Xcode’s thermal inducers to mimic the device hitting its thermal limits and consider how your app responds to fair, serious, and critical thermal notifications. You might need to have different performance goals when under thermal pressure, and prioritize optimizing for power or find ways to dynamically lower your app‘s complexity in response to thermal pressure to give a smoother experience, even if latency is a bit higher.": {
      "zh": "",
      "tips": ""
    },
    "Choose tools to collect performance data": {
      "zh": "",
      "tips": ""
    },
    "There are many tools and APIs you can use to collect performance-related data for your visionOS app. Use a variety of tools to make sure you have the data you need:": {
      "zh": "",
      "tips": ""
    },
    "Monitor the CPU, memory, disk and network gauges in the Debug navigator to track system resources utilization.": {
      "zh": "",
      "tips": ""
    },
    "Profile your app to gather performance data on most metrics. Instruments lets you profile your app’s code execution, find memory leaks, track memory allocations, analyze file-system or graphics performance, SwiftUI performance, and much more. Use the RealityKit Trace template to monitoring and investigate render server stalls and bottlenecks on visionOS.": {
      "zh": "",
      "tips": ""
    },
    "Use XCTest APIs to collect performance data.": {
      "zh": "",
      "tips": ""
    },
    "Use MetricKit to gather on-device app diagnostics and generate reports.": {
      "zh": "",
      "tips": ""
    },
    "Review diagnostic logs for hangs, disk and energy usage, and crashes in the Xcode Organizer.": {
      "zh": "",
      "tips": ""
    },
    "Review statistics on the contents of your RealityKit scenes. Use this information to optimize your 3D models and textures.": {
      "zh": "",
      "tips": ""
    },
    "Add signposts to your code to generate timing information you can view in Instruments. For more information, see Recording performance data.": {
      "zh": "",
      "tips": ""
    },
    "Include log messages to report significant events and relevant data for those events. For more information, see Generating log messages from your code.": {
      "zh": "",
      "tips": ""
    },
    "Get feedback from testers about their experiences with beta versions of your app. Fill out the Test Information page for your beta version, and request that testers provide feedback about the performance of your app.": {
      "zh": "",
      "tips": ""
    },
    "Profile on a physical device": {
      "zh": "",
      "tips": ""
    },
    "In general, profile and analyze performance on a physical device rather than in Simulator. Even if something works well in Simulator, it might not perform as well on devices for all use cases. Simulator doesn’t support some hardware features and APIs. There are differences in the rendering pipeline for Simulator running on macOS, so rendering performance characteristics will be different. Other pipelines such as input delivery and audio or video playback are also different. There are, however, some insights you can gain profiling in Simulator, such as CPU stalls, that help you spot areas to investigate and address.": {
      "zh": "",
      "tips": ""
    },
    "Build automated test cases and run them regularly": {
      "zh": "",
      "tips": ""
    },
    "Xcode comes with tools to help you automate the collection of performance data:": {
      "zh": "",
      "tips": ""
    },
    "Use the XCTest framework to build test cases to collect performance metrics. XCTest lets you gather several different metrics, including the time it takes to perform operations, the amount of CPU activity that occurs during the test, details about memory or storage use, and more.": {
      "zh": "",
      "tips": ""
    },
    "Use Instruments to collect metrics for specific interactions with your app. Record those interactions and play them back later to collect a new set of metrics.": {
      "zh": "",
      "tips": ""
    },
    "Write custom scripts to gather performance-related data using system command-line tools. Integrate these scripts into your project’s build process to automate their execution.": {
      "zh": "",
      "tips": ""
    },
    "Configure Xcode to run test cases each time you build your app, or create a separate target to run test cases or custom scripts on demand. Integrate your performance tests into your Xcode Cloud workflows, or your own custom continuous integration solution.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "Collect performance data using a production version of your app to obtain more accurate results. Debug builds contain additional code to support debugging operations and logging. You can collect data from debug builds too, but keep those metrics separate from production-build metrics.": {
      "zh": "",
      "tips": ""
    },
    "For information about how to write test cases for your app, see Testing your apps in Xcode. For information about how to automate testing with Xcode Cloud, see Xcode Cloud.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/creating-fully-immersive-experiences": {
    "Creating fully immersive experiences in your app": {
      "zh": "在应用中构建完全沉浸式的体验",
      "tips": ""
    },
    "Build fully immersive experiences by combining spaces with content you create using RealityKit or Metal.": {
      "zh": "将 RealityKit 或 Metal 创建的内容与空间结合，构建完全沉浸式的体验。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "A fully immersive experience replaces everything the person sees with custom content you create. You might use this type of experience to:": {
      "zh": "完全沉浸式的体验会用你创建的自定义内容替代用户看到的一切。你可以使用这种类型的体验来：",
      "tips": ""
    },
    "Offer a temporary transitional experience": {
      "zh": "提供一种临时的过渡性体验",
      "tips": ""
    },
    "Create a distraction-free space for your content": {
      "zh": "为你的内容创建一个不受干扰的空间",
      "tips": ""
    },
    "Implement a virtual reality (VR) game": {
      "zh": "实现虚拟现实(VR)游戏",
      "tips": ""
    },
    "Present a virtual world to explore": {
      "zh": "呈现一个可以探索的虚拟世界",
      "tips": ""
    },
    "With a fully immersive experience, you’re responsible for everything that appears onscreen. The system hides passthrough video and displays the content you provide, showing the person’s hands only when they come into view. To achieve the best performance, use RealityKit or Metal to create and animate your content.": {
      "zh": "在完全沉浸式的体验中，你要负责屏幕上显示的所有内容。系统隐藏摄像头捕捉到的实时视频，显示你提供的内容，只有当人出现在视野里时会显示人的手部。为了获得最佳性能，请使用 RealityKit 或 Metal 来创建内容并为其制作动画。",
      "tips": ""
    },
    "Typically, you combine a fully immersive experience with other types of experiences and provide transitions between them. When you display a window first and then offer controls to enter your immersive experience, you give people time to prepare for the transition. It also gives them the option to skip the experience if they prefer to use your app’s windows instead.": {
      "zh": "通常来讲，你将完全沉浸式的体验与其他类型的体验结合起来，并在它们之间提供过渡。当你先显示一个窗口，然后提供控件以进入你的沉浸式体验时，你为用户准备过渡提供了时间。这也为用户提供了选择，如果用户更愿意使用你的应用程序的窗口，可以跳过该体验。",
      "tips": ""
    },
    "Prepare someone for your app’s transitions": {
      "zh": "应用程序的过渡使用户做好准备",
      "tips": ""
    },
    "Give people control over when they enter or exit fully immersive experiences, and provide clear transitions to and from those experiences. Clear visual transitions make it easier to adjust to such a large change. Sudden transitions might be disorienting, unpleasant, or make the person think something went wrong.": {
      "zh": "让用户有权控制何时进入或退出沉浸式的体验，并为这些体验提供明确的过渡。清晰的视觉过渡让用户更容易适应如此巨大的变化。突然的过渡可能会让人感到迷失、不愉快，或让人认为出现了问题。",
      "tips": ""
    },
    "At launch time, display windows or other content that allows the person to see their surroundings. Add controls to that content to initiate the transition to the fully immersive experience, and provide a clear indication of what the controls do. Inside your experience, provide clear controls and instructions on how to exit the experience.": {
      "zh": "在启动时，显示窗口或其他内容，让用户能够看到周围环境。向该内容添加控件，以启动进入完全沉浸式体验的过渡，并清晰指出控件的功能。在用户的体验中，提供清晰的关于如何退出体验的控件和说明。",
      "tips": ""
    },
    "Warning": {
      "zh": "警告",
      "tips": ""
    },
    "When you start a fully immersive experience, visionOS defines a system boundary that extends 1.5 meters from the initial position of the person’s head. If their head moves outside of that zone, the system automatically stops the immersive experience and turns on the external video again. This feature is an assistant to help prevent someone from colliding with objects.": {
      "zh": "当你启动完全沉浸式体验时，visionOS 定义了一个系统边界，其范围从用户头部的初始位置延伸 1.5 米。如果用户的头部移动到该区域之外，系统会自动停止沉浸式体验并重新打开外部视频。这个功能有助于防止用户撞到物体。",
      "tips": ""
    },
    "For guidelines on how to design fully immersive experiences, see Human Interface Guidelines.": {
      "zh": "有关如何设计完全沉浸式体验的指南，请阅读 [人机界面指南](https://developer.apple.com/design/human-interface-guidelines)。",
      "tips": ""
    },
    "Open an immersive space": {
      "zh": "打开一个沉浸式空间",
      "tips": ""
    },
    "To create a fully immersive experience, open an ImmersiveSpace and set its style to full. An immersive space is a type of SwiftUI scene that lets you place content anywhere in the person’s surroundings. Applying the full style to the scene tells the system to hide passthrough video and display only your app’s content.": {
      "zh": "要创建完全沉浸式的体验，请打开一个 [ImmersiveSpace](https://developer.apple.com/documentation/SwiftUI/ImmersiveSpace) 并将其样式设置为 [全屏](https://developer.apple.com/documentation/SwiftUI/ImmersionStyle/full)。沉浸式空间是一种 SwiftUI scene，允许你将内容放置在个体周围的任何地方。将 [全屏](https://developer.apple.com/documentation/SwiftUI/ImmersionStyle/full) 样式应用于场景会告知系统隐藏摄像头捕捉到的实时视频，并仅显示你应用程序的内容。",
      "tips": ""
    },
    "Declare spaces in the body property of your app object, or anywhere you manage SwiftUI scenes. The following example shows an app with a main window and a fully immersive space. At launch time, the app displays the window.": {
      "zh": "在你的应用程序对象的 [body](https://developer.apple.com/documentation/SwiftUI/App/body-swift.property) 属性中声明空间，或者在你管理 SwiftUI scenes 的任何地方声明。以下示例显示了一个具有主窗口和一个完全沉浸式空间的应用程序。在启动时，应用程序显示主窗口。",
      "tips": ""
    },
    "To display an ImmersiveSpace, open it using the openImmersiveSpace action, which you obtain from the SwiftUI environment. This action runs asynchronously and uses the provided information to find and initialize your scene. The following example shows a button that opens the space with the solarSystem identifier:": {
      "zh": "要显示 [ImmersiveSpace](https://developer.apple.com/documentation/SwiftUI/ImmersiveSpace)，请使用从 SwiftUI 环境获取的 [openImmersiveSpace](https://developer.apple.com/documentation/SwiftUI/EnvironmentValues/openImmersiveSpace) 方法。此操作以异步方式运行，并使用提供的信息查找并初始化你的 scene。下面的示例显示一个按钮，该按钮使用 solarSystem 标识符打开空间：",
      "tips": ""
    },
    "An app can display only one space at a time, and it’s an error for you to try to open a space while another space is visible. To dismiss an open space, use the dismissImmersiveSpace action.": {
      "zh": "一个应用同时只能显示一个空间，如果你尝试在存在另一个空间时打开一个新空间，将会报错。要关闭已打开的空间，请使用 [dismissImmersiveSpace](https://developer.apple.com/documentation/SwiftUI/EnvironmentValues/dismissImmersiveSpace) 方法。",
      "tips": ""
    },
    "For more information about displaying spaces, see the ImmersiveSpace type.": {
      "zh": "有关显示空间的更多信息，请参阅 [ImmersiveSpace](https://developer.apple.com/documentation/SwiftUI/ImmersiveSpace) 类型。",
      "tips": ""
    },
    "Draw your content using RealityKit": {
      "zh": "使用 RealityKit 绘制你的内容",
      "tips": ""
    },
    "RealityKit works well when your content consists of primitive shapes or existing content in USD files. Organize the contents of your scene using RealityKit entities, and animate that content using components and systems. Use Reality Composer Pro to assemble your content visually, and to attach dynamic shaders, animations, audio, and other behaviors to your content. Display the contents of your RealityKit scene in a RealityView in your scene.": {
      "zh": "当你的内容由基本形状或存在于 USD 文件中的内容组成的时，RealityKit 效果很好。使用 RealityKit entities 来管理应用里 scene 的内容，并使用组件和系统对该内容做动画效果。使用 Reality Composer Pro 在视觉上组织你的内容，并在你的内容上添加动态着色器、动画、音频和其他操作。在你的 scene 中使用 [RealityView](https://developer.apple.com/documentation/RealityKit/RealityView) 来显示 RealityKit 场景的内容。",
      "tips": ""
    },
    "To load a Reality Composer Pro scene at runtime, fetch the URL of your Reality Composer Pro package file, and load the root entity of your scene. The following example shows how to create the entity for a package located in the app’s bundle:": {
      "zh": "要在运行时加载 Reality Composer Pro scene，请获取 Reality Composer Pro 包文件的 URL，并加载 scene 的根实体。以下示例显示如何为应用程序中的包创建实体：",
      "tips": ""
    },
    "For more information about how to display content in a RealityView and manage interactions with your content, see Adding 3D content to your app.": {
      "zh": "有关如何在 [RealityView](https://developer.apple.com/documentation/RealityKit/RealityView) 中显示内容并管理与内容的交互的更多信息，请参阅 [向你的应用添加 3D 内容](https://developer.apple.com/documentation/visionos/adding-3d-content-to-your-app)。",
      "tips": ""
    },
    "Draw your content using Metal": {
      "zh": "使用 Metal 绘制你的内容",
      "tips": ""
    },
    "Another option for creating fully immersive scenes is to draw everything yourself using Metal. When using Metal to draw your content, use the Compositor Services framework to place that content onscreen. Compositor Services provides the code you need to set up your Metal rendering engine and start drawing.": {
      "zh": "另一种创建完全沉浸式场景的选项是使用 Metal 自己绘制所有内容。在用 Metal 绘制内容时，使用 Compositor Services 框架将该内容放置在屏幕上。Compositor Services 为你提供了设置 Metal 渲染引擎并开始绘制的代码。",
      "tips": ""
    },
    "For details on how to render content using Metal and Compositor Services, and manage interactions with your content, see Drawing fully immersive content using Metal.": {
      "zh": "有关如何使用 Metal 和 Compositor Services 渲染内容以及管理与内容交互的详细信息，请参阅 [使用 Metal 绘制完全沉浸式内容](https://developer.apple.com/documentation/compositorservices/drawing_fully_immersive_content_using_metal)。",
      "tips": ""
    }
  },
  "visionos/creating-your-first-visionos-app": {
    "Creating your first visionOS app": {
      "zh": "创建你的第一个 visionOS 应用",
      "tips": ""
    },
    "Build a new visionOS app using SwiftUI and add platform-specific features.": {
      "zh": "使用 SwiftUI 构建新的 visionOS 应用，并添加平台特有的功能。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "If you’re new to visionOS, start with a new Xcode project to learn about the platform features, and to familiarize yourself with visionOS content and techniques. When you build an app for visionOS, SwiftUI is an excellent choice because it gives you full access to visionOS features. Although you can also use UIKit to build portions of your app, you need to use SwiftUI for many features that are unique to the platform.": {
      "zh": "如果你是 visionOS 的新手，请从一个新的 Xcode 项目开始，了解平台功能，并熟悉 visionOS 的内容和技术。当你为 visionOS 构建应用时，SwiftUI 是一个绝佳的选择，因为它能让你完全发挥 visionOS 的功能。虽然你也可以使用 UIKit 构建部分应用，但你需要使用 SwiftUI 来实现许多该平台的特有功能。",
      "tips": ""
    },
    "Note": {
      "zh": "备注",
      "tips": ""
    },
    "Developing for visionOS requires a Mac with Apple silicon.": {
      "zh": "为 visionOS 开发需要配备 Apple 芯片的 Mac。",
      "tips": ""
    },
    "In any SwiftUI app, you place content onscreen using scenes. A scene contains the views and controls to display onscreen. Scenes also define the appearance of those views and controls when they appear onscreen. In visionOS, you can include both 2D and 3D views in the same scene, and you can present those views in a window or as part of the person’s surroundings.": {
      "zh": "在任何 SwiftUI 应用中，你都可以使用场景在屏幕上放置内容。场景包含了要在屏幕上显示的视图和控件。场景还定义了这些视图和控件在屏幕上显示时的外观。在 visionOS 中，你可以在同一场景中包含二维和三维视图，也可以将这些视图呈现在窗口或在用户周围环境中。",
      "tips": ""
    },
    "Start with a new Xcode project and add features to familiarize yourself with visionOS content and techniques. Run your app in Simulator to verify your content looks like you expect, and run it on device to see your 3D content come to life.": {
      "zh": "从一个新的 Xcode 项目开始，添加功能以熟悉 visionOS 的内容和技术。在模拟器中运行应用，验证内容是否符合你的预期，然后在设备上运行以见证栩栩如生的三维内容。",
      "tips": ""
    },
    "Organize your content around one or more scenes, which manage your app’s interface. Each scene contains the views and controls you want to display, and the scene type determines whether your content adopts a 2D or 3D appearance. SwiftUI adds 3D scene types specifically for visionOS, and also adds 3D elements and layout options for all scene types.": {
      "zh": "围绕一个或多个场景组织内容，场景决定了应用的界面。每个场景都包含了你要显示的视图和控件，而场景类型则决定你的内容采用二维还是三维外观。SwiftUI 专门为 visionOS 添加了三维场景类型，还为所有场景类型添加了三维元素和布局选项。",
      "tips": ""
    },
    "Create your Xcode project": {
      "zh": "创建 Xcode 项目",
      "tips": ""
    },
    "Create a new project in Xcode by choosing File > New > Project. Navigate to the visionOS section of the template chooser, and choose the App template. When prompted, specify a name for your project along with other options.": {
      "zh": "在 Xcode 中选择 \"文件\">\"新建\">\"项目\"，创建一个新项目。导航至模板选择器的 visionOS 部分，然后选择应用模板。出现提示时，为项目指定名称和其他选项。",
      "tips": ""
    },
    "When creating a new visionOS app, you can configure your app’s initial scene types from the configuration dialog. To display primarily 2D content in your initial scene, choose a Window as your initial scene type. For primarily 3D content, choose a Volume. You can also add an immersive scene to place your content in the person’s surroundings.": {
      "zh": "创建新的 visionOS 应用时，你可以在配置对话框中配置应用的初始场景类型。如果要在初始场景中主要显示二维内容，请选择 \"窗口 \"作为初始场景类型。如果主要显示三维内容，则选择 \"体量\"。你还可以添加一个沉浸式场景，将内容置于用户的周围环境中。",
      "tips": ""
    },
    "Include a Reality Composer Pro project file when you want to create 3D assets or scenes to display from your app. Use this project file to build content from primitive shapes and existing USDZ assets. You can also use it to build and test custom RealityKit animations and behaviors for your content.": {
      "zh": "当你想创建显示在应用中的三维素材或场景时，请包含一个 Reality Composer Pro 项目文件。使用此项目文件可从原始形状和现有的 USDZ 素材创建内容。你还可以用它为你的内容构建并测试自定义的 RealityKit 动画和行为。",
      "tips": ""
    },
    "Modify the existing window": {
      "zh": "修改现有窗口",
      "tips": ""
    },
    "Build your initial interface using standard SwiftUI views. Views provide the basic content for your interface, and you customize the appearance and behavior of them using SwiftUI modifiers. For example, the .background modifier adds a partially transparent tint color behind your content:": {
      "zh": "使用标准 SwiftUI 视图构建初始界面。视图为界面提供了基本内容，你可以使用 SwiftUI 修饰符自定义视图的外观和行为。例如，.background 修饰符可在内容后方添加半透明的色调：",
      "tips": ""
    },
    "To learn more about how to create and configure interfaces using SwiftUI, see SwiftUI Essentials.": {
      "zh": "要进一步了解如何使用 SwiftUI 创建和配置界面，请参阅 SwiftUI Essentials。",
      "tips": ""
    },
    "Handle events in your views": {
      "zh": "处理视图中的事件",
      "tips": ""
    },
    "Many SwiftUI views handle interactions automatically — all you do is provide code to run when the interactions occur. You can also add SwiftUI gesture recognizers to a view to handle tap, long-press, drag, rotate, and zoom gestures. The system automatically maps the following types of input to your SwiftUI event-handling code:": {
      "zh": "许多 SwiftUI 视图会自动处理交互，你只需在交互发生时提供要运行的代码即可。你还可以在视图中添加 SwiftUI 手势识别器，以处理轻点、长按、拖动、旋转和缩放手势。系统会自动将以下类型的输入映射到你的 SwiftUI 事件处理代码中：",
      "tips": ""
    },
    "Indirect input. The person’s eyes indicate the target of an interaction. To start the interaction, the person touches their thumb and forefinger together on one or both hands. Additional finger and hand movements define the gesture type.": {
      "zh": "间接输入。用户眼睛指示出了互动目标。要开始互动，用户会将一只或两只手的拇指和食指并拢。其他的手指和手掌动作决定了手势的类型。",
      "tips": ""
    },
    "Direct input. When a person’s finger occupies the same space as an onscreen item, the system reports an interaction. Additional finger and hand movements define the gesture type.": {
      "zh": "直接输入。当用户手指与屏幕上的项目占据相同空间时，系统会报告一次交互。其他的手指和手掌动作决定了手势的类型。",
      "tips": ""
    },
    "Keyboard input. People can use a connected mouse, trackpad, or keyboard to interact with items, trigger menu commands, and perform gestures.": {
      "zh": "键盘输入。用户可以使用连接的鼠标、触控板或键盘与项目互动，触发菜单命令并执行手势。",
      "tips": ""
    },
    "For more information about handling interactions in SwiftUI views, see Handling User Input in the SwiftUI Essentials tutorial.": {
      "zh": "有关在 SwiftUI 视图中处理交互的更多信息，请参阅 SwiftUI Essentials 教程中的处理用户输入。",
      "tips": ""
    },
    "Build and run your app": {
      "zh": "构建并运行应用",
      "tips": ""
    },
    "Build and run your app in Simulator to see how it looks. Simulator for visionOS has a virtual background as the backdrop for your app’s content. Use your keyboard and your mouse or trackpad to navigate around the environment and interact with your app.": {
      "zh": "在模拟器中构建并运行应用来查看外观。visionOS 模拟器有一个虚拟背景，作为应用内容的背景。使用键盘，鼠标或触控板在环境中导航，并与应用进行交互。",
      "tips": ""
    },
    "Tap and drag the window bar below your app’s content to reposition the window in the environment. Move the pointer over the circle next to the window bar to reveal the window’s close button. Move the cursor to one of the window’s corners to turn the window bar into a resizing control.": {
      "zh": "轻点并拖动应用内容下方的窗口栏，可调整窗口在环境中的位置。将指针移至窗口栏旁边的圆圈上，显示窗口的关闭按钮。将光标移至窗口的某个角落，可将窗口栏变成一个调整大小的控件。",
      "tips": ""
    },
    "Apps don’t control the placement of windows in the space. The system places each window in its initial position, and updates that position based on further interactions with the app.": {
      "zh": "应用无法控制窗口在空间中的位置。系统会将每个窗口放置在其初始位置，并根据与应用的进一步交互更新该位置。",
      "tips": ""
    },
    "For additional information about how to interact with your app in Simulator, see Interacting with your app in the visionOS simulator.": {
      "zh": "有关如何在模拟器中与应用交互的更多信息，请参阅在 visionOS 模拟器中与应用交互。",
      "tips": ""
    }
  },
  "visionos/designing-realitykit-content-with-reality-composer-pro": {
    "Designing RealityKit content with Reality Composer Pro": {
      "zh": "使用 Reality Composer Pro 设计 RealityKit 内容",
      "tips": ""
    },
    "Design RealityKit scenes for your visionOS app.": {
      "zh": "为你的 visionOS 应用设计 RealityKit 场景。",
      "tips": ""
    },
    "Overview": {
      "zh": "概览",
      "tips": ""
    },
    "Use Reality Composer Pro to visually design, edit, and preview RealityKit content. In Reality Composer Pro, you can create one or more scenes, which act as a container for RealityKit content. Scenes contain hierarchies of entities, which are virtual objects such as 3D models.": {
      "zh": "Reality Composer Pro 能用于可视化设计、编辑和预览 RealityKit 内容。在 Reality Composer Pro 中，你可以创建一个或多个场景，将其当作 RealityKit 内容的容器。场景包含实体层级，而这些实体则是例如 3D 模型等的虚拟对象。",
      "tips": ""
    },
    "In addition to helping you compose scenes, Reality Composer Pro also gives you the ability to add and configure components — even custom components that you’ve written — to the entities in your scenes and also lets you create complex materials and effects using a node-based material editor called Shader Graph.": {
      "zh": "除了可以帮助你编排场景，Reality Composer Pro 还能让你添加和配置组件——包括你自己编写的自定义组件——到你场景中的实体。并且允许你使用一个基于节点的材质编辑器（称之为 Shader Graph）来创建复杂的材质和效果。",
      "tips": ""
    },
    "Launch Reality Composer Pro": {
      "zh": "启动 Reality Composer Pro",
      "tips": ""
    },
    "When you create a visionOS project in Xcode, it also contains a default Reality Composer Pro project named RealityKitContent within the Packages folder, which is a Swift package. The RealityKitContent package can include images, 3D models, and other assets like audio and video files. The assets you add to your project go in the RealityKitContent.rkassets bundle, while your source code goes into its Sources directory. The package also contains a file called Package.realitycomposerpro, which is the actual Reality Composer Pro project.": {
      "zh": "当你在 Xcode 中创建一个 visionOS 项目时，它还会在 Packages 文件夹中包含一个名为 RealityKitContent 的默认的 Reality Composer Pro 项目，它是一个 Swift package。RealityKitContent 包可以包括图像、3D 模型以及其他音视频文件资源。你添加到项目中的资源会放到 RealityKitContent.rkassets 包中，而源代码则会放在 Sources 目录下。这个包还带有一个名为 Package.realitycomposerpro 的文件，这就是实际的 Reality Composer Pro 项目。",
      "tips": ""
    },
    "To launch Reality Composer Pro, double-click the Package.realitycomposerpro file in the Project navigator, or click the Open in Reality Composer Pro button. If your project doesn’t already have a Reality Composer Pro project, you can launch Reality Composer Pro directly by choosing Xcode > Open Developer Tool > Reality Composer Pro.": {
      "zh": "要启动 Reality Composer Pro，可以在项目导航栏（Project navigator）中双击 Package.realitycomposerpro 文件，或者点击“Open in Reality Composer Pro”按钮。如果你的项目还没有 Reality Composer Pro 项目，你可以通过选择 Xcode > Open Developer Tool > Reality Composer Pro 的方式直接启动 Reality Composer Pro。",
      "tips": ""
    },
    "For efficiency, store all of your RealityKit assets in Reality Composer Pro projects. Xcode compiles Reality Composer Pro projects into a more efficient format when you build your app.": {
      "zh": "要想提高效率，可以将你所有的 RealityKit 资源保存到 Reality Composer Pro 项目中。Xcode 会在你构建项目时将 Reality Composer Pro 项目编译成更高效的格式。",
      "tips": ""
    },
    "Note": {
      "zh": "注意",
      "tips": ""
    },
    "Loading assets from a .reality file is considerably faster and more resource efficient than loading individual asset files.": {
      "zh": "从 .reality 文件加载资源，会比加载单个资源文件要快得多，而且更有效率。",
      "tips": ""
    },
    "Orient yourself in Reality Composer Pro": {
      "zh": "熟悉 Reality Composer Pro 的操作界面",
      "tips": ""
    },
    "The Reality Composer Pro window has several sections. The top-half displays the active scene. If you have multiple scenes, the window shows a tab bar at the top with one tab for each open scene. A scene in Reality Composer Pro is an entity hierarchy stored in a .usda file.": {
      "zh": "Reality Composer Pro 窗口包含多个部分。在上半部分显示处于活跃状态的场景。如果你有多个场景，在窗口顶部会有标签栏，每一个打开的场景对应一个标签页。在 Reality Composer Pro 中的场景是一个保存在 .usda 文件中的实体层级。",
      "tips": ""
    },
    "The left side of the top pane contains the hierarchy browser, which shows a tree representation of the entities in the active scene. You can toggle it using the top-left toolbar button to reveal errors and warnings. The middle pane is the 3D View, which shows a 3D representation of the active scene. The top-right is the inspector, which shows configurable values for the item selected in the 3D view, hierarchy view, or Shader Graph, depending on which has focus.": {
      "zh": "上半部分面板的左侧是层级结构浏览工具，以树状结构显示当前活跃状态场景中的实体。你可以使用左上角的工具栏按钮来进行错误、警告和层级视图结构的显示切换。中间的面板是 3D 视图，展示活跃场景的 3D 内容。在右上角是检查器，分别显示在 3D 视图模式、层级视图模式或者 Shader Graph 下选中的内容的可配置值，具体取决于当前选中的内容。",
      "tips": ""
    },
    "Tip": {
      "zh": "建议",
      "tips": ""
    },
    "A Reality Composer Pro scene can represent an entire RealityKit scene, and you can have multiple scenes in your Reality Composer Pro project, each driving a different RealityView in the same app. A scene can also contain a collection of entities to use as a building block. For example, if you had an airplane model, you might build a scene for it that contains its 3D model, a particle effect to make smoke come out its engine, and audio entities or components that represent the various sounds a plane makes. Your app could then load those combined assets and use them together anywhere it needs.": {
      "zh": "一个 Reality Composer Pro 场景可以表示整个 RealityKit 场景，并且你可以在 Reality Composer Pro 项目中拥有多个场景，在同一个应用中，每一个场景负责驱动不同的 RealityView。一个场景还可以包含一系列作为构建模块的实体。举个例子来说，如果你有一架飞机模型，你可能会为它构建一个包含 3D 模型的场景，从引擎中生成烟雾效果的粒子模型，以及展现飞机产生的各种声音的音频实体或组件。你的应用可以加载这些合并后的资源，并在任何需要的地方使用。",
      "tips": ""
    },
    "The bottom half of Reality Composer Pro contains the following four tabs:": {
      "zh": "Reality Composer Pro 的下半部分包含以下四个标签页：",
      "tips": ""
    },
    "Displays all of the assets in your project.": {
      "zh": "显示你的项目中的所有资源。",
      "tips": ""
    },
    "An advanced, node-based material editor.": {
      "zh": "一种先进的、基于节点的材质编辑器。",
      "tips": ""
    },
    "A tool for combining sound assets.": {
      "zh": "一个用于合成声音资源的工具。",
      "tips": ""
    },
    "Information about the currently open scene, such as the number of entities, vertices, and animations it contains.": {
      "zh": "当前打开的场景信息，比如它包含的实体、顶点和动画的数量。",
      "tips": ""
    },
    "Reality Composer Pro projects start with a single empty scene called Scene which is stored in a file called Scene.usda. You can create as many additional scenes as you need by choosing File > New > Scene. New scenes open as tabs along the top of the window, and they also appear in the Project Browser as .usda files.": {
      "zh": "Reality Composer Pro 项目在开始时会有一个名为 Scene 的空白场景，保存在 Scene.usda 文件中。你可以通过选择 File > New > Scene 来创建你所需的任意数量的新场景。新场景会作为窗口顶部的标签页打开，而且它们也会以 .usda 文件的形式出现在项目浏览器（Project Browser）中。",
      "tips": ""
    },
    "If you close a scene’s tab and need to re-open it, double-click on the scene’s .usda file in the Project Browser. If you no longer need a scene, delete its .usda file from the Project Browser or remove it from your project’s .rkassets bundle in Xcode.": {
      "zh": "如果你关闭了一个场景的标签页且需要重新打开它，那么你可以在项目浏览器上双击场景的 .usda 文件。如果你不再需要一个场景，可以从项目浏览器中删除它的 .usda 文件，或者从 Xcode 中的项目的 .rkassets 包中删除它。",
      "tips": ""
    },
    "To delete a scene:": {
      "zh": "要删除一个场景：",
      "tips": ""
    },
    "Close the scene tab by selecting File > Close Tab": {
      "zh": "通过选择 File > Close Tab 来关闭场景标签页",
      "tips": ""
    },
    "Select the scene’s .usda file in the Project Browser": {
      "zh": "在项目浏览器中选择场景的 .usda 文件",
      "tips": ""
    },
    "Control-click the scene’s .usda file the Project Browser.": {
      "zh": "在项目浏览器中对场景的 .usda 文件按住 Control 的同时进行点击",
      "tips": ""
    },
    "Choose Delete from the contextual menu.": {
      "zh": "在菜单中选择删除",
      "tips": ""
    },
    "Click Move to Trash.": {
      "zh": "选择移动到废纸篓",
      "tips": ""
    },
    "This removes the scene’s .usda and the scene tab at the top of the window.": {
      "zh": "这将移除窗口上方的场景标签页和场景的 .usda 文件。",
      "tips": ""
    },
    "Add assets to your project": {
      "zh": "为你的项目添加资源",
      "tips": ""
    },
    "In Reality Composer Pro, you design scenes by first importing assets into your project. Then add assets to scenes and move, rotate, and scale them. The Project Browser tab displays all of the asset files in your project. You can add new assets by dragging them to the Project Browser or by choosing File > Import and select the assets to add to your project. To add an asset from the Project Browser to the current scene, drag it to the 3D view in the center of the window, or to the hierarchy view in the top-left of the window.": {
      "zh": "在 Reality Composer Pro 中，你首先通过将资源导入到项目中来设计场景。然后将资源添加到场景中并对它们进行移动、旋转和缩放操作。项目浏览器标签页会显示项目中的所有资源文件。你可以将它们拖到项目浏览器或通过选择 File > Import 并选择要添加到项目中的资源来添加新的资源。要将项目浏览器中的一个资源添加到当前场景，你可以将它拖到窗口中心的 3D 视图上，或者拖动到窗口左上角的层级视图处。",
      "tips": ""
    },
    "Reality Composer Pro projects can contain assets not used in any scene. Such assets are still compiled into your app and can be loaded at runtime and take full advantage of the efficient loading process for .reality files.": {
      "zh": "Reality Composer Pro 项目可以包含未在任何场景中使用的资源。这些资源依旧会被编译到你的应用中，并且在运行时加载，并能充分利用 .reality 文件高效的加载过程。",
      "tips": ""
    },
    "Reality Composer Pro can represent many assets as entities, but it can’t represent all assets that way; for example:": {
      "zh": "Reality Composer Pro 可以将许多资源表示为实体，但并不适用于所有资源。例如：",
      "tips": ""
    },
    "USDZ models do become an entity or entity hierarchy when you add them to a scene.": {
      "zh": "当你将 USDC 模型添加到场景中时，它们会变成一个实体或者实体层级结构。",
      "tips": ""
    },
    "Image files do not become an entity. Reality Composer Pro only uses image assets indirectly, such as being the source texture for materials you build in Shader Graph. If you drag assets that Reality Composer Pro can’t turn into an entity, nothing happens.": {
      "zh": "图像文件不会变成实体。Reality Composer Pro 只会间接使用图像资源，比如作为你在 Shader Graph 中构建的材质的原始纹理。如果你拖动 Reality Composer Pro 无法转化成实体的资源，将不会造成任何影响。",
      "tips": ""
    },
    "Add any 3D models, animations, sounds, and image files you need to your project. You can organize your assets into subfolders to make the Project Browser more manageable as your project grows in size.": {
      "zh": "将你所需的任何 3D 模型、动画、声音和图像文件添加到项目中。随着你项目规模的增长，为使项目浏览器更方便管理资源，可以将它们整理到各个子文件夹中。",
      "tips": ""
    },
    "Reality Composer Pro has a library of assets that you can use in your own apps. You can access the library by clicking the Add button (+) in the toolbar. Click the icon of the down-arrow inside a circle next to an asset to download the asset to Reality Composer Pro. When the download finishes, you can double-click or drag the asset into your project.": {
      "zh": "Reality Composer Pro 有一个可以在自己的应用中使用的资源库。你可以通过点击工具栏中的添加按钮（+）来访问库。点击资源旁边带有向下箭头的圆环图标，将资源下载到 Reality Composer Pro。当下载完成后，你可以双击或者拖动资源到你的项目中。",
      "tips": ""
    },
    "Important": {
      "zh": "重要",
      "tips": ""
    },
    "Reality Composer Pro treats your imported assets as read-only.": {
      "zh": "Reality Composer Pro 将已导入的资源视作只读资源。",
      "tips": ""
    },
    "Changes you make to assets in a scene only affect that scene’s copy of the asset. The changes you make are stored in the scene’s .usda file, not in the original asset. That means you can work without fear of inadvertently changing other scenes. If you plan to make significant changes to an imported 3D model, such as by replacing its materials with dynamic Shader Graph materials, import the model as a.usdc file instead of as a .usdz file, and then separately import just the supporting assets you need to avoid Xcode compiling assets that you don’t need into your app.": {
      "zh": "你在场景中对资源的修改只会影响该场景的资源副本。你所做出的更改会保存在场景的 .usda 文件中，而不是在原始资源中。这意味着你可以放心工作，无需担心对其他场景进行不必要的改动。如果你计划对已导入的 3D 模型作出重大修改，例如使用动态的 Shader Graph 材质替换其现有材质，那么需要将模型作为 .usdc 文件而不是 .usdz 文件导入，然后分别导入你需要的支持资源，以避免 Xcode 将你不需要的资源编译进你的应用。",
      "tips": ""
    },
    "Compose scenes from assets": {
      "zh": "使用资源来合成场景",
      "tips": ""
    },
    "All RealityKit entities in a scene exist at a specific position, orientation, and scale, even if that entity has no visual representation. When you click to select an entity in the 3D view or hierarchy view, Reality Composer Pro displays:": {
      "zh": "场景中所有 RealityKit 的实体都有一个明确的位置、方向和比例，即使该实体并不可见。当你在 3D 视图或者层级视图中选择一个实体时，Reality Composer Pro 会显示：",
      "tips": ""
    },
    "A manipulator over the entity in the 3D view.": {
      "zh": "在 3D 视图中的实体上展示一个操纵器",
      "tips": ""
    },
    "Any configurable values from the entity’s components in the inspector on the right.": {
      "zh": "在右侧检查器中显示实体组件的任何可以配置的值。",
      "tips": ""
    },
    "You can use the manipulator to move, rotate, and scale the selected entity.": {
      "zh": "你可以使用操纵器来移动、旋转和缩放所选的实体。",
      "tips": ""
    },
    "To move the selected entity around the 3D scene, drag the small colored cone that corresponds to the axis you want to move it along. Alternatively, you can drag the entity itself to move it freely relative to your viewing angle.": {
      "zh": "要在 3D 场景中移动所选实体，拖动与你想沿其移动的轴对应的小色锥。或者，你可以拖动实体本身，相对于你的观察角度来自由移动它。",
      "tips": ""
    },
    "To rotate the selected entity, click on the manipulator’s rotation control, which looks like a circle, and drag in a circular motion.": {
      "zh": "要旋转所选实体，点击操纵器的旋转控件（它看起来像一个圆）并以圆的动作拖动。",
      "tips": ""
    },
    "Reality Composer Pro’s manipulator only shows one rotation control at a time.": {
      "zh": "Reality Composer Pro 的操纵器在同一时间只显示一个旋转控件。",
      "tips": ""
    },
    "To rotate an entity on one of the other axes, click the cone corresponding to the axis you want to rotate. For example, if you want to rotate the entity on the X axis, tap the red cone to bring up the red rotation handle for that axis.": {
      "zh": "要在其他轴上旋转实体，点击你想要旋转的轴对应的圆锥。例如，如果你想在 X 轴上旋转实体，点击红色圆锥，使其为该轴带出红色的旋转手柄。",
      "tips": ""
    },
    "To scale the selected entity uniformly, click the rotation circle and drag away from the entity origin to scale it up, or toward the entity origin to scale it down. Because it scales uniformly, it doesn’t matter which rotation handle Reality Composer Pro is showing.": {
      "zh": "要统一缩放所选实体，点击旋转圈并从实体原点向外拖动以放大它，或者向实体原点方向拖动以缩小它。由于它是等比例缩放，无论 Reality Composer Pro 正在显示哪个旋转手柄都没有关系。",
      "tips": ""
    },
    "In the manipulator, Red indicates the X axis, Green indicates the Y axis, and Blue indicates the Z axis.": {
      "zh": "在操纵器中，红色代表 X 轴，绿色代表 Y 轴，蓝色代表 Z 轴。",
      "tips": ""
    },
    "Alternatively, you can make the same changes to the selected entity by typing new values into the transform component of the inspector. The transform component stores the position, rotation, and scale for an entity. The manipulator is just a visual way to change the values on this component.": {
      "zh": "另外，你也可以通过在检查器的转换组件中输入新的值，来对选中的实体应用同样的更改操作。转换组件保存实体的位置、旋转和缩放数值。操纵器只是通过可视化来改变此组件值的一种方式。",
      "tips": ""
    },
    "Activate and deactivate scene entities": {
      "zh": "激活和停用场景中的实体",
      "tips": ""
    },
    "Reality Composer Pro scenes can get quite complex and sometimes contain overlapping entities, which can be difficult to work with. To simplify a scene, you can deactivate entities to remove them from the 3D view. Deactivate entities by Control-clicking them and selecting Deactivate from the contextual menu. The entity still exists in your project and is shown in the hierarchy view, albeit grayed out and without any child entities. It won’t, however, appear in the 3D view. Xcode doesn’t compile deactivated entities into your app’s bundle, so it’s important to re-activate any entities your app needs before saving your project. To reactivate an entity, Control-click the entity in the hierarchy view and select Activate from the contextual menu.": {
      "zh": "Reality Composer Pro 的场景可能会非常复杂，有时候会包含难以处理的、重叠的实体。为了简化场景，你可以停用实体从而将它们从 3D 视图中移除。通过按住 Control 的同时在实体上点击，并在上下文菜单中选择停用来停用这个实体。尽管它已经变成灰色而且没有了任何的子实体，但它仍然存在于你的项目中，并在层级视图中展示。然而，它不会展现在 3D 视图中。Xcode 不会将停用的实体编译进应用的包中，所以，在保存项目之前重新激活应用需要的实体是非常重要的。要重新激活实体，可以在层级视图中按住 Control 的同时点击实体，并从上下文菜单中选择激活。",
      "tips": ""
    },
    "Add components to entities": {
      "zh": "为实体添加组件",
      "tips": ""
    },
    "RealityKit follows a design pattern called Entity-Component-System (ECS). In ECS, you store data on an entity using components and then implement entity behavior by writing systems that use the data from those components. You can add and configure components to entities in Reality Composer Pro, including both built-in components like ParticleEmitterComponent, and custom components that you write and place in the Sources folder of your Reality Composer Pro Swift package. You can also create new components in Reality Composer Pro and edit them in Xcode.": {
      "zh": "RealityKit 遵循名为 ECS（Entity-Component-System）的设计模式。在 ECS 中，你通过使用组件来保存实体上的数据，然后通过编写各个系统来实现实体的行为，这些系统则使用保存在组件的数据。你可以在 Reality Composer Pro 中为实体添加和配置组件，包括像内置的 ParticleEmitterComponent 这样的组件，以及你编写并放置在你的 Reality Composer Pro Swift 包的 Sources 文件夹中的自定义组件。你还可以在 Reality Composer Pro 中创建新的组件，并在 Xcode 中对它们进行编辑。",
      "tips": ""
    },
    "For more information about ECS, see Understanding RealityKit’s modular architecture.": {
      "zh": "更多有关 ECS 的内容，详见“理解 RealityKit 的模块化结构”一文。",
      "tips": ""
    },
    "To add a component to an entity, select that entity in the hierarchy view or 3D view. At the bottom-right of the inspector window, click Add Component. A list of available components appears with New Component at the top. If you select the first item, Reality Composer Pro creates a new component class in the Sources folder, and optionally a new system class. It also adds the component to the selected entity. If you select any other item in the list, it adds that component to the selected entity if it doesn’t already have that component.": {
      "zh": "要将组件添加到实体，可以从层级视图或者 3D 视图中选择实体。在检查器窗口的右下角，点击 “Add Component”。会在窗口顶部出现一个名为“New Component”的可用组件列表。如果你选择列表中的第一项，Reality Composer Pro 会在 Sources 文件夹中创建一个新的组件类，和一个可选的新的系统类。它还会将该组件添加到所选的实体。如果你选择列表中的任何其他项，如果该实体尚未拥有该组件，它将将该组件添加到所选实体。",
      "tips": ""
    },
    "Create or modify entity hierarchies": {
      "zh": "创建或修改实体层级结构",
      "tips": ""
    },
    "Reality Composer Pro scenes are hierarchies of RealityKit entities. You can change the relationship between entities in the hierarchy browser except for parts of the hierarchy imported from a .usdz file, which Reality Composer Pro treats as a read-only file.": {
      "zh": "Reality Composer Pro 的场景是 RealityKit 实体的层级结构。你可以在层级结构浏览器中更改实体之间的关系，除了从 .usdz 文件导入的层级结构那部分以外，因为 Reality Composer Pro 将其视作只读文件。",
      "tips": ""
    },
    "To change the relationship between entities, or to create a relationship between two currently unrelated entities, use the hierarchy view and drag an entity onto the entity that you want it to be part of. If you want an entity to become a root entity, drag it to the Root transform at the top of the hierarchy view.": {
      "zh": "要更改实体之间的关系，或是在当前无关的两个实体之间建立新联系，使用层级结构视图并将实体拖放到你希望产生联系的另一个实体之上。如果你想让实体成为根实体，那就将它拖到层级视图顶部的 Root transform 上。",
      "tips": ""
    },
    "Modify or create new materials": {
      "zh": "修改或创建新材质",
      "tips": ""
    },
    "When you import a USDZ model into Reality Composer Pro, it creates a RealityKit material for every physically-based rendering (PBR) material the asset contains. Reality Composer Pro displays materials in the hierarchy view just like it displays entities, except it uses a paintbrush icon. Reality Composer Pro doesn’t display materials in the 3D view.": {
      "zh": "当你将 USDZ 模型导入到 Reality Composer Pro 时，它会为资源包含的所有基于物理渲染的材质（PBR）创建一个对应的 RealityKit 材质。RealityKit Composer Pro 就可以像在展示实体一样在层级视图中展示材质，唯一区别是它使用了画笔图标。Reality Composer Pro 不会在 3D 视图中展示材质。",
      "tips": ""
    },
    "The library in Reality Composer Pro contains materials for several common real-world surfaces like metal, wood, and denim that you can import into your project.": {
      "zh": "Reality Composer Pro 的资源库中包含了一些真实世界常见的材质，诸如金属、木材和牛仔布，你可以将它们导入到你的项目中。",
      "tips": ""
    },
    "If you select a PBR material in the hierarchy view, you can edit it using the inspector. You can replace images, colors, or values for any of the PBR attributes with another image, color, or value of your choosing. Any changes you make to a material affects any entity that’s bound to that material. You can also create new materials from scratch by clicking the Add button (+) at the bottom of the scene hierarchy and choosing Material.": {
      "zh": "如果你在层级视图中选择了一个 PBR 材质，你可以使用检查器来进行编辑。你可以用你选择的其他图像、颜色或值来替换 PBR 属性中的任何图像、颜色或值。你对材质的进行的任何修改都会影响到绑定到该材质的所有实体。你也能够通过在场景层级的底部点击添加按钮（+）并选择 Material 来创建全新的材质。",
      "tips": ""
    },
    "Build materials in Shader Graph": {
      "zh": "在 Shader Graph 中构建材质",
      "tips": ""
    },
    "PBR materials are great at reproducing real-world surfaces. However, they can’t represent nonrealistic materials like cartoon shaders, and they can’t contain logic. This means that you can’t animate a PBR material or have it react to input from your app.": {
      "zh": "PBR 材质擅长再现真实世界的表面。然而，它们不能表示像卡通着色器这样的非现实材质，也不能包含逻辑。这意味着你不能对 PBR 材质进行动画处理，也不能让它对你的应用输入作出反应。",
      "tips": ""
    },
    "Reality Composer Pro offers a second type of material called a custom material. You can build and edit custom materials using the Shader Graph tab. Shader Graph provides a tremendous amount of control over materials and allows you to do things that would otherwise require writing Metal shaders. For more information on writing Metal shaders, see Metal.": {
      "zh": "Reality Composer Pro 提供了第二种类型的材质，称为自定义材质。你可以使用 Shader Graph 标签来构建和编辑自定义材质。Shader Graph 提供了对材质的高度控制能力，并使你能够实现通常需要编写 Metal 着色器才能完成的操作。有关编写 Metal 着色器的更多信息，请参见 Metal。",
      "tips": ""
    },
    "RealityKit doesn’t represent Reality Composer Pro custom materials as an instance of CustomMaterial, as you might expect. Instead, RealityKit represents these materials as ShaderGraphMaterial instances.": {
      "zh": "RealityKit 不会像你可能预期的那样，将 Reality Composer Pro 的自定义材质表示为 CustomMaterial 的实例。相反，RealityKit 会将这些材质表示为 ShaderGraphMaterial 实例。",
      "tips": ""
    },
    "The materials you build in the editor can affect both the look of an entity and its shape. If you build a node graph and connect it to the Custom Surface pin on the output node, that node graph controls the surface appearance of the model and roughly equates to writing Metal code in a fragment shader. If you build a node graph and connect it to the Custom Geometry Modifier output pin, those nodes control the shape of the entity, which equates to Metal code running in a vertex shader.": {
      "zh": "在编辑器中你所构建的材质能够影响实体的外观和形状。如果你构建了一个节点图并将其连接到输出节点上的 Custom Surface 引脚，那么该节点图就会控制模型的表面外观，这基本上等同于在片段着色器中编写 Metal 代码。如果你构建了一个节点图并将其连接到 Custom Geometry Modifier 输出引脚，那么这些节点就会控制实体的形状，这等同于在顶点着色器中运行 Metal 代码。",
      "tips": ""
    },
    "Nodes represent values and operations and serve the same purpose as either a variable or constant, or a function in Metal. If you need the sine of a value, for example, connect the value’s output node to the input pin of a Sin node. Add new nodes to the graph by double-clicking the background of the Shader Graph view or click the New Node button on the right side of the screen.": {
      "zh": "节点代表值和操作，其作用与 Metal 中的变量或常数，或函数相同。例如，如果你需要一个值的正弦，将值的输出节点连接到 Sin 节点的输入引脚。通过双击 Shader Graph 视图的背景或点击屏幕右侧的“New Node”按钮，可以向图中添加新的节点。",
      "tips": ""
    },
    "Some nodes, like Sin, are universal and can be used with either output pin. Other nodes are specific to either the Custom Surface or Geometry Modifier outputs. If a node name starts with Geometry Modifier, you can only connect it to the Geometry Modifier output pin. If the node’s name starts with “Surface”, you can only connect it to the Custom Surface output pin.": {
      "zh": "一些节点，比如 Sin，是通用的，可以用于任意输出引脚。其他节点则特定于 Custom Surface 或 Geometry Modifier 输出。如果一个节点的名称以 Geometry Modifier 开头，那么你只能将它连接到 Geometry Modifier 输出引脚。如果节点的名称以“Surface”开头，你只能将它连接到 Custom Surface 输出引脚。",
      "tips": ""
    },
    "To unlock the real power of Shader Graph, you need to be able to change values on the material from Swift code. Shader Graph allows you to do this by creating promoted inputs, which are parameters you can set and read from Swift to change your material at runtime. If you have a feature that you want to turn on and off, you might create a Boolean input parameter and have conditional logic based on its value. If you want to smoothly interpolate between two colors, you might create a Float input parameter and use it to control how to interpolate between the two colors. You can Control-click on a constant node and select Promote to turn it into a promoted input. You can also turn a promoted input back into a constant by Control-clicking it and selecting Demote.": {
      "zh": "要解锁 Shader Graph 的真正能力，你需要通过 Swift 代码来更改材质上的值。Shader Graph 允许你通过创建提升输入（promoted input）来达到这一点，这些输入是你可以在 Swift 中设置和读取的参数，用于改变在运行时的材质。如果你有一个想要开启和关闭的功能，你可能会创建一个 Boolean 输入参数，并根据其值执行条件逻辑。如果你想在两种颜色之间平滑插值，你可能会创建一个 Float 输入参数，并使用它来控制如何在两种颜色之间插值。你可以按住 Control 并点击一个常量节点并选择 Promote 来将其转换为提升输入。你也可以通过按住 Control 并点击它并选择 Demote 来将提升输入转换回常量。",
      "tips": ""
    },
    "If you don’t have an existing constant to promote, you can create new promoted inputs using the inspector. The New Input button only shows up in the inspector when you select a material in the hierarchy view but have no nodes selected in the Shader Graph tab.": {
      "zh": "如果你没有要提升的现有常量，你可以使用检查器创建新的提升输入。只有当在你在层级视图中选择了材质，但在 Shader Graph 标签中未选择任何节点时，“New Input”按钮才会在检查器中显示。",
      "tips": ""
    },
    "To change the value of an input parameter from Swift code, use setParameter(name:value:), passing the name of the parameter and the new value. Note that parameter names are case sensitive, so your name string must exactly match what you called the parameter in Shader Graph.": {
      "zh": "要从 Swift 代码中更改输入参数的值，使用 setParameter(name:value:) 方法，传入参数名和新值。请注意，参数名称是区分大小写的，因此你的名称字符串必须与你在 Shader Graph 中为参数所取的名称完全匹配。",
      "tips": ""
    },
    "For examples of Shader Graph use, see Diorama and Happy Beam.": {
      "zh": "要查看 Shader Graph 的使用示例，可参看 Diorama 和 Happy Beam。",
      "tips": ""
    },
    "Use references to reuse assets": {
      "zh": "使用引用来复用资源",
      "tips": ""
    },
    "If your project has multiple scenes that share assets, you can use references to avoid creating duplicate assets. A reference acts like an alias in Finder — it points to the original asset and functions just as if it were another copy of that asset.": {
      "zh": "如果你的项目包含多个共享资源的场景，你可以使用引用来避免创建重复的资源。引用就像 Finder 中的别名——它指向原始资源，并且功能上就像是该资源的另一份副本。",
      "tips": ""
    },
    "Create references using the inspector. By default, the references section is hidden for entities and materials that don’t have any references. To add a new reference to an asset or material that doesn’t have one, choose Reality Composer Pro > Settings and uncheck Hide Empty References.": {
      "zh": "使用检查器来创建引用。默认情况下，对于没有任何引用的实体和材质，引用部分是隐藏的。要为没有引用的资源或材质添加新引用，需要选择 Reality Composer Pro > Settings，然后取消选中“Hide Empty References”。",
      "tips": ""
    },
    "To add a reference, click the Add button (+) at the bottom of the references section in the inspector, choose the .usda file for the scene that contains the asset, then choose the asset you want to link to. After you do that, the selected entity or material becomes a copy of the one you linked to.": {
      "zh": "要添加引用，单击检查器中引用部分底部的添加按钮（+），选择包含该资源的场景的 .usda 文件，然后选择你想要链接的资源。完成后，所选的实体或材质将成为你链接的那个的副本。",
      "tips": ""
    },
    "If you make changes to a linked asset, those changes will affect every linked reference.": {
      "zh": "如果你对链接的资源进行了更改，那么这些更改将影响每个链接的引用。",
      "tips": ""
    },
    "Preview scenes on device": {
      "zh": "在设备上预览场景",
      "tips": ""
    },
    "If you have an Apple Vision Pro connected to your Mac, choose Preview > Play or click the preview button in the Reality Composer Pro toolbar to view your scene on device. The Preview button is the left-most button on the right side of the toolbar — the one with an Apple Vision Pro icon. If you have multiple Apple Vision Pro devices connected, choose which device to use by clicking the pull-down menu next to the Preview button.": {
      "zh": "如果你的 Mac 上连接了一台 Apple Vision Pro，选择 Preview > Play 或点击 Reality Composer Pro 工具栏中的预览按钮，就可以在设备上查看你的场景。预览按钮是工具栏右侧最左边的按钮——带有 Apple Vision Pro 图标的按钮。如果你连了多台 Apple Vision Pro 设备，通过点击预览按钮旁边的下拉菜单选择要使用的设备。",
      "tips": ""
    },
    "Load Reality Composer Pro scenes in RealityKit": {
      "zh": "在 RealityKit 中加载 Reality Composer Pro 场景",
      "tips": ""
    },
    "Loading a Reality Composer Pro scene is nearly identical to loading a USDZ asset from your app bundle, except you have to specify the Reality Composer Pro package bundle instead. You typically do this in the make closure of a RealityView initializer. Reality Composer Pro packages define a global constant that points to its bundle, which is named after the project with “Bundle” appended to it. In the default Xcode visionOS template, the Reality Composer Pro project is called RealityKitContent, so the global bundle variable is called realityKitContentBundle:": {
      "zh": "加载 Reality Composer Pro 场景与从你的应用包中加载 USDZ 资源几乎相同，只是你需要指定 Reality Composer Pro 的包内容。你通常会在 RealityView 初始化方法的闭包中完成这一操作。Reality Composer Pro 包定义了一个全局常量，该常量指向其自身的 bundle，并且它的名称是在项目名称后添加“Bundle\"。在默认的 Xcode visionOS 模板中，Reality Composer Pro 项目被称为 RealityKitContent，因此全局 bundle 变量被称为 realityKitContentBundle：",
      "tips": ""
    },
    "The code above saves a reference to the root node. This isn’t required, but with RealityView, unlike ARView on iOS and macOS, you don’t have ready access to the scene content, so it’s often handy to maintain your own reference to the root entity of your scene in your app’s data model.": {
      "zh": "上述代码保存了对根节点的引用。虽然这不是必需的，但与 iOS 和 macOS 上的 ARView 不同，你在 RealityView 中不能直接获取到场景内容，因此在应用的数据模型中保持对你场景的根实体的引用通常会很方便。",
      "tips": ""
    },
    "When RealityKit finishes loading the scene, the scene variable contains the root entity of the scene you specified. Add it to content and RealityKit displays it to the user.": {
      "zh": "当 RealityKit 完成场景加载后，scene 变量会包含你指定的场景的根实体。将它添加到 content 中，RealityKit 就会将它显示给用户。",
      "tips": ""
    }
  },
  "visionos/destination-video": {
    "Destination Video": {
      "zh": "目的地视频",
      "tips": ""
    },
    "Leverage 3D video and Spatial Audio to deliver an immersive experience.": {
      "zh": "利用 3D 视频和空间音频提供身临其境的体验。",
      "tips": "Spatial Audio 译为“空间音频”"
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "Destination Video is a multiplatform video-playback app for visionOS, iOS, and tvOS. People get a familiar media-browsing experience navigating the libraryʼs content and playing videos they find interesting. The app provides a similar experience on supported platforms, but leverages unique features of visionOS to create a novel, immersive playback experience.": {
      "zh": "Destination Video 是一款适用于 visionOS、iOS 和 tvOS 的多平台视频播放应用。应用为用户提供了熟悉的媒体浏览体验：在图书馆中浏览内容并可以播放感兴趣的视频。该应用在所有支持的平台上提供了相近的体验，但同时也利用了 visionOS 的特有功能来创建新颖、身临其境的视听体验。",
      "tips": ""
    },
    "Play video in an inline player": {
      "zh": "在内联播放器中播放视频",
      "tips": "inline player 译为内联播放器"
    },
    "When you select a video in the library, Destination Video presents a view that displays additional details about the item. The view presents controls to play the video and specify whether to include it in your Up Next list. In visionOS, it also displays a video poster along its leading edge. Tapping the view’s Preview button displays an inline preview of the video.": {
      "zh": "当您在资源库中选择视频时，“目的地视频”会显示一个有关该项目详情的视图。该视图显示播放视频的控件，并允许用户指定是否将其包含在“待播清单”列表中。在visionOS中，它还会靠左显示一张视频海报。点击视图中的“预览”按钮可在行中显示视频的预览。",
      "tips": ""
    },
    "When you present an AVPlayerViewController object’s interface as a child of another view, inline controls display, for example, pause, skip, and seek. Showing standard playback controls in your app provides a familiar UI that automatically adapts its appearance to fit each platform, and is the recommended choice in most cases.": {
      "zh": "当您将 AVPlayerViewController 的界面作为一个子视图显示时，暂停、跳过和查找等内联控件将显示。在应用中显示标准播放控件可提供可自动调整其外观以适应平台的熟悉 UI，这在大多数情况下是推荐的选择。",
      "tips": ""
    },
    "Destination Video uses a simple UI for the inline player view: a single button that toggles state of playback. AVPlayerViewController doesn’t provide this controls style, but the app uses it to display the video content without controls by setting the value of its showsPlaybackControls property to false. It then overlays the custom playback controls it requires. See Destination Video’s InlinePlayerView type for details on how you can implement this.": {
      "zh": "目的地视频使用简单的 UI 作为内联播放器视图：一个用于切换播放状态的按钮。 AVPlayerViewController 不提供此控件样式，但本应用仅仅使用它来显示视频内容，而不显示控件，其实现方法是将 showsPlaybackControls 属性的值设置为 false。然后应用会用所需的自定义播放控件覆盖在上。如想了解此功能的详情，请参阅目的地视频中的 InlinePlayerView 类型。",
      "tips": ""
    },
    "Note": {
      "zh": "注意",
      "tips": ""
    },
    "AVPlayerViewController only supports displaying 2D content when embedded inline.": {
      "zh": "",
      "tips": "注意 AVPlayerViewController 在内联嵌入时仅支持显示 2D 内容。"
    },
    "Play video in a full-window player": {
      "zh": "在全屏播放器中播放视频",
      "tips": ""
    },
    "One of the most exciting features of visionOS is its ability to play 3D video along with Spatial Audio, which adds a deeper level of immersion to the viewing experience. Playing 3D content in your app requires that you display AVPlayerViewController full window. When you present the player this way, the system automatically docks it into the ideal viewing position, and presents streamlined playback controls that keep the person’s focus on the content.": {
      "zh": "visionOS 最令人兴奋的功能之一是它能够播放 3D 视频和空间音频，这为观看体验增加了更深层的沉浸感。在应用中播放 3D 内容需要在全屏模式下显示 AVPlayerViewController。当您以这种方式呈现播放器时，系统会自动将其停靠在理想的观看位置，并提供简化的播放控件，使用户专注于内容。",
      "tips": ""
    },
    "In iOS or tvOS, you typically present video in a full-screen presentation using the fullScreenCover(isPresented:onDismiss:content:) modifier. This API is available in visionOS; however, the recommended way to present the player for full-window playback is to set it as the root view of your app’s window group.": {
      "zh": "在 iOS 或 Apple tvOS 中，你可以使用 fullScreenCover(isPresented:onDismiss:content:) 修饰符在全屏模式下演示视频。此 API 在 visionOS 亦可用；然而，推荐的全屏模式播放视频方法是将视图设置为应用窗口组的根视图。",
      "tips": ""
    },
    "Destination Video’s ContentView displays the app’s library by default. It observes changes to the player model’s presentation property, which indicates whether the app requests inline or full-window playback. When the presentation state changes to fullWindow, the view redraws the UI to display the player view in place of the library.": {
      "zh": "默认情况下，目的地视频的 ContentView 会显示应用的资源库。它观察对播放器模型中 presentation（演示状态） 属性的更改，属性的变化意味着应用请求内联播放或全屏播放。当演示状态变为 fullWindow 时，视图将重新绘制 UI，用播放器视图来代替原本的资源库视图。",
      "tips": "Player model 译为播放器模型。presentation 译为演示状态。"
    },
    "When someone selects the Play Video button on the detail view, the app calls the player model’s loadVideo(_: presentation:) method requesting the fullWindow presentation option.": {
      "zh": "当用户在详细信息视图上选择了“播放视频”按钮时，应用会调用播放器模型的 loadVideo(_: presentation:) 方法，请求fullWindow 演示选项。",
      "tips": "presentation option 译为演示选项"
    },
    "After the player model successfully loads the video content for playback, it updates its presentation value to fullWindow, which causes the app to replace the library with PlayerView.": {
      "zh": "当播放器模型成功加载视频内容并播放后，会将其 presentation 值更新为 fullWindow ，这会让应用将资源库替换为 PlayerView 。",
      "tips": ""
    },
    "To dismiss the full-window player in visionOS, people tap the Back button in the player UI. To handle this action, the app’s PlayerViewControllerDelegate type defines an AVPlayerViewControllerDelegate object that handles the dismissal.": {
      "zh": "要在 visionOS 中关闭全屏播放器，用户可以点击播放器 UI 中的“后退”按钮。为了处理此操作，应用的 PlayerViewControllerDelegate 类型定义了一个 AVPlayerViewControllerDelegate 对象，用于关闭界面。",
      "tips": ""
    },
    "When the delegate receives this call, it clears the media from the player model and resets the presentation state back to its default value, which results in the Destination Video app redisplaying the library view.": {
      "zh": "当委托（delegate）收到此调用时，它会从播放器模型中清除媒体，并将演示状态重置回其默认值，这会让目的地视频应用重新显示资源库视图",
      "tips": ""
    },
    "Configure the Spatial Audio experience": {
      "zh": "配置空间音频体验",
      "tips": ""
    },
    "Media playback apps require common configuration of their capabilities and audio session. In addition to performing the steps outlined in Configuring your app for media playback, Destination Video also adopts new AVAudioSession API to customize a person’s Spatial Audio experience.": {
      "zh": "媒体播放应用需要对其功能和音频会话进行通用配置。除了执行配置应用以进行媒体播放中列举的步骤之外，Destination Video 还采用新的 AVAudioSession API 来自定义用户的空间音频体验。",
      "tips": ""
    },
    "After the app successfully loads a video for playback, it configures the Spatial Audio experience for the current presentation. For the inline player view, it sets the experience to a small, focused sound stage where the audio originates from the location of the view. When displaying a video full window, it sets the experience to a large, fully immersive sound stage.": {
      "zh": "应用成功加载视频进行播放后，会为当前的演示内容配置空间音频体验。对于内联播放器视图，它将体验设置为一个小型的、集中的声场，其中音源来自视图的位置。当显示全屏视频时，它会将体验设置为大型、完全沉浸式的声场。",
      "tips": ""
    },
    "Present an immersive space": {
      "zh": "呈现沉浸式空间",
      "tips": ""
    },
    "Building video playback apps for visionOS provides new opportunities to enhance the viewing experience beyond the bounds of the player window. To add a greater level of immersion, the sample presents an immersive space that displays a scene around a person as they watch the video. It defines the immersive space in the DestinationVideo app structure.": {
      "zh": "在 visionOS 上制作视频播放应用提供了新的机会，因为开发者可以将观看体验扩展到播放器窗口之外。为了提供更强的沉浸感，该示例提供了一个在用户观看视频时在其周围显示风景的沉浸式空间。应用结构体 DestinationVideo 中定义了沉浸式空间。",
      "tips": ""
    },
    "The immersive space presents an instance of DestinationView, which maps a texture to the inside of a sphere that it displays around a person. The app presents it using the .progressive immersion style, which lets someone change their amount of immersion by turning the Digital Crown on the device.": {
      "zh": "沉浸式空间呈现了一个 DestinationView 的实例，它将纹理映射到围绕用户而显示的球体内部。应用使用 .progressive 风格呈现它，该风格允许用户通过转动设备上的“数码表冠”来修改沉浸度。",
      "tips": ""
    },
    "The Destination Video app automatically presents the immersive space when a person navigates to a video’s detail view, and dismisses it when they return to the library. To monitor these events, the app observes its navigation path to determine when a navigation event occurs so it can show or dismiss the space.": {
      "zh": "应用会在用户进入视频详情视图时自动显示沉浸式空间，并在返回资源库时将其关闭。为了监视这些事件，应用会观察其导航路径以确定导航事件发生的时机，并显示或关闭空间。",
      "tips": ""
    },
    "Provide a shared viewing experience": {
      "zh": "提供共享的观看体验",
      "tips": ""
    },
    "One of the best ways to enhance your app’s playback experience is to make that experience shareable with others. You can use the AVFoundation and the GroupActivities frameworks to build SharePlay experiences that bring people together even when they can’t be in the same location.": {
      "zh": "增强应用播放体验的最佳方法之一是使体验可与他人共享。您可以使用 AVFoundation 和 Group Activities 框架来构建同播共享体验，即使用户们不在同一个地方，同播体验也能够拉近他们的距离。",
      "tips": ""
    },
    "The Destination Video app creates an experience where people can watch videos with others across devices and platforms. It defines a group activity called VideoWatchingActivity that adopts the GroupActivity protocol. When people have a FaceTime call active and they play a video in the full-window player, it becomes eligible for playback for everyone on the call.": {
      "zh": "目的地视频创造了一种用户可以跨设备和平台与他人一起观看视频的体验。它定义了一个名为 VideoWatchingActivity 且遵循 GroupActivity 协议的组活动。当用户们激活了 FaceTime 通话并在全屏播放器中播放视频时，通话中的每个人都有权限播放该视频。",
      "tips": ""
    },
    "The app’s VideoWatchingCoordinator actor manages Destination Video’s SharePlay functionality. It observes the activation of new VideoWatchingActivity sessions and when one starts, it sets the GroupSession instance on the player object’s AVPlaybackCoordinator.": {
      "zh": "应用的 VideoWatchingCoordinator actor 管理目的地视频的同播共享功能。它观察新 VideoWatchingActivity 会话的激活，当一个会话启动时，它将 GroupSession 对象设置为播放器对象的 AVPlaybackCoordinator。",
      "tips": ""
    },
    "With the player configured to use the group session, when the app loads new videos, they become eligible to share with people in the FaceTime call.": {
      "zh": "将播放器配置使用群组会话后，每当应用加载了新视频，它们都可以在 FaceTime 通话中与他人共享。",
      "tips": ""
    }
  },
  "visionos/diagnosing-and-resolving-bugs-in-your-running-app": {
    "Diagnosing and resolving bugs in your running app": {
      "zh": "",
      "tips": ""
    },
    "Inspect your app to isolate bugs, locate crashes, identify excess system-resource usage, visualize memory bugs, and investigate problems in its appearance.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Unit testing determines whether your code delivers results that meet your expectations, but it doesn’t explain the cause when it doesn’t. To diagnose an error, attach the debugger, reproduce the error, and then narrow down its root cause by inspecting your variables at key points in your code while the app is running with breakpoints. If you configure a scheme’s run action for debugging by using the Debug executable checkbox in Info settings, the app will attach to the debugger automatically when the app uses the scheme. To attach the debugger to a process that is already running, choose Debug → Attach to Process, and select your app’s process from the list. Follow this same process to diagnose and resolve errors in your code, crashes, memory leaks, and layout problems.": {
      "zh": "",
      "tips": ""
    },
    "Pause the app to inspect variables and isolate bugs": {
      "zh": "",
      "tips": ""
    },
    "To fix a bug, you first need to understand what is causing it. To narrow down the cause of a bug, develop a set of steps to reliably reproduce it:": {
      "zh": "",
      "tips": ""
    },
    "Determine where the bug happens in your source code.": {
      "zh": "",
      "tips": ""
    },
    "Pause your app with a breakpoint in your source code before the point at which you believe the bug occurs.": {
      "zh": "",
      "tips": ""
    },
    "Look at your variables and confirm they have the values you expect. If they don’t, begin again with step 1.": {
      "zh": "",
      "tips": ""
    },
    "Step through your code and watch your variables change. Note where your variables have unexpected values.": {
      "zh": "",
      "tips": ""
    },
    "Analyze your code to determine a fix.": {
      "zh": "",
      "tips": ""
    },
    "After determining a potential fix for the bug, confirm the diagnosis by changing your code and retesting to reproduce it. If the change addresses the problem, you’ve resolved the bug. If your change doesn’t resolve it, reconsider where the bug might be occurring, and repeat the steps to isolate and fix it.": {
      "zh": "",
      "tips": ""
    },
    "For more information on setting breakpoints and inspecting variables, see Setting breakpoints to pause your running app and Stepping through code and inspecting variables to isolate bugs.": {
      "zh": "",
      "tips": ""
    },
    "Locate crashes, exceptions, and runtime issues": {
      "zh": "",
      "tips": ""
    },
    "When your app experiences a crash, exception, or runtime issue, it can be challenging to pinpoint the code causing the problem because the stack trace for the crash doesn’t always point to the line of code that causes the crash. Use the rubric below to identify the problem characteristics and then set the correct type of breakpoint:": {
      "zh": "",
      "tips": ""
    },
    "A crash that stops at main or highlights AppDelegate is frequently an Objective-C exception.": {
      "zh": "",
      "tips": ""
    },
    "A crash that is the result of a runtime issue also stops at main or highlights AppDelegate, and may have a message similar to: “Thread 8: EXC_BAD_INSTRUCTION (code=…)”.": {
      "zh": "",
      "tips": ""
    },
    "A crash that stops at an uncaught or unhandled Swift error displays a fatal error message and indicates a Swift error.": {
      "zh": "",
      "tips": ""
    },
    "Add a breakpoint to your code in a location based on problem characteristics, then when your app stops at the breakpoint, check the state of the code execution. For more information on setting breakpoints and identifying crashes, see Setting breakpoints to pause your running app and Identifying the cause of common crashes.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "Your Swift code can receive an Objective-C exception when it uses code from a module that uses Objective-C.": {
      "zh": "",
      "tips": ""
    },
    "Inspect variables and execution sequence without pausing": {
      "zh": "",
      "tips": ""
    },
    "When you develop code, it’s helpful to log actions and variable values so you understand how your code runs and what values your variables have at different points in your app. This is especially true when you develop concurrent code, or code that executes simultaneously across multiple queues or threads, because bugs can be intermittent and difficult to reproduce. Often, you reproduce a bug in normal execution, but not when stepping through the debugger, because the timing is different between normal execution and debugging. The debugger provides tools to inspect variables without pausing and disturbing the timing of your concurrent code.": {
      "zh": "",
      "tips": ""
    },
    "Developers commonly add print or NSLog statements to see variable values. While this technique works, it adds extra code that isn’t useful after you finish development, and leaves your app with a noisy console that makes diagnosing subsequent bugs more difficult. Instead, use breakpoint actions to know when events in your app take place, and inspect variable values without pausing.": {
      "zh": "",
      "tips": ""
    },
    "To determine whether your code executes with minimal effect to timing, use a breakpoint action to play a sound and continue executing. If the debugger reaches the breakpoint when you run the app, it plays the sound and confirms execution.": {
      "zh": "",
      "tips": ""
    },
    "To log a variable value to the console without pausing, add a breakpoint with a Debugger Command action using po to print out the evaluation of an object, or v to print the value of a variable to the console. Select the Automatically continue after evaluating actions option for the breakpoint to prevent pausing.": {
      "zh": "",
      "tips": ""
    },
    "To log custom text to the console and add context to variable values, add a breakpoint with a Log Message action. Specify your custom text, and include expressions, the breakpoint name, or the breakpoint hit count to provide more information.": {
      "zh": "",
      "tips": ""
    },
    "Because po compiles code dynamically to evaluate expressions, it takes more time to evaluate your variable and log it to the console. To reduce timing issues, use v to log variable values instead.": {
      "zh": "",
      "tips": ""
    },
    "Use other breakpoint actions to execute an AppleScript or a shell script, or to capture a GPU frame.": {
      "zh": "",
      "tips": ""
    },
    "For more information on inspecting variables, see Setting breakpoints to pause your running app and Stepping through code and inspecting variables to isolate bugs.": {
      "zh": "",
      "tips": ""
    },
    "Identify potential overuse of CPU and memory": {
      "zh": "",
      "tips": ""
    },
    "An easily overlooked and common problem in development and testing is the overuse of CPU and memory. Xcode’s debugger provides gauges in the Debug navigator to help investigate potential problems. Monitor the gauges while you’re testing your app to uncover unusual usage. Click a gauge for a more detailed view.": {
      "zh": "",
      "tips": ""
    },
    "The CPU gauge shows the amount of CPU the app requires to process instructions over time. When your app is drawing the user interface, processing data it retrieves from the network, or performing calculations, it‘s normal to see CPU usage increase to fairly high numbers for a short period of time. When those tasks are complete and your app is idle and waiting for the user to perform an action, CPU usage should be zero or very low. Do additional analysis if CPU usage is:": {
      "zh": "",
      "tips": ""
    },
    "Persistent at a level above zero when the app appears to be idle.": {
      "zh": "",
      "tips": ""
    },
    "Over 100% for more than very short periods of time.": {
      "zh": "",
      "tips": ""
    },
    "Very high and you see hitches in your user interface.": {
      "zh": "",
      "tips": ""
    },
    "For more information on improving performance, see Improving your app’s performance.": {
      "zh": "",
      "tips": ""
    },
    "The Memory gauge shows how much memory your app uses over time. It starts at a fairly small number, less than 10 MB, when you first launch your app, and then increases as people navigate through your user interface. It may also increase if you fetch, process, and store data from the network, or perform complex calculations. It then decreases when processing is complete. Watch the gauge as you navigate through your app, and note when memory usage goes up and down. Memory usage increases when you present modal views or add a view to a navigation controller, and decreases when you dismiss or navigate away from those views. If your usage continues to increase and doesn’t ever decrease, investigate whether you have a memory leak or abandoned memory. For more information on reducing memory use and resolving memory leaks, see the section below Visualize and diagnose increasing memory usage and Reducing your app’s memory use.": {
      "zh": "",
      "tips": ""
    },
    "Detect high disk access and network use": {
      "zh": "",
      "tips": ""
    },
    "Be aware of issues resulting from frequent access to resources on disk and over the network. You can monitor these resources using the gauges in Xcode’s debugger as well. The Disk I/O gauge shows how much data your app reads and writes from disk over time. The gauge shows if you:": {
      "zh": "",
      "tips": ""
    },
    "Store data that the user generates in your app.": {
      "zh": "",
      "tips": ""
    },
    "Store data in user preferences.": {
      "zh": "",
      "tips": ""
    },
    "Fetch data from the network and store it.": {
      "zh": "",
      "tips": ""
    },
    "Read data from your app bundle or the app’s directories.": {
      "zh": "",
      "tips": ""
    },
    "Storing and reading data frequently from disk uses more power than doing so from memory, and it adds wear and tear to the user’s device. To know whether disk usage is unusual, you need to understand the size of data you’re storing and reading, and compare that to what you observe in the gauge. For example, if you download and store a 5 MB graphic file for display in a view that you use frequently and it writes over 50 MB of data, investigate whether the remote image changes frequently, or whether you need to configure networking to prevent redownloading the same image. If you’re reading more data from disk than you expect, investigate whether a memory-caching solution might help, or whether you’re initiating a data read from the wrong point in your app or view life cycle, and reading it too often. For more information on reducing disk writes, see Reducing disk writes.": {
      "zh": "",
      "tips": ""
    },
    "The Network I/O gauge shows how much data your app reads from and writes to the network over time. If your app only uses local resources, your app may not read or write any data from the network. Communicating data over the network uses energy and reduces the device’s battery life, so minimize data transfer wherever possible. To understand your app’s network usage, watch the Network I/O gauge when your app is sending or receiving data from the network. For example, if you implement a cache system for downloaded images and your network usage increases when accessing them, confirm that your cache settings are correct in the app and on the server. If you’re uploading user-generated content and frequent upload failures during poor networking conditions lead to high network usage, implement a system to recover and restart failed uploads at the point of failure, rather than reuploading the entire file.": {
      "zh": "",
      "tips": ""
    },
    "Visualize and diagnose increasing memory usage": {
      "zh": "",
      "tips": ""
    },
    "Diagnose the cause of memory leaks and abandoned memory with the memory graph. The observable symptom of a memory leak is memory usage that continues to increase over time, even when conditions in the app indicate that memory usage is decreasing. A memory leak can occur in a retain cycle, which is when objects maintain strong references to each other, but the app no longer references them. These objects remain in memory and the app can’t remove them. Abandoned memory occurs when you create objects and your code still references them, but your app no longer needs them or uses them.": {
      "zh": "",
      "tips": ""
    },
    "To see the memory graph in the debugger, pause your app at a breakpoint and click the Debug Memory Graph button in the debug bar. Alternatively, click the Debug Memory Graph button when the app is running to pause the app and show the memory graph.": {
      "zh": "",
      "tips": ""
    },
    "The memory graph view replaces the stack trace in the Debug navigator with a list of types, organized by library, each with a list of instances called nodes. Select a node to view its memory graph.": {
      "zh": "",
      "tips": ""
    },
    "A node’s memory graph shows all the memory references to that node, and highlights strong references. Control-click any node in the graph to perform more actions, such as accessing Quick Look or printing the description to the console. Choose Focus on Node to show the graph for the selected node. Click a reference to see its details, including the name of the variable, the type of reference, and the source and destination objects in memory.": {
      "zh": "",
      "tips": ""
    },
    "To resolve a memory leak for a retain cycle:": {
      "zh": "",
      "tips": ""
    },
    "Observe the Memory gauge while you navigate the app.": {
      "zh": "",
      "tips": ""
    },
    "Note when memory usage increases when your app instantiates an object, but doesn’t decrease when you expect the system to deallocate the object.": {
      "zh": "",
      "tips": ""
    },
    "Examine the memory graph to see if there are an unexpected number of instances of the object or inappropriate strong references to it.": {
      "zh": "",
      "tips": ""
    },
    "If there is a strong reference to the object, Control-click the node with the strong reference and choose Focus on Node to view its graph. If the node also has a strong reference from the object, this is a retain cycle.": {
      "zh": "",
      "tips": ""
    },
    "Resolve the retain cycle by changing one side of the relationship to use a weak declaration for the reference to the other object, or remove the reference altogether by removing any dependencies on the other object. Retest to confirm that the change fixes the issue.": {
      "zh": "",
      "tips": ""
    },
    "To resolve abandoned memory issues, identify the time in your app’s life cycle that it no longer needs the abandoned object and remove any references to it.": {
      "zh": "",
      "tips": ""
    },
    "Inspect and resolve appearance and layout issues": {
      "zh": "",
      "tips": ""
    },
    "Some issues in the appearance or layout of your app only appear when you configure the system with a particular interface style, dynamic text size or when your app uses particular accessibility features. Use environmental overrides when targeting iOS, macOS, and tvOS apps to test your interface in these environments. To understand issues that involve the position or size of your view, you might need to inspect them within the context of views in other layers. Use the view debugger when targeting iOS, macOS, tvOS, and watchOS apps, which displays a 3D representation of the view hierarchy in layers, to help diagnose these issue. Entities within a visionOS app and their surroundings sometimes interact with each other in ways you don’t expect. Enable visualizations to represent coordinate axes, bounding boxes, and other information that is normally invisible, to help understand these interactions.": {
      "zh": "",
      "tips": ""
    },
    "For information on using these features to debug the appearance of your app, see Diagnosing issues in the appearance of a running app.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/diagnosing-issues-in-the-appearance-of-your-running-app": {
    "Diagnosing issues in the appearance of a running app": {
      "zh": "",
      "tips": ""
    },
    "Inspect your running app to investigate issues in the appearance and placement of the content it displays.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "At times your app’s content may appear to be missing, out of place, or have an appearance that is incorrect. To identify and diagnose the cause of these issues, attach the debugger, reproduce the error, and then narrow down its root cause by inspecting changes in your interface, the code that is executing, and the state of variables. If you configure a scheme’s run action for debugging by using the Debug executable checkbox in Info settings, the app will attach to the debugger automatically when the app uses the scheme. To attach the debugger to a process that is already running, choose Debug → Attach to Process, and select your app’s process from the list.": {
      "zh": "",
      "tips": ""
    },
    "Temporarily override system settings to control your app’s appearance and reveal problems that only occur when these settings are in effect, understand layout issues by visualize your views in stacked layers, and debug content in immersive space by adding visual overlays.": {
      "zh": "",
      "tips": ""
    },
    "Adjust system configurations to identify their impact on your views": {
      "zh": "",
      "tips": ""
    },
    "Some visual issues only arise when you configure the system using specific environmental settings. Xcode provides environmental overrides when targeting iOS, macOS, and tvOS apps to help you debug these issue. Use these environmental overrides to change the interface style, dynamic text size, and to induce the effects of other accessibility options, so you can understand the effect of these changes on the layout and visual appearance of your views.": {
      "zh": "",
      "tips": ""
    },
    "To enable one or more of these overrides, click the Enable Overrides button on Xcode’s debugging toolbar, toggle the switch next to the override category, and configure the controls under the category heading.": {
      "zh": "",
      "tips": ""
    },
    "View your app’s content with a light or dark appearance. Select between light and dark appearances using the radio button.": {
      "zh": "",
      "tips": ""
    },
    "View your app’s content using different dynamic type sizes. Select the size using the slider. For more information on dynamic types, see DynamicTypeSize.": {
      "zh": "",
      "tips": ""
    },
    "View the effects various accessibility features have on your app’s content. Click the checkboxes to enable or disable the accessibility features.": {
      "zh": "",
      "tips": ""
    },
    "Resolve issues in the layout of your UIKit and SwiftUI views": {
      "zh": "",
      "tips": ""
    },
    "Use the View debugger, available when targeting iOS, macOS, tvOS, and watchOS apps, to diagnose the reasons an item in your user interface is in the wrong position or is the wrong size. Set a breakpoint in your app after it presents the view, for example, in a viewDidAppear: method, then click the View Debugger button in the debug bar when the debugger pauses on your breakpoint. Alternatively, just click the View Debugger button after your app presents the view.": {
      "zh": "",
      "tips": ""
    },
    "The debugger displays a 3D rendering of the current view on the canvas in the center, with a representation of the view hierarchy in the Debug navigator. Drag the view in any direction to see a 3D representation of the current view stack, and use the controls at the bottom of the canvas to adjust the views and the spacing between them.": {
      "zh": "",
      "tips": ""
    },
    "Click to select a view in either the visual rendering or the view hierarchy in the Debug navigator, then inspect details in the Object inspector or Size inspector. Resolve your layout issue according to the type of layout:": {
      "zh": "",
      "tips": ""
    },
    "The view debugger shows the frames you specify in the Size inspector. If the size isn’t what you expect, step through your code to diagnose issues with your frame calculations. Then fix and retest.": {
      "zh": "",
      "tips": ""
    },
    "The Size inspector shows constraints. Click a constraint to highlight it in the view debugger. Analyze the constraints that affect the misplaced or mis-sized view to diagnose the issue. Adjust your constraints, either in your code or in Interface Builder, and retest.": {
      "zh": "",
      "tips": ""
    },
    "The Size inspector shows how SwiftUI resolves the size and placement of your view. With that information, analyze and adjust your SwiftUI code and retest.": {
      "zh": "",
      "tips": ""
    },
    "Understand the relationships between objects in a immersive space": {
      "zh": "",
      "tips": ""
    },
    "For visionOS apps with content in an immersive space, it’s often helpful to see a visual representation of coordinate axes, bounding boxes, and other information that is normally invisible. Xcode’s debugging tools include options to display this information in Simulator or on a device. Use them to ensure that your entities are located where you expect, and interacting with each other and the surroundings the way you anticipate. For example, if an entity isn’t responding to events, enable Collision Shapes to confirm the presence of one, required for event handling, and indicate its boundary.": {
      "zh": "",
      "tips": ""
    },
    "To annotate your content with an overlay, click the Enable Visualizations button on Xcode’s debugging toolbar and select one or more of the options:": {
      "zh": "",
      "tips": ""
    },
    "Red, green and blue arrows indicating the x, y, and z axes of each object in the space. Use this to understand the orientation of each object.": {
      "zh": "",
      "tips": ""
    },
    "Green lines that indicate the bounding edge of each entity.": {
      "zh": "",
      "tips": ""
    },
    "A dot marking the the origin of each object.": {
      "zh": "",
      "tips": ""
    },
    "Red, green and blue arrows indicating the x, y, and z axes of each anchor point and a yellow line betwen entities and their anchors. Use this to understand the placement of entities in relation to other real-world objects in the space.": {
      "zh": "",
      "tips": ""
    },
    "A white outline around the collision shape of an entity. Use this to understand issues in event detection.": {
      "zh": "",
      "tips": ""
    },
    "A multi-colored wireframe around real objects in the space. Use this to identify areas where virtual objects are correctly or incorrectly being hidden behind real objects.": {
      "zh": "",
      "tips": ""
    },
    "White border lines and diagonals marking each surface. Use this to understand the borders of surfaces that the system detects.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/diorama": {
    "Diorama": {
      "zh": "西洋镜",
      "tips": ""
    },
    "Design scenes for your visionOS app using Reality Composer Pro.": {
      "zh": "使用 Reality Composer Pro 设计 visionOS 应用中的场景。",
      "tips": ""
    },
    "Overview": {
      "zh": "概览",
      "tips": ""
    },
    "Use Reality Composer Pro to compose, edit, and preview RealityKit content for your visionOS app. In your Reality Composer Pro project, you can create one or more scenes, each of which contains a hierarchy of virtual objects called entities that your app can efficiently load and display.": {
      "zh": "VisionOS 应用程序使用 RealityKit 展示的虚拟现实内容，可以通过 Reality Composer Pro 来构建，编辑，预览。在 Reality Composer Pro 项目中，可以创建多个场景，每个场景通过层次结构组织虚拟对象（也就是实体），这样你的应用程序可以高效率地加载显示虚拟现实内容。",
      "tips": ""
    },
    "In addition to helping you compose entity hierarchies, Reality Composer Pro also gives you the ability to add and configure components — even custom components that you’ve written — to the entities in your scenes.": {
      "zh": "另外，在 Reality Composer Pro 中也可以为场景中的实体（ Entity ）增加和配置组件（ Component ）—— 也包括自定义的组件，这样可以帮助你构建实体的层次结构。",
      "tips": ""
    },
    "You can also design the visual appearance of entities using Shader Graph, a node-based visual tool for creating RealityKit materials. Shader Graph gives you a tremendous amount of control over the surface details and shape of entities. You can even create animated materials and dynamic materials that change based on the state of your app or user input.": {
      "zh": "你也可以使用 Shader Graph 设计实体的虚拟外观，Shader Graph 也是一个基于节点的视觉工具，用来创造 RealityKit 可以使用的素材（Materials）。Shader Graph 提供了丰富的表面细节和形状可以操作的实体。你也可以创建有动画效果的材质( animated materials )和动态的材质（ dynamic materials ），这些素材可以根据应用程序的状态或用户的输入而改变。",
      "tips": ""
    },
    "Diorama demonstrates many of RealityKit and Reality Composer Pro’s features. It displays an interactive, virtual topographical trail map, much like the real-world dioramas you find at trailheads and ranger stations in national parks. This virtual map has points of interest you can tap to bring up more detailed information. You can also smoothly transition between two trail maps: Yosemite and Catalina Island.": {
      "zh": "Diorama 项目展示了 RealityKit 和 Reality Composer Pro 许多特性。这个项目展示了一个可交互的虚拟徒步地形图，模拟了现实世界中国家公园的登山路径和护林员站点的地形图。虚拟地图上有标志性景点，可以点击获取详细信息。也可以在 Yosemite 和 Catalina Island 这两个虚拟徒步地图之间丝滑的切换。",
      "tips": ""
    },
    "Import assets for building the scene": {
      "zh": "导入 Asset 来构建场景",
      "tips": ""
    },
    "Your Reality Composer Pro project must contain assets, which you use to compose scenes for your app. Diorama’s project has several assets, including 3D models like the diorama table, trail map, some birds and clouds that fly over the map, and a number of sounds and images. Reality Composer Pro provides a library of 3D models you can use. Access the library by clicking the Add (+) button on the right side of the toolbar. Selecting objects from the library imports them into your project.": {
      "zh": "Reality Composer Pro 项目包含了应用程序用来构建场景的各种数字资源（ Asset ）。Diorama 项目中有多个 Asset ，包括许多 3D 模型，比如仿真桌子，模拟的徒步地形图，几只鸟儿和云朵，以及环境音和一些图像。Reality Composer Pro 提供了一系列内置 3D 模型。可以点击窗口右上角的“ Add (+) ”按钮，在右边弹出的工具栏中可以看到这些 3D 模型。选择相应的对象就将它们导入到项目中。",
      "tips": ""
    },
    "Diorama uses custom assets instead of the available library assets. To use custom assets in your own Reality Composer Pro scenes, import them into your project in one of three ways: by dragging them to Reality Composer Pro’s project browser, using File > Import from the File menu, or copying the assets into the .rkassets bundle inside your project’s Swift package.": {
      "zh": "Diorama 使用的是自定义的 Asset。为了在 Reality Composer Pro 的场景中使用自定义的 Asset ，有三种方式将 Asset 导入到项目中：直接将它们拖拽到 Reality Composer Pro 项目的 Project Browser 窗口中；点击菜单栏中“ File > Import ”选择相应的资源文件( Asset )导入；将资源文件( Asset ) 拷贝到项目关联的 Swift package 的 .rkassets Bundle中。",
      "tips": ""
    },
    "Note": {
      "zh": "注意",
      "tips": ""
    },
    "Although you can still load USDZ files and other assets directly in visionOS, RealityKit compiles assets in your Reality Composer Pro project into a binary format that loads considerably faster than loading from individual files.": {
      "zh": "即使可以在 VisionOS 系统中直接加载 USDZ 文件，以及其他的资源文件( Asset )，但是 RealityKit 会将 Reality Composer Pro 项目中的资源文件( Asset )编译为二进制格式，这比加载单独的文件要快得很多。",
      "tips": ""
    },
    "Create scenes containing the app’s entities": {
      "zh": "创建包含应用程序实体的场景",
      "tips": ""
    },
    "A single Reality Composer Pro project can have multiple scenes. A scene is an entity hierarchy stored in the project as a .usda file that you can load and display in a RealityView. You can use Reality Composer’s scenes to build an entire RealityKit scene, or to store reusable entity hierarchies that you can use as building block for composing scenes at runtime — the approach Diorama uses. You can add as many different scenes to your project as you need by selecting File > New > Scene, or pressing ⌘N.": {
      "zh": "单独的 Reality Composer Pro 项目中可以有很多个场景。场景是实体的层次结构，在项目中以 .usda 类型的文件存储场景，可以通过 RealityView 加载显示。你可以使用 Reality Composer 的“ Scenes ”可以构建完整的 RealityKit 场景，也可以用于存储可重用的实体层次结构——在运行时作为构建块创建其他场景——类似于 Diorama 项目中那样使用。可以根据需要，在菜单栏中选择“ File > New > Scene ”，或者点击“ ⌘N ”，在项目中添加不同场景。",
      "tips": ""
    },
    "At the top of the Reality Composer Pro window, there’s a separate tab for every scene that’s currently open. To open a scene, double-click the scene’s .usda file in the project browser. To edit a scene, select its tab, and make changes using the hierarchy viewer, the 3D view, and the inspector.": {
      "zh": "在 Reality Composer Pro 窗口的顶端显示当前所有打开场景的标签 Tab 。 Project Browser 窗口中双击 .usda 文件来打开场景。选中场景的标签 tab ，这样就可以编辑场景——在 Hierarchy Viewer 窗口（在左侧），3D 内容展示（中间），Inspector 属性窗口（在右侧）可以对场景做修改。",
      "tips": ""
    },
    "Add assets to your scenes": {
      "zh": "在场景中添加资源 Asset",
      "tips": ""
    },
    "RealityKit can only include entities in a scene, but it can’t use every type of asset that Reality Composer Pro supports as an entity. Reality Composer Pro automatically turns some assets, like 3D models, into an entity when you place them in a scene. It uses other assets indirectly. It uses image files, for example, primarily to define the surface details of model entities.": {
      "zh": "RealityKit 只支持场景中包含实体，但它无法将 Reality Composer Pro 支持的所有类型的资源 Asset 转化为实体使用。当你将某些 Asset——例如3D模型，置于场景中时，Reality Composer Pro 会自动将 Asset 转化为一个实体。Reality Composer Pro 则会间接使用其他类型的资源 Asset。例如，它主要使用图像文件描绘模型实体的表面细节。",
      "tips": ""
    },
    "Diorama uses multiple scenes to group assets together and then, at runtime, combines those scenes into a single immersive experience. For example, the diorama table has its own scene that includes the table, the map surface, and the trail lines. There are separate scenes for the birds that flock over the table, and for the clouds that float above it.": {
      "zh": "Diorama 使用多个场景将资源 Asset 整合在一起，这样运行时可以将这些场景整合为一个完整的沉浸式体验环境。例如，DioramaAssembled 场景中包含了桌子，徒步地形图作为桌面，以及地形图上的路线。在地形图上飞翔的鸟群和漂浮的云朵也分作独立的场景。",
      "tips": ""
    },
    "To add entities to a scene, drag assets from the project browser to the scene’s hierarchy view or 3D view. If the asset you drag is a type that can be represented as an entity, Reality Composer Pro adds it to your scene. You can select any asset in the scene hierarchy or the 3D view and change its location, rotation, and scale using the inspector on the right side of the window or the manipulator in the 3D view.": {
      "zh": "将 Asset 从 Project Browser 窗口拖拽到场景层次结构中或 3D 内容展示区域中，这样就在场景中添加了实体。如果你拖拽的 Asset 可以作为实体的类型，Reality Composer Pro 就会将它添加到场景中。在场景层次结构 或者 3D 内容展示区域中选中任何一个 Asset ，可以在右侧的 Inspector 属性窗口中，或者3D 内容展示区域使用操纵器 Manipulator ，调整 Asset 的位置，旋转角度，或者缩放操作。",
      "tips": ""
    },
    "Add components to entities": {
      "zh": "给实体添加组件",
      "tips": ""
    },
    "RealityKit follows a design pattern called Entity Component System (ECS). In an ECS app, you store additional data on an entity using components and can implement entity behavior by writing systems that use the data from those components. You can add and configure components to entities in Reality Composer Pro, including both shipped components like PhysicsBodyComponent, and custom components that you write and place in the Sources folder of your Reality Composer Pro Swift package. You can even create new components in Reality Composer Pro and then edit them in Xcode. For more information about ECS, see Understanding RealityKit’s modular architecture.": {
      "zh": "RealityKit 遵循“实体-组件-系统”（ ECS ）的设计原则。在 ECS 架构的应用程序中，你就可以使用组件存储实体额外的数据，使用组件中的数据编写系统逻辑实现实体的行为。Reality Composer Pro 中可以为实体添加和设置组件，组件类型包括像 PhysicsBodyComponent 这样自带的组件，也可以自定义的组件——位于 Reality Composer Pro 项目的 Swift Package 包中的 Sources 文夹件下。你也可以在 Reality Composer Pro 中创建新的组件，并且可以在 Xcode 中修改它们。更多关于 ECS 的信息，请查阅 Understanding RealityKit’s modular architecture 。",
      "tips": ""
    },
    "Diorama uses custom components to identify which transforms are points of interest, to mark the birds so the app can make sure they flock together, and to control the opacity of entities that are specific to just one of the two maps.": {
      "zh": "Diorama 使用自定义组件辨认那些标志性景点的变换操作 transform ，标记鸟儿让它们成群结队的飞翔，或者指定两张地图中的一个的组件以控制实体的透明度。",
      "tips": ""
    },
    "To add a component to an entity, select that entity in the hierarchy view or 3D view. At the bottom right of the inspector window, click on the Add Component button. A list of available components appears and the first item in that list is New Component. This item creates a new component class, and optionally a new system class, and adds the component to the selected entity.": {
      "zh": "在层次结构或 3D 内容展示区域中选择其中的实体，这时展示在右侧 Inspector 属性窗口种，点击最下面的 Add Component 按钮来为选中的实体添加组件。这时，屏幕中间会出现一个可用的组件列表，列表的第一行是“ New Component ”。这个选项是创建一个新的组件类别，也可以选择创建一个新的系统类别，同时把这个新创建的组件添加到了选中的实体中。",
      "tips": ""
    },
    "If you look at the list of components, you see the PointOfInterestComponent that Diorama uses to indicate which transforms are points of interest. If the selected entity doesn’t already contain a PointOfInterestComponent, selecting that adds it to the selected entity. Each entity can only have one component of a specific type. You can edit the values of the existing component in the inspector, which changes what shows up when you tap that point of interest in the app.": {
      "zh": "在组件列表中，可以看到 Diorama 项目中用来辨认标志性景点的变换操作 Transform 的 PointOfInterestComponent 组件。如果选中实体没有包含 PointOfInterestComponent 组件，选择把这个组件添加到选中的实体中。每个实体有且仅有一个某种类型组件的实例。你可以在 Inspector 属性窗口编辑现存组件的数值，这些会改变标志性景点被点击时的显示。",
      "tips": ""
    },
    "Use transforms to mark locations": {
      "zh": "使用 Transform 去做标注点",
      "tips": ""
    },
    "In Reality Composer Pro, a transform is an empty entity that marks a point in space. A transform contains a location, rotation, and scale, and its child entities inherit those. But, transforms have no visual representation and do nothing by themselves. Use transforms to mark locations in your scene or organize your entity hierarchy. For example, you might make several entities that need to move together into child entities of the same transform, so you can move them together by moving the parent transform.": {
      "zh": "在 Reality Composer Pro 中，Transform 是标记空间的点的虚实体。Transform 包含位置信息 Position，旋转信息 Rotation，缩放信息 Scale，同时他的子类实体会继承这些信息。但是，Transform 没有视觉表述，它们本身没有独立的功能。Transform 是用来标记场景中位置，或者用来组织实体层次结构。比如，你会将需要一起移动的实体设置为有相同 Transform 的子实体，这样就可以通过移动父实体的 Transform 的同时将子实体们一起移动。",
      "tips": ""
    },
    "Diorama uses transforms with a PointOfInterestComponent to indicate points of interest on the map. When the app runs, those transforms mark the location of the floating placards with the name of the location. Tapping on a placard expands it to show more detailed information. To turn transforms into an interactive view, the app looks for a specific component on transforms called a PointOfInterestComponent. Because a transform contains no data other than location, orientation, and scale, it uses this component to hold the data the app needs to display on the placards. If you open the DioramaAssembled scene in Reality Composer Pro and click on the transform called Cathedral_Rocks, you see the PointOfInterestComponent in the inspector.": {
      "zh": "Diorama 使用 PointOfInterestComponent 组件和 Transform 一起标示地图上的标志性景点。在应用程序运行时，Transform 会标记展示地理位置名称的悬浮标牌的位置。点击标牌使其展开显示详细信息。将 PointOfInterestComponent 组件添加到 Transform 虚实体中，应用程序查找有 PointOfInterestComponent 类型组件的 Transform 虚实体，将其转化为可交互的视图。因为 Transform 除了包含位置数据 Position，方向数据 Rotation，缩放数据 Scale 之外没有其他的数据，所以 Transform 使用 PointOfInterestComponent 组件来存储标牌显示所需要的数据。在 Reality Composer Pro 打开名为 DioramaAssembled 场景，点击名为 Cathedral_Rocks 的 Transform，这时在 Inspector 属性窗口就能看到 PointOfInterestComponent 组件。",
      "tips": ""
    },
    "Load a scene at runtime": {
      "zh": "程序运行时加载场景",
      "tips": ""
    },
    "To load a Reality Composer Pro scene, use load(named:in:), passing the name of the scene you want to load and the project’s bundle. Reality Composer Pro Swift packages define a constant that provides ready access to its bundle. The constant is the name of the Reality Composer Pro project with “Bundle” appended to the end. In this case, the project is called RealityKitContent, so the constant is called RealityKitContentBundle. Here’s how Diorama loads the map table in the RealityView initializer:": {
      "zh": "为了更方便快捷地加载 Reality Composer Pro 场景，Reality Composer Pro Swift package 定义了一个常量，这个常量就是 Reality Composer Pro 项目名称后面追加 “Bundle” 字符。在调用 load(named:in:)，将场景的名称字符串作为 named 参数，“ {{ProjectName}}Bundle ”常量作为 in 参数，就可以加载 Reality Composer Pro 项目 Bundle 中的场景。下面的例子中，项目名是 RealityKitContent ，所以常量就是 RealityKitContentBundle 。下面代码就是在 Diorama 项目中通过 RealityView 初始化方法加载地图桌面场景：",
      "tips": ""
    },
    "The load(named:in:) function is asynchronous when called from an asynchronous context. Because the content closure of the RealityView initializer is asynchronous, it automatically uses the async version to load the scene. Note that when using it asynchronously, you must call it using the await keyword.": {
      "zh": "当从一个异步上下文中调用时 load(named:in:) 方法时，这个方法就会被异步执行的。因为 RealityView 初始化方法中的 content 闭包时异步执行，那么在闭包中加载场景也是异步的。注意异步调用 load(named:in:) 须要使用 await 关键字。",
      "tips": ""
    },
    "Create the floating view": {
      "zh": "创建悬浮视图",
      "tips": ""
    },
    "Diorama adds a PointOfInterestComponent to a transform to display details about interesting places. Every point of interest’s name appears in a view that floats above its location on the map. When you tap the floating view, it expands to show detailed information, which the app pulls from the PointOfInterestComponent. The app shows these details by creating a SwiftUI view for each point of interest and querying for all entities that have a PointOfInterestComponent using this query declared in ImmersiveView.swift:": {
      "zh": "Diorama 将 PointOfInterestComponent 组件添加到 Transform 用以显示景点的详细信息。地图上每个景点的位置上面都悬浮着显示景点名字的视图。点击悬浮视图时，便会展开显示详细信息，这些信息就是来自 PointOfInterestComponent 组件存储的数据。创建 SwiftUI 视图展示景点的详细信息，通过 PointOfInterestComponent 组件查询相应的实体，使用 ImmersiveView.swift 中声明的查询：",
      "tips": ""
    },
    "In the RealityView initializer, Diorama queries to retrieve the points of interest entities and passes them to a function called createLearnMoreView(for:), which creates the view and saves it for display when it’s tapped.": {
      "zh": "Diorama 项目中，在 RealityView 初始化方法中查询获取那些标志性景点实体，并将它们传递给 createLearnMoreView(for:) 函数，这个函数创建详情视图，并将它存储下来，在点击的时候在展示它。",
      "tips": ""
    },
    "Create attachments for points of interest": {
      "zh": "为标志性景点创建附属视图",
      "tips": ""
    },
    "Diorama displays the information added to a PointOfInterestComponent in a LearnMoreView, which it stores as an attachment. Attachments are SwiftUI views that are also RealityKit entities and that you can place into a RealityKit scene at a specific location. Diorama uses attachments to position the view that floats above each point of interest.": {
      "zh": "Diorama 用 LearnMoreView 视图展示 PointOfInterestComponent 组件中储存的详细信息，首先将 LearnMoreView 存储为附属视图。附属视图是 SwiftUI 视图，也是 RealityKit 实体，而在 RealityKit 场景中使用的是附属视图作为实体并设定位置。例如，Diorama 设置的是附属视图（ Attachment ）的位置，让它们悬浮在每个标志景点的上方。",
      "tips": "译者注：将 Attachment 译作“附属视图”，attachment 就像是链接 SwiftUI 环境 和 RealityKit 环境 的一个中间件。"
    },
    "The app first checks to see if the entity has a component called PointOfInterestRuntimeComponent. If it doesn’t, it creates a new one and adds it to the entity. This new component contains a value you only use at runtime that you don’t need to edit in Reality Composer Pro.": {
      "zh": "应用程序首先会检查实体是否有 PointOfInterestRuntimeComponent 组件。如果没有，会创建新的 PointOfInterestRuntimeComponent 组件并将这个组件添加到实体中。这个组件存储的是只有在运行时使用的数值，无需用 Reality Composer Pro 编辑。",
      "tips": ""
    },
    "By putting this value into a separate component and adding it to entities at runtime, Reality Composer Pro never displays it in the inspector. The PointOfInterestRuntimeComponent stores an identifier called an attachment tag, which uniquely identifies an attachment so the app can retrieve and display it at the appropriate time.": {
      "zh": "在运行时将数值放在单独的组件中，并把组件添加到实体中，Reality Composer Pro 不会在 Inspector 属性窗口中显示出这个运行时组件。PointOfInterestRuntimeComponent 用 attachmentTag 属性存储附属视图的唯一标识符，这样应用程序会在合适的时候通过 attachmentTag 获取相应视图并显示出来。",
      "tips": ""
    },
    "Next, Diorama creates a SwiftUI view called a LearnMoreView with the information from the PointOfInterestComponent, tags that view, and stores the tag in the PointOfInterestRuntimeComponent. Finally, it stores the view in an AttachmentProvider, which is a custom class that maintains references to the attachment views so they don’t get deallocated when they’re not in a scene.": {
      "zh": "接下来， Diorama 创建 LearnMoreView 类型的 SwiftUI 视图，显示 PointOfInterestComponent 中的信息，接下来设置详细视图的 tag 值，同时使用相同的 tag 值设置 PointOfInterestRuntimeComponent 的 attachmentTag 属性。最后，讲这些详细视图存储在 AttachmentProvider 中，AttachmentProvider 是用来维护持有附属视图引用的自定义类，以防这些视图没有在场景中而被释放。",
      "tips": ""
    },
    "Display point of interest attachments": {
      "zh": "展示标志景点的附属视图",
      "tips": ""
    },
    "Assigning a view to an attachment provider doesn’t actually display that view in the scene. The initializer for RealityView has an optional view builder called attachments that’s used to specify the attachments.": {
      "zh": "将视图添加到 AttachmentProvider 中时，并不会立即显示在场景中。可以选择 RealityView 有名为 attachments 的视图构建器（ ViewBuilder）参数的初始化方法，这个视图构建器创建的附属视图指定给了 attachments 参数。",
      "tips": ""
    },
    "In the update closure of the initializer, which RealityKit calls when the contents of the view change, the app queries for entities with a PointOfInterestRuntimeComponent, uses the tag from that component to retrieve the correct attachment for it, and then adds that attachment and places it above its location on the map.": {
      "zh": "当 RealityKit 视图内容发生变化的时候，会调用初始化时指定 update 闭包，在这个闭包中会通过 PointOfInterestRuntimeComponent 类型查询相应的实体，通过组件的 attachmentTag 属性获取对应的附属视图，然后将附属视图添加到地图上并设置它的位置。（译者注：详细请参阅 RealityView 的初始化方法）。",
      "tips": ""
    },
    "Create custom materials with Shader Graph": {
      "zh": "使用 Shader Graph 创建自定义的素材",
      "tips": ""
    },
    "To switch between the two different topographical maps, Diorama shows a slider that morphs the map between the two locations. To accomplish this, and to draw elevation lines on the map, the FlatTerrain entity in the DioramaAssembled scene uses a Shader Graph material. Shader Graph is a node-based material editor that’s built into Reality Composer Pro. Shader Graph gives you the ability to create dynamic materials that you can change at runtime. Prior to Reality Composer Pro, the only way to implement a dynamic material like this was to create a CustomMaterial and write Metal shaders to implement the necessary logic.": {
      "zh": "Diorama 通过滑动条控制两张地图之间渐变地切换。为了达到这种效果，先在地图上绘制等高翔，DioramaAssembled 场景中的 FlatTerrain 实体使用的 Shader Graph 素材。 Shader Graph 是基于节点（ node-base ）的素材编辑器，它已经集成到 Reality Composer Pro 。使用 Shader Graph 可以创建运行时改变的动态素材。在 Reality Composer Pro 推出之前，实现动态素材唯一办法就是创建自定义素材 CustomMaterial 并通过编写 Metal Shader 实现必要逻辑。",
      "tips": ""
    },
    "Diorama’s DynamicTerrainMaterialEnhanced does two things. It draws contour lines on the map based on height data stored in displacement map images, and it also offsets the vertices of the flat disk based on the same data. By interpolating between two different height maps, the app achieves a smooth transition between the two different sets of height data.": {
      "zh": "Diorama 项目中的 DynamicTerrainMaterialEnhanced 做了两件事情：根据地图模型的位移贴图中存储高度数据来描绘等高线和平面圆形上地形外表的顶点；通过在两个不同的高度地图之间进行插值。应用程序实现了在两组有不同的高度数据的地图之间平滑切换。",
      "tips": ""
    },
    "When you build Shader Graph materials, you can give them input parameters called promoted inputs that you set from Swift code. This allows you to implement logic that previously required writing a Metal shader. The materials you build in the editor can affect both the look of an entity using the custom surface output node, which equates to writing Metal code in a fragment shader, or the position of vertices using the geometry modifier output, which equates to Metal code running in a vertex shader.": {
      "zh": "在创建 Shader Graph 素材时，你可以在Swift代码中通过 Promote Input 参数给 Shader Graph 素材传递数据。这样可以实现编写 Metal Shader 所需要的逻辑。使用编辑器创建的素材后，可以使用素材中自定义外表的输出节点（ custom surface output ）作用与实体的外观，这等价于编写 Fragment Shader 的 Metal 代码；也可以使用素材中集合修改器的输出（ geometry modifier output ）摆放顶点的位置，这等价于编写 Vertex Shader 的 Metal 代码。",
      "tips": ""
    },
    "Node graphs can contain subgraphs, which are similar to functions. They contain reusable sets of nodes with inputs and outputs. Subgraphs contain the logic to draw the contour lines and the logic to offset the vertices. Double-click a subgraph to edit it. For more information about building materials using Shader Graph, see Explore Materials in Reality Composer Pro.": {
      "zh": "节点图（ Node graph ）可以包含子图（ Subgraph ），这类似函数。它们包含一系列可重用的输入和输出节点。子图（ Subgraph ）包含绘制等高线和调整顶点的逻辑。双击子图（ Subgraph ）进行编辑操作。更多关于使用 Shader Graph 创建素材，请参照 Explore Materials in Reality Composer Pro 。",
      "tips": ""
    },
    "Update the Shader Graph material at runtime": {
      "zh": "运行时更新 Shader Graph 素材",
      "tips": ""
    },
    "To change the map, DynamicTerrainMaterialEnhanced has a promoted input called Progress. If that parameter is set to 1.0, it displays Catalina Island. If it’s set to 0, it displays Yosemite. Any other number shows a state in transition between the two. When someone manipulates the slider, the app updates that input parameter based on the slider’s value.": {
      "zh": "DynamicTerrainMaterialEnhanced 有名为 Progress 的 Promoted Input 参数。如果将参数设置为 1.0 ，则会显示 Catalina Island。如果见参数设为 0 ，则会显示 Yosemite。如果将参数设置为 0 到 1 之间的数值，则显示两个地图切换时的中间状态。当用户操作滑动条时，应用程序会用滑动条当前的数值更新输入参数。",
      "tips": ""
    },
    "Important": {
      "zh": "要点",
      "tips": ""
    },
    "Shader Graph material parameters are case-sensitive. If the capitalization is wrong, your code won’t actually update the material.": {
      "zh": "Shader Graph 素材参数的名称是区分大小写的。如果大写和小写的拼写不正确，你的代码就无法更新材料。",
      "tips": ""
    },
    "The app sets the value of the input parameter in a function called handleMaterial() that the slider’s .onChanged closure calls. That function retrieves the ShaderGraphMaterial from the terrain entity and calls setParameter(name:value:) on it.": {
      "zh": "应用程序会在 Slider 的 .onChanged 回调闭包中调用 handleMaterial() 函数，在函数中获取 terrain 实体中的 ShaderGraphMaterial 素材，然后调用素材的 setParameter(name:value:) 的方法去更新素材的输入参数。",
      "tips": ""
    }
  },
  "visionos/drawing-sharp-layer-based-content": {
    "Drawing sharp layer-based content in visionOS": {
      "zh": "在 visionOS 中绘制基于图层的清晰内容",
      "tips": ""
    },
    "Deliver text and vector images at multiple resolutions from custom Core Animation layers in visionOS.": {
      "zh": "在 visionOS 中，从自定义的 Core Animation 图层中以多种分辨率提供文本和矢量图形",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "If your app uses Core Animation layers directly, update your layer code to draw a high-resolution version of your content when appropriate. SwiftUI and UIKit views use Core Animation layers to manage interface content efficiently. When a view draws its content, the underlying layer captures that content and caches it to improve subsequent render operations.": {
      "zh": "如果你的应用直接使用了 Core Animation 图层（layer），请更新这部分代码，以便在适当的时候绘制高分辨率版本的内容。SwiftUI 和 UIKit 视图使用 Core Animation 层来高效管理界面内容。当一个 View 绘制其内容时，底层的 layer 会捕获该内容并对其进行缓存，为后续的渲染操作作出优化。",
      "tips": ""
    },
    "Core Animation on most Apple platforms rasterizes your layer at the same resolution as the screen, but Core Animation on visionOS can rasterize at different resolutions to maximize both content clarity and performance. The system follows the person’s eyes and renders content immediately in front of them at the highest possible resolution. Outside of this focal area, the system renders content at progressively lower resolutions to reduce GPU workloads. Because the content is in the person’s peripheral vision, these lower resolutions don’t impact the content’s clarity. As the person’s eyes move around, the system redraws content at different resolutions to match the change in focus.": {
      "zh": "大多数 Apple 平台上的 Core Animation 使用与屏幕相同的分辨率对图层进行栅格化，但是 visionOS 有所不同，在 visionOS 上的 Core Animation 可以以不同的分辨率栅格化，以最大化提升绘制内容的清晰度和性能。系统会跟踪人眼，根据人眼所在焦点以尽可能高的分辨率立即呈现内容。在此焦点的区域之外，系统以逐渐降低的分辨率渲染内容，以减少 GPU 工作负载。由于焦点外的内容位于人的周边视觉中，因此这些较低的分辨率不会影响内容的清晰度。当人的眼睛四处移动时，系统会以不同的分辨率重新绘制内容，来匹配焦点的变化。",
      "tips": ""
    },
    "If you deliver content using custom CALayer objects, you can configure your custom layers to support drawing at different resolutions. If you don’t perform this extra configuration step, each layer rasterizes its content at a @2x scale factor, which is good enough for most content and matches what the layer provides on a Retina display. However, if you opt in to drawing at different resolutions, the layer rasterizes its content at up to @8x scale factor in visionOS, which adds significant detail to text and vector-based content.": {
      "zh": "如果使用自定义 CALayer 对象提供内容，则可以配置你的自定义图层以支持以不同分辨率来进行绘制。如果不执行这一额外的配置步骤，则每个图层都会以 @2x 的比例栅格化其内容，这对于大多数内容来说已经足够了，并且与图层在 Retina 显示屏上提供的内容相匹配。但是，如果您选择以不同的分辨率进行绘制，则图层会在 visionOS 中以高达  @8x 的比例栅格化其内容，从而为文本和基于矢量的内容添加大量细节。",
      "tips": ""
    },
    "Request dynamic scaling for custom layers": {
      "zh": "请求自定义图层的动态缩放",
      "tips": ""
    },
    "Dynamic content scaling is off by default for all Core Animation layers, and frameworks or apps must turn on this support explicitly. If your interface uses only SwiftUI or UIKit views, you don’t need to do anything to support this feature. SwiftUI and UIKit enable it automatically for views that benefit from the added detail, such as text views and image views with SF Symbols or other vector-based artwork. However, the frameworks don’t enable the feature for all views, including UIView and View.": {
      "zh": "默认情况下，所有 Core Animation 图层的动态内容缩放都处于关闭状态，框架或应用必须显式地启用此支持。如果您的界面仅使用 SwiftUI 或 UIKit 视图，则无需执行任何操作即可支持此功能。SwiftUI 和 UIKit 会自动为那些受益于被添加了细节的视图启用它，例如带有 SF 符号的文本和图像视图，或其他基于矢量的美术资源。但是，框架不会为所有视图（包括 UIView 和 View ）启用该功能。",
      "tips": ""
    },
    "If your visionOS interface includes custom Core Animation layers, you can enable the wantsDynamicContentScaling property of any CALayer objects that contain vector-based content. Setting this property to true tells the system that you support rendering your layer’s content at different resolutions. However, the setting is not a guarantee that the system applies dynamic content scaling to your content. The system can disable the feature if your layer draws using incompatible functions or techniques.": {
      "zh": "如果您的 visionOS 界面包含自定义的 Core Animation 图层，对于包含基于矢量的内容的任意 CALayer 对象，您都可以启用它们的 wantsDynamicContentScaling 属性。将此属性设置为 true 会告知系统您支持以不同的分辨率渲染图层的内容。但是，此设置并不能保证系统将动态内容缩放应用于您的内容。如果图层使用不兼容的函数或技术进行绘制，系统可能会禁用该属性。",
      "tips": ""
    },
    "The following example shows how to enable this feature for a CATextLayer object. After configuring the layer, set the wantsDynamicContentScaling property to true and add the layer to your layer hierarchy.": {
      "zh": "以下示例演示如何为 CATextLayer 对象启用此功能。配置图层后，将 wantsDynamicContentScaling 属性设置为 true ，然后将此图层添加到图层层次结构中。",
      "tips": ""
    },
    "Dynamic content scaling works best when the layer contains text or vector-based content. Don’t enable the feature if you do any of the following in your layer:": {
      "zh": "当图层包含文本或基于矢量的内容时，动态内容缩放效果最佳。如果在图层中执行以下任一操作，请勿启用该功能：",
      "tips": ""
    },
    "You set the layer’s content using the contents property.": {
      "zh": "您使用 contents 属性设置了图层的内容。",
      "tips": ""
    },
    "You draw primarily bitmap-based content.": {
      "zh": "您主要绘制的是基于位图的内容。",
      "tips": ""
    },
    "You redraw your layer’s contents repeatedly over a short time period.": {
      "zh": "您可能会在短时间内多次重绘您的内容。",
      "tips": ""
    },
    "The CAShapeLayer class ignores the value of the wantsDynamicContentScaling property and always enables dynamic content scaling. For other Core Animation layers, you must enable the feature explicitly to take advantage of it.": {
      "zh": "CAShapeLayer 类忽略 wantsDynamicContentScaling 属性的值，并始终启用动态内容缩放。对于其他 Core Animation 图层，必须显式启用该功能才能利用它。",
      "tips": ""
    },
    "Draw the layer’s content dynamically": {
      "zh": "动态绘制图层的内容",
      "tips": ""
    },
    "Dynamic content scaling requires you to draw your layer’s contents using one of the prescribed methods. If you define a custom subclass of CALayer, draw your layer’s content in the draw(in:) method. If you use a CALayerDelegate object to draw the layer’s content, use the delgate’s drawLayer:inContext: method instead.": {
      "zh": "动态内容缩放要求您使用某个指定的方法绘制图层的内容。如果定义了一个自定义的 CALayer 子类，请在 draw(in:) 方法中绘制图层的内容。如果使用 CALayerDelegate 对象绘制图层的内容，请改用 delgate 中的 drawLayer:inContext: 方法。",
      "tips": ""
    },
    "When you enable dynamic content scaling for a layer, the system captures your app’s drawing commands for playback later. As the person’s eyes move, the system draws the layer at higher resolutions when someone looks directly at it, or at lower resolutions otherwise. Because the redraw operations implicitly communicate what the person is looking at, the system performs them outside of your app’s process. Letting the system handle these operations maintains the person’s privacy while still giving your app the benefits of high-resolution drawing.": {
      "zh": "当您为图层启用动态内容缩放时，系统会捕获应用程序的绘图命令以供以后重绘。当人的眼睛移动时，如果视线直视图层，系统会以更高的分辨率绘制图层，否则系统会以较低的分辨率绘制图层。由于重绘操作隐式透露了用户正在查看的内容，因此系统会在应用进程之外执行这些操作。让系统处理这些操作不仅可以保护用户隐私，同时可使您的应用程序能够受益于高分辨率绘制。",
      "tips": ""
    },
    "Some Core Graphics routines are incompatible with dynamic content scaling. Even if you enable dynamic content scaling for your layer, the system automatically disables the feature if your layer uses any of the following:": {
      "zh": "一些 Core Graphics 的 API 与动态内容缩放不兼容。即使您为图层启用了动态内容缩放，如果您的图层使用以下任一选项，系统也会自动禁用该功能：",
      "tips": ""
    },
    "Core Graphics shaders.": {
      "zh": "使用 Core Graphics 的 着色器（shader）",
      "tips": ""
    },
    "APIs that set intent, quality, or other bitmap-related properties. For example, don’t call CGContextSetInterpolationQuality.": {
      "zh": "设置意图、质量或其他位图相关属性的 API。例如，不要调用 CGContextSetInterpolationQuality 。",
      "tips": ""
    },
    "A CGBitmapContext to draw content.": {
      "zh": "用于绘制内容的 CGBitmapContext",
      "tips": ""
    },
    "If your app creates timer-based animations, don’t animate layer changes using your drawing method. Calling setNeedsDisplay() on your layer repeatedly in a short time causes the system to draw the layer multiple times in quick succession. Because visionOS needs a little extra time to draw a layer at high resolution, each redraw request forces it to throw away work. A better option is to animate layer-based properties to achieve the same effect, or use a CAShapeLayer to animate paths when needed.": {
      "zh": "如果您的应用创建基于计时器的动画，请不要使用绘制方法对图层更改进行动画处理。在短时间内重复调用图层的 setNeedsDisplay() 方法会导致系统快速连续多次绘制图层。由于 visionOS 需要一些额外的时间来以高分辨率绘制图层，因此每次重绘请求都会强制它放弃当前工作。更好的选择是对基于图层的属性进行动画处理以实现相同的效果，或者在需要时使用 CAShapeLayer 对路径进行动画处理。",
      "tips": ""
    },
    "Modify layer hierarchies to improve performance": {
      "zh": "修改图层层次结构以改善性能",
      "tips": ""
    },
    "The backing store for a layer consumes more memory at higher resolutions than at lower resolutions. Measure your app’s memory usage before and after you enable dynamic content scaling to make sure the increased memory cost is worth the benefit. If your app’s memory usage increases too much, limit which layers adopt dynamic content scaling. You can also reduce the amount of memory each layer uses in the following ways:": {
      "zh": "图层的后端存储在较高分辨率下比在较低分辨率下消耗更多的内存。在启用动态内容缩放之前和之后测量应用的内存使用情况，以确保增加的内存成本物有所值。如果应用的内存使用量增加过多，请对某些图层是否采用动态内容缩放加以限制。您还可以通过以下方式减少每个图层使用的内存量：",
      "tips": ""
    },
    "Make your layer the smallest size possible. Larger layers require significantly more memory, especially at higher resolutions. Make the size of the layer match the size of your content by eliminating padding or extra space.": {
      "zh": "尽可能最小化您的图层尺寸。越大的图层需要的内存也越多，尤其是在更高的分辨率下。通过消除缩进或周围额外的空间，来使图层的大小与内容的大小相匹配。",
      "tips": ""
    },
    "Separate complex content into different layers. Instead of drawing everything in a single layer, build your content from multiple layers and arrange them hierarchically to achieve the same result. Enable dynamic content scaling only in the layers that actually need it.": {
      "zh": "将复杂内容置于不同图层。相比在单个图层中绘制所有内容，不如从多个图层构建内容并分层排列它们，以达到相同的效果。仅在实际需要的图层中启用动态内容缩放。",
      "tips": ""
    },
    "Apply special effects using layer properties whenever possible. Applying effects during drawing might require you to increase the layer’s size. For example, apply scale and rotation effects to the layer’s transform property, instead of during drawing.": {
      "zh": "尽可能使用图层属性来应用特殊效果。在绘制过程中应用某些效果可能需要增加图层的占用大小。例如，请将缩放和旋转效果应用于图层的 transform 属性，而不是在绘制过程中这么做。",
      "tips": ""
    },
    "Don’t draw your layer’s content at different resolutions in advance and cache the images. Maintaining multiple images requires more memory. If you do cache images, draw them only at @2x scale factor.": {
      "zh": "不要提前用不同的分辨率绘制图层的内容并缓存图像。维护多个图像需要更多内存。如果您确需缓存图像，请仅以 @2x 的比例绘制它们。",
      "tips": ""
    },
    "Don’t use your drawing code to draw a single image. If your layer’s content consists of an image, assign that image to the layer’s contents property directly.": {
      "zh": "不要使用绘制代码绘制单个图像。如果图层的内容由图像组成，请直接将该图像分配给图层的 contents 属性。",
      "tips": ""
    },
    "Complex drawing code can also lead to performance issues. A layer with many strokes can render quickly at lower scale factors, but might be computationally too complex to render at larger scales. If a complex layer doesn’t render correctly at higher resolutions, turn off dynamic content scaling and measure the render times again.": {
      "zh": "复杂的绘图代码也可能导致性能问题。一个具有许多描边的图层可以在较低分辨率下快速渲染，但在计算上可能过于复杂，继而无法在较大比例下渲染。如果复杂图层无法在更高分辨率下正确渲染，请关闭动态内容缩放并再次测量渲染时间。",
      "tips": ""
    }
  },
  "visionos/happybeam": {
    "Happy Beam": {
      "zh": "快乐光束",
      "tips": ""
    },
    "Leverage a Full Space to create a fun game using ARKit.": {
      "zh": "使用 ARKit 在 Full Space 中创建有趣的游戏。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "In visionOS, you can create fun, dynamic games and apps using several different frameworks to create new kinds of spatial experiences: RealityKit, ARKit, SwiftUI, and Group Activities. This sample introduces Happy Beam, a game where you and your friends can hop on a FaceTime call and play together.": {
      "zh": "在 visionOS 中，您可以使用多种不同的框架创建有趣、动态的游戏和应用，以创建新型空间体验：RealityKit、ARKit、SwiftUI 和 Group Activities。此示例介绍了快乐光束(Happy Beam)，这是一款游戏，您和朋友可以在其中进行 FaceTime 通话并一起玩。",
      "tips": ""
    },
    "You’ll learn the mechanics of the game where grumpy clouds float around in the space, and people play by making a heart shape with their hands to project a beam. People aim the beam at the clouds to cheer them up, and a score counter keeps track of how well each player does cheering up the clouds.": {
      "zh": "这个游戏的机制是：暴躁乌云在空间中漂浮，玩家通过用心形手势投射光束来进行游戏。玩家使用光束射击乌云并使其振作起来，同时记分器会记录每个玩家在振奋乌云时的表现。",
      "tips": "Grumpy clouds 在此处被译为暴躁乌云。"
    },
    "Design the game interface in SwiftUI": {
      "zh": "使用 SwiftUI 设计游戏界面",
      "tips": ""
    },
    "Most apps in visionOS launch as a window that opens different scene types depending on the needs of the app.": {
      "zh": "visionOS 中的大多数应用都以窗口的形式启动，该窗口会根据应用的需要打开不同的场景类型。",
      "tips": ""
    },
    "Here you see how Happy Beam presents a fun interface to people by using several SwiftUI views that display a welcome screen, a coaching screen that gives instructions, a scoreboard, and a game-ending screen.": {
      "zh": "在这里，您可以看到 Happy Beam 如何使用多个 SwiftUI 视图向玩家呈现一个有趣的用户界面，其中包括了欢迎界面、提供规则说明的教学界面、记分板和游戏结束界面。",
      "tips": ""
    },
    "The following shows you the primary view in the app that displays each phase of gameplay:": {
      "zh": "下方代码中包含了应用中每个游戏阶段显示的主要视图：",
      "tips": ""
    },
    "When 3D content starts to appear, the game opens an immersive space to present content outside of the main window and in a person’s surroundings.": {
      "zh": "当 3D 内容开始出现时，游戏会打开一个沉浸式空间，以在主窗口之外，玩家周围环境之中呈现内容。",
      "tips": ""
    },
    "The HappyBeam container view declares a dependency on openImmersiveSpace:": {
      "zh": "HappyBeam 容器视图定义了一个名为 openImmersiveSpace 的依赖：",
      "tips": "依赖变量 openImmersiveSpace 的类型是 OpenImmersiveSpaceAction，是用于打开沉浸式空间的操作，详见 https://developer.apple.com/documentation/swiftui/openimmersivespaceaction"
    },
    "It later uses that dependency to open the space from the app’s declaration when it’s time to start showing 3D content:": {
      "zh": "稍后，当需要开始显示 3D 内容时，该视图会使用此依赖从应用的声明中打开沉浸式空间：",
      "tips": ""
    },
    "Detect a heart gesture with ARKit": {
      "zh": "使用 ARKit 检测心形手势",
      "tips": ""
    },
    "The Happy Beam app recognizes the central heart-shaped hands gesture using ARKit’s support for 3D hand tracking in visionOS. Using hand tracking requires a running session and authorization from the wearer. It uses the NSHandsTrackingUsageDescription user info key to explain to players why the app requests permission for hand tracking.": {
      "zh": "Happy Beam 应用程序使用 ARKit 支持的 visionOS 中 3D 手部追踪功能来识别中央心形手势。使用手部追踪需要一个运行中的会话（ARKitSession）以及设备佩戴者的授权。它使用 NSHandsTrackingUsageDescription 用户信息键中的字符串向玩家解释为什么应用程序请求手部追踪权限。",
      "tips": "想了解更多和 ARKitSession 相关的内容，请参考 https://developer.apple.com/documentation/arkit/arkitsession"
    },
    "Hand-tracking data isn’t available when your app is only displaying a window or volume. Instead, it’s available when you present an immersive space, as in the previous example.": {
      "zh": "当您的应用仅显示窗口或体量时，手部追踪数据不可用。相反，当您演示沉浸式空间时，它可用，如上例所示。",
      "tips": ""
    },
    "You can detect gestures using ARKit data with a level of accuracy that depends on your use case and intended experience. For example, Happy Beam could require strict positioning of finger joints to closely resemble a heart shape. Instead, however, it prompts people to make a heart shape and uses a heuristic to indicate when the gesture is close enough.": {
      "zh": "您可以使用 ARKit 数据检测手势，其准确程度取决于您的用例和预期体验。例如，Happy Beam 可以更加严格地要求手指关节位置，规定手势必须非常接近心形。然而，实际上应用会提示用户摆出心形手势，并使用启发式的方法来提示手势已经足够接近心形。",
      "tips": ""
    },
    "The following checks whether a person’s thumbs and index fingers are almost touching:": {
      "zh": "下述代码检查玩家的拇指和食指是否近乎接触：",
      "tips": ""
    },
    "Support several kinds of input": {
      "zh": "支持多种输入类型",
      "tips": ""
    },
    "To support accessibility features and general user preferences, include multiple kinds of input in an app that uses hand tracking as one form of input.": {
      "zh": "为了支持辅助功能和用户首选项，请在使用手部追踪作为输入形式的应用中包含并支持多种输入类型。",
      "tips": ""
    },
    "Happy Beam supports several kinds of input:": {
      "zh": "Happy Beam 支持以下几种输入方式：",
      "tips": ""
    },
    "Display 3D content with RealityKit": {
      "zh": "使用 RealityKit 展示 3D 内容",
      "tips": ""
    },
    "The 3D content in the app comes in the form of assets that you can export from Reality Composer Pro. You place each asset in the RealityView that represents your immersive space.": {
      "zh": "应用程序中的 3D 内容以资源的形式提供，您可以从 Reality Composer Pro 中导出这些资源。应用将每个资源放置在一个代表沉浸式空间的 RealityView 中。",
      "tips": ""
    },
    "The following shows how Happy Beam generates clouds when the game starts, as well as materials for the floor-based beam projector. Because the game uses collision detection to keep score — the beam cheers up grumpy clouds when they collide — you make collision shapes for each model that might be involved.": {
      "zh": "下述代码展示了 Happy Beam 在游戏开始时如何生成云朵，以及地面上的激光发射器的材质。因为游戏使用碰撞检测来计算得分——当碰撞时，光束会让暴躁乌云开心起来——所以你要为每个可能参与互动的模型制作碰撞体积。",
      "tips": ""
    },
    "Add SharePlay support for multiplayer gaming experiences": {
      "zh": "添加同播共享以支持多人游戏体验",
      "tips": "SharePlay 的官方中译为同播共享，见 https://developer.apple.com/cn/shareplay/"
    },
    "You use the Group Activities framework in visionOS to support SharePlay during a FaceTime call. Happy Beam uses Group Activities to sync the score, active players list, and the position of each player’s projected beam.": {
      "zh": "您可以在 visionOS 中通过 Group Activities 框架在 FaceTime 通话期间支持同播共享。Happy Beam 使用 Group Activities 来同步分数、活跃玩家列表以及每个玩家射出光束的位置。",
      "tips": ""
    },
    "Note": {
      "zh": "注意",
      "tips": ""
    },
    "Developers using the Apple Vision Pro developer kit can test spatial SharePlay experiences on-device by installing the Persona Preview Profile.": {
      "zh": "使用 Apple Vision Pro developer kit 的开发者可以通过安装 Persona Preview Profile 在设备上测试空间中的同播共享体验。",
      "tips": ""
    },
    "Use a reliable channel to send information that’s important to be correct, even if it can be slightly delayed as a result. The following shows how Happy Beam updates the game model’s score state in response to a score message:": {
      "zh": "使用可靠的频道发送要求正确性的信息，即使因此可能会稍有延迟。下面展示了 Happy Beam 如何根据分数信息更新游戏模型的分数状态：",
      "tips": ""
    },
    "Use an unreliable messenger for sending data with low-latency requirements. Because the delivery mode is unreliable, some messages might not make it. Happy Beam uses the unreliable mode to send live updates to the position of the beam when each participant in the call chooses the Spatial option in FaceTime.": {
      "zh": "使用不可靠的信使发送具有低延迟要求的数据。由于传递模式不可靠，因此某些消息可能无法送达。当 FaceTime 参与者在通话中选择 Spatial 选项时，Happy Beam 会使用不可靠模式发送光束位置的实时更新。",
      "tips": ""
    },
    "The following shows how Happy Beam serializes beam data for each message:": {
      "zh": "下述代码展示了 Happy Beam 如何在每条消息中序列化光束数据：",
      "tips": ""
    }
  },
  "visionos/improving-accessibility-support-in-your-app": {
    "Improving accessibility support in your visionOS app": {
      "zh": "在你的 visionOS 应用中增强对辅助功能的支持",
      "tips": ""
    },
    "Update your code to ensure everyone can access your app’s content in visionOS.": {
      "zh": "更新你的代码以确保所有用户都可以在 visionOS 中访问你的应用内容。",
      "tips": ""
    },
    "Overview": {
      "zh": "概览",
      "tips": ""
    },
    "visionOS is an immersive platform that supports people of all abilities. Even though experiences incorporate stunning visual content and hand- and eye-tracking technologies, people can engage with content in other ways. In fact, the platform supports people in many different situations, including those who are blind, have low vision, have limited mobility, or have limb differences. With the help of assistive technologies, people can interact with all of your app’s content.": {
      "zh": "visionOS 是一个可以支持不同人群的沉浸式平台。虽然平台的体验融合了引人入胜的视觉内容和手眼追踪技术，但用户仍可以通过其他方式与内容互动。事实上，平台为许多不同人群都提供了支持，包括视力障碍者、行动不便者或是有肢体差异的用户。在辅助技术的帮助下，用户就能全面地与应用中的内容进行互动。",
      "tips": ""
    },
    "During development, enable VoiceOver and other assistive features and test your app’s accessibility support. Make sure people can navigate your app’s interface intuitively, and that all of the necessary elements are present. Improve the descriptive information for those elements to communicate their intended purpose. And make sure your app adapts to changing conditions, such as changes to the Dynamic Type setting while your app is running.": {
      "zh": "在开发过程中，建议启用 VoiceOver 以及其他辅助特性，来测试你的应用对辅助功能的支持情况。要确保用户能够直观地操作应用界面，并确认所有必要的元素都已展示到位。为这些元素增加描述信息，传达其预期的用途。并且确保你的应用能够适配那些会动态改变的设置，例如在应用运行时 Dynamic Type 的设置发生变化。",
      "tips": ""
    },
    "For general information about supporting accessibility, see Accessibility. For design guidance, see Human Interface Guidelines > Accessibility.": {
      "zh": "如需了解有关支持辅助功能的内容，请参阅“辅助功能”。对于设计指导，参见人机界面指南 > 辅助功能。",
      "tips": ""
    },
    "Add accessibility traits to RealityKit entities": {
      "zh": "给 RealityKit 实体添加辅助功能特性",
      "tips": ""
    },
    "VoiceOver and other assistive technologies rely on the accessibility information that your app’s views and content provide. SwiftUI and UIKit provide default information for the standard system views, but RealityKit doesn’t provide default information for the entities in your scenes.": {
      "zh": "VoiceOver 以及其他辅助技术依赖于你应用的视图和内容所提供的辅助功能信息。虽然 SwiftUI 和 UIKit 已为标准的系统视图控件提供了默认信息，但是 RealityKit 并不会为你场景中的实体预设任何信息。",
      "tips": ""
    },
    "To configure the accessibility information for a RealityKit entity, add an instance of AccessibilityComponent to the entity. Use this component to specify the same values you specify for the rest of your app’s views. The following example shows how to create this component and add it to an entity:": {
      "zh": "要为 RealityKit 实体赋予辅助功能信息，就需要给这个实体添加一个 AccessibilityComponent 实例。使用这个组件你可以像设定你应用中其他视图一样地去设置相同的参数值。以下的示例代码展示了如何去创建这个组件并将其添加到实体中：",
      "tips": ""
    },
    "People can use VoiceOver to initiate specific types of actions on your entities. Assign a value to the systemActions property of your component if your entity supports the incrementing or decrementing of its value, or supports activation with a gesture other than a standard tap. You don’t need to set a system action if you let people interact with the entity using a standard single-tap gesture.": {
      "zh": "用户能够借助 VoiceOver 触发你的实体中的特定操作。如果你的实体支持改变值的大小，或者能通过非标准点击手势被激活，那么就需要为你的组件中的 systemActions 属性设置一个值。不过，如果用户使用的是单击手势来和实体进行交互，那就无需设定该属性。",
      "tips": ""
    },
    "The following example uses the content of a RealityView to determine when activation events occur on the view’s entities. After subscribing to the view’s activation events, the code sets up an asynchronous task to handle incoming events. When a new event occurs, the task executes the custom code to handle a collision.": {
      "zh": "以下的代码示例利用了 RealityView 的 content 属性来判断在视图上的实体何时去触发激活辅助功能的事件。在订阅了视图的这项事件后，代码会绑定一个异步任务去处理接收到的事件。当新的事件产生时，这个任务就会调用 handleCollision 方法以处理该实体的碰撞事件。",
      "tips": ""
    },
    "Add support for Direct Gesture mode": {
      "zh": "为直接手势操作模式提供支持",
      "tips": ""
    },
    "When VoiceOver is active in visionOS, people use hand gestures to navigate your app’s interface and inspect elements. To prevent your app’s code from interfering with VoiceOver interactions, the system doesn’t deliver hand input to your app during this time. However, a person can perform a special VoiceOver gesture to enable Direct Gesture mode, which leaves VoiceOver enabled but restores hand input to your app.": {
      "zh": "当在 visionOS 中启用了 VoiceOver 时，用户会借助手势来浏览你的应用界面和查看相应元素内容。为了避免你的程序干扰到 VoiceOver 的交互，在此期间，系统不会给你的程序传达手势输入的信号。不过，用户仍旧可以通过一个特别的 VoiceOver 手势来启用直接手势操作模式（Direct Gesture mode），这种模式允许在保持 VoiceOver 正常工作的同时恢复手势输入对程序的影响。",
      "tips": ""
    },
    "Add VoiceOver announcements to your code to communicate the results of meaningful events. VoiceOver speaks these announcements at all times, but they are particularly useful when Direct Gesture mode is on. The following example posts an announcement when a custom gesture causes an interaction with a game piece:": {
      "zh": "在你的代码中添加支持 VoiceOver 的提示，来传达重要事件的结果。VoiceOver 会随时播放这些提示，尤其是在直接手势操作模式下，这些提示会更具意义。以下的示例代码会在自定义手势与游戏棋子触发交互时产生提示内容：",
      "tips": ""
    },
    "Provide alternatives to input that involves physical movement": {
      "zh": "给涉及物理动作的输入方式提供额外选择",
      "tips": ""
    },
    "Reduced mobility can affect a person’s ability to interact with your app’s content. When designing your app’s input model, avoid experiences that require specific body movements or positions. For example, if your app supports custom hand gestures, add menu commands for each gesture so someone can enter them using a keyboard or assistive device.": {
      "zh": "受限的移动能力会影响一个人与你的应用内容交互的能力。在设计应用的输入方式时，尽量避免依赖特定的身体动作或是姿势。举个例子来说，如果你的应用支持自定义手部动作，那么应该为每一个手势提供相应的菜单命令，从而让用户能通过键盘或者辅助设备进行操作。",
      "tips": ""
    },
    "Some assistive technologies let people interact with your app using only their eyes. Using these technologies they can select, scroll, long press, or drag items in your interface. Even if you support other types of interactions, give people a way to access all of your app’s behavior using only these interactions.": {
      "zh": "有些辅助技术让用户只需用他们的双眼就能和应用进行交互。借助这些技术，他们能够在你提供的界面中选取、滚动、长按或拖拽内容。因此，即使你的应用支持其它类型的交互，也请务必确保用户能仅通过这些眼动操作就能全方位使用你的应用。",
      "tips": ""
    },
    "Avoid head-anchored content": {
      "zh": "避免固定于头部的内容",
      "tips": ""
    },
    "Some assistive technologies allow people to navigate or view your app’s interface using head movements. As the person’s head moves, the assistive technology focuses on the item directly in front of them. Content that follows the movements of the person’s head interferes with the behavior of these assistive technologies.": {
      "zh": "一些辅助技术能让用户通过头部的移动来操作或浏览你的应用界面。随着用户头部的移动，这些技术会将内容直接地聚焦在用户的视线前。如果一些显示内容随着用户头部的移动而发生变化，那么这将会干扰这些设备的正常使用。",
      "tips": ""
    },
    "When designing your interface, place content in windows or anchor it to locations other than the virtual camera. If you do need head-anchored content, provide an alternative solution when relevant assistive technologies are in use. For example, you might move head-anchored content to an anchor point that doesn’t follow the person’s head movements.": {
      "zh": "在构造你的界面时，建议将内容设定在窗口中，或是锚定在与虚拟摄像机无关的位置。如果考虑到你确实要使用固定于头部的内容，那么在用户使用相关辅助技术时，需要提供可替代的解决方案。例如，你可以将原本固定于头部的内容移至锚定位置，使之和用户的头部移动动作无关。",
      "tips": ""
    },
    "To determine when to change the anchoring approach for your content, check the accessibilityPrefersHeadAnchorAlternative environment variable in SwiftUI, or call the AXPrefersHeadAnchorAlternative() function. This environment variable is true when an assistive technology is in use that conflicts with head-anchored content. Adapt your content to use alternate anchoring mechanisms at that time.": {
      "zh": "你可以在 SwiftUI 中检查 accessibilityPrefersHeadAnchorAlternative 这个环境变量，或是调用 AXPrefersHeadAnchorAlternative 方法来判断何时去改变你的应用内容的锚定方式。当正在使用的辅助设备与头部锚定内容产生冲突时，这个变量会返回 true。每当这个时候，就应当去调整你应用的内容来兼容新的锚定方式。",
      "tips": ""
    },
    "Limit motion effects in your content": {
      "zh": "减弱应用内容的动态效果",
      "tips": ""
    },
    "Motion effects on any immersive device can be jarring, even for people who aren’t sensitive to motion. Limit the use of motion effects that incorporate rapid movement, bouncing or wave-like movement, zooming animations, multi-axis movement, spinning, or rotations. When the person wearing the device is sensitive to motion effects, eliminate the use of these effects altogether.": {
      "zh": "对于任何沉浸式设备来说，过于强烈的动态效果可能会让人感到不适，即使对于那些对动效并不敏感的人也是如此。尽量减少对快速移动、弹跳货波状运动、缩放动画、多轴移动、旋转在内的动效运用。特别是当使用设备的人对动效敏感时，需要彻底避免使用这些元素。",
      "tips": ""
    },
    "The Reduce Motion system setting lets you know when to provide alternatives for all of your app’s motion effects. Access this setting using the accessibilityReduceMotion environment variable in SwiftUI or with the isReduceMotionEnabled property in UIKit. When the setting is true, provide suitable alternatives for motion effects or eliminate them altogether. For example, show a static snapshot of the ocean instead of a video.": {
      "zh": "系统设置中的减弱动态效果可以提示你什么情况下应当为你应用中的动态效果提供替代方案。你可以在 SwiftUI 中通过 accessibilityReduceMotion 环境变量，或是 UIKit 中通过 isReduceMotionEnabled 属性来访问这个设置。当被开启时，尝试为这些动效呈现合适的替代方案，或是完全移除它们。比如，你可以选择展示一张静态海洋的图片来代替播放视频。",
      "tips": ""
    },
    "For more information, see Human Interface Guidelines > Motion.": {
      "zh": "欲了解更多内容，详见人机界面指南 > 动态效果",
      "tips": ""
    },
    "Include captions for audio content": {
      "zh": "为音频内容添加字幕",
      "tips": ""
    },
    "For people who are deaf or hard of hearing, provide high-quality captions for your app’s content. Captions are a necessity to some, but are practical for everyone in certain situations. For example, captions are useful to someone watching a video in a noisy environment. Remember to include captions not just for text and dialogue, but also for music and sound effects in your content. For Spatial Audio content, include information in your captions that indicates the direction of various sounds.": {
      "zh": "对于患有耳聋或听障的人来说，提供高质量的字幕显得格外重要。虽然字幕对于某些人是必须的，但在特定情况下也适用任何人。比如，在喧闹的环境中观看视频时，字幕就大有用处。需要注意的是，不仅对话和文字需要字幕，音乐和音效也同样需要添加字幕。对于空间音频内容，还应在字幕中标注出声音的来源方向。",
      "tips": ""
    },
    "AVKit and AVFoundation provide built-in support for displaying captioned content. These frameworks configure the font, size, color, and style of the captions automatically according to the person’s accessibility settings. For example, the frameworks adopt the current Dynamic Type setting when displaying text.": {
      "zh": "AVKit 和 AVFoundation 提供对于显示字幕内容的内置支持。这些框架会根据用户的辅助功能设置，自动调整字幕的字体、大小、颜色和样式。例如，它们在显示文本时会应用当前的 Dynamic Type 设定。",
      "tips": ""
    },
    "If you have a custom video engine, check the isClosedCaptioningEnabled accessibility setting to determine when to display captions. To get the correct appearance information for your captioned content, adopt Media Accessibility in your project. This framework provides you with the optimal font, color, and opacity information to apply to captioned text and images.": {
      "zh": "如果你使用的是自定义的视频引擎，你可以通过检查辅助功能设定中的 isClosedCaptioningEnabled 来判断何时展示字幕。想要获取正确的字幕内容显示效果，你应在项目中引入 Media Accessibility。这个框架能提供最佳的字体、颜色和透明度信息，以便你在带字幕的文本和图像上使用。",
      "tips": ""
    }
  },
  "visionos/incorporating-real-world-surroundings-in-an-immersive-experience": {
    "Incorporating real-world surroundings in an immersive experience": {
      "zh": "",
      "tips": ""
    },
    "Create an immersive experience by making your app’s content respond to the local shape of the world.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Scene reconstruction helps bridge the gap between the rendered 3D content in your app and the person’s surroundings. Use scene reconstruction in ARKit to give your app an idea of the shape of the person’s surroundings and to bring your app experience into their world. Immersive experiences — those that use the mixed space style — are best positioned to incorporate this kind of contextual information: scene reconstruction is only available in spaces and isn’t as relevant for the full space style.": {
      "zh": "",
      "tips": ""
    },
    "In addition to providing a 3D mesh of the shape of different nearby objects, ARKit gives a classification to each mesh face it detects. For example, it might classify a face of a mesh as being part of an appliance, a piece of furniture, or structural information about the room like the position of walls and floors. The following video shows virtual cubes colliding with the scene reconstruction mesh, which makes the cubes appear to land on a table:": {
      "zh": "",
      "tips": ""
    },
    "Configure a scene reconstruction session": {
      "zh": "",
      "tips": ""
    },
    "Scene reconstruction requires the ARKitSession.AuthorizationType.worldSensing authorization type and corresponding usage description that you supply in your app’s Info.plist file. The following starts a session and processes updates as ARKit refines its reconstruction of the person’s surroundings:": {
      "zh": "",
      "tips": ""
    },
    "Add real-world interactivity using collision components": {
      "zh": "",
      "tips": ""
    },
    "You can make rendered 3D content more lifelike by having it appear to interact physically with objects in the person’s surroundings, like furniture and floors. Use RealityKit’s collision components and physics support to provide these interactions in your app. The generateStaticMesh(from:) method bridges between scene reconstruction and RealityKit’s physics simulation.": {
      "zh": "",
      "tips": ""
    },
    "Warning": {
      "zh": "",
      "tips": ""
    },
    "Be mindful of how much content you include in immersive scenes that use the mixed style. Content that fills a significant portion of the screen, even if that content is partially transparent, can prevent the person from seeing potential hazards in their surroundings. If you want to immerse the person in your content, configure your space with the full style. For more information, see Creating fully immersive experiences in your app.": {
      "zh": "",
      "tips": ""
    },
    "Use low-priority tasks to generate meshes, because generating them is a computationally expensive operation. The following creates a mesh entity with collision shapes using scene reconstruction:": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "Scene reconstruction meshes only support the PhysicsBodyMode.static physics body component mode.": {
      "zh": "",
      "tips": ""
    },
    "Each object in the scene reconstruction mesh updates its originFromAnchorTransform information independently and requires a separate static mesh because ARKit subdivides its representation of the world into multiple, distinct sections.": {
      "zh": "",
      "tips": ""
    },
    "Display scene reconstruction meshes during debugging": {
      "zh": "",
      "tips": ""
    },
    "People using an app that leverages scene reconstruction typically don’t need to see a visual rendering of the scene reconstruction mesh. The system already shows passthrough video in an immersive experience. However, temporarily displaying the scene reconstruction mesh can help while you’re developing and debugging your app. In Xcode’s debugging toolbar, click the Enable Visualizations button and select Collision Shapes. Because each element of the scene reconstruction mesh has a collision component, the details of the mesh appear in the debug visualization. For more information, see Diagnosing issues in the appearance of a running app.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/interacting-with-your-app-in-the-visionos-simulator": {
    "Interacting with your app in the visionOS simulator": {
      "zh": "",
      "tips": ""
    },
    "Use your Mac to navigate spaces and control interactions with your visionOS apps in Simulator.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Use Simulator to run apps in visionOS without installing them on a physical device. When you run your app in Simulator, you can see a monoscopic view of your app’s windows and 3D content inside an immersive space. Use your Mac to alter the viewpoint of the app within the space and navigate the app’s interface.": {
      "zh": "",
      "tips": ""
    },
    "Interact with your app": {
      "zh": "",
      "tips": ""
    },
    "To use your Mac’s pointer and keyboard to create gestures, choose “Select to interact with the scene” from the buttons at the bottom-right of a visionOS simulator window. The current gaze position tracks your pointer movements when you hover over content within the space.": {
      "zh": "",
      "tips": ""
    },
    "Use the following actions to trigger gestures:": {
      "zh": "",
      "tips": ""
    },
    "Gesture": {
      "zh": "",
      "tips": ""
    },
    "To simulate": {
      "zh": "",
      "tips": ""
    },
    "Tap": {
      "zh": "",
      "tips": ""
    },
    "Click.": {
      "zh": "",
      "tips": ""
    },
    "Double-tap": {
      "zh": "",
      "tips": ""
    },
    "Double-click.": {
      "zh": "",
      "tips": ""
    },
    "Touch and hold": {
      "zh": "",
      "tips": ""
    },
    "Click and hold.": {
      "zh": "",
      "tips": ""
    },
    "Drag (left, right, up, and down)": {
      "zh": "",
      "tips": ""
    },
    "Drag left, right, up, and down.": {
      "zh": "",
      "tips": ""
    },
    "Drag (forward and back)": {
      "zh": "",
      "tips": ""
    },
    "Shift-drag up and down.": {
      "zh": "",
      "tips": ""
    },
    "Two-handed gestures": {
      "zh": "",
      "tips": ""
    },
    "Press and hold the Option key to display touch points. Move the pointer while pressing the Option key to change the distance between the touch points. Move the pointer and hold the Shift and Option keys to reposition the touch points.": {
      "zh": "",
      "tips": ""
    },
    "Activate device buttons using menu items or by clicking the controls in the simulator window toolbar.": {
      "zh": "",
      "tips": ""
    },
    "Navigate the space": {
      "zh": "",
      "tips": ""
    },
    "Use your Mac’s pointer and the keyboard to reposition your viewpoint in a visionOS simulator window:": {
      "zh": "",
      "tips": ""
    },
    "Movement": {
      "zh": "",
      "tips": ""
    },
    "Forward": {
      "zh": "",
      "tips": ""
    },
    "Press the W key (or Up Arrow key), or perform a pinch gesture moving two fingers away from each other on a trackpad.": {
      "zh": "",
      "tips": ""
    },
    "Backward": {
      "zh": "",
      "tips": ""
    },
    "Press the S key (or Down Arrow key), or perform a pinch gesture moving two fingers toward each other on a trackpad.": {
      "zh": "",
      "tips": ""
    },
    "Left": {
      "zh": "",
      "tips": ""
    },
    "Press the A key (or Left Arrow key), or scroll left using a trackpad or Magic Mouse.": {
      "zh": "",
      "tips": ""
    },
    "Right": {
      "zh": "",
      "tips": ""
    },
    "Press the D key (or Right Arrow key), or scroll right using a trackpad or Magic Mouse.": {
      "zh": "",
      "tips": ""
    },
    "Up": {
      "zh": "",
      "tips": ""
    },
    "Press the E key, or scroll up using a trackpad or Magic Mouse.": {
      "zh": "",
      "tips": ""
    },
    "Down": {
      "zh": "",
      "tips": ""
    },
    "Press the Q key, or scroll down using a trackpad or Magic Mouse.": {
      "zh": "",
      "tips": ""
    },
    "You can also control the viewpoint with a standard drag. To do so, choose “Drag to pan the camera” from the buttons at the bottom-right of the simulator window to move the viewpoint left, right, up or down and choose “Drag to dolly the camera” to move it forward or backward.": {
      "zh": "",
      "tips": ""
    },
    "To change your viewing angle, Control-drag inside a visionOS simulator window. You can choose “Drag to tilt the camera” from the buttons at the bottom-right of the simulator window to use a drag without the Control key.": {
      "zh": "",
      "tips": ""
    },
    "To reset the viewpoint and viewing angle for a visionOS simulator, choose the Reset Camera button from the toolbar at the top-right of its window.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "To capture the input from the pointer and keyboard, bypassing navigation control, to direct the input to the simulated device, use the Pointer Capture and Keyboard Capture buttons in the toolbar at the top-right of a visionOS simulator window. Press the Esc (Escape) key to disable capture and restore navigation controls.": {
      "zh": "",
      "tips": ""
    },
    "When moving with a trackpad or Magic Mouse, Simulator respects the natural scrolling setting on macOS.": {
      "zh": "",
      "tips": ""
    },
    "You can also use a game controller to control your movement. Use the left stick to move left, right, forward or back. Use R2 and L2 to move up and down. Use the right stick on a game controller to pan around the space.": {
      "zh": "",
      "tips": ""
    },
    "Switch between simulated scenes": {
      "zh": "",
      "tips": ""
    },
    "Simulator provides multiple built-in scenes you can use to simulate passthrough in different surroundings. These include unique room layouts and furniture for different testing scenarios, each available in different lighting conditions.": {
      "zh": "",
      "tips": ""
    },
    "Use the simulated scene to test:": {
      "zh": "",
      "tips": ""
    },
    "Readability of your app in varying backgrounds and varying lighting conditions.": {
      "zh": "",
      "tips": ""
    },
    "Different scenarios, including limited and cluttered surroundings, to see how your app adapts to them.": {
      "zh": "",
      "tips": ""
    },
    "Content layout, positioning, and scale.": {
      "zh": "",
      "tips": ""
    },
    "Spatial audio and acoustics.": {
      "zh": "",
      "tips": ""
    },
    "To change the simulated scene, click the Simulated Scenes button in the toolbar at the top-right of a visionOS simulator window and choose a different scene.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/making-your-app-compatible-with-visionos": {
    "Making your existing app compatible with visionOS": {
      "zh": "使现有应用与 visionOS 兼容",
      "tips": ""
    },
    "Modify your iPadOS or iOS app to run successfully in visionOS.": {
      "zh": "修改你的 iPadOS 或 iOS 应用，以便在 visionOS 中成功运行。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "A compatible iPadOS or iOS app links against the iOS SDK and runs in visionOS. Although visionOS provides a complete set of iOS frameworks for linking, some features of those frameworks might be unavailable due to hardware or usage differences. To ensure your app runs correctly in visionOS, handle any missing features gracefully and provide workarounds wherever possible.": {
      "zh": "兼容的 iPadOS 或 iOS 应用可链接 iOS SDK 并在 visionOS 中运行。尽管 visionOS 提供了一套完整的 iOS 桥接框架，但由于硬件或使用上的差异，这些框架的某些功能可能无法使用。为确保你的应用能在 visionOS 中正确运行，请优雅地应对可能缺失的功能，并尽可能提供变通方法。",
      "tips": ""
    },
    "Perform availability and authorization checks before using features": {
      "zh": "使用功能前进行可用性和授权检查",
      "tips": ""
    },
    "Some frameworks offer APIs to let you determine when framework features are available or whether your app is authorized to use them. Always check these APIs before you try to use the corresponding features, and don’t assume a feature is available because the necessary hardware is present. The device’s configuration also plays a role in determining the results of some availability and authorization checks, and features might not be present when your app runs in Simulator. If an availability or authorization check fails, don’t try to use the associated feature in your app.": {
      "zh": "有些框架提供了 API 让你检查框架功能何时可用，或你的应用是否已被授权使用这些功能。在尝试使用相应功能之前，请务必检查这些 API，不要因为存在必要的硬件就认为某项功能可用。设备的配置也会对某些可用性和授权检查的结果产生影响，另外当你的应用在模拟器中运行时，某些功能可能并不存在。如果可用性或授权检查失败，请不要尝试在应用中使用相关功能。",
      "tips": ""
    },
    "The following frameworks support availability or authorization checks:": {
      "zh": "以下框架支持可用性或授权检查：",
      "tips": ""
    },
    "ActivityKit. Check the areActivitiesEnabled property of ActivityAuthorizationInfo to determine if Live Activities are authorized.": {
      "zh": "ActivityKit。检查 ActivityAuthorizationInfo 的 areActivitiesEnabled 属性，以确认”实时活动“是否已获得授权。",
      "tips": ""
    },
    "ARKit. Check the isSupported property of your configuration object to determine availability of augmented reality features. In visionOS, ARKit views such as ARView are never available, so isolate interface code containing those views to the iOS version of your app.": {
      "zh": "ARKit。检查配置对象的 isSupported 属性，以确认增强现实功能是否可用。在 visionOS 中，ARView 等 ARKit 视图总是不可用，因此请将包含这些视图的接口代码隔离到 iOS 版本的应用中。",
      "tips": ""
    },
    "AVFoundation. Identify what cameras are available using the AVCaptureDevice.DiscoverySession class. Don’t assume the presence of specific cameras.": {
      "zh": "AVFoundation。使用 AVCaptureDevice.DiscoverySession 类确认哪些摄像头可用。不要假设存在特定的摄像头。",
      "tips": ""
    },
    "Automatic Assessment Configuration. Check for error values when you configure an AEAssessmentSession object.": {
      "zh": "自动评估配置。请在配置 AEAssessmentSession 对象时检查错误值。",
      "tips": ""
    },
    "Contacts. Use the CNContactStore class to determine your app’s authorization status.": {
      "zh": "联系人。使用 CNContactStore 类确认应用的授权状态。",
      "tips": ""
    },
    "Core Bluetooth. Use the CBCentralManager and CBPeripheralManager classes to determine feature availability and your app’s authorization status.": {
      "zh": "核心蓝牙。使用 CBCentralManager 和 CBPeripheralManager 类确认功能可用性和应用的授权状态。",
      "tips": ""
    },
    "Core Haptics. Call the capabilitiesForHardware() method of the haptic engine to determine the available features.": {
      "zh": "核心触觉。调用触觉引擎的 capabilitiesForHardware() 方法确认可用功能。",
      "tips": ""
    },
    "Core Location. Check the properties of CLLocationManager to determine the availability of location services.": {
      "zh": "核心位置。检查 CLLocationManager 的属性以确认位置服务的可用性。",
      "tips": ""
    },
    "Core Motion. Check the properties of CMMotionManager to determine the availability of accelerometers, gyroscopes, magnetometers, and other hardware sensors.": {
      "zh": "核心运动。检查 CMMotionManager 的属性，以确认加速计、陀螺仪、磁力计和其他硬件传感器是否可用。",
      "tips": ""
    },
    "Core NFC. Check the readingAvailable property of your reader session to determine if NFC tag reading is available.": {
      "zh": "核心 NFC。检查读取器会话的 readingAvailable 属性，以确认 NFC 标签读取是否可用。",
      "tips": ""
    },
    "EventKit. Use the EKEventStore class to determine your app’s authorization status.": {
      "zh": "EventKit。使用 EKEventStore 类确认应用的授权状态。",
      "tips": ""
    },
    "ExposureNotification. Use the ENManager class to determine your app’s authorization status.": {
      "zh": "ExposureNotification。使用 ENManager 类确认应用的授权状态。",
      "tips": ""
    },
    "HealthKit. Use the HKHealthStore class to determine if health-related data is available.": {
      "zh": "HealthKit。使用 HKHealthStore 类确认健康相关数据是否可用。",
      "tips": ""
    },
    "HomeKit. Check the properties of HMHomeManager to determine your app’s authorization status.": {
      "zh": "HomeKit。检查 HMHomeManager 的属性，确认应用的授权状态。",
      "tips": ""
    },
    "Local Authentication. Use the LAContext class to determine the authentication policies you can use.": {
      "zh": "本地身份验证。使用 LAContext 类确认可以使用的身份验证策略。",
      "tips": ""
    },
    "Media Player. Use the MPMediaLibrary class to determine your app’s authorization status.": {
      "zh": "媒体播放器。使用 MPMediaLibrary 类确认应用的授权状态。",
      "tips": ""
    },
    "Nearby Interaction. Check the deviceCapabilities property of your session to determine whether features are available.": {
      "zh": "邻近交互。检查会话的 deviceCapabilities 属性，确认功能是否可用。",
      "tips": ""
    },
    "PhotoKit. Use the PHPhotoLibrary class to determine your app’s authorization status.": {
      "zh": "PhotoKit。使用 PHPhotoLibrary 类确认应用的授权状态。",
      "tips": ""
    },
    "ProximityReader. Check the isSupported property of the card reader object to determine if Tap to Pay on iPhone is available.": {
      "zh": "ProximityReader。检查读卡器对象的 isSupported 属性，以确认 iPhone 上的“Tap to Pay”是否可用。",
      "tips": ""
    },
    "ReplayKit. Check the isAvailable property of RPScreenRecorder to determine if screen recording support is available.": {
      "zh": "ReplayKit。检查 RPScreenRecorder 的 isAvailable 属性，以确认屏幕录制功能是否可用。",
      "tips": ""
    },
    "RoomPlan. Check the isSupported property of the RoomCaptureSession object to determine if LiDAR scanning is available on the device.": {
      "zh": "RoomPlan。检查 RoomCaptureSession 对象的 isSupported 属性，以确认设备上是否支持 3D 激光扫描。",
      "tips": "LiDAR 是 Light Detection And Ranging 的缩写，通常被称为“3D 激光扫描”。"
    },
    "SensorKit. Use the SRSensorReader class to determine your app’s authorization status.": {
      "zh": "SensorKit。使用 SRSensorReader 类确认应用的授权状态。",
      "tips": ""
    },
    "Speech. Use the SFSpeechRecognizer class to determine if speech recognition is available.": {
      "zh": "语音。使用 SFSpeechRecognizer 类确认语音识别是否可用。",
      "tips": ""
    },
    "User Notifications. Use the getNotificationSettings(completionHandler:) method of UNUserNotificationCenter to determine your app’s authorization status.": {
      "zh": "用户通知。使用 UNUserNotificationCenter 的 getNotificationSettings(completionHandler:) 方法确认应用的授权状态。",
      "tips": ""
    },
    "WatchConnectivity. Call the isSupported() method of the WCSession object to determine if the framework is available.": {
      "zh": "WatchConnectivity。调用 WCSession 对象的 isSupported() 方法来确认框架是否可用。",
      "tips": ""
    },
    "Handle environmental differences appropriately": {
      "zh": "妥善处理环境差异",
      "tips": ""
    },
    "Apple frameworks take a device-agnostic approach whenever possible to minimize issues when you use them on different device types. Apple devices come in a variety of shapes and sizes, and with different sets of features. Rather than build your app for a specific device, make sure it adapts to any device and can gracefully handle differences.": {
      "zh": "Apple 框架在设计时尽可能地采用了无视设备的方式，以减少在不同类型设备上使用时出现的问题。苹果设备的形状和大小各不相同，功能也不尽相同。与其为特定设备构建应用，不如确保应用能适应任何设备，并能从容应对差异。",
      "tips": ""
    },
    "Build robustness into your app during the design process. Avoid assumptions that might cause your app to break when it runs on a new device, and make sure your app adapts dynamically to different conditions. For example:": {
      "zh": "请在应用的设计过程中考虑到稳健性。请避免可能导致应用在新设备上运行时发生故障的假设，并确保你的应用能动态地适应不同的条件。例如：",
      "tips": ""
    },
    "Don’t assume the device type or idiom is always iPhone, iPad, or iPod Touch. Avoid decisions based on the current idiom. If you do rely on the current idiom, provide reasonable defaults for unknown idioms.": {
      "zh": "不要假设设备类型或惯用名总是 iPhone、iPad 或 iPod Touch。请避免根据当前的惯用名做出决定。如果你确实依赖当前的惯用名，请为未知惯用名提供合理的默认值。",
      "tips": ""
    },
    "Design your app to handle unavailable hardware or features. Specific hardware and features might be unavailable for many different reasons. For example, a feature might be unavailable when your app runs in Simulator. Perform availability checks whenever possible, and handle missing features gracefully.": {
      "zh": "将应用设计为能够对应不可用的硬件或功能。导致特定硬件和功能不可用的原因多种多样。例如，当应用在模拟器中运行时，某个功能或许不可用。请尽可能地执行可用性检查，并从容应对功能缺失。",
      "tips": ""
    },
    "Design your windows and views to adapt dynamically. Build your interface to adapt dynamically to any size using SwiftUI or Auto Layout. Assume the size of your app can change dynamically.": {
      "zh": "设计能够动态适应的窗口和视图。使用 SwiftUI 或自动布局来构建界面，以便动态适应任何尺寸。请假设应用的尺寸会动态变化。",
      "tips": ""
    },
    "Don’t assume the device has a specific number of displays. People can connect iPad and iPhone to an external display, and visionOS devices use two displays to create a stereoscopic version of your app’s content.": {
      "zh": "不要假设设备有特定数量的显示屏。人们可以将 iPad 和 iPhone 连接到外部显示屏，而 visionOS 设备则使用两个显示屏来创建应用内容的立体版。",
      "tips": ""
    },
    "Don’t make assumptions based on the available frameworks or symbols. The presence or absence of frameworks or code symbols is an unreliable way to identify a device type, and can change in later software updates.": {
      "zh": "不要根据可用的框架或符号做出假设。某个框架或代码符号的存在或缺失不是识别设备类型的可靠方法，而且可能会在今后的软件更新中变化。",
      "tips": ""
    },
    "Don’t assume your app runs in the background. visionOS doesn’t support the location, external accessory, or Bluetooth-peripheral background execution modes.": {
      "zh": "不要假设你的应用在后台运行。visionOS 不支持定位、外部访问或蓝牙外设后台执行模式。",
      "tips": ""
    },
    "Don’t assume that background apps are hidden. In visionOS, the windows of background apps remain visible, but are dimmed when no one looks at them. The only time app windows disappear is when one app presents an immersive space.": {
      "zh": "不要假设所有后台应用都是隐藏的。在 visionOS 中，后台应用的窗口仍然可见，但在未被观看时会变暗。只有当某个应用呈现出沉浸式空间时，应用窗口才会消失。",
      "tips": ""
    },
    "When you make decisions using device details, your app might produce inconsistent or erroneous results on an unknown device type, or it might fail altogether. Find solutions that rely on environmental information, rather than the device type. For example, SwiftUI and UIKit start layout using the app’s window size, which isn’t necessarily the same size as the device’s display.": {
      "zh": "当你使用设备详细信息进行决策时，你的应用可能会在未知设备类型上产生不一致或错误的结果，或者彻底崩溃。请寻找依赖环境信息而非设备类型的解决方案。例如，SwiftUI 和 UIKit 使用应用的窗口大小启动布局，而窗口大小并不一定与设备显示屏大小相同。",
      "tips": ""
    },
    "Note": {
      "zh": "备注",
      "tips": ""
    },
    "Device-specific information is available when you absolutely need it, but validate the information you receive and provide reasonable default behavior for unexpected values.": {
      "zh": "在绝对必要时可以使用设备特定信息，但要对收到的信息进行验证，并为意外值提供合理的默认行为。",
      "tips": ""
    },
    "Audit your interface code": {
      "zh": "审核你的界面代码",
      "tips": ""
    },
    "To minimize disruptions, visionOS runs your compatible iPad or iPhone app in an environment that matches an iPad as much as possible. Windows and views retain the same appearance that they have in iPadOS or iOS, and the system sizes your app’s window to fit an iPad whenever possible.": {
      "zh": "为了最大限度地减少干扰，visionOS 会尽可能在与 iPad 相匹配的环境中运行兼容的 iPad 或 iPhone 应用。窗口和视图保留了与 iPadOS 或 iOS 中相同的外观，而且系统会尽可能调整应用窗口的大小以适应 iPad。",
      "tips": ""
    },
    "When building your app’s interface, make choices that ensure your app runs well in visionOS too. Adopt the following best practices for your interface-related code:": {
      "zh": "在构建应用的界面时，请选择能确保你的应用在 visionOS 中也能正常运行的选项。对于与界面相关的代码，请采用以下最佳实践：",
      "tips": ""
    },
    "Support iPad and iPhone in the same app. Create one app that supports both device types, rather than separate apps for each device. SwiftUI and UIKit support adaptable interfaces, and Xcode provides tools to help you visualize your interface at different supported sizes.": {
      "zh": "在一个应用中支持 iPad 和 iPhone。创建一个同时支持两种设备类型的应用，而不是为每种设备分别创建应用。SwiftUI 和 UIKit 支持自适应界面，而 Xcode 提供的工具可帮助你在不同的支持尺寸下显示界面。",
      "tips": ""
    },
    "Organize your interface using scenes. Scenes are a fundamental tool for managing your app’s interface. Use the scene types in SwiftUI and UIKit to assemble and manage the views you display in windows.": {
      "zh": "使用场景来组织界面。场景是管理应用界面的基本工具。使用 SwiftUI 和 UIKit 中的场景类型来组合和管理你在窗口中显示的视图。",
      "tips": ""
    },
    "Adapt your interface to any size. Design your interface to adapt naturally to different sizes. For an introduction to SwiftUI views and layout, see Declaring a custom view. For information about laying out views in UIKit, see View layout.": {
      "zh": "让界面适应任何尺寸。将你的界面设计成能自然适应不同尺寸。有关 SwiftUI 视图和布局的介绍，请参阅声明自定义视图。有关在 UIKit 中布局视图的信息，请参阅视图布局。",
      "tips": ""
    },
    "Don’t access screen details. visionOS provides reasonable values for UIScreen objects, but don’t use those values to make decisions.": {
      "zh": "不要访问屏幕细节。visionOS 为 UIScreen 对象提供了合理的值，但请不要使用这些值来做决策。",
      "tips": ""
    },
    "Specify the supported interface orientations. Add the UISupportedInterfaceOrientations key to your app’s Info.plist file to specify the interface orientations it supports. Support all interface orientations whenever possible. visionOS adds an interface rotation for your app button only when this key is present.": {
      "zh": "指定支持的界面方向。在应用的 Info.plist 文件中添加 UISupportedInterfaceOrientations 键以指定支持的界面方向。请尽可能地支持所有的界面方向。只有当该键存在时，visionOS 才会为你的应用按钮添加界面旋转。",
      "tips": ""
    },
    "Update hover effects in custom views. Hover effects convey the focused view or control in your interface. Standard system views apply hover effects as needed. For custom views and controls, verify that the hover effects look appropriate in visionOS. Add or update the content shape for your hover effects if needed.": {
      "zh": "更新自定义视图中的悬停效果。悬停效果用于表明界面中被选中的视图或控件。标准系统视图会根据需要添加悬停效果。对于自定义视图和控件，请确认悬停效果在 visionOS 中看起来是否合适。必要时，为悬停效果添加或更新内容形状。",
      "tips": ""
    },
    "Adopt vector-based images when possible. Vector-based images scale well to different sizes while retaining a crisp appearance. If you use bitmap-based assets, make them the exact size you need. Don’t use oversized assets, which require extra work to display at the correct size.": {
      "zh": "尽可能采用基于矢量的图像。基于矢量的图像可以很好地缩放至不同尺寸，同时保持清晰的外观。如果你使用基于位图的资源，请将它们生成为所需的精确尺寸。不要使用过大的资源，因为那样需要额外的工作才能将它们显示为正确尺寸。",
      "tips": ""
    },
    "If you want visionOS to display your app’s interface in a particular orientation at launch, add the UIPreferredDefaultInterfaceOrientation key to your app’s Info.plist file. Set the value of the key to one of the values in your app’s UISupportedInterfaceOrientations key. For example, to specify a preference for a portrait orientation, set the value to UIInterfaceOrientationPortrait. Add ~ipad or ~iphone to the key name to specify device-specific orientation preferences.": {
      "zh": "如果你希望 visionOS 在启动时以特定方向展示应用的界面，请在应用的 Info.plist 文件中添加 UIPreferredDefaultInterfaceOrientation 键盘。将该键的值设置为应用的 UISupportedInterfaceOrientations 键中的值之一。例如，如要指定偏好纵向，请将值设置为 UIInterfaceOrientationPortrait。在键名中添加 ~ipad 或 ~iphone 以指定特定设备的方向首选项。",
      "tips": ""
    },
    "Respond gracefully to missing features": {
      "zh": "优雅地应对功能缺失",
      "tips": ""
    },
    "If your app relies on frameworks that behave differently in visionOS, update your code to handle those differences. Availability checks give you a clear indication when you can’t use a feature, but some frameworks might have more subtle behavior. Throughout your code, make sure you respond to unusual situations:": {
      "zh": "如果你的应用依赖的框架在 visionOS 中表现不同，请更新你的代码以处理这些差异。可用性检查会在无法使用某项功能时给出明确指示，但某些框架可能会有更微妙的差异。请在你的所有代码中，确保能应对以下异常情况：",
      "tips": ""
    },
    "Handle error conditions. If a function throws an exception or returns an error, handle the error. Use error information to adjust your app’s behavior or provide an explanation of why it can’t perform certain operations.": {
      "zh": "处理错误情况。如果函数抛出异常或返回错误，请处理错误。使用错误信息来调整应用行为，或解释无法执行某些操作的原因。",
      "tips": ""
    },
    "Handle nil or empty values gracefully. Validate objects and return values before you try to use them.": {
      "zh": "优雅地处理 nil 或空值。在尝试使用对象和返回值之前对其进行验证。",
      "tips": ""
    },
    "Update your interface. Provide appropriate messaging in your interface when a feature is missing, or remove feature-specific views entirely if you can do so cleanly. Don’t leave empty views where the feature was.": {
      "zh": "更新界面。当某一功能缺失时，请在界面中提供展示适当的信息，如能干净利落地移除特定功能视图，则请完全移除。不要在功能的原位置留下空视图。",
      "tips": ""
    },
    "For information about frameworks that behave differently in visionOS, see Checking whether your existing app is compatible with visionOS.": {
      "zh": "关于在 visionOS 中表现不同的框架的信息，请参阅检查现有应用是否与 visionOS 兼容。",
      "tips": ""
    },
    "Remove code that uses deprecated APIs": {
      "zh": "移除使用了废弃 API 的代码",
      "tips": ""
    },
    "If your app currently uses deprecated APIs or frameworks, update your code to use appropriate replacements. Deprecated symbols represent outdated features, and in some cases might not do anything when you call them. To prevent potential issues, replace them with modern equivalents to ensure your code behaves as expected.": {
      "zh": "如果你的应用当前使用了废弃的 API 或框架，请更新代码以使用适当的替代。废弃符号代表着过时的功能，在某些情况下，调用它们可能什么也做不了。为防止发生潜在的问题，请使用当前的等效符号替换它们，以确保你的代码按预期运行。",
      "tips": ""
    },
    "The following frameworks are deprecated in their entirety in iPadOS, iOS, and visionOS. If your app still uses these frameworks, move off of them immediately. The reference documentation for each framework includes information about how to update your code.": {
      "zh": "在 iPadOS、iOS 和 visionOS 中，以下框架已被完全废弃。如果你的应用仍在使用这些框架，请立即停止使用。每个框架的参考文档都包含有关如何更新代码的信息。",
      "tips": ""
    },
    "Accounts": {
      "zh": "Accounts",
      "tips": ""
    },
    "Address Book": {
      "zh": "Address Book",
      "tips": ""
    },
    "Address Book UI": {
      "zh": "Address Book UI",
      "tips": ""
    },
    "Assets Library": {
      "zh": "Assets Library",
      "tips": ""
    },
    "iAd": {
      "zh": "iAd",
      "tips": ""
    },
    "Newsstand Kit": {
      "zh": "Newsstand Kit",
      "tips": ""
    },
    "NotificationCenter": {
      "zh": "NotificationCenter",
      "tips": ""
    },
    "OpenGL ES": {
      "zh": "OpenGL ES",
      "tips": ""
    }
  },
  "visionos/monitoring_playback_progress_in_your_app": {
    "Monitoring playback progress in your app": {
      "zh": "",
      "tips": ""
    },
    "Observe the playback of a media asset to update your app’s user-interface state.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "Media playback apps commonly need to monitor playback progress to drive the state of player UI or perform other actions. Monitoring this state requires a higher level of time precision than key-value observing can deliver, so AVPlayer provides specific API to observe playback time. This article describes how you can observe this state at regular intervals or as playback crosses specific time boundaries.": {
      "zh": "",
      "tips": ""
    },
    "Observe the current playback time at regular intervals": {
      "zh": "",
      "tips": ""
    },
    "The most common way to observe a player’s current time is at regular intervals. Observing it this way is useful when driving the state of a time display in a player’s user interface.": {
      "zh": "",
      "tips": ""
    },
    "To observe the player’s current time at regular intervals, call its addPeriodicTimeObserver(forInterval:queue:using:) method. This method takes a CMTime value that represents the interval at which to observe the time, a serial dispatch queue, and a callback that the player invokes at the specified time interval. The following example adds an observer that the player calls every half-second during normal playback:": {
      "zh": "",
      "tips": ""
    },
    "Always pair a call to the player’s addPeriodicTimeObserver(forInterval:queue:using:) method with a call to removeTimeObserver(_:) when you’re finished monitoring the state. Failing to observe this rule results in undefined behavior.": {
      "zh": "",
      "tips": ""
    },
    "Observe the playback of specific times within a media presentation": {
      "zh": "",
      "tips": ""
    },
    "Another way to observe the player is when it crosses specific times boundaries during playback. You can respond to the passage of these times by updating your player UI or performing other actions.": {
      "zh": "",
      "tips": ""
    },
    "To have the player notify your app as it cross specific points in the media timeline, call the player’s addBoundaryTimeObserver(forTimes:queue:using:) method. This method takes an array of NSValue objects that wrap CMTime values that define your boundary times, a serial dispatch queue, and a callback closure. The following example shows how to define boundary times for each quarter of playback:": {
      "zh": "",
      "tips": ""
    },
    "If you add either a periodic or boundary time observer, you need to remove observation by calling removeTimeObserver(_:) when complete.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/placing-content-on-detected-planes": {
    "Placing content on detected planes": {
      "zh": "在检测到的平面上放置内容",
      "tips": ""
    },
    "Detect horizontal surfaces like tables and floors, as well as vertical planes like walls and doors.": {
      "zh": "检测水平平面（如桌子和地板）以及垂直平面（如墙壁和门）。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "Flat surfaces are an ideal place to position content in an app that uses a Full Space in visionOS. They provide a place for virtual 3D content to live alongside a person’s surroundings. Use plane detection in ARKit to detect these kinds of surfaces and filter the available planes based on criteria your app might need, such as the size of the plane, its proximity to someone, or a required plane orientation.": {
      "zh": "平面是在 visionOS 上使用“完整空间”的应用中放置内容的理想场所。它们为虚拟 3D 内容提供了与用户周围环境共存的场所。使用 ARKit 中的平面检测功能可检测到这类表面，并根据你的应用可能需要的条件（如平面大小、与用户的距离或所需的平面方向）过滤可用的平面。",
      "tips": ""
    },
    "Use RealityKit anchor entities for basic plane anchoring": {
      "zh": "使用 RealityKit 锚点实体进行基本的平面锚定",
      "tips": ""
    },
    "If you don’t need a specific plane in your app and you’re rendering your app’s 3D content in RealityKit, you can use an AnchorEntity instead. This approach lets you attach 3D content to a plane without prompting the person for world-sensing permission and without any particular knowledge of where that plane is relative to the person.": {
      "zh": "如果你的应用不需要特定的平面，而且你在使用 RealityKit 渲染应用的 3D 内容，那么你可以使用锚点实体（AnchorEntity）作为代替。这种方法可以让你将 3D 内容添加到一个平面上，且无需提示用户获得世界感知权限，也无需去了解该平面相对于用户的位置。",
      "tips": ""
    },
    "The following shows an anchor that you can use to attach entities to a table:": {
      "zh": "下代码显示了一个锚点，你可以用它将实体添加到桌子上：",
      "tips": ""
    },
    "Anchor entities don’t let you choose a specific plane in a person’s surroundings, but rather let you ask for a plane with certain characteristics. When you need more specific plane selection or real-time information about the plane’s position and orientation in the world, use ARKitSession and PlaneDetectionProvider.": {
      "zh": "锚点实体不允许你选择人物周围环境中的特定平面，而是允许你请求具有某些特征的平面。当你需要选择更具体的平面或有关平面在世界中位置和方向的实时信息时，请使用 ARKitSession 和 PlaneDetectionProvider。",
      "tips": ""
    },
    "Configure an ARKit session for plane detection": {
      "zh": "为平面检测配置 ARKit 会话",
      "tips": ""
    },
    "Plane-detection information comes from an ARKitSession that’s configured to use a PlaneDetectionProvider. You can choose to detect horizontal planes, vertical planes, or both. Each plane that ARKit detects comes with a classification, like PlaneAnchor.Classification.table or PlaneAnchor.Classification.floor. You can use these classifications to further refine which kinds of planes your app uses to present content. Plane detection requires ARKitSession.AuthorizationType.worldSensing authorization.": {
      "zh": "平面检测信息来自配置了 PlaneDetectionProvider 的 ARKitSession。你可以选择检测水平或垂直平面或两者。ARKit 检测到的每个平面都有一个分类，如 PlaneAnchor.Classification.table 或 PlaneAnchor.Classification.floor。你可以使用这些分类来进一步选择用哪类平面来应用中呈现内容。平面检测需要 ARKitSession.AuthorizationType.worldSensing 授权。",
      "tips": ""
    },
    "The following starts a session that detects both horizontal and vertical planes, but filters out planes classified as windows:": {
      "zh": "下面代码启动的会话可检测水平和垂直平面，但会过滤掉被归类为窗口的平面：",
      "tips": ""
    },
    "Create and update entities associated with each plane": {
      "zh": "创建并更新与平面关联的实体",
      "tips": ""
    },
    "If you’re displaying content that needs to appear attached to a particular plane, update your content whenever you receive new information from ARKit. When a plane is no longer available in the person’s surroundings, ARKit sends a removal event. Respond to these events by removing content associated with the plane.": {
      "zh": "如果你在显示需要绑定至特定平面的内容，请在收到来自 ARKit 的新信息时更新这些内容。当用户周围环境中的某个平面不再可用时，ARKit 会发送移除事件。请通过移除与平面相关的内容来响应移除事件。",
      "tips": ""
    },
    "The following shows plane updates that place a text entity on each plane in a person’s surroundings; the text entity displays the kind of plane ARKit detected:": {
      "zh": "下面代码展示了更新平面过程：向用户周围的每个平面上放置文本实体；文本实体显示的是 ARKit 检测到的平面类型：",
      "tips": ""
    }
  },
  "visionos/positioning-and-sizing-windows": {
    "Positioning and sizing windows": {
      "zh": "定位和调整窗口大小",
      "tips": ""
    },
    "Influence the initial geometry of windows that your app presents.": {
      "zh": "影响应用呈现的窗口的初始几何位置和大小",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "visionOS and macOS enable people to move and resize windows. In some cases, your app can use scene modifiers to influence a window’s initial geometry on these platforms, as well as to specify the strategy that the system employs to place minimum and maximum size limitations on a window. This kind of configuration affects both windows and volumes, which are windows with the volumetric window style.": {
      "zh": "visionOS 和 macOS 允许用户能够移动和调整窗口大小。在某些情况下，你的应用可以使用场景修饰器来影响窗口在这些平台上的初始几何位置和大小，以及指定系统用于在窗口上设置最小和最大尺寸限制的策略。这种配置会影响窗口和立体窗口（具有 volumetric 窗口样式的窗口）。",
      "tips": ""
    },
    "Your ability to configure window size and position is subject to the following constraints:": {
      "zh": "配置窗口大小和位置的能力受以下限制：",
      "tips": ""
    },
    "The system might be unable to fulfill your request. For example, if you specify a default size that’s outside the range of the window’s resizability, the system clamps the affected dimension to keep it in range.": {
      "zh": "系统可能无法满足你的请求。例如，如果指定的默认大小超出了窗口大小的可调整范围，则系统会收缩受影响的尺寸以使其保持在合理范围内。",
      "tips": ""
    },
    "Although you can change the window’s content, you can’t directly manipulate window position or size after the window appears. This ensures that people have full control over their workspace.": {
      "zh": "虽然你可以更改窗口的内容，但不能在窗口出现后直接操作窗口位置或大小。这确保了用户可以完全控制他们的工作空间。",
      "tips": ""
    },
    "During state restoration, the system restores windows to their previous position and size.": {
      "zh": "在 app 状态恢复的时候，系统会将窗口恢复到其以前的位置和大小。",
      "tips": ""
    },
    "Note": {
      "zh": "注意",
      "tips": ""
    },
    "Windows in iPadOS occupy the full screen, or share the screen with another window in Slide Over or Split View. You can’t programmatically affect window geometry on that platform.": {
      "zh": "iPadOS 中的窗口占据全屏，或在“侧拉”（Slide Over）或“分屏浏览”（Split）中与另一个窗口共享屏幕。你无法以编程方式影响该平台上的窗口几何位置和大小。",
      "tips": ""
    },
    "Specify initial window position": {
      "zh": "指定窗口初始位置",
      "tips": ""
    },
    "In macOS, the first time your app opens a window from a particular scene declaration, the system places the window at the center of the screen by default. For scene types that support multiple simultaneous windows, the system offsets each additional window by a small amount to avoid fully obscuring existing windows.": {
      "zh": "在 macOS 中，当你的 App 首次从特定场景声明中打开窗口时，系统会默认将该窗口置于屏幕中央。对于支持多个同时并存窗口的场景类型，系统会将每个新添加的窗口偏移一小段距离，以避免完全遮挡现有窗口。",
      "tips": ""
    },
    "You can override the default placement of the first window in macOS by applying the defaultPosition(_:) scene modifier to indicate where to place the window relative to the screen bounds. For example, you can request that the system place a new window in the bottom trailing corner of the screen:": {
      "zh": "你可以通过应用 defaultPosition(_:) 场景修饰器来指示窗口相对于屏幕边界的放置位置，从而覆盖 macOS 中首个窗口的默认位置。例如，你可以请求系统在屏幕的右下角放置一个新窗口：",
      "tips": ""
    },
    "The system aligns the point in the window that corresponds to the specified UnitPoint with the point in the screen that corresponds to the same unit point. You can use a built-in unit point, like bottomTrailing in the above example, or define a custom one.": {
      "zh": "系统将窗口中与指定 UnitPoint 点相对应的点与屏幕中与同一单位点相对应的点对齐。你可以使用内置单位点（如上例所示的 bottomTrailing），也可以定义一个自定义单位点。",
      "tips": ""
    },
    "Important": {
      "zh": "重要",
      "tips": ""
    },
    "You can’t use defaultPosition(_:) in visionOS. The system always places new windows directly in front of people, where they happen to be looking at the moment the window opens. This helps to make people aware of new windows.": {
      "zh": "你不能在 visionOS 中使用 defaultPosition(_:)。visionOS 总是将新窗口直接放置在用户面前，在窗口打开时用户一眼就能看到的位置。这有助于用户感知新窗口的出现。",
      "tips": ""
    },
    "Specify initial window size": {
      "zh": "指定窗口初始大小",
      "tips": ""
    },
    "You can indicate a default initial size for a new window that the system creates from a Scene declaration by applying one of the default size scene modifiers, like defaultSize(width:height:). For example, you can request that new windows that a WindowGroup generates occupy 600 points in the x-dimension and 400 points in the y-dimension:": {
      "zh": "你可以通过应用默认大小场景修饰器的其中一个（如 defaultSize(width:height:) ）来指示系统从 Scene 声明中创建的新窗口的默认初始大小。例如，你可以请求 WindowGroup 生成的新窗口在 x 维度中占据 600 个点，在 y 维度中占据 400 个点：",
      "tips": ""
    },
    "The system might clamp the actual size of the window depending on both the window’s content and resizability settings.": {
      "zh": "系统可能会根据窗口的内容和可调整大小设置来限制窗口的实际大小。",
      "tips": ""
    },
    "Specify window resizability": {
      "zh": "指定窗口大小的可调整性",
      "tips": ""
    },
    "Both macOS and visionOS provide interface controls that enable people to resize windows, within certain limits. For example, people can use the control that appears when they look at the corner of a visionOS window to resize a window on that platform.": {
      "zh": "macOS 和 visionOS 都提供相应的界面控件，使用户能够在一定限制内调整窗口大小。例如，用户可以使用查看 visionOS 窗口角落时出现的控件来调整该系统平台上的窗口大小。",
      "tips": ""
    },
    "You can specify how the system limits window resizability. The default resizability for all scenes is automatic. With that strategy, Settings windows use the contentSize strategy, where both the minimum and maximum window size match the respective minimum and maximum sizes of the content that the window contains. Other scene types use contentMinSize by default, which retains the minimum size restriction, but doesn’t limit the maximium size.": {
      "zh": "你可以指定系统对窗口尺寸调整的限制。所有场景的默认可调整性为 automatic。应用该策略时，Settings 窗口使用该 contentSize 策略， 其中最小和最大窗口尺寸都与窗口所包含内容的最小和最大尺寸相匹配。其他场景类型默认使用 contentMinSize 策略 ，它保留了最小尺寸限制，但并不限制最大尺寸。",
      "tips": ""
    },
    "You can specify one of these resizability strategies explicitly by adding the windowResizability(_:) scene modifier to a scene. For example, people can resize windows from the following window group to between 100 and 400 points in both dimensions because the frame modifier imposes those bounds on the content view:": {
      "zh": "你可以通过向场景添加 windowResizability(_:) 场景修改器来显式指定某个特定的可调整尺寸策略。例如，用户可以将窗口的大小从以下窗口组调整为两个维度的 100 到 400 点之间，因为 frame 修饰器会将这些边界强加在内容视图上：",
      "tips": ""
    },
    "You can take this even further and enforce a specific size for a window with content that has a fixed size.": {
      "zh": "你可以更进一步，为具有固定大小的内容的窗口强制指定尺寸。",
      "tips": ""
    },
    "Specify a volume size": {
      "zh": "指定一个立体窗口的大小",
      "tips": ""
    },
    "When you create a volume, which is a window with the volumetric style, you can specify the volume’s size using one of the three-dimensional default size modifiers, like defaultSize(width:height:depth:in:). The following code creates a volume that’s one meter on a side:": {
      "zh": "当你创建一个立体窗口（具有 volumetric 窗口样式的窗口）时，你可以使用三维的默认尺寸修饰器（如 defaultSize(width:height:depth:in:)））。",
      "tips": ""
    },
    "The volume maintains this size for its entire lifetime. People can’t change the size of a volume at runtime.": {
      "zh": "立体窗口将在其整个生命周期内保持此大小。用户无法在运行时更改立体窗口的大小。",
      "tips": ""
    },
    "Although you can specify a volume’s size in points, it’s typically better to use physical units, like the above code which specifies a size in meters. This is because the system renders a volume with fixed scaling rather than dynamic scaling, unlike a regular window, which means the volume appears more like a physical object than a user interface. For information about the different kinds of scaling, see Spatial layout.": {
      "zh": "虽然你可以以“点”为单位指定立体窗口的大小，但通常最好使用物理单位，如上面的代码，它以米为单位指定大小。这是因为与常规窗口不同，系统以固定缩放而不是动态缩放的形式来呈现立体窗口，这意味着立体窗口看起来更像是物理对象，而不是用户界面。有关不同类型缩放的信息，请参阅空间布局。",
      "tips": ""
    }
  },
  "visionos/presenting-windows-and-spaces": {
    "Presenting windows and spaces": {
      "zh": "展示窗口和空间",
      "tips": ""
    },
    "Open and close the scenes that make up your app’s interface.": {
      "zh": "打开和关闭组成应用界面的场景。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "An app’s scenes, which contain views that people interact with, can take different forms. For example, a scene can fill a window, a tab in a window, or an entire screen. Some scenes can even place views throughout a person’s surroundings. How a scene appears depends on its type, the platform, and the context.": {
      "zh": "一个应用程序的场景，包括了用户与之进行交互的视图，它可以有多样的形式。例如，场景可以被一个窗口、一个窗口中的选项卡或一整个其他场景所填满。有些场景甚至可以将视图置于用户的周围环境中。场景的出现方式取决于其类型、系统平台和上下文。",
      "tips": ""
    },
    "When someone launches your app, SwiftUI looks for the first WindowGroup, Window, or DocumentGroup in your app declaration and opens a scene of that type, typically filling a new window or the entire screen, depending on the platform. For example, the following app running in macOS presents a window that contains a MailViewer view:": {
      "zh": "当用户启动你的 app 时，SwiftUI 会在你的 app 声明中查找首个 WindowGroup 、 Window 或 DocumentGroup ，然后打开该类型的场景，通常会用一个新窗口或整个屏幕填充它，具体取决于系统平台。例如，在 macOS 中运行的以下应用会显示一个包含 MailViewer 视图的窗口：",
      "tips": ""
    },
    "In visionOS, you can alternatively configure your app to open the first ImmersiveSpace that the app declares. In any case, specific platforms and configurations enable you to open more than one scene at a time. Under those conditions, you can use actions that appear in the environment to programmatically open and close the scenes in your app.": {
      "zh": "在 visionOS 中，您也可以将 app 配置为打开 app 声明的首个 ImmersiveSpace 。在任何情况下，特定的平台和配置都允许您一次打开多个场景。在这些条件下，您可以使用环境中出现的操作人为地打开和关闭应用中的场景。",
      "tips": ""
    },
    "Check for multiple-scene support": {
      "zh": "检查多场景支持",
      "tips": ""
    },
    "If you share code among different platforms and need to find out at runtime whether the current system supports displaying multiple scenes, read the supportsMultipleWindows environment value. The following code creates a button that’s hidden unless the app supports multiple windows:": {
      "zh": "如果您在不同系统平台上共享一套代码，并且需要在运行时了解当前系统是否支持显示多个场景，请读取 supportsMultipleWindows 环境变量。以下代码创建了一个按钮，只有在 app 支持多个窗口时按钮才会显示：",
      "tips": ""
    },
    "The value that you read depends on both the platform and how you configure your app:": {
      "zh": "你读取到的值由平台和你的 app 配置共同决定：",
      "tips": ""
    },
    "In macOS, this property returns true for any app that uses the SwiftUI app lifecycle.": {
      "zh": "在 macOS 中，对于使用 SwiftUI app 生命周期的任何 app，该值返回 true 。",
      "tips": ""
    },
    "In iPadOS and visionOS, this property returns true for any app that uses the SwiftUI app lifecycle and has the Information Property List key UIApplicationSupportsMultipleScenes set to true, and false otherwise.": {
      "zh": "在 iPadOS 和 visionOS 中，对于使用 SwiftUI app 生命周期且 info plist 中键 UIApplicationSupportsMultipleScenes 设为 true 的任何 app，此属性返回 true ，否则返回 false 。",
      "tips": ""
    },
    "For all other platforms and configurations, the value returns false.": {
      "zh": "对于所有其他系统平台和配置，该值返回 false 。",
      "tips": ""
    },
    "If your app only ever runs in one of these situations, you can assume the associated behavior and don’t need to check the value.": {
      "zh": "如果您的 app 仅在其中一种情况下运行，则可以默认其采取对应的行为，而无需检查该值。",
      "tips": ""
    },
    "Enable multiple simultaneous scenes": {
      "zh": "同时启用多个共存场景",
      "tips": ""
    },
    "You can always present multiple scenes in macOS. To enable an iPadOS or visionOS app to simultaneously display multiple scenes — including ImmersiveSpace scenes in visionOS — add the UIApplicationSupportsMultipleScenes key with a value of true in the UIApplicationSceneManifest dictionary of your app’s Information Property List. Use the Info tab in Xcode for your app’s target to add this key:": {
      "zh": "您始终可以在 macOS 中呈现多个场景。若要使 iPadOS 或 visionOS 上的 app 能够同时显示多个场景（包括 visionOS 中的 ImmersiveSpace 场景），请在 app 中 info.plist 里的 UIApplicationSceneManifest 字典中添加值为 true 的 UIApplicationSupportsMultipleScenes 键。在 Xcode 中，选择你 app 对应的一个 target 的 info 标签页以添加此键：",
      "tips": ""
    },
    "Apps on other platforms can display only one scene during their lifetime.": {
      "zh": "其他平台上的 app 在其生命周期内只能显示一个场景。",
      "tips": ""
    },
    "Open windows programmatically": {
      "zh": "以编程方式打开窗口",
      "tips": ""
    },
    "Some platforms provide built-in controls that enable people to open instances of the window-style scenes that your app defines. For example, in macOS people can choose File > New Window from the menu bar to open a new window. SwiftUI also provides ways for you to open new windows programmatically.": {
      "zh": "某些系统平台提供内置控件，使用户能够打开 app 自定义的窗口样式的场景的实例。例如，在 macOS 中，用户可以从菜单栏中选取 File > New Window 以打开新窗口。SwiftUI 还为您提供了以编程方式打开新窗口的方法。",
      "tips": ""
    },
    "To do this, get the openWindow action from the environment and call it with an identifier, a value, or both to indicate what kind of window to open and optionally what data to open it with. The following view opens a new instance of the previously defined mail viewer window when someone clicks or taps the button:": {
      "zh": "为此，请从环境中获取 openWindow 操作，并使用标识符、值或同时使用两者调用它，以指示要打开的窗口类型以及要打开的窗口（可选）数据。当有人单击或轻按该按钮时，以下视图将打开之前定义的邮件查看器窗口的新实例：",
      "tips": ""
    },
    "When the action runs on a system that supports multiple scenes, SwiftUI looks for a window in the app declaration that has a matching identifier and creates a new scene of that type.": {
      "zh": "当该操作在支持多个场景的系统上运行时，SwiftUI 会在 app 声明中查找具有匹配标识符的窗口，并创建该类型的新场景。",
      "tips": ""
    },
    "Important": {
      "zh": "重要",
      "tips": ""
    },
    "If supportsMultipleWindows is false and you try to open a new window, SwiftUI ignores the action and logs a runtime error.": {
      "zh": "如果在 supportsMultipleWindows 为 false 的情况下，您尝试打开一个新窗口，SwiftUI 会忽略该操作并记录一个运行时错误。",
      "tips": ""
    },
    "In addition to opening more instances of an app’s main window, as in the above example, you can also open other window types that your app’s body declares. For example, you can open an instance of the Window that displays connectivity information:": {
      "zh": "除了打开 app 主窗口的更多实例（如上例所示）之外，还可以打开 app 的 body 内声明的其他窗口类型。例如，您可以打开显示连接信息的 Window 实例：",
      "tips": ""
    },
    "Open a space programmatically": {
      "zh": "以编程方式打开空间",
      "tips": ""
    },
    "In visionOS, you open an immersive space — a scene that you can use to present unbounded content in a person’s surroundings — in much the same way that you open a window, except that you use the openImmersiveSpace action. The action runs asynchronously, so you use the await keyword when you call it, and typically do so from inside a Task:": {
      "zh": "在 visionOS 中，您可以打开一个沉浸式空间（可用于在用户周围环境中呈现无限内容的场景），其方式与打开窗口的方式大致相同，只需使用 openImmersiveSpace 操作。该操作以异步方式运行，因此在调用它时需使用 await 关键字，并且通常在一个 Task 闭包内部执行此操作：",
      "tips": ""
    },
    "Because your app operates in a Full Space when you open an ImmersiveSpace scene, you can only open one scene of this type at a time. If you try to open a space when one is already open, the system logs a runtime error.": {
      "zh": "由于当您打开 ImmersiveSpace 场景时，您的应用在 ImmersiveSpace 中运行，因此您一次只能打开一个此类场景。如果尝试在空间已存在时再次打开空间，系统将记录一个运行时错误。",
      "tips": ""
    },
    "Your app can display any number of windows together with an immersive space. However, when you open a space from your app, the system hides all windows that belong to other apps. After you dismiss your space, the other apps’ windows reappear. Similarly, the system hides your app’s windows if another app opens an immersive space.": {
      "zh": "你的 app 可以在一个沉浸式空间中显示任意数量的窗口。。但是，当您从 app 中打开空间时，系统会隐藏属于其他应用程序的所有窗口。关闭您的 app 的空间后，其他应用的窗口会重新显示。同样地，如果另一个 app 打开沉浸式空间，系统会隐藏您的 app 的窗口。",
      "tips": ""
    },
    "Designate a space as your app’s main interface": {
      "zh": "将空间指定为 app 的主界面",
      "tips": ""
    },
    "When visionOS launches an app, it opens the first window group, window, or document scene that the app’s body declares, just like on other platforms. This is true even if you first declare a space. However, if you want to open your app into an immersive space directly, specify a space as the default scene for your app by adding the UIApplicationPreferredDefaultSceneSessionRole key to your app’s information property list and setting its value to UISceneSessionRoleImmersiveSpaceApplication. In that case, visionOS opens the first space that it finds in your app declaration.": {
      "zh": "当 visionOS 启动一个 app 时，它会打开 app 的 body 中声明的第一个窗口组、窗口或文档场景，就像在其他系统平台上一样。即使您先声明的是一个空间，也是如此。但是，如果要直接在沉浸式空间中打开 app，请将 UIApplicationPreferredDefaultSceneSessionRole 键添加到 app 的 info.plist 中并将其值设置为 UISceneSessionRoleImmersiveSpaceApplication ，从而将空间指定为 app 的默认场景。在这种情况下，visionOS 会打开它在 app 声明中找到的第一个空间。",
      "tips": ""
    },
    "Be careful not to overwhelm people when starting your app with an immersive space. For design guidance, see Immersive experiences.": {
      "zh": "在以沉浸式空间启动 app 时，避免用户产生不知所措的感觉。有关设计指南，请参阅《沉浸式体验》。",
      "tips": ""
    },
    "Close windows programmatically": {
      "zh": "以编程方式关闭窗口",
      "tips": ""
    },
    "People can close windows using system controls, like the close button built into the frame around a macOS window. You can also close windows programmatically. Get the dismissWindow action from the environment, and call it using the identifier of the window that you want to dismiss:": {
      "zh": "用户可以使用系统自带的控件关闭窗口，例如 macOS 窗口上面系统默认的关闭按钮。您当然也可以以编程方式关闭窗口。从环境中获取 dismissWindow 操作，并使用要关闭的窗口的标识符来调用它：",
      "tips": ""
    },
    "In iPadOS and visionOS, the system ignores the dismiss action if you use it to close a window that’s your app’s only open scene.": {
      "zh": "在 iPadOS 和 visionOS 中，如果要关闭是当前 app 唯一打开的场景，系统会忽略该操作。",
      "tips": ""
    },
    "Close spaces programmatically": {
      "zh": "以编程方式关闭空间",
      "tips": ""
    },
    "To close a space, call the dismissImmersiveSpace action. Like the corresponding open space action, the close action operates asynchronously and requires the await keyword:": {
      "zh": "若要关闭空间，请调用 dismissImmersiveSpace 操作。与相应的打开空间的操作类似，关闭操作是异步执行的，并且需要 await 关键字：",
      "tips": ""
    },
    "You don’t need to specify an identifier for this action, because there can only ever be one space open at a time. Like with windows, you can’t dismiss a space that’s your app’s only open scene.": {
      "zh": "您无需为此操作指定标识符，因为一次只能打开一个空间。与窗口一样，你不能关闭 app 唯一打开的场景的空间。",
      "tips": ""
    },
    "Transition between a window and a space": {
      "zh": "在窗口和空间之间过渡",
      "tips": ""
    },
    "Because you can’t programmatically close the last open window or immersive space in a visionOS app, be sure to open a new scene before closing the old one. Pay particular attention to the sequencing when moving between a window and an immersive space, because the space’s open and dismiss actions run asynchronously.": {
      "zh": "由于无法以编程方式关闭 visionOS app 中上次打开的窗口或沉浸式空间，因此请务必在关闭旧场景之前打开新场景。在窗口和沉浸式空间之间移动时，请特别注意事件发生的顺序，因为空间的打开和关闭操作是异步运行的。",
      "tips": ""
    },
    "For example, consider a chess game that begins by displaying a start button in a window. When someone taps the button, the app dismisses the window and opens an immersive space that presents a chess board. The following button demonstrates proper sequencing by opening the space and then closing the window:": {
      "zh": "例如，考虑一个国际象棋游戏，它首先在窗口中显示一个开始按钮。当有人点击按钮时，应用程序会关闭窗口并打开一个显示棋盘的沉浸式空间。以下按钮演示了一个正确的事件顺序--先打开空间然后关闭窗口：",
      "tips": ""
    },
    "In the above code, it’s important to include the dismissWindow action inside the task, so that it waits until the openImmersiveSpace action completes. If you put the action outside the task — either before or after — it might execute before the asynchronous open action completes, when the window is still the only open scene. In that case, the system opens the space but doesn’t close the window.": {
      "zh": "在上面的代码中，务必将 dismissWindow 操作放在一个 Task 中，以便它会等待 openImmersiveSpace 操作完成后执行。如果将操作放在 Task 之外（无论是在 Task 之前还是之后），它可能会在异步打开操作完成之前执行，此时窗口仍是唯一打开的场景。在这种情况下，系统会打开空间，但不会关闭窗口。",
      "tips": ""
    }
  },
  "visionos/running-your-app-in-simulator-or-on-a-device": {
    "Running your app in Simulator or on a device": {
      "zh": "",
      "tips": ""
    },
    "Launch your app in a simulated iOS, tvOS, watchOS, or visionOS device, or on a device connected to a Mac.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "To test your app, build and run it on a simulated or real device. Use simulated devices to debug your app on a variety of hardware to which you don’t have immediate access. The tradeoff is that simulated devices run within the Simulator app on your Mac and don’t replicate the performance or features of an actual device. To verify your app runs exactly as intended, run it on one or more real devices. You can connect a real device to your Mac using a cable, or for iOS, tvOS, or visionOS apps, connect it over Wi-Fi after you pair it with Xcode.": {
      "zh": "",
      "tips": ""
    },
    "SwiftUI previews let you see your app’s interface without building and running your app. For more information on these dynamic previews, see Previews in Xcode.": {
      "zh": "",
      "tips": ""
    },
    "Select a build scheme and run destination": {
      "zh": "",
      "tips": ""
    },
    "Before you build and run your app, select a build scheme that includes the target for your app. A scheme is a collection of project details and settings that tell Xcode how to build and run a product from your project. Xcode determines where the resulting product can run based on the scheme you select, and populates the run destination menu in the toolbar with the list of available devices. For example, if the scheme contains a tvOS app, Xcode includes only tvOS simulators and devices as potential run destinations.": {
      "zh": "",
      "tips": ""
    },
    "To learn more about schemes, see Customizing the build schemes for a project.": {
      "zh": "",
      "tips": ""
    },
    "Important": {
      "zh": "",
      "tips": ""
    },
    "When running apps in Simulator, some hardware-specific features might not be available. Frameworks that provide access to device-specific features also provide API to tell you when those features are available. Call those APIs and handle the case where a feature isn’t available. To test the feature itself, run your code on a real device.": {
      "zh": "",
      "tips": ""
    },
    "Configure the list of simulated devices": {
      "zh": "",
      "tips": ""
    },
    "Manage real and simulated devices in the Devices and Simulators window in Xcode. To view this window, choose Window > Devices and Simulators. View and configure simulated devices from the Simulators tab.": {
      "zh": "",
      "tips": ""
    },
    "To add a new simulated device, click the plus (+) button at the bottom of the list of simulators and specify the configuration you want. You can add new simulators to specify a different device type or operating system version than the default set. To remove a simulator from the list, select it and press Delete.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "Xcode requires the Simulator runtime for each platform and system version for which you build and run Simulator. If Xcode doesn’t display device types for a platform, you might need to install that platform’s Simulator runtime. For more information on this installation, see Installing and managing Simulator runtimes.": {
      "zh": "",
      "tips": ""
    },
    "Connect real devices to your Mac": {
      "zh": "",
      "tips": ""
    },
    "To view and manage connections to your real devices, choose the Devices tab in the Devices and Simulators window in Xcode. The Devices tab shows the currently connected and disconnected devices and can help you diagnose problems that might occur. For example, Xcode might show a device as unavailable if it’s not running an operating system version your app supports. It also shows new devices available for pairing with your Xcode installation. Pair a device with Xcode to include them in the list of run destinations for your projects.": {
      "zh": "",
      "tips": ""
    },
    "To pair a device with a physical connection, connect the device to your Mac using an appropriate cable. Unlock the device and follow any instructions that appear in Xcode or on the device.": {
      "zh": "",
      "tips": ""
    },
    "To pair Apple Vision Pro or Apple TV without a physical connection:": {
      "zh": "",
      "tips": ""
    },
    "Ensure that both your Mac and the device to connect are on the same Wi-Fi network. The Wi-Fi network must be compatible with Bonjour.": {
      "zh": "",
      "tips": ""
    },
    "Broadcast the device to the target Mac over the local network. To do this for a visionOS device, choose Settings > General > Remote Devices and for a tvOS device, choose Settings > Remotes and Devices > Remote App and Devices.": {
      "zh": "",
      "tips": ""
    },
    "Select the device from the list in the Devices and Simulators window in Xcode and click the pairing button which triggers a code to appear on the target device.": {
      "zh": "",
      "tips": ""
    },
    "Enter the code on the Mac to complete the pairing process.": {
      "zh": "",
      "tips": ""
    },
    "After pairing is complete, the device shows up under connected devices in Devices and Simulators window in Xcode. You don’t need to keep a paired device physically connected to your Mac to install and run apps. If your device is connected to Wi-Fi on the same network as your Mac, Xcode can use that connection to install and run your app.": {
      "zh": "",
      "tips": ""
    },
    "To pair an Apple Watch to a Mac, connect its companion iPhone to the Mac with a cable, and ensure that the iPhone is paired for development. After this step, follow any instructions on the Apple Watch to trust the Mac. When paired through an iPhone running iOS 17 or later, Xcode connects to the Apple Watch over Wi-Fi. Series 5 and older models of Apple Watch additionally require the Apple Watch and Mac to be associated with the same Bonjour-compatible Wi-Fi network. When paired through an iPhone running older versions of iOS, Xcode requires the iPhone to remain connected to the Mac in order to develop on any model of Apple Watch.": {
      "zh": "",
      "tips": ""
    },
    "Before installing your app, perform a few additional steps:": {
      "zh": "",
      "tips": ""
    },
    "Specify your Apple ID in the Account preferences in Xcode.": {
      "zh": "",
      "tips": ""
    },
    "Specify a valid team in your project’s Signing & Capabilities pane.": {
      "zh": "",
      "tips": ""
    },
    "Code sign your macOS app if it includes capabilities that require code signing; see Adding capabilities to your app.": {
      "zh": "",
      "tips": ""
    },
    "Register the device with your team if you belong to the Apple Developer Program.": {
      "zh": "",
      "tips": ""
    },
    "Enable Developer Mode on an iOS, watchOS, or visionOS device, as described in Enabling Developer Mode on a device.": {
      "zh": "",
      "tips": ""
    },
    "You don’t need to configure a Mac device to run your macOS apps. Similarly, to run the macOS version of an iPad app, choose My Mac (the Mac running Xcode) as the device.": {
      "zh": "",
      "tips": ""
    },
    "Run the app": {
      "zh": "",
      "tips": ""
    },
    "Click the Run button in the toolbar or choose Product > Run to build and run the app on the selected simulated or real device. View the status of the build in the activity area of the toolbar.": {
      "zh": "",
      "tips": ""
    },
    "If the build is successful, Xcode runs the app and opens a debugging session in the debug area. Use the controls in the debug area to step through your code, inspect variables, and interact with the debugger.": {
      "zh": "",
      "tips": ""
    },
    "If the build is unsuccessful, click the indicators in the activity area to read the error or warning messages in the Issue navigator. Alternatively, choose View > Navigators > Show Issue Navigator to view the messages.": {
      "zh": "",
      "tips": ""
    },
    "When you’re done testing the app, click the Stop button in the toolbar.": {
      "zh": "",
      "tips": ""
    },
    "Interact with the simulated environment": {
      "zh": "",
      "tips": ""
    },
    "If you choose a simulated device as the run destination, Simulator launches and displays a window that corresponds to the simulated environment. For some devices, Simulator surrounds the screen content with a shell that resembles the target device. In visionOS, it displays a synthetic space to mimic the experience someone would have when they wear the device.": {
      "zh": "",
      "tips": ""
    },
    "Each device shell and space has specific controls to support interactions. For device-specific details, see the reference on interactions.": {
      "zh": "",
      "tips": ""
    },
    "Interacting with your app in the iOS and iPadOS simulator": {
      "zh": "",
      "tips": ""
    },
    "Interacting with your app in the tvOS simulator": {
      "zh": "",
      "tips": ""
    },
    "Interacting with your app in the watchOS simulator": {
      "zh": "",
      "tips": ""
    },
    "Interacting with your app in the visionOS simulator": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/setting-up-access-to-arkit-data": {
    "Setting up access to ARKit data": {
      "zh": "",
      "tips": ""
    },
    "Check whether your app can use ARKit and respect people’s privacy.": {
      "zh": "",
      "tips": ""
    },
    "Overview": {
      "zh": "",
      "tips": ""
    },
    "In visionOS, ARKit can enable new kinds of experiences that leverage data such as hand tracking and world sensing. The system gates access to this kind of sensitive information. Because people can decline your app’s request to use ARKit data or revoke access later, you need to provide alternative ways to use your app and to handle cases where your app loses access to data.": {
      "zh": "",
      "tips": ""
    },
    "Add usage descriptions for ARKit data access": {
      "zh": "",
      "tips": ""
    },
    "People need to know why your app wants to access data from ARKit. Add the following keys to your app’s information property list to provide a user-facing usage description that explains how your app uses the data:": {
      "zh": "",
      "tips": ""
    },
    "Use this key if your app uses hand tracking.": {
      "zh": "",
      "tips": ""
    },
    "Use this key if your app uses image tracking, plane detection, or scene reconstruction.": {
      "zh": "",
      "tips": ""
    },
    "Note": {
      "zh": "",
      "tips": ""
    },
    "World tracking — unlike world sensing — doesn’t require authorization. For more information, see Tracking specific points in world space.": {
      "zh": "",
      "tips": ""
    },
    "Choose between up-front or as-needed authorization": {
      "zh": "",
      "tips": ""
    },
    "You can choose when someone sees an authorization request to use ARKit data. If you need precise control over when the request appears, call the requestAuthorization(for:) method on ARKitSession to explicitly authorize access at the time you call it. Otherwise, people see an authorization request when you call the run(_:) method. This is an implicit authorization because the timing of the request depends entirely on when you start the session.": {
      "zh": "",
      "tips": ""
    },
    "Open a space and run a session": {
      "zh": "",
      "tips": ""
    },
    "To help protect people’s privacy, ARKit data is available only when your app presents a Full Space and other apps are hidden. Present one of these space styles before calling the run(_:) method.": {
      "zh": "",
      "tips": ""
    },
    "The following shows an app structure that’s set up to use a space with ARKit:": {
      "zh": "",
      "tips": ""
    },
    "Call openImmersiveSpace from your app’s user interface to create a space, start running an ARKit session, and kick off an immersive experience. The following shows a simple view with a button that opens the space:": {
      "zh": "",
      "tips": ""
    },
    "Provide alternatives for declined and revoked authorizations": {
      "zh": "",
      "tips": ""
    },
    "Someone might not want to give your app access to data from ARKit, or they might choose to revoke that access later in Settings. Handle these situations gracefully, and remove or transition content that depends on ARKit data. For example, you might fade out content that you need to remove, or recenter content to an appropriate starting position. If your app uses ARKit data to place content in a person’s surroundings, consider letting people place content using the system-provided interface.": {
      "zh": "",
      "tips": ""
    },
    "Providing alternatives is especially important if you’re using ARKit for user input. People using accessibility features, trackpads, keyboards, or other forms of input might need a way to use your app without ARKit.": {
      "zh": "",
      "tips": ""
    }
  },
  "visionos/swift-splash": {
    "Swift Splash": {
      "zh": "Swift Splash",
      "tips": ""
    },
    "Use RealityKit to create an interactive ride in visionOS.": {
      "zh": "使用 RealityKit 在 visionOS 中搭建一个交互式的水上游乐设施。",
      "tips": ""
    },
    "Overview": {
      "zh": "概览",
      "tips": ""
    },
    "Apple Vision Pro’s ability to combine virtual content seamlessly with the real world allows for many kinds of interactive virtual experiences. Swift Splash leverages RealityKit and Reality Composer Pro to create a virtual water slide by combining modular slide pieces. When the builder finishes their ride, they can release an adventurous goldfish to try it out.": {
      "zh": "Apple Vision Pro 能够将虚拟内容和现实世界无缝结合，从而为诸多类型的虚拟交互体验提供可能。Swift Splash 使用 RealityKit 和 Reality Composer Pro 来构建一个由模块化的滑道部件组成的虚拟水上滑梯。而当建造者完成了他们的游乐设施，就能够释放一只勇于冒险的小金鱼去体验他们的作品。",
      "tips": ""
    },
    "Swift Splash uses multiple Reality Composer Scenes to create prepackaged entity hierarchies that represent each of the slide pieces the player connects to construct their ride. It demonstrates how to hide and reveal sections of the entity hierarchy based on the current state of the app. For example, each slide piece contains an animated fish entity that’s hidden until the ride runs and the fish arrives at that particular piece. While Swift Splash is a fun, game-like experience, the core idea of assembling virtual objects out of predefined parts can also be used as the basis for a productivity or creation app.": {
      "zh": "Swift Splash 使用多个 Reality Composer 场景形成预设的实体层次结构，这些结构代表了玩家在构筑游乐设施过程中所需要衔接的每一块滑道部件。它示范了如何依照应用的当前状态去隐藏和展示实体层次结构的部分。举个例子来说，每一片滑道部件包含了一条会游动但隐藏着的鱼，直至启动整个游乐设施装置且小鱼到达指定物件时才会被看到。尽管 Swift Splash 看上去提供了一种有趣的、类似游戏的体验，不过其本质利用预设部分来构造虚拟物件的核心思想也可以被用于生产力或是创造性应用的基础。",
      "tips": ""
    },
    "Swift Splash scenes include Shader Graph materials built in Reality Composer Pro to change the appearance of the ride at runtime. Each piece can be configured to display in one of three materials: metal, wood, or plastic. Other Shader Graph materials create special effects, such as the movement of the water and the flashing lights on the start and end pieces. Even particle effects are included in some of these prepackaged entities, such as the fireworks that play when the goldfish crosses the finish line.": {
      "zh": "Swift Splash 的场景囊括了在 Reality Composer Pro 中内建的 Shader Graph 材质，它们用于在运行时改变游乐设施的外观。每一块滑道部件都可以被设定用来展示三种不同材质中的某一种：金属、木质或塑料。其他风格的 Shader Graph 材质会创建特效，例如水的流动以及起点和终点物件上的闪光灯灯效。甚至其中的一些预设实体内还包含了粒子效果，比如当小金鱼抵达终点线时绽放的礼花。",
      "tips": ""
    },
    "Build slide pieces in Reality Composer Pro": {
      "zh": "在 Reality Composer Pro 中构建水上滑道部件",
      "tips": ""
    },
    "Slide pieces are the building blocks of Swift Splash. The Reality Composer project contains a separate scene for each one. In addition to the 3D models that make up the slide piece, each scene contains a number of other entities the app uses to animate and place the slide piece.": {
      "zh": "滑道部件是构建 Swift Splash 项目的基础模块。Reality Composer 为每一个物件元素提供了独立的编辑场景。除了组成滑梯的 3D 模型以外，每一个场景还包含了若干个在程序中用于对滑道部件进行动画和定位的其他实体。",
      "tips": ""
    },
    "In the hierarchy viewer on the left side of the screenshot above, there are two transform entities called connect_in and connect_out. These transforms mark the points where the slide piece connects to the next or previous piece. Swift Splash uses these transforms to place new pieces at the end of the existing slide, as well as to snap pieces to other slide pieces when you manually move them near each other.": {
      "zh": "在上方屏幕截图左侧的层级检视面板中，有两个被称作 connect_in 和 connect_out 的变换节点。这两个变换节点会对滑道部件的前后连接做出标记。Swift Splash 就是利用了这些节点从而将新的滑道部件对接到现有内容的末端，也可通过手动移动滑道部件并靠近其他物件的方式将它们吸附在一起。",
      "tips": ""
    },
    "Slide pieces demonstrate the two primary mechanisms Swift Splash uses to find entities at runtime. For some entities, such as connect_in, Swift Splash uses a naming convention and retrieves the entities by name or suffix when it needs to use them. In other cases, such as when names aren’t unique or the retrieving code needs configuration values, Swift Splash uses a custom component to mark and retrieve entities.": {
      "zh": "这个滑道部件窗口展示了在 Swift Splash 中通过运行时去查找实体的两种主要机制。对于一些实体来说，例如 connect_in，Swift Splash 会借助命名规则并在需要使用这些实体时通过匹配名称或后缀来获取它们。在其他场景下，例如名称不唯一或者必须通过配置值取得实体时，Swift Splash 会使用自定义组件来对实体进行标记和检索。",
      "tips": ""
    },
    "For example, animated entities that appear when the ride runs contain a component called RideAnimationComponent. The app uses this component to determine if the entity is an animation that plays while the ride is running. The component also stores additional state the app needs to implement the ride animation, such as a property called duration that specifies when to start the animations on the next connected slide piece.": {
      "zh": "举例来说，当游乐设施运行起来后出现的动画实体会包含一个名为 RideAnimationComponent 的组件。程序借助这个组件来判断这个实体是否为设施在运行状态下播放的动画。该组件还负责存储这个程序实现游乐设施动画所需要的额外状态信息，比如名为 duration 的属性，它用于明确何时去启动下一个已经连接的滑梯组件上的动画。",
      "tips": ""
    },
    "RideAnimationComponent also includes a property called isPersistent. Persistent ride animations stay visible at all times but only animate when the ride is running, such as the animated door on the start piece. Nonpersistent ride animations, such as the fish swimming through a slide piece, display only while the ride is running and the fish swims through that particular piece.": {
      "zh": "RideAnimationComponent 组件还有一个名为 isPersistent 的属性。持续的水上游乐设施动画内容是始终可见的，不过只有当设施在运行时才会去执行动画，像是在起点区块上通过动画打开的门。非持续的设施动画，例如小鱼在滑道内游过，只会在设施运行并且小鱼正在通过对应的滑道物件时才会显示出来。",
      "tips": ""
    },
    "Avoid duplicate materials with material references": {
      "zh": "通过材质引用避免重复的材质实例",
      "tips": ""
    },
    "Many of Swift Splash’s slide pieces use the same materials. For example, the shader graph material that changes pieces from metal to wood to plastic is shared by all but one of the slide pieces. To avoid having duplicate copies of each material, Swift Splash leverages USD material references to share materials between multiple entities in multiple scenes.": {
      "zh": "在 Swift Splash 中，许多滑道部件会使用相同的材质元素。举个例子，所有部件都共享着同一个能够将部件从金属转变成木质或是塑料的着色器图形材质。为了避免每一种材质都产生重复的副本，Swift Splash 借助 USD 材质引用特性，做到了在多个场景的多个实体之间共享材质。",
      "tips": "有关 USD（Universal Scene Description）的概述和定义：https://www.nvidia.cn/omniverse/usd/#:~:text=USD%20%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80,%E7%9A%84%E4%BB%BB%E4%BD%95%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E3%80%82"
    },
    "The Reality Composer Pro project contains a separate scene for each shared material, containing only that one material. Other track pieces create references to that material. If you change the original material, it affects all of the entities that reference it. For example, a scene called M_RainbowLights.usda contains the material M_RainbowLights, and both StartPiece.usda and EndPiece.usda reference that material.": {
      "zh": "Reality Composer Pro 工程中对每一个共享的材质都做了独立的场景设定，这个场景只包含了那一种材质。其他的轨道部件只会建立对这材质的引用。如果你尝试改变原始材质，就会影响所有引用了它的实体。例如，一个名为 M_RainbowLights.usda 的场景包含了 M_RainbowLights 的材质，而 StartPiece.usda 和 EndPiece.usda 两者都引用了这种材质。",
      "tips": ""
    },
    "Parallelize the asset load": {
      "zh": "并行化的资产加载",
      "tips": ""
    },
    "To maximize load speed and make the most efficient use of available compute resources, Swift Splash parallelizes loading scenes from the Reality Composer project using a TaskGroup. The app creates a separate Task for each of the scenes it needs to load.": {
      "zh": "为了尽可能提升加载速度以及最高效地运用可用的计算资源，Swift Splash 通过 TaskGroup 并行化地加载 Reality Composer 工程中的所有场景。程序会为需要加载资产的每一个场景创建一个独立的 Task。",
      "tips": ""
    },
    "The app then uses an async iterator to wait for and receive the results.": {
      "zh": "程序随后会使用异步迭代器来等待并接收加载结果。",
      "tips": ""
    },
    "For more information on task groups, see Concurrency in The Swift Programming Language.": {
      "zh": "有关任务组（task groups）的更多信息，详见 The Swift Programming Language 中的 Concurrency 相关内容。",
      "tips": ""
    },
    "Each of these loaded pieces acts as a template. When the player adds a new piece of that type, the app clones the piece loaded from Reality Composer Pro and adds the clone to the scene.": {
      "zh": "每一个已经加载的部件都会被看作是一个模板。当玩家在项目中添加了同类部件时，程序会从 Reality Composer Pro 中复制加载过的部件，然后将该部件添加到场景中。",
      "tips": ""
    },
    "Specify sort ordering for transparent entities": {
      "zh": "指定透明实体的排序顺序",
      "tips": ""
    },
    "When multiple entities have more than one overlapping, nonopaque material, RealityKit’s default depth-sorting can cause it to draw those entities in the wrong order. As a result, some entities may not be visible from certain angles or in certain positions relative to other transparent entities. The default depth sorting is based on the center of the entity’s bounding box, which may result in the incorrect drawing order when there are multiple overlapping materials with any amount of transparency. You can see an example of this by looking at the start piece in Reality Composer Pro, or by watching the video below.": {
      "zh": "当遇到多个实体产生超过一个重叠，并且存在非不透明的材质时，RealityKit 的默认深度排序可能会按照错误的顺序绘制这些实体内容。这就导致，从特定角度或是相对于其他透明实体的特定位置上看，有一部分实体可能无法被看到。默认深度排序的计算基于实体边界盒的中心点，当存在多个任何透明度的重叠材质时，可能会引发不正确的绘制顺序。你可以在 Reality Composer Pro 中查看起始部件，或观看下方的视频来了解示例的表现形式。",
      "tips": ""
    },
    "The following video demonstrates the problem. If the three boxes are the bounding boxes for three different transparent entities, and the small spheres are the box centers, the sphere that’s closest to the camera changes as the camera moves around the boxes, which changes the order that RealityKit’s default depth sorting algorithm draws them.": {
      "zh": "下方的视频演示了这个问题。假设这三个矩形框分别是三个不同的透明实体的边界盒，其中的圆形则代表着盒子的中心，当摄像机在矩形框周围移动时，距离摄像机最近的圆形就会改变，这就会影响 RealityKit 的默认深度排序算法绘制它们的顺序。",
      "tips": ""
    },
    "Swift Splash assigns a ModelSortGroupComponent to each of the transparent entities to manually specify the relative depth sorting. To fix the transparency issues in the start piece in the video above, Swift Splash instructs RealityKit to draw the opaque parts of the fish first, its transparent goggles second, the water third, the glass globe fourth, and the selection glow shell last. Swift Splash does this by assigning a ModelSortGroupComponent to each of the overlapping entities using the same ModelSortGroup, but with a different order specified.": {
      "zh": "Swift Splash 会为每一个透明实体关联一个 ModalSortGroupComponent 组件，用于手动去指定相对的深度排序。为了修正上方视频中起始部件的透明度问题，Swift Splash 会命令 RealityKit 首先去绘制鱼的不透明部分，再者是透明的护目镜，第三是水，第四是玻璃球，把选中发光的外壳作为最后的绘制物件。Swift Splash 通过使用相同的但制定了不同顺序的 ModelSortGroup，并为每一个重叠实体关联 ModelSortGroupComponent 组件来实现这一点。",
      "tips": ""
    },
    "Traverse connected track pieces": {
      "zh": "逐个操作连接的轨道部件",
      "tips": ""
    },
    "The root entity for all of the individual slide pieces has a ConnectableComponent. This custom component marks the entity as one that can be connected or snapped to other connectable entities. At runtime, the app adds a ConnectableStateComponent to each slide piece it adds. The component stores state information for the track piece that doesn’t need to be edited in Reality Composer Pro. Among the state information that this component stores is a reference to the next and previous piece.": {
      "zh": "所有独立的滑道部件的根实体都有一个 ConnectableComponent 组件。这个可自定义的组件会将实体标记为允许连接或者吸附到其他可连接的实体。在程序运行时，应用会为每一个添加的部件都新增一个 ConnectableStateComponent 组件。这个组件储存的轨道部件状态信息不需在 Reality Composer Pro 进行编辑修改。在这个组件存储的状态信息中也涵盖了前后部件的连接关系。",
      "tips": ""
    },
    "To iterate through the entire ride, ignoring any disconnected pieces, the app gets a reference to the start piece and then iterates until nextPiece is nil. This iteration, similar to iterating a linked list, repeats many times throughout the app. One example is the function that calculates the duration of the built ride by iterating through the individual pieces and adding up the duration of their animations.": {
      "zh": "要把整条游乐设施串联起来，略去未对接上的滑道部件，应用程序可以从起始部件获取一个引用，然后遍历直至没有后续部件。这种迭代，类似于遍历一条链表，会在应用中被重复运用很多次。一个例子就是计算已搭建的设施运行时长的函数，它通过遍历整轨上每条单独的部件并将它们执行动画的时长依次累加来完成计算。",
      "tips": ""
    },
    "Interact with the ride": {
      "zh": "体验游乐设施",
      "tips": ""
    },
    "To build and edit the ride, players interact with Swift Splash in two different ways. They interact with SwiftUI windows to perform certain tasks, such as adding a new piece or deleting an existing piece of the ride. They also manipulate slide pieces using standard visionOS gestures, including taps, double taps, drags, and rotates. The player taps on a piece to select or deselect it. When a player double taps a piece, they select that piece without deselecting any other selected pieces. When someone drags a piece, it moves around the immsersive space, snapping together with other pieces if placed near one. A two-finger rotate gesture spins the selected track piece or pieces on the Z-axis.": {
      "zh": "有两种不同的方式可供玩家在 Swift Splash 中进行交互来构建和编辑游乐设施。他们可以通过 SwiftUI 窗口完成特定的操作，例如新增一段新滑道，或是移除一段已经添加到设施中的滑道部件。玩家还可利用 visionOS 支持的标准手势来操作部件，包括点按、双击、拖动和旋转。玩家点击部件以选择或取消选择它。当玩家双击部件时，他们会选择该部件，而不会取消选中的其他部件。当有人去拖移部件时，它会在沉浸式空间中移动，如果和另一个部件靠得足够近，它们就会自动吸附在一起。使用两指旋转手势会让选中的轨道部件或所有部件沿着 Z 轴进行旋转。",
      "tips": ""
    },
    "Swift Splash handles all of these interactions using standard SwiftUI gestures targeted to an entity. To support any of these gestures at any time, the app declares them using SimultaneousGesture. The code for all of the gestures are contained in TrackBuildingView, which controls the app’s immersive space. Here’s how the app defines the rotation gesture:": {
      "zh": "Swift Splash 在目标实体上采用标准的 SwiftUI 手势去处理其所有的交互操作。为了能随时给任意手势提供支持，应用内使用 SimultaneousGesture 来进行声明。所有的手势代码都包含在 TrackBuildingView 中，这个视图管理着应用内的沉浸式空间。以下是在应用中定义旋转手势的代码：",
      "tips": ""
    },
    "Because multiple tap gestures on the same RealityView execute with a different number of taps, multiple gestures may be called at once. If a player double taps an entity, for example, both the single tap and the double tap gesture code get called, and the app has to determine which one to execute. Swift Splash makes this determination by using a Boolean state variable. If a player single taps, it sets that variable — called shouldSingleTap — to true. Then it waits for a period of time before executing the rest of its code. If shouldSingleTap gets set to false while it’s waiting, the code doesn’t execute. When SwiftSplash detects a double tap gesture, it sets shouldSingleTap to false, preventing the single-tap code from firing when it executes the double-tap code.": {
      "zh": "因为在相同的 RealityView 上执行的多次点按手势可能带有不同的点击次数，多种手势可能会同时被响应。举个例子来说，如果玩家对一个实体进行双击操作，实际上单击和双击的手势代码都会被调用，最终执行的手势由程序决定。Swift Splash 通过一个布尔状态变量来做这个决定。如果玩家单击了，程序会将此变量（叫做 shouldSingleTap）设置为 true。然后程序会等待一段时间再去执行后续的代码。如果在等待阶段 shouldSingleTap 被设定为 false，那么代码就不会被执行。当 Swift Splash 检测到一个双击手势，它会将 shouldSingleTap 设置为 false，以避免在执行双击代码时触发单击代码。",
      "tips": ""
    }
  },
  "visionos/tracking-images-in-3d-space": {
    "Tracking preregistered images in 3D space": {
      "zh": "在三维空间中追踪预登记图像",
      "tips": ""
    },
    "Place content based on the current position of a known image in a person’s surroundings.": {
      "zh": "根据已知图像的当前位置在用户周围放置内容。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "Use ARKit’s support for tracking 2D images to place 3D content in a space. ARKit provides updates to the image’s location as it moves relative to the person. If you supply one or more reference images in your app’s asset catalog, people can use a real-world copy of that image to place virtual 3D content in your app. For example, if you design a pack of custom playing cards and provide those assets to people in the form of a real-world deck of playing cards, they can place unique content per card in a fully immersive experience.": {
      "zh": "使用 ARKit 对二维图像的追踪支持，在空间中放置三维内容。当图像相对于用户移动时，ARKit 会提供图像位置的更新。如果你在应用的资源目录中提供了一张或多张参考图片，用户就可以使用该图像的真实副本在应用中放置虚拟的三维内容。例如，如果你设计了一副定制纸牌,并以真实的纸牌包的形式将这些资源提供给用户，他们就可以在完全沉浸式的体验中为每张牌添加独特的内容。",
      "tips": "这一段的纸牌例子可能有点难理解，可以想象一下哈利波特电影中出现的报纸上会动的照片。"
    },
    "The following example tracks a set of images loaded from an app’s asset catalog:": {
      "zh": "下面的代码展示了如何追踪从应用资源目录中加载的一组图像：",
      "tips": ""
    },
    "If you know the real-world dimensions of the images you’re tracking, use the physicalSize property to improve tracking accuracy. The estimatedScaleFactor property provides information about how the scale of the tracked image differs from the expected physical size you provide.": {
      "zh": "如果你知道所追踪图像的实际尺寸，可使用 physicalSize 属性来提高追踪精度。estimatedScaleFactor 属性提供了追踪图像的实际尺寸与你预期的物理尺寸之间的差异信息。",
      "tips": ""
    }
  },
  "visionos/tracking-points-in-world-space": {
    "Tracking specific points in world space": {
      "zh": "追踪世界空间中的特定点",
      "tips": ""
    },
    "Retrieve the position and orientation of anchors your app stores in ARKit.": {
      "zh": "检索应用在 ARKit 中存储锚点的位置和方向。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "Use world anchors along with an ARKit session’s WorldTrackingProvider to track points of interest in the world over time, as a person moves while wearing the device, and across device usage sessions. For example, someone might place a 3D object in a specific position on their desk and expect it to come back the next time they use the device.": {
      "zh": "将世界锚点与 ARKit 会话的 WorldTrackingProvider 结合使用，可以随着佩戴设备用户的移动，跨设备、跨会话地追踪你感兴趣的世界点。例如，用户可能会将一个 3D 物体放置在桌子的特定位置，并希望下次使用设备时它再次出现在同一位置。",
      "tips": ""
    },
    "ARKit keeps track of a unique identifier for each world anchor your app creates and automatically places those anchors back in the space when the person returns to your app in the same location. A world tracking provider also provides the position of the device the person is wearing.": {
      "zh": "ARKit 会为应用创建的每个世界锚点收录一个唯一标识符，当用户在同一地点返回你的应用时，ARKit 会自动将这些锚点放回空间。世界追踪提供程序还会提供用户佩戴设备的位置。",
      "tips": ""
    },
    "Start an ARKit session with world tracking": {
      "zh": "使用世界追踪启动 ARKit 会话",
      "tips": ""
    },
    "Use an ARKitSession configured for world tracking to start receiving updates on the world anchors your app places. The following shows updates to world anchors your app previously registered using the addAnchor(_:) method:": {
      "zh": "使用为世界追踪配置过的 ARKitSession 开始接收应用放置的世界锚点的更新。下面代码展示了应用之前使用方法 addAnchor(_:) 注册的世界锚点的更新：",
      "tips": ""
    },
    "Important": {
      "zh": "重要",
      "tips": ""
    },
    "If a person repositions the current space — for example, by holding down the Digital Crown — world anchor updates begin updating their position relative to the new world origin. For example, a world anchor placed on a table still reports information about the table’s position, but those positions are relative to the updated world origin.": {
      "zh": "如果用户重新定位当前空间（例如按住数码表冠），世界锚点更新将开始更新其相对于新世界原点的位置。例如，放置在桌子上的世界锚点仍会报告桌子的位置信息，但这些位置是相对于更新后的世界原点的。",
      "tips": ""
    },
    "Create and add world anchors": {
      "zh": "创建和添加世界锚点",
      "tips": ""
    },
    "You can create world anchors for any point of interest in your app’s world coordinate system once you’ve started a world tracking ARKit session. For example, you might track that a person placed an item at a particular offset from a desk in their space:": {
      "zh": "启动世界追踪 ARKit 会话后，你可以在应用的世界坐标系中为任何感兴趣的点创建世界锚点。例如，你可能会追踪到用户将某件物品放置在空间内距桌子有特定位移的某一位置：",
      "tips": ""
    },
    "Once you add a world anchor to your app’s tracking provider using the addAnchor(_:) method, the anchorUpdates sequence in the current session and future runs of your app provides updates to the current position of that new world anchor.": {
      "zh": "使用 addAnchor(_:) 方法将世界锚点添加到应用的追踪提供程序后，当前和未来运行的应用会话中的 anchorUpdates 序列会持续更新该新锚点的当前位置。",
      "tips": ""
    },
    "Persist world anchors across sessions": {
      "zh": "跨会话保留世界锚点",
      "tips": ""
    },
    "The only information ARKit persists about the world anchors in your app is their UUID — a WorldAnchor instance’s id property — and pose in a particular space. It’s your app’s responsibility to persist additional information, such as the meaning of each anchor. For example, you might save local data about a custom 3D lamp model that a person placed on their desk.": {
      "zh": "ARKit 保留的你应用中世界锚点的唯一信息是它们的 UUID（WorldAnchor 实例的 id 属性）以及在特定空间中的位置。你的应用负责保留其他信息，譬如每个锚点的含义。例如，你可以保存用户放在桌子上的自定义 3D 台灯模型的本地数据。",
      "tips": ""
    },
    "As a person moves from town-to-town or room-to-room, your app won’t receive all of the world anchor updates from each place someone used your app. Instead, the anchorUpdates sequence only provides world anchors for nearby objects.": {
      "zh": "当用户从一个城市移动到另一个城市或从一个房间移动到另一个房间时，应用不会从被使用过的每个地方接收所有的世界锚点更新。相反， anchorUpdates 序列仅为附近的物体提供世界锚点更新。",
      "tips": ""
    },
    "Track the device position in the world": {
      "zh": "追踪设备在世界中的位置",
      "tips": ""
    },
    "Use the Compositor Services framework and the WorldTrackingProvider class’s queryDeviceAnchor(atTimestamp:) method to get low-latency information about the current and future-predicted pose of the person’s device in world space. For more information, see Drawing fully immersive content using Metal.": {
      "zh": "使用 Compositor Services 框架和 WorldTrackingProvider 类的 queryDeviceAnchor(atTimestamp:) 方法在空间中获取有关用户设备当前和未来预测姿势的低延迟信息。更多信息，请参阅使用 Metal 绘制完全沉浸式内容。",
      "tips": ""
    }
  },
  "visionos/trimming_and_exporting_media_in_visionos": {
    "Trimming and exporting media in visionOS": {
      "zh": "在 visionOS 中剪辑和导出媒体",
      "tips": ""
    },
    "Display standard controls in your app to edit the timeline of the currently playing media.": {
      "zh": "在应用中显示标准控件，以编辑当前播放媒体的时间轴。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "You use AVPlayerViewController to present the system video-player interface in your visionOS app. In addition to its primary role, AVPlayerViewController can also provide a media-trimming experience similar to the interface of QuickTime Player in macOS, like that below.": {
      "zh": "你可以使用 AVPlayerViewController 在你的 visionOS 应用中显示系统默认的视频播放器界面。除了其主要作用外，AVPlayerViewController 还能提供类似于 macOS 中 QuickTime Player 界面的媒体剪辑体验，如下图所示。",
      "tips": ""
    },
    "When you enable this feature, people can specify a segment of the media timeline for display. This article describes how to adopt this feature in your app, and shows how to use AVFoundation to export the trimmed result.": {
      "zh": "启用此功能后，用户可以指定显示媒体时间轴的某个片段。本文将介绍如何在应用中采用这一功能，并说明如何使用 AVFoundation 导出剪辑后的结果。",
      "tips": ""
    },
    "Determine whether the media supports trimming": {
      "zh": "确定媒体是否支持剪辑",
      "tips": ""
    },
    "Apps typically provide a user-interface element to put the player view controller into trimming mode. Because the player doesn’t support trimming certain media, such as HTTP Live Streaming or protected content, apps observe the state of the canBeginTrimming property to update the enabled state of their user interface accordingly. For example, the following code observes the state of the canBeginTrimming property and updates the state of a published property, which sets the appropriate enabled state in the UI:": {
      "zh": "应用通常会提供一个 UI 元素，让播放器视图控制器进入剪辑模式。由于播放器不支持剪辑某些媒体，如 HTTP 实时流媒体或受保护的内容，因此应用会观察 canBeginTrimming 属性的状态，并相应地更新用户界面的启用状态。例如，以下代码会观察 canBeginTrimming 属性的状态，并更新已发布属性的状态，从而在 UI 中设置相应的启用状态：",
      "tips": ""
    },
    "Enable the trimming user interface": {
      "zh": "启用剪辑用户界面",
      "tips": ""
    },
    "After you determine that the player view controller supports editing the current media’s timeline, call the player’s beginTrimming(completionHandler:) method to enable its trimming interface. Call this method from an asynchronous context:": {
      "zh": "确定播放器视图控制器支持编辑当前媒体的时间轴后，调用播放器的 beginTrimming(completionHandler:) 方法启用其剪辑界面。你需要在异步上下文中调用此方法：",
      "tips": ""
    },
    "This method returns a Boolean value that indicates whether the user pinched the Done button or the Cancel button. Pinching the Done button causes the view controller to update the values of the player item’s reversePlaybackEndTime and forwardPlaybackEndTime properties to match the trimmed selection.": {
      "zh": "此方法返回一个布尔值，表示用户是按了 \"完成 \"按钮还是 \"取消 \"按钮。按下 \"完成 \"按钮会导致视图控制器更新播放器项目的 reversePlaybackEndTime 和 forwardPlaybackEndTime 属性值，使其与剪辑后的选区相匹配。",
      "tips": ""
    },
    "Export the trimmed media selection": {
      "zh": "导出剪辑后的媒体选区",
      "tips": ""
    },
    "A convenient way to export your trimmed selection is to use AVAssetExportSession. This object provides a simple preset-based approach to transcode media in various formats. Create an instance of an export session by passing it the player item’s asset and an export preset. Additionally, configure its output URL and file type:": {
      "zh": "使用 AVAssetExportSession 是导出剪辑后选区的便捷方法。该对象提供了一种基于预设的简单方法，可对各种格式的媒体进行转码。通过传入播放器项目的素材和导出预设，来创建一个导出会话的实例。此外，还要配置其输出 URL 和文件类型：",
      "tips": ""
    },
    "To export only the portion of the asset that matches your trimmed selection, create a CMTimeRange based on the reverse and forward playback end times of the current player item:": {
      "zh": "要只导出与剪辑选区匹配的素材部分，可根据当前播放器项目的反向和正向播完时间创建一个 CMTimeRange:",
      "tips": ""
    },
    "Finally, begin the export operation to begin asynchronously transcoding the media to the output URL:": {
      "zh": "最后，开始导出操作，将媒体异步转码到输出 URL：",
      "tips": ""
    }
  },
  "visionos/understanding-the-realitykit-modular-architecture": {
    "Understanding RealityKit’s modular architecture": {
      "zh": "了解 RealityKit 的模块化架构",
      "tips": ""
    },
    "Learn how everything fits together in RealityKit.": {
      "zh": "了解如何在 RealityKit 中将一切组合在一起。",
      "tips": ""
    },
    "Overview": {
      "zh": "概览",
      "tips": ""
    },
    "RealityKit is a 3D framework designed for building apps, games, and other immersive experiences. Although it’s built in an object-oriented language and uses object-oriented design principles, RealityKit’s architecture avoids heavy use of composition — where objects are built by adding instance variables that hold references to other objects — in favor of a modular design based on a paradigm called Entity Component System (ECS) that divides application objects into one of three types.": {
      "zh": "RealityKit 是专为构建应用程序、游戏和其他沉浸式体验而设计的 3D 框架。虽然，它是使用面向对象的编程语言和设计原则，但是 RealityKit 采用了 “实体-组件-系统” 架构范式，将应用程序中对象分为 “实体 Entity ”，“组件 Component ”，”系统 System “三种，从而避免“组合模式”的繁重设计——通过添加实例变量来持有其他对象引用从而构建对象。",
      "tips": "译者注：本文中的“系统”，除非特别指明 VisionOS ，否则默认是 ECS 中的“系统 System ”，下面“创建系统以执行实体行为”小节会做详细介绍“系统”； Entity Component System ( ECS ), “实体-组件-系统”是一种软件体系结构模式，主要用于视频游戏开发中，用于表示游戏世界对象。ECS包括由数据组件组成的实体，以及在实体组件上运行的系统。ECS遵循组合优于继承的原则，这意味着每个实体不是由类型层次结构定义的，而是由与其关联的组件定义的。系统对具有所需组件的所有实体进行全局操作。"
    },
    "Following the ECS paradigm allows you to re-use the functionality contained in a component in many different entities, even if they have very different inheritance chains. Even if two objects have no common ancestors other than Entity, you can add the same components to both of them and give them the same behavior or functionality.": {
      "zh": "遵循 ECS 范式可以在有着各不相同的继承链的实体之间中重用同一个组件中的功能。又或者是在除了 Entity 之外没有共同祖先的两个对象中添加同一组件，以赋予它们相同的“行为”或“功能”。",
      "tips": ""
    },
    "Start with Entities": {
      "zh": "从实体开始",
      "tips": ""
    },
    "Entities are the core actors of RealityKit. Any object that you can put into a scene, whether visible or not, is an entity and must be a descendent of Entity. Entities can be 3D models, shape primitives, lights, or even invisible items like sound emitters or trigger volumes. Add components to entities to let them store additional state relevant to a specific type of functionality. Entities themselves contain relatively few properties: Nearly all entity state is stored on an entity’s components.": {
      "zh": "实体在 RealityKit 中扮演核心角色。在场景中的任何一个对象都是 Entity 的后代，不论对象是否可见。实体可以是3D模型，几何图元，光线，又或者像是发声器（ sound emitters ）和立体触发器（ trigger volumes ）这种隐形的存在。在实体中添加组件以使组件能够存储与特定类型功能相关的附加状态。实体自身包含相对较少的状态属性：几乎所有的实体状态都存储在实体的组件中。",
      "tips": "shape primitives ，几何图元，在构造实体几何中，图元是简单的几何形状，例如立方体，圆柱体，球体，圆锥体，棱锥，圆环； trigger volumes ，立体触发器。是游戏开发中常用的一种机制，用于检测游戏中的物体或角色是否进入或离开某个特定区域。当物体或角色与触发器相交时，可以触发特定的事件或行为。也可以检测物体之间的碰撞，并进行相应的处理，比如计算伤害、改变生命值等。"
    },
    "RealityKit provides a number of entity types you use to represent different kinds of objects. For example, a ModelEntity represents a 3D model, such as one imported from a .usdz or .reality file. These provided entities are essentially just an Entity with certain components already added to them. Adding a ModelComponent to an instance of Entity, for example, results in an entity with identical functionality to a ModelEntity.": {
      "zh": "RealityKit 提供了一些实体类型来代表不同种类的对象。例如，ModelEntity 代表从 .usdz 或者是 .reality 文件导入的 3D 模型。RealityKit 提供的这些实体基本上是已经有了特定类型组件的 Entity 。例如，在 Entity 的实例中添加 ModelComponent 组件，这个“实体”就会有和 ModelEntity 类型的实体相拥完全的功能。",
      "tips": ""
    },
    "Add components to entities": {
      "zh": "在实体添加组件",
      "tips": ""
    },
    "Components are modular building blocks that you add to an entity; they identify which entities a system will act on, and maintain the per-entity state that systems rely on. Components can contain logic, but limit component logic to code that validates its property values or sets its initial state. Use systems for any logic that affects the behavior of entities or that potentially changes their state on every frame. To add accessibility information to an entity, for example, add a AccessibilityComponent to it and populate its fields with the information the accessibility system needs, such as putting the description that VoiceOver reads into its label property.": {
      "zh": "组件是添加到实体中的模块化构建的代码块；系统通过组件确定对哪些实体进行操作，组件同时维护系统依赖的每个实体的状态。组件只能包含验证属性值或者设置初始化状态的逻辑代码。系统是用来管理影响实体行为或者每一帧状态潜在变化的逻辑代码。为实体添加可访问性的信息，例如，向其添加 AccessibilityComponent 组件，同时根据系统需要访问的信息设置组件的相应字段，比如 VoiceOver 会读取它的 label 属性所包含的描述信息（“它的 label 属性”指的 AccessibilityComponent 的 label 属性）。",
      "tips": "译者注：这段原文是突出介绍“组件 Component”的，但读起来有点绕，例如：“ they identify which entities a system will act on ”，“  they ”指的是组件，我把这句话的主谓宾换了位置翻译为：“系统通过组件确定对哪些实体进行操作”。这样翻译是因为通过阅读官方时例子代码理解下来：系统（ System ）是通过组件（ Component ）识别和操作实体（ Entity ）。"
    },
    "Keep in mind that an entity can only hold one copy of any particular type of component at a time. So, for example, you can’t add two accessibility components to one entity. If you add an accessibility component to an entity that already has one, the new component replaces the previous one.": {
      "zh": "请记住，一个实体一次只能持有某种特定类型组件的一个副本。例如，不能在同一个实体中添加两个可访问性组件  AccessibilityComponent 。如果实体已经添加了一个可访问性组件，新添加的会取代之前添加的。",
      "tips": ""
    },
    "Create systems to implement entity behavior": {
      "zh": "创建系统以执行实体行为",
      "tips": ""
    },
    "A System contains code that RealityKit calls on every frame to implement a specific type of entity behavior or to update a particular type of entity state. Systems use components to store their entity-specific state and query for entities to act on by looking for ones with a specific component or combination of components.": {
      "zh": "系统包含实现特定类型实体的行为，或者更新特殊类型实体的状态的代码，而 RealityKit 会在每帧调用“系统”的代码。系统使用组件存储实体特定状态，同时可以通过某种类型组件或者多种类型组件组合查询需要进行操作的实体。",
      "tips": ""
    },
    "For example, a game might have a damage system that monitors and updates the health of every entity that can be damaged or destroyed. Systems typically work together with one or more components, so that damage system might use a health component to keep track of how much damage each entity has taken and how much each one is able to take before it’s destroyed. It might also interact with other components. For example, an entity might have an armor component that provides protection to the entity, and the damage system would also need to use the state stored in that component.": {
      "zh": "例如，游戏可以通过伤害系统监听和更新实体生命值，这样实体就可以被伤害或者被毁灭。系统会通常操作一个或多个组件，所以伤害系统通过生命值组件 记录每个实体受到的伤害值，以及每个实体在被毁灭之前还能承受多少伤害。系统也会和其他的组件交互。比如，实体也可以有保护作用的盔甲组件，这时伤害系统也会去使用该组件存储的状态值。",
      "tips": ""
    },
    "Every frame, the damage system queries for entities that have the health component and updates values on those entities’ components based on the current state of the app. If an entity has taken too much damage, the system might trigger a specific animation or remove the entity from the scene.": {
      "zh": "每帧刷新时，伤害系统 会查询有生命值组件的实体，并根据App当前的状态更新这些实体的组件。如果实体受到了过大的伤害，系统就会执行特殊的动画，或者将实体从场景中移除。",
      "tips": ""
    },
    "Writing entity logic in a system avoids duplication of work. Using traditional OOP design patterns, where this type of logic would reside on the entity class, can often result in the same calculations being performed multiple times, once for every entity potentially affected. No matter how many entities the calculation potentially impacts the system only has to do the calculation once.": {
      "zh": "采用传统的面向对象程序设计模式，实体类会包含逻辑代码，这样会导致同样的计算被多次执行，因为每个可能会受到伤害的实体都要执行一次。而在系统中编写实体逻辑可以避免重复性的工作。不管有多少个实体需要计算伤害，只需要系统执行一次计算即可。",
      "tips": ""
    },
    "For more information on creating systems, see Implementing systems for entities in a scene": {
      "zh": "想了解更多关于系统创建的信息，请参照 Implementing systems for entities in a scene 。",
      "tips": ""
    }
  },
  "visionos/visionos": {
    "visionOS": {
      "zh": "visionOS",
      "tips": ""
    },
    "Create a new universe of apps and games for Apple Vision Pro.": {
      "zh": "为 Apple Vision Pro 打造全新的应用和游戏世界。",
      "tips": ""
    },
    "Overview": {
      "zh": "概览",
      "tips": ""
    },
    "visionOS is the operating system that powers Apple Vision Pro. Use visionOS together with familiar tools and technologies to build immersive apps and games for spatial computing.": {
      "zh": "visionOS 是为 Apple Vision Pro 提供支持的操作系统。将 visionOS 与熟悉的工具和技术结合使用，可为空间计算打造沉浸式的应用和游戏。",
      "tips": ""
    },
    "Developing for visionOS requires a Mac with Apple silicon. Create new apps using SwiftUI to take full advantage of the spectrum of immersion available in visionOS. If you have an existing iPad or iPhone app, add the visionOS destination to your app’s target to gain access to the standard system appearance, and add platform-specific features to create a compelling experience. To provide continuous access to your content in the meantime, deliver a compatible version of your app that runs in visionOS.": {
      "zh": "为 visionOS 开发需要一台配备了苹果芯片的 Mac。使用 SwiftUI 创建新应用，从而充分利用 visionOS 提供的各种沉浸式体验。如果你已有 iPad 或 iPhone 应用，可将 visionOS 终端添加到应用的目标中以访问标准系统外观，并添加平台特定的功能以创建引人入胜的体验。同时为了用户能够无间断地访问你的内容，请提供能在 visionOS 中运行的兼容版本应用。",
      "tips": ""
    },
    "Expand your app into immersive spaces": {
      "zh": "将应用扩展到沉浸式空间",
      "tips": ""
    },
    "Start with a familiar window-based experience to introduce people to your content. From there, add SwiftUI scene types specific to visionOS, such as volumes and spaces. These scene types let you incorporate depth, 3D objects, and immersive experiences.": {
      "zh": "从熟悉的窗口式体验开始，引导用户了解你的内容。在此基础上，添加 visionOS 特有的 SwiftUI 场景类型，如体量和空间。这些场景类型可让你呈现深度、3D 物体和沉浸式的体验。",
      "tips": ""
    },
    "Build your app’s 3D content with RealityKit and Reality Composer Pro, and display it with a RealityView. In an immersive experience, use ARKit to integrate your content with the person’s surroundings.": {
      "zh": "使用 RealityKit 和 Reality Composer Pro 构建应用中的 3D 内容，并通过 RealityView 呈现它们。在沉浸式体验中，使用 ARKit 将应用内容与用户周围环境整合在一起。",
      "tips": ""
    },
    "Explore new kinds of interaction": {
      "zh": "探索新型交互方式",
      "tips": ""
    },
    "People can select an element by looking at it and tapping their fingers together. They can also pinch, drag, zoom, and rotate objects using specific hand gestures. SwiftUI provides built-in support for these standard gestures, so rely on them for most of your app’s input. When you want to go beyond the standard gestures, use ARKit to create custom gestures.": {
      "zh": "用户可以通过注视某个元素并轻点手指来选择该元素。他们还可以使用特定的手势来捏合、拖动、缩放和旋转对象。SwiftUI 提供了对这些标准手势的内置支持，因此你的应用的大部分输入都可以依靠它们。如果你想使用标准手势之外的手势，请使用 ARKit 创建自定义手势。",
      "tips": ""
    },
    "Dive into featured sample apps": {
      "zh": "深入了解精选示例应用",
      "tips": ""
    },
    "Explore the core concepts for all visionOS apps with Hello World. Understand how to detect custom gestures using ARKit with Happy Beam. Discover streaming 2D and stereoscopic media with Destination Video. And learn how to build 3D scenes with RealityKit and Reality Composer Pro with Diorama and Swift Splash.": {
      "zh": "通过“你好，世界”探索所有 visionOS 应用共通的核心概念。通过“快乐光束”了解如何使用 ARKit 检测自定义手势。通过“目的地视频”探索演示 2D 和立体媒体。通过“西洋镜”和“迅捷飞溅”学习如何使用 RealityKit 和 Reality Composer Pro 构建 3D 场景。",
      "tips": ""
    }
  },
  "visionos/world": {
    "Hello World": {
      "zh": "你好，世界 （Hello World）",
      "tips": ""
    },
    "Use windows, volumes, and immersive spaces to teach people about the Earth.": {
      "zh": "使用窗口、体量和沉浸式空间让用户了解地球。",
      "tips": ""
    },
    "Overview": {
      "zh": "概述",
      "tips": ""
    },
    "You can use visionOS scene types and styles to share information in fun and compelling ways. Features like volumes and immersive spaces let you put interactive virtual objects into people’s environments, or put people into a virtual environment.": {
      "zh": "您可以使用 visionOS 场景类型和样式，以有趣且引人入胜的方式传达信息。体量和沉浸式空间等功能可以让你将可交互的虚拟物体放入用户的环境中，或反之将用户置于虚拟环境中。",
      "tips": ""
    },
    "Hello World uses these tools to teach people about the Earth — the planet we call home. The app shows how the Earth’s tilt creates the seasons, how objects move as they orbit the Earth, and how Earth appears from space.": {
      "zh": "Hello World 使用了这些工具向用户介绍地球--这个我们称之为家的星球。该应用程序展示了地球的倾斜角如何形成季节，物体如何围绕地球运行，以及地球在太空中的样子。",
      "tips": ""
    },
    "The app uses SwiftUI to define its interface, including both 2D and 3D elements. To create, customize, and manage 3D models and effects, it also relies on the RealityKit framework and Reality Composer Pro.": {
      "zh": "该应用程序使用 SwiftUI 来制作其用户界面，其中包含了 2D 和 3D 元素。为了创建、自定义和管理 3D 模型和效果，它还依赖于 RealityKit 框架和 Reality Composer Pro。",
      "tips": ""
    },
    "Create an entry point into the app": {
      "zh": "创建应用的入口",
      "tips": ""
    },
    "Hello World constructs the scene that it displays at launch — the first scene that appears in the WorldApp structure — using a WindowGroup:": {
      "zh": "Hello World 使用了 WindowGroup 来构建启动时显示的场景（WorldApp 结构体中出现的第一个场景）：",
      "tips": ""
    },
    "Like other platforms — for example, macOS and iOS — visionOS displays a window group as a familiar-looking window. In visionOS, people can resize and move windows around the Shared Space. Even if your app offers a sophisticated 3D experience, a window is a great starting point for an app because it eases people into the experience. It’s also a good place to provide instructions or controls.": {
      "zh": "与其他平台（如 macOS 和 iOS）一样，visionOS 将窗口组显示为用户熟悉的窗口。在 visionOS 中，用户可以在共享空间中调整窗口大小并移动窗口。即使你的应用提供了复杂的 3D 体验，窗口也是应用的一个很好的起点，因为它可以让用户由浅入深地顺利进入体验。同时窗口也是提供说明或放置控件的理想位置。",
      "tips": ""
    },
    "Tip": {
      "zh": "提示",
      "tips": ""
    },
    "This particular window group uses the plain window style to maintain control over the glass background effect that visionOS would otherwise automatically add.": {
      "zh": "此窗口组使用了 plain 窗口样式以保持控件悬浮在毛玻璃背景上的效果。即使没有此行代码 visionOS 也会自动添加毛玻璃背景效果。",
      "tips": ""
    },
    "Present different modules using a navigation stack": {
      "zh": "使用导航栈展示不同的模块",
      "tips": ""
    },
    "After you watch a brief introductory animation that shows the text Hello World typing in, the Modules view that defines the primary scene’s content presents options to explore different aspects of the world. This view contains a table of contents at the root of a NavigationStack:": {
      "zh": "在观看键入文本 Hello World 的简短介绍动画后，定义主场景内容的 Modules 视图会显示多种探索世界的选项。此视图包含了一个导航栈 （NavigationStack），导航栈的根视图是一个目录：",
      "tips": ""
    },
    "A visionOS navigation stack has the same behavior that it has in other platforms. When it first appears, the stack displays its root view. When someone chooses an embedded NavigationLink, the stack draws a new view and displays a back button in the toolbar. When someone taps the back button, the stack restores the previous view.": {
      "zh": "visionOS 导航栈与其他平台的导航栈具有相同的行为。当它首次出现时，导航栈会显示其根视图。当用户点击内嵌的导航链接 （NavigationLink） 时，导航栈会绘制一个新视图并在工具栏中显示一个后退按钮。当用户点击后退按钮时，导航堆将恢复上一个视图。",
      "tips": ""
    },
    "The trailing closure of the navigationDestination(for:destination:) view modifier in the code above displays a view when someone activates a link based on a module input that comes from the corresponding link’s initializer:": {
      "zh": "上面代码中的 navigationDestination(for:destination:) 视图修饰符的尾部闭包，会根据链接初始化时传入的模块，在用户激活链接时显示相应的视图：",
      "tips": ""
    },
    "The possible module values come from a custom Module enumeration:": {
      "zh": "可选的模块值来源于自定义的 Module 枚举：",
      "tips": ""
    },
    "Display an interactive globe in a new scene": {
      "zh": "在新场景中显示可交互的地球仪",
      "tips": ""
    },
    "The globe module opens with a few facts about the Earth in the main window next to a decorative, flat image that supports the content. To help people understand even more, the module includes a button titled View Globe that opens a 3D interactive globe in a new window.": {
      "zh": "当地球仪（globe）模块打开时，主窗口中会显示一些有关地球的知识，旁边装饰着一个解释内容的平面图像。为了帮助用户更好地理解模块内容，该模块包含了一个名为“View Globe”的按钮，该按钮可在新窗口中打开一个三维交互式的地球仪。",
      "tips": ""
    },
    "To be able to open multiple scene types, Hello World includes the UIApplicationSceneManifest key in its Information Property List file. The value for this key is a dictionary that includes the UIApplicationSupportsMultipleScenes key with a value of true:": {
      "zh": "为了能够打开多种场景类型，Hello World 在其 Information Property List 文件中包含了 UIApplicationSceneManifest 键。该键的值是一个字典，其中包含了 UIApplicationSupportsMultipleScenes 键，且其值为：true",
      "tips": ""
    },
    "Declare a volumetric window for the globe": {
      "zh": "为地球仪定义一个三维窗口",
      "tips": ""
    },
    "With the key in place, the app makes use of a second WindowGroup in its App declaration. This new window group uses the Globe view as its content:": {
      "zh": "在上述键值就位后，应用程序就可以在其 App 声明中使用第二个 WindowGroup 了。这个新窗口组使用视图 Globe 作为其内容：",
      "tips": ""
    },
    "This window group creates a window that has arbitrary depth — great for displaying a 3D model in a bounded region that behaves like a transparent box — because Hello World uses the volumetric window style scene modifier. People can move this box around the Shared Space like any other window, and the content remains fixed inside. The defaultSize(width:height:depth:in:) modifier specifies a size for the window in meters, including a depth dimension.": {
      "zh": "由于 Hello World 使用了三维 （volumetric） 窗口样式场景修饰符，因此该窗口组创建了一个可自定义深度的窗口--非常适合在有边界的区域中显示三维模型，其行为就像一个透明的盒子。用户可以像移动任何其他窗口一样在共享空间中移动这个盒子，而里面的内容则保持不变。defaultSize(width:height:depth:in:) 修饰符用来指定窗口的（包含深度的）大小（以米为单位）。",
      "tips": ""
    },
    "The Globe view contains 3D content, but is still just a SwiftUI view. It contains two elements in a ZStack: a subview that draws a model of the Earth, and another that provides a control panel that people can use to configure the model’s appearance.": {
      "zh": "该 Globe 视图虽然包含了 3D 内容，但其本身仍然只是一个 SwiftUI 视图。它的 ZStack 中包含了两个元素：一个绘制地球模型的子视图，另一个子视图负责提供控制面板，用户可以使用它来配置地球仪的外观。",
      "tips": ""
    },
    "Open and dismiss the globe window": {
      "zh": "打开和关闭地球仪窗口",
      "tips": ""
    },
    "The globe module presents a View Globe button that people can tap to display the volumetric window or dismiss the window, depending on the current state. Hello World achieves this behavior by creating a Toggle with the button style, and embedding it in a custom GlobeToggle view.": {
      "zh": "地球仪模块显示了一个 View Globe 按钮。当用户点击该按钮后，系统会根据当前状态来显示三维窗口或关闭窗口。Hello World 通过创建一个按钮样式的 Toggle，并将其嵌入到自定义 GlobeToggle 视图中来实现这一功能。",
      "tips": ""
    },
    "When someone taps the toggle, the isShowingGlobe state changes, and the onChange(of:initial:_:) modifier calls the openWindow or dismissWindow action to open or dismiss the window, respectively. The view gets these actions from the environment and uses an identifier that matches the window’s identifier.": {
      "zh": "当用户点击切换按钮时，isShowingGlobe 状态会发生变化， 且 onChange(of:initial:_:) 修饰符会分别调用 openWindow 或 dismissWindow 操作来打开或关闭窗口。视图从环境变量中获取这些操作，并使用对应的窗口标识符来运行操作。",
      "tips": ""
    },
    "Display objects that orbit the Earth": {
      "zh": "显示绕地球运行的物体",
      "tips": ""
    },
    "You use windows in visionOS the same way you do in other platforms. But windows in visionOS provide a small amount of depth you can use to create 3D effects — like elements that appear in front of other elements. Hello World takes advantage of this depth to present small models inline with 2D content.": {
      "zh": "在 visionOS 中使用窗口的方式与其他平台相同。但是，visionOS 中的窗口提供了可用于创建 3D 效果的少量深度--比如显示在其他元素前方的元素。Hello World 利用这种深度来在 2D 内容的行间展示小的 3D 模型。",
      "tips": ""
    },
    "The app’s second module, Objects in Orbit, provides information about objects that go around the Earth, like the Moon and artificial satellites. To give a sense of what these objects look like, the module displays 3D models of these items directly inside the window.": {
      "zh": "应用的第二个模块，“轨道上的物体”（Objects in Orbit）提供了月球和人造卫星等绕地球飞行的物体的信息。为了让用户了解这些对象的外观，该模块直接在窗口内显示这些对象的 3D 模型。",
      "tips": ""
    },
    "Hello World loads these models from the asset bundle using a Model3D structure inside a custom ItemView. The view scales and positions the model to fit the available space, and applies optional orientation adjustments:": {
      "zh": "Hello World 在自定义的 ItemView 中使用 Model3D 结构体从资源包里加载这些模型。视图会根据可用空间对模型进行缩放和定位，并视情况调整角度：",
      "tips": ""
    },
    "The app uses this ItemView once for each model, placing each in an overlay that only becomes visible based on the current selection. For example, the following overlay displays the satellite model with a small amount of tilt in the x-axis and z-axis:": {
      "zh": "该应用为每个模型都创建了上述的 ItemView，并将它们放在一个叠加层中， 且只有当前被选中的模型会显示出来。例如，下述的叠加层显示了一个在 x 轴和 z 轴上有稍微倾斜卫星模型：",
      "tips": ""
    },
    "The VStack that contains the models also contains a Picker that people use to select a model to view:": {
      "zh": "包含上述模型的 VStack 中还包含了一个 Picker，用来选择查看的模型：",
      "tips": ""
    },
    "When you add 3D effects to a 2D window, keep this guidance in mind:": {
      "zh": "当你向 2D 窗口添加 3D 效果时，请牢记以下几点：",
      "tips": ""
    },
    "Don’t overdo it. These kinds of effects add interest, but can unintentionally obscure important controls or information as people view the window from different directions.": {
      "zh": "不要过度使用。这种类型的效果虽然增加了趣味性，但当用户从不同方向查看窗口时，这些效果有可能会无意中遮挡重要控件或信息。",
      "tips": ""
    },
    "Ensure that elements don’t exceed the available depth. Excess depth causes elements to clip. Account for any position or orientation changes that might occur after initial placement.": {
      "zh": "确保元素不超出可用深度。过大的深度会导致元素被剪切。要考虑到初始放置后可能发生的位置或角度变化。",
      "tips": ""
    },
    "Avoid models intersecting with the backing glass. Again, account for potential movement after initial placement.": {
      "zh": "避免模型与玻璃背景相交。再次强调，请考虑初始放置物体后可能发生的移动。",
      "tips": ""
    },
    "Show Earth’s relationship to its satellites in an immersive space": {
      "zh": "在沉浸式空间中展示地球与其卫星的关系",
      "tips": ""
    },
    "People can visualize how satellites move around the Earth because the app’s orbit module displays the Earth, the Moon, and a communications satellite together as a single system. People can move the system anywhere in their environment or resize it using standard gestures. They can also move themselves around the system to get different perspectives.": {
      "zh": "用户可以直观地看到卫星是如何围绕地球运动的，因为应用的轨道模块将地球、月球和一个通信卫星显示在同一个系统里。用户可以将该系统拖动到环境中的任何位置，或使用标准手势调整其大小。用户自己也可以在系统移动以获得不同的视角。",
      "tips": ""
    },
    "Note": {
      "zh": "备注",
      "tips": ""
    },
    "To learn about designing with gestures in visionOS, read Gestures in Human Interface Guidelines.": {
      "zh": "想了解如何在 visionOS 中使用手势进行设计，请阅读《用户界面指南》中的手势章节。",
      "tips": ""
    },
    "To create this visualization, the app displays the Orbit view — which contains a single RealityView that models the entire system — in an ImmersiveSpace scene with the mixed immersion style:": {
      "zh": "为创建这一效果，应用在 mix 沉浸风格的 ImmersiveSpace 场景中展示了 Orbit 视图--其中包含了一个模拟整套系统的 RealityView：",
      "tips": ""
    },
    "As with any secondary scene in a visionOS app, this scene depends on having the UIApplicationSupportsMultipleScenes key in the Information Property List file. The app also opens and closes the space using a toggle view that resembles the one used for the globe:": {
      "zh": "与 visionOS 应用中的所有辅助场景一样，此场景依赖于 Information Property List file 文件中的 UIApplicationSupportsMultipleScenes 键。同时，应用还使用了与地球仪模组中类似的开关按钮来打开和关闭空间：",
      "tips": ""
    },
    "There are a few key differences from the version that appears in the section Open and dismiss the globe window:": {
      "zh": "这里与“打开和关闭地球仪窗口”一节中的版本有几个主要区别：",
      "tips": ""
    },
    "OrbitToggle uses openImmersiveSpace and dismissImmersiveSpace from the environment, rather than the window equivalents.": {
      "zh": "OrbitToggle 使用了环境变量中的 openImmersiveSpace 和 dismissImmersiveSpace 沉浸式空间操作，而不是窗口操作。",
      "tips": ""
    },
    "The dismiss action in this case doesn’t require an identifier, because people can only open one space at a time, even across apps.": {
      "zh": "这时关闭操作不需要标识符，因为用户一次只能打开一个沉浸式空间，即使切换应用也是如此。",
      "tips": ""
    },
    "The open and dismiss actions for spaces operate asynchronously, and so they appear inside a Task.": {
      "zh": "打开和关闭空间操作是异步的，因此它们的使用出现在 Task 闭包中。",
      "tips": ""
    },
    "View the solar system from space using full immersion": {
      "zh": "使用完全沉浸式从太空观察太阳系",
      "tips": ""
    },
    "The app’s final module gives people a sense of the Earth’s place in the solar system. Like other modules, this one includes information and a decorative image next to a button that leads to another visualization — in this case so people can experience Earth from space.": {
      "zh": "应用的最后一个模块意在帮助用户了解地球在太阳系中的位置。与其他模块一样，这个模块包括了说明、装饰图像、及一个指向另一个场景的按钮--在本模块的场景中，用户可以从太空中观察地球。",
      "tips": ""
    },
    "When a person taps the button, the app takes over the entire display and shows stars in all directions. The Earth appears directly in front, the Moon to the right, and the Sun to the left. The main window also shows a small control panel that people can use to exit the fully immersive experience.": {
      "zh": "当用户点击按钮后，应用将接管整个显示屏，并在各个方位显示星星。地球出现在正前方，月球在右侧，太阳在左侧。主窗口还显示了一个小型控制面板，用户可以用它来退出完全沉浸式体验。",
      "tips": ""
    },
    "People can exit full immersion by pressing the device’s Digital Crown, but it’s typically useful when you provide a built-in mechanism to maintain control of the experience within your app.": {
      "zh": "用户可以按下设备的数码表冠来退出完全沉浸式体验，但通常情况下，在应用程序中提供一个内置机制来控制体验是非常有帮助的。",
      "tips": ""
    },
    "The app uses another immersive space scene for this module, but here with the full immersion style that turns off the passthrough video:": {
      "zh": "本模块使用了另一个沉浸式空间场景，但此处使用的是 full 沉浸风格，它会关闭设备的现实映射功能：",
      "tips": ""
    },
    "This scene depends on the same UIApplicationSupportsMultipleScenes key that other secondary scenes do, and is activated by a SolarSystemToggle that’s similar to the ones that the app uses for the other scenes:": {
      "zh": "与其他辅助场景相同，此场景也依赖于的 UIApplicationSupportsMultipleScenes 键，并由与其他场景中用的开关类似的 SolarSystemToggle 激活：",
      "tips": ""
    },
    "This control appears in the main window to provide a way to begin the fully immersive experience, and separately in the control panel as a way to exit the experience. Because the app uses this control as two distinct buttons rather than as a toggle in one location, it’s composed of a Button with behavior that changes depending on the app state rather than as a toggle with a button style.": {
      "zh": "此控件显示在主窗口中，以提供进入完全沉浸式体验的入口，同时又单独显示在控制面板中，作为退出体验的一种方式。由于应用在不同的两个位置将此控件用作按钮，而不是一个位置不变的开关，因此它是由一个根据应用状态而改变行为的 Button 构成的，而不是使用了按钮样式的 Toggle。",
      "tips": ""
    },
    "To reuse the main window for the solar system controls, Hello World places both the navigation stack and the controls in a ZStack, and then sets the opacity of each to ensure that only one appears at a time:": {
      "zh": "为了能在太阳系模块的控件中复用主窗口，Hello World 将导航栈和控件放在了一个 ZStack 中，然后通过设置每个控件的不透明度，确保每次只显示一个视图：",
      "tips": ""
    }
  }
}
{"Animating Shapes": {"zh": "åŠ¨ç”»å½¢çŠ¶", "tips": ""}, "Learn how to use shapes and simple animations in SwiftUI.": {"zh": "å­¦ä¹ å¦‚ä½•åœ¨ SwiftUI ä¸­ä½¿ç”¨å½¢çŠ¶å’Œç®€å•åŠ¨ç”»ã€‚", "tips": ""}, "First up, youâ€™ll learn to use the SwiftUI Shape protocol to create and modify shape views.": {"zh": "é¦–å…ˆï¼Œä½ å°†å­¦ä¹ ä½¿ç”¨ SwiftUI Shape åè®®æ¥åˆ›å»ºå’Œä¿®æ”¹å½¢çŠ¶è§†å›¾ã€‚", "tips": ""}, "Youâ€™ll learn the basics of animating views and how to create animations â€“ some easy, some more complex!": {"zh": "ä½ å°†å­¦ä¹ åŠ¨ç”»è§†å›¾çš„åŸºç¡€çŸ¥è¯†ä»¥åŠå¦‚ä½•åˆ›å»ºåŠ¨ç”» - æœ‰äº›ç®€å•ï¼Œæœ‰äº›æ›´å¤æ‚ï¼", "tips": ""}, "Heart Pulse": {"zh": "å¿ƒè„è„‰å†²", "tips": ""}, "Discover how to make a heart pulse in this basic animation.": {"zh": "æ¢ç´¢å¦‚ä½•åœ¨è¿™ä¸ªåŸºæœ¬åŠ¨ç”»ä¸­ä½¿å¿ƒè„è·³åŠ¨ã€‚", "tips": ""}, "Step 1": {"zh": "", "tips": ""}, "In this walkthrough, you will learn how to create a custom heart shape as well as how to make it pulse. From there, youâ€™ll learn how to scale the pulsing heart up or down.": {"zh": "åœ¨è¿™ä¸ªæ¼”ç»ƒä¸­ï¼Œä½ å°†å­¦ä¹ å¦‚ä½•åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰çš„å¿ƒå½¢ï¼Œä»¥åŠå¦‚ä½•è®©å®ƒè·³åŠ¨ã€‚ä»é‚£é‡Œå¼€å§‹ï¼Œä½ å°†å­¦ä¹ å¦‚ä½•å°†è·³åŠ¨çš„å¿ƒè„æ”¾å¤§æˆ–ç¼©å°ã€‚", "tips": ""}, "Step 2": {"zh": "", "tips": ""}, "To create a heart shape, define a structure that adopts the Shape protocol by implementing the required path(in:) method.": {"zh": "ä¸ºäº†åˆ›å»ºä¸€ä¸ªå¿ƒå½¢ï¼Œè¿™é‡Œä½ é€šè¿‡å®ç° required path(in:) æ–¹æ³•ï¼Œå®šä¹‰ä¸€ä¸ªé‡‡ç”¨ Shape åè®®çš„ç»“æ„ã€‚", "tips": ""}, "Step 3": {"zh": "", "tips": ""}, "path.move starts the path at the point of the heart.": {"zh": "path.move ä»å¿ƒè„çš„ç‚¹å¼€å§‹è·¯å¾„ã€‚", "tips": ""}, "Step 4": {"zh": "", "tips": ""}, "path.addCurve creates a curved line from where your point is to a specified end point. This is what draws the curved sides of the heart shape.": {"zh": "path.addCurve ä¼šä»ä½ æŒ‡å®šçš„èµ·ç‚¹åˆ°ç»ˆç‚¹åˆ›å»ºä¸€æ¡æ›²çº¿ã€‚è¿™å°±æ˜¯ç»˜åˆ¶å¿ƒå½¢çš„æ›²çº¿è¾¹çš„æ–¹æ³•ã€‚", "tips": ""}, "Step 5": {"zh": "", "tips": ""}, "path.addArc adds the arcs at the top of the heart shape. By specifying the start and end angles, the path knows where to draw the arc. The arc is drawn off of specific points in the unit circle that you specify for the start and end angles.": {"zh": "path.addArc ä¼šåœ¨å¿ƒå½¢çš„é¡¶éƒ¨æ·»åŠ åœ†å¼§ã€‚é€šè¿‡æŒ‡å®šèµ·å§‹è§’åº¦å’Œç»“æŸè§’åº¦ï¼ŒPath å®ä¾‹çŸ¥é“åœ¨å“ªé‡Œç»˜åˆ¶åœ†å¼§ã€‚åœ†å¼§æ˜¯ä»ä½ ä¸ºèµ·å§‹è§’åº¦å’Œç»“æŸè§’åº¦æŒ‡å®šçš„å•ä½åœ†çš„ç‰¹å®šç‚¹ç»˜åˆ¶çš„ã€‚", "tips": ""}, "Step 6": {"zh": "", "tips": ""}, "To make the heart pulse, youâ€™ll tap the play button. When the heart pulses, it scales up and then back down, repeating the animation indefinitely. Your heartPulse state property determines the scale of the heart in this animation.": {"zh": "ä¸ºäº†è®©å¿ƒè„è·³åŠ¨ï¼Œä½ å°†ç‚¹å‡»æ’­æ”¾æŒ‰é’®ã€‚å½“å¿ƒè„è·³åŠ¨æ—¶ï¼Œå®ƒä¼šæ”¾å¤§ç„¶åç¼©å°ï¼Œæ— é™æœŸåœ°é‡å¤åŠ¨ç”»ã€‚åœ¨è¿™ä¸ªåŠ¨ç”»ä¸­ï¼Œä½ çš„ heartPulse çŠ¶æ€å±æ€§å†³å®šäº†å¿ƒè„çš„æ¯”ä¾‹ã€‚", "tips": ""}, "Step 7": {"zh": "", "tips": ""}, "When you tap play, the heartPulse value increases. Setting autoreverses to true allows the animation to first play forward, as the heart scales up, and then backward as it scales back down again.": {"zh": "å½“ä½ ç‚¹å‡»æ’­æ”¾æ—¶ï¼ŒheartPulse å€¼ä¼šå¢åŠ ã€‚å°† autoreverses è®¾ç½®ä¸º true å…è®¸åŠ¨ç”»é¦–å…ˆæ­£å‘æ’­æ”¾ï¼Œè¿™ä¼šä½¿å¿ƒè„æ”¾å¤§ï¼Œç„¶ååå‘æ’­æ”¾ï¼Œè¿™ä¼šä½¿å®ƒç¼©å°ã€‚", "tips": ""}, "Step 8": {"zh": "", "tips": ""}, "By changing the value of heartPulse inside of a withAnimation closure, you animate any changes to its value with the animation you pass in, resulting in the pulsing effect. ğŸ’—": {"zh": "é€šè¿‡åœ¨ withAnimation é—­åŒ…ä¸­æ›´æ”¹ heartPulse çš„å€¼ï¼Œä½ å¯ä»¥ä½¿ç”¨ä¼ å…¥çš„åŠ¨ç”»æ¥åŠ¨ç”»åŒ–å…¶å€¼çš„ä»»ä½•æ›´æ”¹ï¼Œä»è€Œäº§ç”Ÿè·³åŠ¨çš„æ•ˆæœã€‚ğŸ’—", "tips": ""}, "Spinning Animation": {"zh": "æ—‹è½¬åŠ¨ç”»", "tips": ""}, "Discover how to create a spinning effect.": {"zh": "æ¢ç´¢å¦‚ä½•åˆ›å»ºæ—‹è½¬æ•ˆæœã€‚", "tips": ""}, "Next, youâ€™ll learn to create a spinning animation when you tap a button. Time to get dizzy!": {"zh": "æ¥ä¸‹æ¥ï¼Œä½ å°†å­¦ä¹ å¦‚ä½•åœ¨ç‚¹å‡»æŒ‰é’®æ—¶åˆ›å»ºæ—‹è½¬åŠ¨ç”»ã€‚æ˜¯æ—¶å€™è®©ä½ å¤´æ™•äº†ï¼", "tips": ""}, "There is no preset animation that actually causes a shape to spin, but you can create the illusion of spinning by changing the width of the shape. To do this, youâ€™ll use a width state property.": {"zh": "è¿™é‡Œæ²¡æœ‰é¢„è®¾çš„åŠ¨ç”»å¯ä»¥è®©å½¢çŠ¶æ—‹è½¬ï¼Œä½†æ˜¯ä½ å¯ä»¥é€šè¿‡æ”¹å˜å½¢çŠ¶çš„å®½åº¦æ¥åˆ¶é€ æ—‹è½¬çš„å¹»è§‰ã€‚ä¸ºæ­¤ï¼Œä½ å°†ä½¿ç”¨ä¸€ä¸ª width çŠ¶æ€å±æ€§ã€‚", "tips": ""}, "When you tap the button, the ellipse animates to change its width from 200 to 0. Notice that the Animation used is .easeInOut.repeatForever(autoreverses: true).speed(2). This chains together three animations to create a specific effect. Try to predict how each part of the animation affects the overall effect.": {"zh": "å½“ä½ ç‚¹å‡»æŒ‰é’®æ—¶ï¼Œæ¤­åœ†åŠ¨ç”»å°†å…¶å®½åº¦ä» 200 æ”¹å˜ä¸º 0ã€‚æ³¨æ„ï¼Œä½¿ç”¨çš„åŠ¨ç”»æ˜¯ .easeInOut.repeatForever(autoreverses: true).speed(2)ã€‚è¿™å°†ä¸‰ä¸ªåŠ¨ç”»é“¾æ¥åœ¨ä¸€èµ·ï¼Œä»¥åˆ›å»ºä¸€ä¸ªç‰¹å®šçš„æ•ˆæœã€‚ä½ å¯ä»¥è¯•ç€é¢„æµ‹åŠ¨ç”»çš„æ¯ä¸ªéƒ¨åˆ†å¦‚ä½•å½±å“æ•´ä½“æ•ˆæœã€‚", "tips": ""}, "Hereâ€™s the sequence: .easeInOut first creates an animation that eases in and eases out. Then .repeatForever(autoreverses: true) takes the .easeInOut animation and puts it in a loop that runs forever. Because autoreverses is true, the animation first runs forward, then in reverse before starting over. And finally, .speed(2) determines how quickly the animation runs. With an argument of 2, it runs at 200 percent of its default speed.": {"zh": "åŠ¨ç”»çš„æ‰§è¡Œé¡ºåºå¦‚ä¸‹ï¼š.easeInOut é¦–å…ˆåˆ›å»ºä¸€ä¸ªç¼“å…¥ç¼“å‡ºçš„åŠ¨ç”»ã€‚ç„¶å .repeatForever(autoreverses: true) å°† .easeInOut åŠ¨ç”»æ”¾å…¥ä¸€ä¸ªæ°¸è¿œè¿è¡Œçš„å¾ªç¯ä¸­ã€‚å› ä¸º autoreverses æ˜¯ trueï¼Œæ‰€ä»¥åŠ¨ç”»é¦–å…ˆæ­£å‘è¿è¡Œï¼Œç„¶ååå‘è¿è¡Œï¼Œç„¶åå†é‡æ–°å¼€å§‹ã€‚æœ€åï¼Œ.speed(2) ç¡®å®šåŠ¨ç”»è¿è¡Œçš„é€Ÿåº¦ã€‚ä½¿ç”¨ 2 ä½œä¸ºå‚æ•°ï¼Œå®ƒä»¥å…¶é»˜è®¤é€Ÿåº¦çš„ 200% è¿è¡Œã€‚", "tips": ""}, "This animation results in a spinning effect as the circleâ€™s width changes first from 200 to 0, and then from 0 to 200, repeating the entire animation on a recurring loop.": {"zh": "è¿™ä¸ªåŠ¨ç”»ä¼šäº§ç”Ÿä¸€ä¸ªæ—‹è½¬çš„æ•ˆæœï¼Œå› ä¸ºåœ†çš„å®½åº¦é¦–å…ˆä» 200 å˜ä¸º 0ï¼Œç„¶åä» 0 å˜ä¸º 200ï¼Œåœ¨ä¸€ä¸ªå¾ªç¯ä¸­é‡å¤æ•´ä¸ªåŠ¨ç”»ã€‚", "tips": ""}, "Exploding Animation": {"zh": "çˆ†ç‚¸åŠ¨ç”»", "tips": ""}, "Learn how to create an explosion effect.": {"zh": "å­¦ä¹ å¦‚ä½•åˆ›å»ºçˆ†ç‚¸æ•ˆæœã€‚", "tips": ""}, "To create an exploding animation, youâ€™ll replace a rectangle with many small rectangular pieces that animate outward.": {"zh": "è¦åˆ›å»ºä¸€ä¸ªçˆ†ç‚¸åŠ¨ç”»ï¼Œä½ å°†ç”¨è®¸å¤šå°çš„çŸ©å½¢å—æ›¿æ¢ä¸€ä¸ªçŸ©å½¢ï¼Œè¿™äº›çŸ©å½¢å—ä¼šä»¥åŠ¨ç”»çš„å½¢å¼å‘å¤–ç§»åŠ¨ã€‚", "tips": ""}, "The isExploded state property tracks whether the exploding animation is currently running. Youâ€™ll use this value to start all of the animations when you tap the button.": {"zh": "è¿™ä¸ª isExploded çŠ¶æ€å±æ€§ä¼šè·Ÿè¸ªçˆ†ç‚¸åŠ¨ç”»æ˜¯å¦æ­£åœ¨è¿è¡Œã€‚ä½ å°†ä½¿ç”¨è¿™ä¸ªå€¼æ¥åœ¨ç‚¹å‡»æŒ‰é’®æ—¶å¯åŠ¨æ‰€æœ‰çš„åŠ¨ç”»ã€‚", "tips": ""}, "In the large Rectangle view, the opacity animates from 1 to 0 when isExploded is set to true; this makes the large rectangle disappear.": {"zh": "åœ¨è¿™ä¸ªå¤§çš„ Rectangle è§†å›¾ä¸­ï¼Œå½“ isExploded è®¾ç½®ä¸º true æ—¶ï¼Œä¸é€æ˜åº¦ä» 1 ä»¥åŠ¨ç”»çš„å½¢å¼å˜åŒ–ä¸º 0ï¼›è¿™ä½¿å¾—è¿™ä¸ªå¤§çŸ©å½¢æ¶ˆå¤±ã€‚", "tips": ""}, "When the large rectangle disappears, you want many small rectangles to explode outward. To create this effect, youâ€™ll first generate a large number of smaller rectangles using a ForEach. These rectangles are initially hidden behind the large rectangle in a ZStack. When the large rectangle disappears, youâ€™ll see the smaller rectangles.": {"zh": "å½“è¿™ä¸ªå¤§çŸ©å½¢æ¶ˆå¤±æ—¶ï¼Œä½ å¸Œæœ›å‡ºç°è®¸å¤šå°çŸ©å½¢å‘å¤–çˆ†ç‚¸ã€‚ä¸ºäº†åˆ›å»ºè¿™ä¸ªæ•ˆæœï¼Œä½ é¦–å…ˆè¦ä½¿ç”¨ ForEach ç”Ÿæˆå¤§é‡çš„å°çŸ©å½¢ã€‚è¿™äº›çŸ©å½¢æœ€åˆè¢«éšè—åœ¨ä¸€ä¸ª ZStack ä¸­çš„å¤§çŸ©å½¢åé¢ã€‚å½“å¤§çŸ©å½¢æ¶ˆå¤±æ—¶ï¼Œä½ ä¼šçœ‹åˆ°è¿™äº›å°çŸ©å½¢ã€‚", "tips": ""}, "Experiment": {"zh": "å®éªŒ", "tips": ""}, "Try changing the number of small rectangles to see how that affects the animation.": {"zh": "å°è¯•æ”¹å˜å°çŸ©å½¢çš„æ•°é‡ï¼Œçœ‹çœ‹è¿™å¯¹åŠ¨ç”»æœ‰ä»€ä¹ˆå½±å“ã€‚", "tips": ""}, "For each of these small rectangles, youâ€™ll use a conditional modifier to animate their offsets to random positions in the view. This makes it look like theyâ€™re little shards of the larger rectangle that propel out in different directions.": {"zh": "å¯¹äºè¿™äº›å°çŸ©å½¢ï¼Œä½ å°†ä½¿ç”¨ä¸€ä¸ªæ¡ä»¶ä¿®é¥°ç¬¦æ¥å°†å®ƒä»¬çš„åç§»é‡åŠ¨ç”»åˆ°è§†å›¾ä¸­çš„éšæœºä½ç½®ã€‚è¿™ä½¿å¾—å®ƒä»¬çœ‹èµ·æ¥åƒæ˜¯å¤§çŸ©å½¢çš„å°ç¢ç‰‡ï¼Œæœä¸åŒçš„æ–¹å‘å–·å°„å‡ºå»ã€‚", "tips": ""}, "Add a twist! Try changing the speed of the ease-in -out animation for the small rectangles and see what happens.": {"zh": "åŠ ç‚¹å˜åŒ–ï¼å°è¯•æ”¹å˜å°çŸ©å½¢çš„ç¼“å…¥ç¼“å‡ºåŠ¨ç”»çš„é€Ÿåº¦ï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆã€‚", "tips": ""}, "As those little rectangles explode out, youâ€™ll fade their opacity from 1 to 0 so they eventually disappear. And thatâ€™s your explosion animation. Now, you may be thinking, â€œThis isnâ€™t a real explosion, itâ€™s an illusion.â€, and youâ€™re absolutely right. All animations are illusions, and youâ€™re the magician who creates them. ğŸª„": {"zh": "å½“è¿™äº›å°çŸ©å½¢çˆ†ç‚¸æ—¶ï¼Œä½ ä¼šå°†å®ƒä»¬çš„ä¸é€æ˜åº¦ä» 1 æ¸å˜ä¸º 0ï¼Œè¿™æ ·å®ƒä»¬æœ€ç»ˆä¼šæ¶ˆå¤±ã€‚è¿™å°±æ˜¯ä½ çš„çˆ†ç‚¸åŠ¨ç”»ã€‚ç°åœ¨ï¼Œä½ å¯èƒ½ä¼šæƒ³ï¼Œâ€œè¿™ä¸æ˜¯ä¸€ä¸ªçœŸæ­£çš„çˆ†ç‚¸ï¼Œè¿™åªæ˜¯ä¸€ä¸ªå¹»è§‰ã€‚â€ï¼Œä½ æ˜¯ç»å¯¹æ­£ç¡®çš„ã€‚æ‰€æœ‰çš„åŠ¨ç”»éƒ½æ˜¯å¹»è§‰ï¼Œè€Œä½ å°±æ˜¯åˆ›é€ å®ƒä»¬çš„é­”æœ¯å¸ˆã€‚ğŸª„", "tips": ""}, "Use scaling and animation delays to create a wave effect.": {"zh": "ä½¿ç”¨ç¼©æ”¾å’ŒåŠ¨ç”»å»¶è¿Ÿæ¥åˆ›å»ºæ³¢æµªæ•ˆæœã€‚", "tips": ""}, "Now that youâ€™ve dabbled with some basic animations, take a look at how you can combine them to create a more advanced interactive effect. Youâ€™ll learn how to animate a grid of circles to form a fabulous wave effect when you tap them. In the preview, try tapping on different circles in the grid. What do you notice?": {"zh": "ç°åœ¨ä½ å·²ç»å°è¯•äº†ä¸€äº›åŸºæœ¬çš„åŠ¨ç”»ï¼Œçœ‹çœ‹ä½ å¦‚ä½•å°†å®ƒä»¬ç»“åˆèµ·æ¥åˆ›å»ºä¸€ä¸ªæ›´é«˜çº§çš„äº¤äº’æ•ˆæœã€‚ä½ å°†å­¦ä¹ å¦‚ä½•å¯¹ä¸€ä¸ªåœ†åœˆç½‘æ ¼è¿›è¡ŒåŠ¨ç”»å¤„ç†ï¼Œå½“ä½ ç‚¹å‡»å®ƒä»¬æ—¶ï¼Œå®ƒä»¬ä¼šå½¢æˆä¸€ä¸ªç¥å¥‡çš„æ³¢æµªæ•ˆæœã€‚åœ¨é¢„è§ˆä¸­ï¼Œå°è¯•ç‚¹å‡»ç½‘æ ¼ä¸­çš„ä¸åŒåœ†åœˆã€‚ä½ æ³¨æ„åˆ°äº†ä»€ä¹ˆï¼Ÿ", "tips": ""}, "Youâ€™ll need a few state properties to keep track of how the circles change when you tap them. The gridColumns property defines the columns for the grid, and colors provides the color options for the rainbow effect.": {"zh": "ä½ å°†éœ€è¦ä¸€äº›çŠ¶æ€å±æ€§æ¥è·Ÿè¸ªåœ†åœˆåœ¨ä½ ç‚¹å‡»å®ƒä»¬æ—¶çš„å˜åŒ–ã€‚gridColumns å±æ€§å®šä¹‰äº†ç½‘æ ¼çš„åˆ—ï¼Œcolors ä¸ºå½©è™¹æ•ˆæœæä¾›äº†é¢œè‰²é€‰é¡¹ã€‚", "tips": ""}, "Try changing the number of columns, by changing the value for count in gridColumns. What happens if you change the colors in the colors array?": {"zh": "å°è¯•é€šè¿‡æ”¹å˜ gridColumns ä¸­ count çš„å€¼æ¥æ”¹å˜åˆ—æ•°ã€‚å¦‚æœä½ æ”¹å˜ colors æ•°ç»„ä¸­çš„é¢œè‰²ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ", "tips": ""}, "The numCircles constant defines the number of circles in your grid. Your LazyVGrid uses gridColumns and numCircles to generate the initial grid of circles.": {"zh": "numCircle å¸¸é‡å®šä¹‰äº†ç½‘æ ¼ä¸­åœ†åœˆçš„æ•°é‡ã€‚ä½ çš„ LazyVGrid ä½¿ç”¨ gridColumns å’Œ numCircles æ¥ç”Ÿæˆåœ†åœˆçš„åˆå§‹ç½‘æ ¼ã€‚", "tips": ""}, "Try changing the value of numCircles and see how your grid changes.": {"zh": "å°è¯•æ”¹å˜ numCircles çš„å€¼ï¼Œçœ‹çœ‹ä½ çš„ç½‘æ ¼å¦‚ä½•å˜åŒ–ã€‚", "tips": ""}, "The springAnimation constant defines the animation to use later in the animation modifier.": {"zh": "springAnimation å¸¸é‡å®šä¹‰äº†ç¨ååœ¨åŠ¨ç”»ä¿®é¥°ç¬¦ä¸­ä½¿ç”¨çš„åŠ¨ç”»ã€‚", "tips": ""}, "Try changing some of these values and tap the grid to see how they affect the animation.": {"zh": "å°è¯•æ”¹å˜å…¶ä¸­ä¸€äº›å€¼ï¼Œç„¶åç‚¹å‡»ç½‘æ ¼ï¼Œçœ‹çœ‹å®ƒä»¬å¦‚ä½•å½±å“åŠ¨ç”»ã€‚", "tips": ""}, "Your springAnimation is used to animate changes to the scale of the circles in the grid. However, to create a rolling wave effect you want to animate the circles in your grids at different times. Add delay(_:) to springAnimation to specify the duration of the animation delay for each individual circle. To calculate the delay, divide the circleâ€™s index by the number of columns, taking the truncating remainder as a value between 1 and 10 (the number of columns). This creates a per-column animation effect.": {"zh": "ä½ çš„ springAnimation ç”¨äºå¯¹ç½‘æ ¼ä¸­åœ†åœˆçš„ç¼©æ”¾è¿›è¡ŒåŠ¨ç”»å¤„ç†ã€‚ç„¶è€Œï¼Œä¸ºäº†åˆ›å»ºä¸€ä¸ªæ»šåŠ¨çš„æ³¢æµªæ•ˆæœï¼Œä½ å¸Œæœ›ä»¥ä¸åŒçš„æ—¶é—´å¯¹ç½‘æ ¼ä¸­çš„åœ†åœˆè¿›è¡ŒåŠ¨ç”»å¤„ç†ã€‚å°† delay(_:) æ·»åŠ åˆ° springAnimation ä¸­ï¼Œä»¥æŒ‡å®šæ¯ä¸ªå•ç‹¬åœ†åœˆçš„åŠ¨ç”»å»¶è¿ŸæŒç»­æ—¶é—´ã€‚ä¸ºäº†è®¡ç®—å»¶è¿Ÿï¼Œå°†åœ†åœˆçš„ç´¢å¼•é™¤ä»¥åˆ—æ•°ï¼Œå°†æˆªæ–­çš„ä½™æ•°ä½œä¸º 1 åˆ° 10 ä¹‹é—´çš„å€¼ï¼ˆåˆ—æ•°ï¼‰ã€‚è¿™æ ·å°±åˆ›å»ºäº†ä¸€ä¸ªæ¯åˆ—åŠ¨ç”»æ•ˆæœã€‚", "tips": ""}, "The .animation modifier determines how the circle animates, but the value for scaleFactor and any changes made to scaleFactor are what causes the increase in scale.": {"zh": ".animation ä¿®é¥°ç¬¦å†³å®šäº†åœ†åœˆçš„åŠ¨ç”»æ–¹å¼ï¼Œä½†æ˜¯ scaleFactor çš„å€¼å’Œå¯¹ scaleFactor çš„ä»»ä½•æ›´æ”¹æ‰æ˜¯å¯¼è‡´ç¼©æ”¾å¢åŠ çš„åŸå› ã€‚", "tips": ""}, "The tapGesture modifier allows you to change the scaleFactor by tapping a circle in the grid. When you tap a circle, the value of scaleFactor is set based on that circleâ€™s index. The further the circleâ€™s position is in the grid, the larger the scaleFactor will be.": {"zh": "tapGesture ä¿®é¥°ç¬¦å…è®¸ä½ é€šè¿‡ç‚¹å‡»ç½‘æ ¼ä¸­çš„ä¸€ä¸ªåœ†åœˆæ¥æ”¹å˜ scaleFactorã€‚å½“ä½ ç‚¹å‡»ä¸€ä¸ªåœ†åœˆæ—¶ï¼ŒscaleFactor çš„å€¼æ˜¯åŸºäºè¯¥åœ†åœˆçš„ç´¢å¼•è®¾ç½®çš„ã€‚åœ†åœˆåœ¨ç½‘æ ¼ä¸­çš„ä½ç½®è¶Šè¿œï¼ŒscaleFactor å°±è¶Šå¤§ã€‚", "tips": ""}, "Because the index of circles starts at 0, you need to set the scaleFactor using index+1 so you never have to set the scaleFactor to an undefined number.": {"zh": "å› ä¸ºåœ†åœˆçš„ç´¢å¼•ä» 0 å¼€å§‹ï¼Œæ‰€ä»¥ä½ éœ€è¦ä½¿ç”¨ index+1 æ¥è®¾ç½® scaleFactorï¼Œè¿™æ ·ä½ å°±æ°¸è¿œä¸éœ€è¦å°† scaleFactor è®¾ç½®ä¸ºä¸€ä¸ªæœªå®šä¹‰çš„æ•°å­—ã€‚", "tips": ""}, "Step 9": {"zh": "", "tips": ""}, "There you have itâ€¦a beautiful rolling rainbow!": {"zh": "å°±æ˜¯è¿™æ ·...ä½ å·²ç»æ‹¥æœ‰äº†ç¾ä¸½çš„çš„æ»šåŠ¨å½©è™¹", "tips": ""}, "Try tinkering with this animation until itâ€™s exactly as you like it. Good luck!": {"zh": "å°è¯•è°ƒæ•´è¿™ä¸ªåŠ¨ç”»ï¼Œç›´åˆ°å®ƒå®Œå…¨ç¬¦åˆä½ çš„å–œå¥½ã€‚ç¥ä½ å¥½è¿ï¼", "tips": ""}, "Use a drag gesture to move a grid of dots.": {"zh": "ä½¿ç”¨æ‹–åŠ¨æ‰‹åŠ¿æ¥ç§»åŠ¨ä¸€ä¸ªç½‘æ ¼çš„ç‚¹ã€‚", "tips": ""}, "Dragginâ€™ Drop Dots is very similar to Rollinâ€™ Rainbow, but with some differences. Instead of changing the scale of the circles when you tap them, the circleâ€™s offset changes based on a drag gesture applied to the entire grid. Time to dive into the code.": {"zh": "Dragginâ€™ Drop Dots ä¸ Rollinâ€™ Rainbow éå¸¸ç›¸ä¼¼ï¼Œä½†ä¹Ÿæœ‰ä¸€äº›ä¸åŒä¹‹å¤„ã€‚å½“ä½ ç‚¹å‡»åœ†åœˆæ—¶ï¼Œåœ†åœˆçš„åç§»é‡ä¼šæ ¹æ®åº”ç”¨äºæ•´ä¸ªç½‘æ ¼çš„æ‹–åŠ¨æ‰‹åŠ¿è€Œæ”¹å˜ï¼Œè€Œä¸æ˜¯æ”¹å˜åœ†åœˆçš„ç¼©æ”¾ã€‚æ˜¯æ—¶å€™æ·±å…¥ä»£ç äº†ã€‚", "tips": ""}, "This is a much larger grid than Rollinâ€™ Rainbow â€“ there are a lot more circles and columns. See what happens when you change the number of dots in the grid. Do you need more circles in this animation?": {"zh": "è¿™æ˜¯ä¸€ä¸ªæ¯” Rollinâ€™ Rainbow å¤§å¾—å¤šçš„ç½‘æ ¼â€”â€”æœ‰æ›´å¤šçš„åœ†åœˆå’Œåˆ—ã€‚çœ‹çœ‹å½“ä½ æ”¹å˜ç½‘æ ¼ä¸­çš„ç‚¹æ•°æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚ä½ éœ€è¦åœ¨è¿™ä¸ªåŠ¨ç”»ä¸­æœ‰æ›´å¤šçš„åœ†åœˆå—ï¼Ÿ", "tips": ""}, "Add a drag gesture instead of a tap gesture so the grid moves when you drag it. You can use the translation value in the drag gesture closure to set the offset of each circle, resulting in the entire grid moving to the new drag.translation value.": {"zh": "æ·»åŠ ä¸€ä¸ªæ‹–åŠ¨æ‰‹åŠ¿ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç‚¹å‡»æ‰‹åŠ¿ï¼Œè¿™æ ·å½“ä½ æ‹–åŠ¨å®ƒæ—¶ï¼Œç½‘æ ¼å°±ä¼šç§»åŠ¨ã€‚ä½ å¯ä»¥åœ¨æ‹–åŠ¨æ‰‹åŠ¿é—­åŒ…ä¸­ä½¿ç”¨ translation å€¼æ¥è®¾ç½®æ¯ä¸ªåœ†åœˆçš„åç§»é‡ï¼Œä»è€Œå¯¼è‡´æ•´ä¸ªç½‘æ ¼ç§»åŠ¨åˆ°æ–°çš„ drag.translation å€¼ã€‚", "tips": ""}, "When the offset changes, youâ€™ll animate the circles to their new positions. Instead of moving all of the dots at the same time, you can use delay on the animation so that each circle moves individually. If you set the delay based on each circleâ€™s index, the circles will have a slightly different delay. This results in the entire grid animating one circle after the other. Because this animation would otherwise be very slow, you can divide the value for delay by the animationSpeed value to speed it up.": {"zh": "å½“æ‰‹åŠ¿çš„åç§»é‡å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä½ å°†å¯¹åœ†åœˆè¿›è¡ŒåŠ¨ç”»å¤„ç†ï¼Œä½¿å®ƒä»¬å¤„äºæ–°çš„ä½ç½®ã€‚ä½ å¯ä»¥ä½¿ç”¨åŠ¨ç”»ä¸Šçš„å»¶è¿Ÿï¼Œè€Œä¸æ˜¯åŒæ—¶ç§»åŠ¨æ‰€æœ‰çš„ç‚¹ï¼Œè¿™æ ·æ¯ä¸ªåœ†åœˆå°±å¯ä»¥å•ç‹¬ç§»åŠ¨ã€‚å¦‚æœä½ æ ¹æ®æ¯ä¸ªåœ†åœˆçš„ç´¢å¼•è®¾ç½®å»¶è¿Ÿï¼Œé‚£ä¹ˆåœ†åœˆçš„å»¶è¿Ÿå°±ä¼šç•¥æœ‰ä¸åŒã€‚è¿™å¯¼è‡´æ•´ä¸ªç½‘æ ¼ä¼šåœ¨ä¸€ä¸ªåœ†åœˆä¹‹ååŠ¨ç”»æ‰§è¡Œç»“æŸä¹‹åå†æ‰§è¡Œå¦ä¸€ä¸ªåœ†åœˆçš„åŠ¨ç”»ã€‚å› ä¸ºè¿™ä¸ªåŠ¨ç”»æœ¬æ¥ä¼šéå¸¸æ…¢ï¼Œæ‰€ä»¥ä½ å¯ä»¥å°†å»¶è¿Ÿçš„å€¼é™¤ä»¥ animationSpeed çš„å€¼æ¥åŠ å¿«é€Ÿåº¦ã€‚", "tips": ""}, "Try changing the animationSpeed to something very low, like 20. How does the animation change?": {"zh": "å°è¯•å°† animationSpeed æ›´æ”¹ä¸ºéå¸¸ä½çš„å€¼ï¼Œæ¯”å¦‚ 20ã€‚åŠ¨ç”»ä¼šå¦‚ä½•å˜åŒ–ï¼Ÿ", "tips": ""}, "Dancing Dots": {"zh": "è·³èˆçš„ç‚¹", "tips": ""}, "Make the circles boogie!": {"zh": "è®©åœ†åœˆè·³èˆï¼", "tips": ""}, "Animate more complex model data in cool and interesting ways using observable objects.": {"zh": "è®©æ›´å¤šå¤æ‚çš„æ¨¡å‹æ•°æ®ä»¥æœ‰è¶£çš„æ–¹å¼ä½¿ç”¨ observable å¯¹è±¡è¿›è¡ŒåŠ¨ç”»å¤„ç†ã€‚", "tips": ""}, "What if the changes you want to animate arenâ€™t coming from user actions? SwiftUI has a way of animating published values in observable objects. Create an observable object BigDot that publishes an offset, color, scale, and an array of small dot observable objects. Youâ€™ll use this object to model the view animations you want in your view.": {"zh": "å¦‚æœä½ æƒ³è¦åŠ¨ç”»å¤„ç†çš„å˜åŒ–ä¸æ˜¯æ¥è‡ªç”¨æˆ·çš„æ“ä½œæ€ä¹ˆåŠï¼ŸSwiftUI æœ‰ä¸€ç§æ–¹æ³•å¯ä»¥å¯¹ observable å¯¹è±¡ä¸­å‘å¸ƒçš„å€¼è¿›è¡ŒåŠ¨ç”»å¤„ç†ã€‚åˆ›å»ºä¸€ä¸ª observable å¯¹è±¡ BigDotï¼Œå®ƒå‘å¸ƒä¸€ä¸ªåç§»é‡ã€é¢œè‰²ã€æ¯”ä¾‹å’Œä¸€ä¸ªå°ç‚¹ observable å¯¹è±¡çš„æ•°ç»„ã€‚ä½ å°†ä½¿ç”¨è¿™ä¸ªå¯¹è±¡æ¥æ¨¡æ‹Ÿä½ åœ¨è§†å›¾ä¸­æƒ³è¦çš„è§†å›¾åŠ¨ç”»ã€‚", "tips": ""}, "Add a SmallDot observable object that publishes a color and an offset.": {"zh": "æ·»åŠ ä¸€ä¸ª SmallDot observable å¯¹è±¡ï¼Œå®ƒå°†å‘å¸ƒä¸€ä¸ªé¢œè‰²å’Œä¸€ä¸ªåç§»é‡ã€‚", "tips": ""}, "When you create a bigDot, you also need to create an array of small dots that are linked to the big dot.": {"zh": "å½“ä½ åˆ›å»ºä¸€ä¸ª bigDot æ—¶ï¼Œä½ è¿˜éœ€è¦åˆ›å»ºä¸€ä¸ªä¸ bigDot ç›¸å…³è”çš„ smallDot æ•°ç»„ã€‚", "tips": ""}, "Now, a grid of big dots needs to populate the grid with five small dots for every big dot. Because there are so many dots, youâ€™ll use a DotTracker class when publishing an array of BigDots. This is the published value youâ€™ll track to create your animations. What happens to the animation if you increase or decrease the number of smallDots in the array?": {"zh": "ç°åœ¨ï¼Œä¸€ä¸ªå¤§ç‚¹çš„ç½‘æ ¼éœ€è¦ä¸ºæ¯ä¸ªå¤§ç‚¹å¡«å……äº”ä¸ªå°ç‚¹ã€‚å› ä¸ºæœ‰è¿™ä¹ˆå¤šçš„ç‚¹ï¼Œæ‰€ä»¥åœ¨å‘å¸ƒä¸€ä¸ª BigDots æ•°ç»„æ—¶ï¼Œä½ å°†ä½¿ç”¨ä¸€ä¸ª DotTracker ç±»ã€‚è¿™æ˜¯ä½ å°†è·Ÿè¸ªçš„å‘å¸ƒå€¼ï¼Œä»¥åˆ›å»ºä½ çš„åŠ¨ç”»ã€‚å¦‚æœä½ å¢åŠ æˆ–å‡å°‘æ•°ç»„ä¸­çš„ smallDots æ•°é‡ï¼ŒåŠ¨ç”»ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ", "tips": ""}, "Your bigDots array has 100 BigDot instances that appear in the grid view.": {"zh": "ä½ çš„ bigDots æ•°ç»„æœ‰ 100 ä¸ª BigDot å®ä¾‹ï¼Œå®ƒä»¬å‡ºç°åœ¨ç½‘æ ¼è§†å›¾ä¸­ã€‚", "tips": ""}, "You may notice that the BigDot class and DotTracker both include a randomizePositions() function that do almost the same thing. The function in BigDot creates random positions for each SmallDot in its smallDot array, while the function in DotTracker creates random positions for each BigDot. Together, these functions create the changes in the offset, color, and scale values reflected by animations in your grid view.": {"zh": "ä½ å¯èƒ½ä¼šæ³¨æ„åˆ°ï¼ŒBigDot ç±»å’Œ DotTracker éƒ½åŒ…å«ä¸€ä¸ª randomizePositions() å‡½æ•°ï¼Œå®ƒä»¬å‡ ä¹åšäº†ç›¸åŒçš„äº‹æƒ…ã€‚BigDot ä¸­çš„å‡½æ•°ä¸ºå…¶ smallDot æ•°ç»„ä¸­çš„æ¯ä¸ª SmallDot åˆ›å»ºéšæœºä½ç½®ï¼Œè€Œ DotTracker ä¸­çš„å‡½æ•°ä¸ºæ¯ä¸ª BigDot åˆ›å»ºéšæœºä½ç½®ã€‚è¿™äº›å‡½æ•°ä¸€èµ·åœ¨ç½‘æ ¼è§†å›¾ä¸­åˆ›å»ºäº†åç§»é‡ã€é¢œè‰²å’Œæ¯”ä¾‹å€¼çš„å˜åŒ–ï¼Œè¿™äº›å˜åŒ–åæ˜ åœ¨åŠ¨ç”»ä¸­ã€‚", "tips": ""}, "Try changing the value of the scale in the randomizePositions() function. What happens to the animation when you lower the scale value?": {"zh": "å°è¯•ä¿®æ”¹ randomizePositions() å‡½æ•°ä¸­çš„ scale å€¼ã€‚å½“ä½ é™ä½ scale å€¼æ—¶ï¼ŒåŠ¨ç”»ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ", "tips": ""}, "Add a resetPositions() function, so the dots reset to their original positions when you tap the reset button. This is very similar to the randomizePositions() function used to place circles in random locations around the view.": {"zh": "æ·»åŠ ä¸€ä¸ª resetPositions() å‡½æ•°ï¼Œè¿™æ ·å½“ä½ ç‚¹å‡»é‡ç½®æŒ‰é’®æ—¶ï¼Œç‚¹ä¼šé‡ç½®åˆ°å®ƒä»¬çš„åŸå§‹ä½ç½®ã€‚è¿™ä¸ç”¨äºåœ¨è§†å›¾å‘¨å›´éšæœºä½ç½®æ”¾ç½®åœ†åœˆçš„ randomizePositions() å‡½æ•°éå¸¸ç›¸ä¼¼ã€‚", "tips": ""}, "The randomizePositions() function calls bigDot.randomizePositions(). This puts every SmallDot in the smallDot array defined in the BigDot class into random positions.": {"zh": "randomizePositions() å‡½æ•°ä¼šè°ƒç”¨ bigDot.randomizePositions()ã€‚è¿™å°† BigDot ç±»ä¸­å®šä¹‰çš„ smallDot æ•°ç»„ä¸­çš„æ¯ä¸ª SmallDot æ”¾ç½®åœ¨éšæœºä½ç½®ã€‚", "tips": ""}, "The DancingDotsView needs to define an instance of the DotTracker as a @StateObject so SwiftUI redraws its contents whenever any of the viewâ€™s dots change color or position.": {"zh": "DansingDotsView éœ€è¦å°† DotTracker çš„å®ä¾‹å®šä¹‰ä¸º @StateObjectï¼Œè¿™æ · SwiftUI å°±ä¼šåœ¨è§†å›¾çš„ä»»ä½•ç‚¹çš„é¢œè‰²æˆ–ä½ç½®å‘ç”Ÿå˜åŒ–æ—¶é‡æ–°ç»˜åˆ¶å…¶å†…å®¹ã€‚", "tips": ""}, "Step 10": {"zh": "", "tips": ""}, "Add in this ForEach loop to place each BigDot tracked by the tracker into the grid.": {"zh": "å°†è¿™ä¸ª ForEach å¾ªç¯æ·»åŠ åˆ° tracker ä¸­ï¼Œä»¥å°†æ¯ä¸ªè¢« tracker è¿½è¸ªçš„ BigDot æ”¾ç½®åˆ°ç½‘æ ¼ä¸­ã€‚", "tips": ""}, "Step 11": {"zh": "", "tips": ""}, "For each BigDot, you can create a circle view with its offset, color, and scale.": {"zh": "å¯¹äºæ¯ä¸ª BigDotï¼Œä½ å¯ä»¥é€šè¿‡é…ç½®å®ƒçš„åç§»é‡ã€é¢œè‰²å’Œæ¯”ä¾‹æ¥åˆ›å»ºä¸€ä¸ªåœ†å½¢è§†å›¾ã€‚", "tips": ""}, "Step 12": {"zh": "", "tips": ""}, "Because every BigDot has five SmallDots, you can do the same thing for the small dots.": {"zh": "å› ä¸ºæ¯ä¸ª BigDot éƒ½æœ‰äº”ä¸ª SmallDotï¼Œæ‰€ä»¥ä½ å¯ä»¥å¯¹å°ç‚¹åšåŒæ ·çš„äº‹æƒ…ã€‚", "tips": ""}, "Step 13": {"zh": "", "tips": ""}, "When you tap the play button, the circles animate and the randomizePositions() function is called. This causes the circlesâ€™ offsets to change, creating a dancing effect for the dots.": {"zh": "å½“ä½ ç‚¹å‡»æ’­æ”¾æŒ‰é’®æ—¶ï¼Œåœ†åœˆä¼šæ‰§è¡ŒåŠ¨ç”»ï¼ŒåŒæ—¶ randomizePositions() å‡½æ•°ä¼šè¢«è°ƒç”¨ã€‚è¿™ä¼šå¯¼è‡´åœ†åœˆçš„åç§»é‡å‘ç”Ÿå˜åŒ–ï¼Œä¸ºç‚¹åˆ›å»ºä¸€ä¸ªè·³èˆæ•ˆæœã€‚", "tips": ""}, "Step 14": {"zh": "", "tips": ""}, "Add this isAnimating state property, which calls the resetPositions() method and resets the circleâ€™s positions when you tap Reset.": {"zh": "æ·»åŠ è¿™ä¸ª isAnimating çŠ¶æ€å±æ€§ï¼Œå®ƒä¼šè°ƒç”¨ resetPositions() æ–¹æ³•ï¼Œå¹¶åœ¨ä½ ç‚¹å‡»é‡ç½®æ—¶é‡ç½®åœ†åœˆçš„ä½ç½®ã€‚", "tips": ""}, "Step 15": {"zh": "", "tips": ""}, "Because everything is animating, adding drawingGroup() helps to make the animation render smoothly.": {"zh": "å› ä¸ºä¸€åˆ‡å†…å®¹éƒ½åœ¨æ‰§è¡ŒåŠ¨ç”»ï¼Œæ‰€ä»¥æ·»åŠ  drawingGroup() æœ‰åŠ©äºä½¿åŠ¨ç”»æ¸²æŸ“å¹³æ»‘ã€‚", "tips": ""}, "Step 16": {"zh": "", "tips": ""}, "Now you know how to create more complex animations with shapes. Time to take what youâ€™ve learned in this guide and use it to make some cool Swift apps!": {"zh": "ç°åœ¨ä½ çŸ¥é“å¦‚ä½•ä½¿ç”¨å½¢çŠ¶åˆ›å»ºæ›´å¤æ‚çš„åŠ¨ç”»äº†ã€‚ç°åœ¨æ˜¯æ—¶å€™å°†ä½ åœ¨æœ¬æŒ‡å—ä¸­å­¦åˆ°çš„çŸ¥è¯†ç”¨äºåˆ¶ä½œä¸€äº›å¾ˆé…·çš„ Swift åº”ç”¨äº†ï¼", "tips": ""}, "Previewing the Camera Output": {"zh": "é¢„è§ˆç›¸æœºè¾“å‡º", "tips": ""}, "Preview the output from the camera.": {"zh": "é¢„è§ˆæ¥è‡ªç›¸æœºçš„è¾“å‡ºã€‚", "tips": ""}, "Rollin Rainbow": {"zh": "", "tips": ""}, "Draggin Drop It": {"zh": "", "tips": ""}}
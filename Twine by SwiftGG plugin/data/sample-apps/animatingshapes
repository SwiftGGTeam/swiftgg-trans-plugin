{"Animating Shapes": {"zh": "动画形状", "tips": ""}, "Learn how to use shapes and simple animations in SwiftUI.": {"zh": "学习如何在 SwiftUI 中使用形状和简单动画。", "tips": ""}, "First up, you’ll learn to use the SwiftUI Shape protocol to create and modify shape views.": {"zh": "首先，你将学习使用 SwiftUI Shape 协议来创建和修改形状视图。", "tips": ""}, "You’ll learn the basics of animating views and how to create animations – some easy, some more complex!": {"zh": "你将学习动画视图的基础知识以及如何创建动画 - 有些简单，有些更复杂！", "tips": ""}, "Heart Pulse": {"zh": "心脏脉冲", "tips": ""}, "Discover how to make a heart pulse in this basic animation.": {"zh": "探索如何在这个基本动画中使心脏跳动。", "tips": ""}, "Step 1": {"zh": "", "tips": ""}, "In this walkthrough, you will learn how to create a custom heart shape as well as how to make it pulse. From there, you’ll learn how to scale the pulsing heart up or down.": {"zh": "在这个演练中，你将学习如何创建一个自定义的心形，以及如何让它跳动。从那里开始，你将学习如何将跳动的心脏放大或缩小。", "tips": ""}, "Step 2": {"zh": "", "tips": ""}, "To create a heart shape, define a structure that adopts the Shape protocol by implementing the required path(in:) method.": {"zh": "为了创建一个心形，这里你通过实现 required path(in:) 方法，定义一个采用 Shape 协议的结构。", "tips": ""}, "Step 3": {"zh": "", "tips": ""}, "path.move starts the path at the point of the heart.": {"zh": "path.move 从心脏的点开始路径。", "tips": ""}, "Step 4": {"zh": "", "tips": ""}, "path.addCurve creates a curved line from where your point is to a specified end point. This is what draws the curved sides of the heart shape.": {"zh": "path.addCurve 会从你指定的起点到终点创建一条曲线。这就是绘制心形的曲线边的方法。", "tips": ""}, "Step 5": {"zh": "", "tips": ""}, "path.addArc adds the arcs at the top of the heart shape. By specifying the start and end angles, the path knows where to draw the arc. The arc is drawn off of specific points in the unit circle that you specify for the start and end angles.": {"zh": "path.addArc 会在心形的顶部添加圆弧。通过指定起始角度和结束角度，Path 实例知道在哪里绘制圆弧。圆弧是从你为起始角度和结束角度指定的单位圆的特定点绘制的。", "tips": ""}, "Step 6": {"zh": "", "tips": ""}, "To make the heart pulse, you’ll tap the play button. When the heart pulses, it scales up and then back down, repeating the animation indefinitely. Your heartPulse state property determines the scale of the heart in this animation.": {"zh": "为了让心脏跳动，你将点击播放按钮。当心脏跳动时，它会放大然后缩小，无限期地重复动画。在这个动画中，你的 heartPulse 状态属性决定了心脏的比例。", "tips": ""}, "Step 7": {"zh": "", "tips": ""}, "When you tap play, the heartPulse value increases. Setting autoreverses to true allows the animation to first play forward, as the heart scales up, and then backward as it scales back down again.": {"zh": "当你点击播放时，heartPulse 值会增加。将 autoreverses 设置为 true 允许动画首先正向播放，这会使心脏放大，然后反向播放，这会使它缩小。", "tips": ""}, "Step 8": {"zh": "", "tips": ""}, "By changing the value of heartPulse inside of a withAnimation closure, you animate any changes to its value with the animation you pass in, resulting in the pulsing effect. 💗": {"zh": "通过在 withAnimation 闭包中更改 heartPulse 的值，你可以使用传入的动画来动画化其值的任何更改，从而产生跳动的效果。💗", "tips": ""}, "Spinning Animation": {"zh": "旋转动画", "tips": ""}, "Discover how to create a spinning effect.": {"zh": "探索如何创建旋转效果。", "tips": ""}, "Next, you’ll learn to create a spinning animation when you tap a button. Time to get dizzy!": {"zh": "接下来，你将学习如何在点击按钮时创建旋转动画。是时候让你头晕了！", "tips": ""}, "There is no preset animation that actually causes a shape to spin, but you can create the illusion of spinning by changing the width of the shape. To do this, you’ll use a width state property.": {"zh": "这里没有预设的动画可以让形状旋转，但是你可以通过改变形状的宽度来制造旋转的幻觉。为此，你将使用一个 width 状态属性。", "tips": ""}, "When you tap the button, the ellipse animates to change its width from 200 to 0. Notice that the Animation used is .easeInOut.repeatForever(autoreverses: true).speed(2). This chains together three animations to create a specific effect. Try to predict how each part of the animation affects the overall effect.": {"zh": "当你点击按钮时，椭圆动画将其宽度从 200 改变为 0。注意，使用的动画是 .easeInOut.repeatForever(autoreverses: true).speed(2)。这将三个动画链接在一起，以创建一个特定的效果。你可以试着预测动画的每个部分如何影响整体效果。", "tips": ""}, "Here’s the sequence: .easeInOut first creates an animation that eases in and eases out. Then .repeatForever(autoreverses: true) takes the .easeInOut animation and puts it in a loop that runs forever. Because autoreverses is true, the animation first runs forward, then in reverse before starting over. And finally, .speed(2) determines how quickly the animation runs. With an argument of 2, it runs at 200 percent of its default speed.": {"zh": "动画的执行顺序如下：.easeInOut 首先创建一个缓入缓出的动画。然后 .repeatForever(autoreverses: true) 将 .easeInOut 动画放入一个永远运行的循环中。因为 autoreverses 是 true，所以动画首先正向运行，然后反向运行，然后再重新开始。最后，.speed(2) 确定动画运行的速度。使用 2 作为参数，它以其默认速度的 200% 运行。", "tips": ""}, "This animation results in a spinning effect as the circle’s width changes first from 200 to 0, and then from 0 to 200, repeating the entire animation on a recurring loop.": {"zh": "这个动画会产生一个旋转的效果，因为圆的宽度首先从 200 变为 0，然后从 0 变为 200，在一个循环中重复整个动画。", "tips": ""}, "Exploding Animation": {"zh": "爆炸动画", "tips": ""}, "Learn how to create an explosion effect.": {"zh": "学习如何创建爆炸效果。", "tips": ""}, "To create an exploding animation, you’ll replace a rectangle with many small rectangular pieces that animate outward.": {"zh": "要创建一个爆炸动画，你将用许多小的矩形块替换一个矩形，这些矩形块会以动画的形式向外移动。", "tips": ""}, "The isExploded state property tracks whether the exploding animation is currently running. You’ll use this value to start all of the animations when you tap the button.": {"zh": "这个 isExploded 状态属性会跟踪爆炸动画是否正在运行。你将使用这个值来在点击按钮时启动所有的动画。", "tips": ""}, "In the large Rectangle view, the opacity animates from 1 to 0 when isExploded is set to true; this makes the large rectangle disappear.": {"zh": "在这个大的 Rectangle 视图中，当 isExploded 设置为 true 时，不透明度从 1 以动画的形式变化为 0；这使得这个大矩形消失。", "tips": ""}, "When the large rectangle disappears, you want many small rectangles to explode outward. To create this effect, you’ll first generate a large number of smaller rectangles using a ForEach. These rectangles are initially hidden behind the large rectangle in a ZStack. When the large rectangle disappears, you’ll see the smaller rectangles.": {"zh": "当这个大矩形消失时，你希望出现许多小矩形向外爆炸。为了创建这个效果，你首先要使用 ForEach 生成大量的小矩形。这些矩形最初被隐藏在一个 ZStack 中的大矩形后面。当大矩形消失时，你会看到这些小矩形。", "tips": ""}, "Experiment": {"zh": "实验", "tips": ""}, "Try changing the number of small rectangles to see how that affects the animation.": {"zh": "尝试改变小矩形的数量，看看这对动画有什么影响。", "tips": ""}, "For each of these small rectangles, you’ll use a conditional modifier to animate their offsets to random positions in the view. This makes it look like they’re little shards of the larger rectangle that propel out in different directions.": {"zh": "对于这些小矩形，你将使用一个条件修饰符来将它们的偏移量动画到视图中的随机位置。这使得它们看起来像是大矩形的小碎片，朝不同的方向喷射出去。", "tips": ""}, "Add a twist! Try changing the speed of the ease-in -out animation for the small rectangles and see what happens.": {"zh": "加点变化！尝试改变小矩形的缓入缓出动画的速度，看看会发生什么。", "tips": ""}, "As those little rectangles explode out, you’ll fade their opacity from 1 to 0 so they eventually disappear. And that’s your explosion animation. Now, you may be thinking, “This isn’t a real explosion, it’s an illusion.”, and you’re absolutely right. All animations are illusions, and you’re the magician who creates them. 🪄": {"zh": "当这些小矩形爆炸时，你会将它们的不透明度从 1 渐变为 0，这样它们最终会消失。这就是你的爆炸动画。现在，你可能会想，“这不是一个真正的爆炸，这只是一个幻觉。”，你是绝对正确的。所有的动画都是幻觉，而你就是创造它们的魔术师。🪄", "tips": ""}, "Use scaling and animation delays to create a wave effect.": {"zh": "使用缩放和动画延迟来创建波浪效果。", "tips": ""}, "Now that you’ve dabbled with some basic animations, take a look at how you can combine them to create a more advanced interactive effect. You’ll learn how to animate a grid of circles to form a fabulous wave effect when you tap them. In the preview, try tapping on different circles in the grid. What do you notice?": {"zh": "现在你已经尝试了一些基本的动画，看看你如何将它们结合起来创建一个更高级的交互效果。你将学习如何对一个圆圈网格进行动画处理，当你点击它们时，它们会形成一个神奇的波浪效果。在预览中，尝试点击网格中的不同圆圈。你注意到了什么？", "tips": ""}, "You’ll need a few state properties to keep track of how the circles change when you tap them. The gridColumns property defines the columns for the grid, and colors provides the color options for the rainbow effect.": {"zh": "你将需要一些状态属性来跟踪圆圈在你点击它们时的变化。gridColumns 属性定义了网格的列，colors 为彩虹效果提供了颜色选项。", "tips": ""}, "Try changing the number of columns, by changing the value for count in gridColumns. What happens if you change the colors in the colors array?": {"zh": "尝试通过改变 gridColumns 中 count 的值来改变列数。如果你改变 colors 数组中的颜色会发生什么？", "tips": ""}, "The numCircles constant defines the number of circles in your grid. Your LazyVGrid uses gridColumns and numCircles to generate the initial grid of circles.": {"zh": "numCircle 常量定义了网格中圆圈的数量。你的 LazyVGrid 使用 gridColumns 和 numCircles 来生成圆圈的初始网格。", "tips": ""}, "Try changing the value of numCircles and see how your grid changes.": {"zh": "尝试改变 numCircles 的值，看看你的网格如何变化。", "tips": ""}, "The springAnimation constant defines the animation to use later in the animation modifier.": {"zh": "springAnimation 常量定义了稍后在动画修饰符中使用的动画。", "tips": ""}, "Try changing some of these values and tap the grid to see how they affect the animation.": {"zh": "尝试改变其中一些值，然后点击网格，看看它们如何影响动画。", "tips": ""}, "Your springAnimation is used to animate changes to the scale of the circles in the grid. However, to create a rolling wave effect you want to animate the circles in your grids at different times. Add delay(_:) to springAnimation to specify the duration of the animation delay for each individual circle. To calculate the delay, divide the circle’s index by the number of columns, taking the truncating remainder as a value between 1 and 10 (the number of columns). This creates a per-column animation effect.": {"zh": "你的 springAnimation 用于对网格中圆圈的缩放进行动画处理。然而，为了创建一个滚动的波浪效果，你希望以不同的时间对网格中的圆圈进行动画处理。将 delay(_:) 添加到 springAnimation 中，以指定每个单独圆圈的动画延迟持续时间。为了计算延迟，将圆圈的索引除以列数，将截断的余数作为 1 到 10 之间的值（列数）。这样就创建了一个每列动画效果。", "tips": ""}, "The .animation modifier determines how the circle animates, but the value for scaleFactor and any changes made to scaleFactor are what causes the increase in scale.": {"zh": ".animation 修饰符决定了圆圈的动画方式，但是 scaleFactor 的值和对 scaleFactor 的任何更改才是导致缩放增加的原因。", "tips": ""}, "The tapGesture modifier allows you to change the scaleFactor by tapping a circle in the grid. When you tap a circle, the value of scaleFactor is set based on that circle’s index. The further the circle’s position is in the grid, the larger the scaleFactor will be.": {"zh": "tapGesture 修饰符允许你通过点击网格中的一个圆圈来改变 scaleFactor。当你点击一个圆圈时，scaleFactor 的值是基于该圆圈的索引设置的。圆圈在网格中的位置越远，scaleFactor 就越大。", "tips": ""}, "Because the index of circles starts at 0, you need to set the scaleFactor using index+1 so you never have to set the scaleFactor to an undefined number.": {"zh": "因为圆圈的索引从 0 开始，所以你需要使用 index+1 来设置 scaleFactor，这样你就永远不需要将 scaleFactor 设置为一个未定义的数字。", "tips": ""}, "Step 9": {"zh": "", "tips": ""}, "There you have it…a beautiful rolling rainbow!": {"zh": "就是这样...你已经拥有了美丽的的滚动彩虹", "tips": ""}, "Try tinkering with this animation until it’s exactly as you like it. Good luck!": {"zh": "尝试调整这个动画，直到它完全符合你的喜好。祝你好运！", "tips": ""}, "Use a drag gesture to move a grid of dots.": {"zh": "使用拖动手势来移动一个网格的点。", "tips": ""}, "Draggin’ Drop Dots is very similar to Rollin’ Rainbow, but with some differences. Instead of changing the scale of the circles when you tap them, the circle’s offset changes based on a drag gesture applied to the entire grid. Time to dive into the code.": {"zh": "Draggin’ Drop Dots 与 Rollin’ Rainbow 非常相似，但也有一些不同之处。当你点击圆圈时，圆圈的偏移量会根据应用于整个网格的拖动手势而改变，而不是改变圆圈的缩放。是时候深入代码了。", "tips": ""}, "This is a much larger grid than Rollin’ Rainbow – there are a lot more circles and columns. See what happens when you change the number of dots in the grid. Do you need more circles in this animation?": {"zh": "这是一个比 Rollin’ Rainbow 大得多的网格——有更多的圆圈和列。看看当你改变网格中的点数时会发生什么。你需要在这个动画中有更多的圆圈吗？", "tips": ""}, "Add a drag gesture instead of a tap gesture so the grid moves when you drag it. You can use the translation value in the drag gesture closure to set the offset of each circle, resulting in the entire grid moving to the new drag.translation value.": {"zh": "添加一个拖动手势，而不是一个点击手势，这样当你拖动它时，网格就会移动。你可以在拖动手势闭包中使用 translation 值来设置每个圆圈的偏移量，从而导致整个网格移动到新的 drag.translation 值。", "tips": ""}, "When the offset changes, you’ll animate the circles to their new positions. Instead of moving all of the dots at the same time, you can use delay on the animation so that each circle moves individually. If you set the delay based on each circle’s index, the circles will have a slightly different delay. This results in the entire grid animating one circle after the other. Because this animation would otherwise be very slow, you can divide the value for delay by the animationSpeed value to speed it up.": {"zh": "当手势的偏移量发生变化时，你将对圆圈进行动画处理，使它们处于新的位置。你可以使用动画上的延迟，而不是同时移动所有的点，这样每个圆圈就可以单独移动。如果你根据每个圆圈的索引设置延迟，那么圆圈的延迟就会略有不同。这导致整个网格会在一个圆圈之后动画执行结束之后再执行另一个圆圈的动画。因为这个动画本来会非常慢，所以你可以将延迟的值除以 animationSpeed 的值来加快速度。", "tips": ""}, "Try changing the animationSpeed to something very low, like 20. How does the animation change?": {"zh": "尝试将 animationSpeed 更改为非常低的值，比如 20。动画会如何变化？", "tips": ""}, "Dancing Dots": {"zh": "跳舞的点", "tips": ""}, "Make the circles boogie!": {"zh": "让圆圈跳舞！", "tips": ""}, "Animate more complex model data in cool and interesting ways using observable objects.": {"zh": "让更多复杂的模型数据以有趣的方式使用 observable 对象进行动画处理。", "tips": ""}, "What if the changes you want to animate aren’t coming from user actions? SwiftUI has a way of animating published values in observable objects. Create an observable object BigDot that publishes an offset, color, scale, and an array of small dot observable objects. You’ll use this object to model the view animations you want in your view.": {"zh": "如果你想要动画处理的变化不是来自用户的操作怎么办？SwiftUI 有一种方法可以对 observable 对象中发布的值进行动画处理。创建一个 observable 对象 BigDot，它发布一个偏移量、颜色、比例和一个小点 observable 对象的数组。你将使用这个对象来模拟你在视图中想要的视图动画。", "tips": ""}, "Add a SmallDot observable object that publishes a color and an offset.": {"zh": "添加一个 SmallDot observable 对象，它将发布一个颜色和一个偏移量。", "tips": ""}, "When you create a bigDot, you also need to create an array of small dots that are linked to the big dot.": {"zh": "当你创建一个 bigDot 时，你还需要创建一个与 bigDot 相关联的 smallDot 数组。", "tips": ""}, "Now, a grid of big dots needs to populate the grid with five small dots for every big dot. Because there are so many dots, you’ll use a DotTracker class when publishing an array of BigDots. This is the published value you’ll track to create your animations. What happens to the animation if you increase or decrease the number of smallDots in the array?": {"zh": "现在，一个大点的网格需要为每个大点填充五个小点。因为有这么多的点，所以在发布一个 BigDots 数组时，你将使用一个 DotTracker 类。这是你将跟踪的发布值，以创建你的动画。如果你增加或减少数组中的 smallDots 数量，动画会发生什么？", "tips": ""}, "Your bigDots array has 100 BigDot instances that appear in the grid view.": {"zh": "你的 bigDots 数组有 100 个 BigDot 实例，它们出现在网格视图中。", "tips": ""}, "You may notice that the BigDot class and DotTracker both include a randomizePositions() function that do almost the same thing. The function in BigDot creates random positions for each SmallDot in its smallDot array, while the function in DotTracker creates random positions for each BigDot. Together, these functions create the changes in the offset, color, and scale values reflected by animations in your grid view.": {"zh": "你可能会注意到，BigDot 类和 DotTracker 都包含一个 randomizePositions() 函数，它们几乎做了相同的事情。BigDot 中的函数为其 smallDot 数组中的每个 SmallDot 创建随机位置，而 DotTracker 中的函数为每个 BigDot 创建随机位置。这些函数一起在网格视图中创建了偏移量、颜色和比例值的变化，这些变化反映在动画中。", "tips": ""}, "Try changing the value of the scale in the randomizePositions() function. What happens to the animation when you lower the scale value?": {"zh": "尝试修改 randomizePositions() 函数中的 scale 值。当你降低 scale 值时，动画会发生什么？", "tips": ""}, "Add a resetPositions() function, so the dots reset to their original positions when you tap the reset button. This is very similar to the randomizePositions() function used to place circles in random locations around the view.": {"zh": "添加一个 resetPositions() 函数，这样当你点击重置按钮时，点会重置到它们的原始位置。这与用于在视图周围随机位置放置圆圈的 randomizePositions() 函数非常相似。", "tips": ""}, "The randomizePositions() function calls bigDot.randomizePositions(). This puts every SmallDot in the smallDot array defined in the BigDot class into random positions.": {"zh": "randomizePositions() 函数会调用 bigDot.randomizePositions()。这将 BigDot 类中定义的 smallDot 数组中的每个 SmallDot 放置在随机位置。", "tips": ""}, "The DancingDotsView needs to define an instance of the DotTracker as a @StateObject so SwiftUI redraws its contents whenever any of the view’s dots change color or position.": {"zh": "DansingDotsView 需要将 DotTracker 的实例定义为 @StateObject，这样 SwiftUI 就会在视图的任何点的颜色或位置发生变化时重新绘制其内容。", "tips": ""}, "Step 10": {"zh": "", "tips": ""}, "Add in this ForEach loop to place each BigDot tracked by the tracker into the grid.": {"zh": "将这个 ForEach 循环添加到 tracker 中，以将每个被 tracker 追踪的 BigDot 放置到网格中。", "tips": ""}, "Step 11": {"zh": "", "tips": ""}, "For each BigDot, you can create a circle view with its offset, color, and scale.": {"zh": "对于每个 BigDot，你可以通过配置它的偏移量、颜色和比例来创建一个圆形视图。", "tips": ""}, "Step 12": {"zh": "", "tips": ""}, "Because every BigDot has five SmallDots, you can do the same thing for the small dots.": {"zh": "因为每个 BigDot 都有五个 SmallDot，所以你可以对小点做同样的事情。", "tips": ""}, "Step 13": {"zh": "", "tips": ""}, "When you tap the play button, the circles animate and the randomizePositions() function is called. This causes the circles’ offsets to change, creating a dancing effect for the dots.": {"zh": "当你点击播放按钮时，圆圈会执行动画，同时 randomizePositions() 函数会被调用。这会导致圆圈的偏移量发生变化，为点创建一个跳舞效果。", "tips": ""}, "Step 14": {"zh": "", "tips": ""}, "Add this isAnimating state property, which calls the resetPositions() method and resets the circle’s positions when you tap Reset.": {"zh": "添加这个 isAnimating 状态属性，它会调用 resetPositions() 方法，并在你点击重置时重置圆圈的位置。", "tips": ""}, "Step 15": {"zh": "", "tips": ""}, "Because everything is animating, adding drawingGroup() helps to make the animation render smoothly.": {"zh": "因为一切内容都在执行动画，所以添加 drawingGroup() 有助于使动画渲染平滑。", "tips": ""}, "Step 16": {"zh": "", "tips": ""}, "Now you know how to create more complex animations with shapes. Time to take what you’ve learned in this guide and use it to make some cool Swift apps!": {"zh": "现在你知道如何使用形状创建更复杂的动画了。现在是时候将你在本指南中学到的知识用于制作一些很酷的 Swift 应用了！", "tips": ""}, "Previewing the Camera Output": {"zh": "预览相机输出", "tips": ""}, "Preview the output from the camera.": {"zh": "预览来自相机的输出。", "tips": ""}, "Rollin Rainbow": {"zh": "", "tips": ""}, "Draggin Drop It": {"zh": "", "tips": ""}}
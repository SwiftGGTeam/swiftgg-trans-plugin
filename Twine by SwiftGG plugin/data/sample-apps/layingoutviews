{"Laying Out Views": {"zh": "布局视图", "tips": ""}, "Organize, size and align view layouts.": {"zh": "组织、调整大小和对齐视图布局。", "tips": ""}, "When creating an app, one of the first skills to learn is how to lay out your user interface, or UI. When laying out a UI, there are three major things you need to do:": {"zh": "当创建一个应用程序时，需要学习的第一个技能就是如何布局用户界面，也就是 UI。当布局一个 UI 时，有三件主要的事情：", "tips": ""}, "Organize your views in different configurations using container views.": {"zh": "使用不同配置的容器视图来组织你的视图。", "tips": ""}, "Fine tune the sizing, spacing, alignment, and positioning of your views.": {"zh": "精细调整视图的大小、间距、对齐和定位。", "tips": ""}, "Debug your views when something goes wrong.": {"zh": "在出现问题时调试视图。", "tips": ""}, "In this sample, you’ll learn all of these skills and more. Ready to start your journey into view layout?": {"zh": "在这个示例中，你将学习以上所有技能以及更多拓展。准备开始你的视图布局之旅了吗?", "tips": ""}, "Organize your views": {"zh": "组织视图", "tips": ""}, "Step 1": {"zh": "第一步", "tips": ""}, "A view can act as a container that holds and organizes other views, known as subviews. The VStack that holds all of your code is an example of a container view that organizes the two shape subviews vertically.": {"zh": "一个视图可以充当容器以容纳和组织其他视图，其被称为子视图。包含你所有代码的 VStack 就是一个垂直组织两个子视图的容器视图的例子。", "tips": ""}, "Step 2": {"zh": "第二步", "tips": ""}, "Shape views expand to fill the entire space that’s offered by the container view. Because there are two shape views that need to share the space in the VStack equally, their sizes adapt accordingly.": {"zh": "形状视图会扩展以填充容器视图提供的所有空间。因为 VStack 中有两个形状视图需要平分空间，它们的大小会相互适应。", "tips": ""}, "Step 3": {"zh": "第三步", "tips": ""}, "You can also organize your views on top of each other using a ZStack. To stack a circle view on top of a rectangle, the views need to be put into a ZStack.": {"zh": "你也可以使用 ZStack 将视图组织在一起。要在矩形视图上面堆叠一个圆形视图，这些视图需要放入一个 ZStack 中。", "tips": ""}, "Step 4": {"zh": "第四步", "tips": ""}, "If you want to organize a pair of circles horizontally, you can use an HStack.": {"zh": "如果你想要水平放置一对圆形，可以使用 HStack。", "tips": ""}, "Step 5": {"zh": "第五步", "tips": ""}, "You may have noticed that you have stacks that contain other stacks. SwiftUI organizes and tracks the relationships of views using a view hierarchy.": {"zh": "你可能已经注意到你有包含其他堆栈的堆栈。SwiftUI 使用视图层次结构来组织和跟踪视图之间的关系。", "tips": ""}, "Step 6": {"zh": "第六步", "tips": ""}, "There are more containers than just HStack, VStack, and ZStack views. To explore different containers and how to use them to lay out your content, see Picking container views for your content": {"zh": "除了 HStack、VStack 和 ZStack 视图，还有更多的容器。要探索不同的容器以及如何使用它们来布局你的内容，请参阅 为你的内容选择容器视图（Picking container views for your content）。", "tips": ""}, "Modify and determine view sizes": {"zh": "修改和确定视图大小", "tips": ""}, "A SwiftUI View determines its size based on the space offered by its container view. That’s why this rectangle is taking up the entire view – because that’s what the parent VStack is doing.": {"zh": "一个 SwiftUI 视图根据其容器视图提供的空间来确定其大小。这就是为什么这个矩形占据了整个视图 - 因为这就是父 VStack 正在做的。", "tips": ""}, "Tip": {"zh": "提示", "tips": ""}, "Different views have different space requirements; not all views take up the same amount of space.": {"zh": "不同的视图有不同的空间要求；并非所有视图都占用相同的空间量。", "tips": ""}, "Note": {"zh": "注意", "tips": ""}, "Often times you need to add size constraints to images since they can be extremely large.": {"zh": "通常需要为图像添加大小约束，因为图像可能非常大。", "tips": ""}, "Because all views are unique, different types of views have their own space requirements within a container. This is why the Rectangle view adjusts how much space it takes up, but the Text and Image only take up as much space as they need.": {"zh": "因为所有视图都是独特的，所以不同类型的视图在容器中的空间需求也不同。这就是为什么 Rectangle 视图占用其所拥有的空间大小，而 Text 和 Image 只占用它们所需的空间。", "tips": ""}, "A view can also maintain a specific size that doesn’t change, like Stepper.": {"zh": "一个视图也可以保持特定的大小不变，比如 Stepper。", "tips": ""}, "To adjust the amount of space views need, you can specify which view needs to take up more space. The frame(width:height:alignment:) allows you to adjust the size of a view. The frame modifier is setting a specific height and width for the rose image view.": {"zh": "要调整视图所需的空间量，可以指定哪个视图需要占用更多空间。frame(width:height:alignment:) 允许调整视图的大小。frame 修饰符正在为 rose 图像视图设置特定的高度和宽度。", "tips": ""}, "Step 7": {"zh": "第七步", "tips": ""}, "Providing fixed values for the width and height limits how adaptive the view can be. 🙃": {"zh": "为宽度和高度提供固定值会限制视图的自适应能力。🙃", "tips": ""}, "A better way to do this is to give a maximum, minimum, or ideal width and height for a view. This allows the view to resize as necessary based on how much space is available in the container.": {"zh": "更好的方法是为视图的宽度和高度提供最大值、最小值或理想值。这允许视图根据容器中可用的空间进行必要的调整大小。", "tips": ""}, "Step 8": {"zh": "第八步", "tips": ""}, "When you use the frame modifer on an Image it only affects the size of the displayed image if you first use the .resizable modifier to indicate that you want the image to be resized as its frame changes.": {"zh": "当你对 Image 使用 frame 修饰符时，如果你先使用 .resizable 修饰符来指明你希望图像随着其 frame 的改变而调整大小，它只会影响显示图像的大小。", "tips": ""}, "Warning": {"zh": "警告", "tips": ""}, "Adding resizable after frame causes a compiler error. Applying the frame modifier to the Image actually creates a new view that’s no longer an Image, so it doesn’t have access to the resizable modifier.": {"zh": "在 frame 之后添加 resizable 会导致编译错误。应用 frame 修饰符实际上会创建一个不再是 Image 的新视图，所以它无法访问 resizable 修饰符。", "tips": ""}, "Step 9": {"zh": "第九步", "tips": ""}, "Using both can help get a precise size for an image that is not distorted or too large.": {"zh": "同时使用两者可以帮助获得具有精确大小的图像，不会变形或过大。", "tips": ""}, "Step 10": {"zh": "第十步", "tips": ""}, "If you want to make the text bigger or different than the default, you can add the font(_:) modifier to your Text view.": {"zh": "如果你想让文本变大或与默认不同，可以给 Text 视图添加 font(:) 修饰符。", "tips": ""}, "If you add the frame to the Text view, the actual text inside the view doesn’t change — it makes the view holding the text larger. This allows for more text to fit into the view.": {"zh": "如果你给 Text 视图添加 frame，实际文本内容不会改变 - 它使文本视图变大。这允许更多文本适应视图。", "tips": ""}, "Refine the spacing and alignment of your views": {"zh": "调整视图的间距和对齐", "tips": ""}, "There are multiple ways to specify alignment in SwiftUI. One way is to specify the alignment inside HStack, VStack, or ZStack. The default alignment for a VStack is centered.": {"zh": "在 SwiftUI 中有多种方式来指定对齐。一种方式是在 HStack、VStack 或 ZStack 中指定对齐。VStack 的默认对齐是居中。", "tips": ""}, "Experiment": {"zh": "实验", "tips": ""}, "Try adding in the alignment: .leading parameter to your VStack and see what happens.": {"zh": "尝试在你的 VStack 中添加 alignment: .leading 参数,看看会发生什么。", "tips": ""}, "Adding the alignment: .leading parameter to your VStack aligns the books to the left edge of the screen. This is because the VStack is the container view and the images and shapes are subviews.": {"zh": "在 VStack 中添加 alignment: .leading 参数会使书对齐到屏幕左侧。这是因为 VStack 是容器视图，图像和形状是子视图。", "tips": ""}, "A different way to add a row of books aligned to the right edge of the shelf is by adding a VStack and setting its alignment to .trailing.": {"zh": "将书对齐到书架右侧的另一种方法是添加 VStack 并将其对齐设置为 .trailing。", "tips": ""}, "In vertical stacks, you can only set the horizontal alignment, like .leading or .trailing.": {"zh": "在垂直堆栈中，你只能设置水平对齐，如 .leading 或 .trailing。", "tips": ""}, "In horizontal stacks you can only set the vertical alignment, like .top or .bottom.": {"zh": "在水平堆栈中你只能设置垂直对齐，如 .top 或 .bottom。", "tips": ""}, "Another way to align books to the other side of the shelf is to use a frame modifier and specify the alignment.": {"zh": "将书对齐到书架另一侧的另一种方法是使用 frame 修饰符并指定对齐方式。", "tips": ""}, "By setting the maxWidth to .infinity, you stretch the Image view horizontally until it fills the remaining space. Setting alignment parameter to .trailing makes the frame contents align to the .trailing edge.": {"zh": "通过将 maxWidth 设置为 .infinity，你可以水平拉伸 Image 视图直到填满剩余空间。将 alignment 参数设置为 .trailing 会使 frame 内容对齐到 .trailing 边缘。", "tips": ""}, "But wait, there’s more! You can also create space in a view with a Spacer.": {"zh": "但是等等！你还可以使用 Spacer 在视图中创建空间。", "tips": ""}, "Add a yellow background color to the image next to the Spacer to visualize how much space it’s creating.": {"zh": "在 Spacer 旁边的图像添加一个黄色背景色，以可视化它创建了多少空间。", "tips": ""}, "Adding a Spacer inside an HStack causes the stack to expand to fill in any remaining horizontal space, and pushes the Image view to the .trailing edge.": {"zh": "在 HStack 中添加 Spacer 会导致堆栈扩展以填充任何剩余的水平空间，并将 Image 视图推到 .trailing 边缘。", "tips": ""}, "The Spacer only fills in the empty space in the HStack. On the contrary, if there is no space available for the spacer, it won’t render.": {"zh": "Spacer 只填充 HStack 中的空白空间。相反，如果没有可用的空间供 spacer 使用，它就不会渲染。", "tips": ""}, "You just learned about three different ways to align your views. Using the alignment parameter in the container view, adding a frame modifier with the alignment parameter and utilizing a Spacer are all great ways to align your views.": {"zh": "你刚才学习了三种不同的方法来对齐你的视图。使用容器视图中的对齐参数、添加具有对齐参数的 frame 修饰符和利用 Spacer 都是用来对齐你的视图的好方法。", "tips": ""}, "Different types of views and circumstances require different techniques. To learn more about the size and spacing of views, see Laying out a simple view.": {"zh": "不同类型的视图和环境需要不同的技术。要了解更多关于视图大小和间距的信息，请参阅 布局一个简单的视图（Laying out a simple view）。", "tips": ""}, "You can also specify the spacing as a parameter for the HStack. This changes the horizontal spacing between every subview inside the HStack.": {"zh": "你也可以将间距作为参数指定给 HStack。这会改变 HStack 中每个子视图之间的水平间距。", "tips": ""}, "Step 11": {"zh": "第 11 步", "tips": ""}, "You can also add padding to the .trailing edge the image view to position it further from the edge.": {"zh": "你也可以在图像视图的 .trailing 边缘添加填充，将其与边缘隔开。", "tips": ""}, "Explore other padding options such as .leading, .top, .bottom, .horizontal, and so on.": {"zh": "尝试其他填充选项，如 .leading、.top、.bottom、.horizontal 等。", "tips": ""}, "Step 12": {"zh": "第 12 步", "tips": ""}, "You could add horizontal padding to every row of shelves and books, but that’s a lot of work and not easy to maintain. Instead, apply modifiers to the container view. In this case, the container is the VStack.": {"zh": "你可以为每个书架和书籍的行添加水平填充，但这需要很多工作且不易维护。相反，你应该将修饰符应用于容器视图。在本例中，容器是 VStack。", "tips": ""}, "By applying the padding modifier to the VStack, you only have to add it once instead of adding it to every subview inside the VStack.": {"zh": "通过将填充修饰符应用到 VStack，你只需要添加一次，而不必将其添加到 VStack 内的每个子视图。", "tips": ""}, "Step 13": {"zh": "第 13 步", "tips": ""}, "However, if you want your bookshelf to have a specific width, use a frame instead of padding. Adding a border after the frame helps you visualize the frame.": {"zh": "然而,如果你希望书架具有特定的宽度，请使用 frame 而不是填充。在 frame 之后添加边框有助于可视化 frame。", "tips": ""}, "Step 14": {"zh": "第 14 步", "tips": ""}, "Woohoo! Now you have all the tools to create your own views.": {"zh": "太棒了！现在你已经掌握了所有创建自己视图的工具。", "tips": ""}, "Debugging views": {"zh": "调试视图", "tips": ""}, "When your SwiftUI views don’t show up as you expect, you’ll need to flex your debugging skills to fix them. Start by looking at the view displayed in the preview — it’s clearly not showing up correctly! 😩 Can you guess what this view is supposed to be?": {"zh": "当你的 SwiftUI 视图没有按预期显示时，你需要发挥调试技巧来解决它们。首先看预览中显示的视图 - 它明显没有正确显示出来！😩 你能猜出这个视图应该是什么吗？", "tips": ""}, "It’s the queen of hearts playing card (or, it’s supposed to be 😵‍💫). As the name suggests, HalfCard contains half a card. You use two HalfCard instances in a VStack to create this view. Then, flip the bottom HalfCard upside down to form a mirror image of the top HalfCard. By combining the top and bottom halves, you create a full playing card.": {"zh": "这是一个红心皇后的扑克牌(或者，应该是一个红心皇后🤔)。顾名思义，HalfCard 包含半张牌。你在 VStack 中使用两个 HalfCard 实例来创建这个视图。然后，将底部的 HalfCard 翻转成顶部 HalfCard 的镜像。通过组合顶部和底部的一半，你可以创建一整张扑克牌。", "tips": ""}, "Any code applied to the HalfCard view affects both the top and bottom halves of the card, allowing you to fix issues in both halves at the same time.": {"zh": "应用于 HalfCard 视图的任何代码都会影响牌的顶部和底部两半，因此可以同时修复两半中的问题。", "tips": ""}, "Adding a border to a view is a great debugging tool because it allows you to see how much space a view occupies. You can use this technique to diagnose lots of issues in your code.": {"zh": "向视图添加边框是很好的调试工具，因为它允许你看到视图占用了多少空间。你可以使用这种技术来诊断代码中的许多问题。", "tips": ""}, "The first major problem here is that all of the graphics are squished together. Add a frame in HalfCard and set the maxWidth and maxHeight to .infinity. This allows the frame to expand to fill any available space offered by the container, VStack.": {"zh": "这里的第一个主要问题是所有图形都被挤在一起。在 HalfCard 中添加 frame 并将 maxWidth 和 maxHeight 设置为 .infinity。这允许 frame 扩展以填充容器 VStack 提供的任何可用空间。", "tips": ""}, "Even though the frame expanded, all of the graphics are still squished together. Add another border above the frame modifier. This allows you to see the outline of the VStack before you apply the frame.": {"zh": "即使 frame 扩展了，所有的图形仍然挤在一起。在 frame 修饰符上面再添加一个边框。这使你可以看到应用 frame 之前 VStack 的轮廓。", "tips": ""}, "You might wonder, why would it make a difference if you apply the border before or after the frame? This is because you actually produce a new view each time you apply a modifier, so the order that you apply them really matters. See Configuring views for more on this.": {"zh": "你可能会想，在 frame 之前或之后添加边框有什么区别？这是因为每次应用修饰符实际上会产生一个新的视图，所以应用它们的顺序真的很重要。更多详细信息，请参阅 配置视图（Configuring views）。", "tips": ""}, "Look at the difference in the blue and green borders. The blue border surrounds the squished graphics in the VStack, but doesn’t expand into the empty surrounding space of the green frame.": {"zh": "看看蓝色和绿色边框的区别。蓝色边框包围着 VStack 中挤在一起的图形，但没有扩展到绿色 frame 周围的空白空间。", "tips": ""}, "Can you think of anyway to fix this so the contents of the VStack fill the entire frame?": {"zh": "你能想到任何方法来修复这个问题，以便 VStack 的内容填充整个 frame 吗？", "tips": ""}, "What if you switched up the order of the overlay and the frame? That would allow you to expand the frame first, which gives you extra space, then apply the overlay where it fits.": {"zh": "如果你改变 overlay 和 frame 的顺序会怎样？这将允许你先扩展 frame，这给了你额外的空间，然后应用适应大小的 overlay。", "tips": ""}, "Try removing the existing frame and add a new one right below the top-level VStack.": {"zh": "尝试删除现有的 frame，并在顶层 VStack 下面添加一个新的。", "tips": ""}, "There is just one more thing to fix. By default any content inside the frame is center-aligned. However, the crown at the center of the HalfCard needs to align to the bottom edge of HalfCard.": {"zh": "只剩下一件事要修复。默认情况下，frame 内的任何内容都是居中对齐的。然而，HalfCard 中心的皇冠需要对齐到 HalfCard 的底边。", "tips": ""}, "Can you figure out a way to make this happen? Remember that you can add a border to visualize how much space your view needs and compare it to how you think the view should behave.": {"zh": "你能想到任何办法来实现这一目的吗？记住，你可以添加边框来可视化你的视图需要多少空间，并将其与你认为的视图应该如何表现进行比较。", "tips": ""}, "There are two ways to align the crown to the bottom of your HalfCard view. You can add the alignment parameter to the frame– .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .bottom) Or, add a Spacer above the crown.": {"zh": "有两种方法可以将皇冠对齐到 HalfCard 视图的底部。你可以在 frame 中添加对齐参数 - .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .bottom) 或者在皇冠上方添加一个 Spacer。", "tips": ""}, "Now that you have fixed the alignment in this card, you can remove any borders that you’ve added.": {"zh": "现在你已经修复了这张牌中的对齐，可以删除你额外添加的边框。", "tips": ""}, "Look at that beautiful playing card! The next time you’re unsure why your views aren’t displaying the way you want them to, don’t forget that you can add a border or background to help you debug issues with your views.": {"zh": "看那漂亮的扑克牌！下次当你不确定视图为什么没有按你想要的方式显示时，不要忘记你可以添加边框或背景来帮助调试视图中的问题。", "tips": ""}, "Bringing it all together": {"zh": "把它们结合在一起", "tips": ""}, "Now that you’ve gone through all of the different parts for laying out a view, it’s time to bring them all together to see how you can use it when creating a view for a real app.": {"zh": "现在你已经遍历了布局视图的不同部分，是时候把它们结合起来，看看在为真实应用程序创建视图时你可以如何使用它。", "tips": ""}, "Start by setting height of your card. There are many different ways to lay out a view and using .frame(minHeight:maxHeight:) is just one way you can set the height.": {"zh": "首先设置卡片的高度。有许多不同的方法可以布局视图，使用 .frame(minHeight:maxHeight:) 只是设置高度的一种方式。", "tips": ""}, "Setting the minHeight and maxHeight allows the view to scale for different screen sizes.": {"zh": "设置 minHeight 和 maxHeight 允许视图根据不同的屏幕尺寸进行缩放。", "tips": ""}, "Push the card title to the edge by setting the maximum height to .infinity.": {"zh": "通过设置最大高度为 .infinity，可以将卡片标题推到边缘。", "tips": ""}, "With the card title aligned, add padding to create space between the title of the view and the edge of the card. By adding padding to the VStack, you are applying padding to every view within the VStack.": {"zh": "对齐卡片标题后，添加填充以在标题和卡片边缘之间创建空间。", "tips": ""}, "Having a .frame modifier with a maxWidth of .infinity stretches the Text view horizontally and fills the available space. The alignment parameter ensures that any content inside the frame aligns to the leading edge.": {"zh": "具有 .frame 修饰符的 Text 视图的 maxWidth 设置为 .infinity 会水平拉伸 Text 视图并填充可用空间。alignment 参数确保 frame 内的任何内容都对齐到 leading 边缘。", "tips": ""}, "You want the emojis to be in the middle of the view. To make sure they aren’t squished in the middle of the view, set the maxWidth to infinity.": {"zh": "你希望表情符号位于视图的中间。为了确保它们不会在视图中间被挤压，请将 maxWidth 设置为 infinity。", "tips": ""}, "To add a gap between the circular buttons and the emojis you need to add padding below the text.": {"zh": "要在圆形按钮和表情符号之间添加间隙，需要在文本下方添加填充。", "tips": ""}, "You are now on your way to being a SwiftUI view layout expert!": {"zh": "你现在在成为 SwiftUI 视图布局专家的路上！", "tips": ""}, "Try it out yourself by going to the Swift Playgrounds App to practice laying out views for a journal app!": {"zh": "尝试着去 Swift Playgrounds App 练习为日记应用布局视图吧！’", "tips": ""}, "Meme Creator": {"zh": "Meme 制作器", "tips": ""}, "Fetch structured data from a server asynchronously.": {"zh": "从服务器异步获取结构化数据。", "tips": ""}, "Notice that there are Text and Image views in your VStack. No matter how big the screen you’re using, the Text and Image views take up exactly the amount of space they need depending on the size of the content.": {"zh": "请注意，VStack 中有 Text 和 Image 视图。无论使用多大的屏幕，Text 和 Image 视图所占用的空间跟内容的大小完全一样。", "tips": ""}, "Views can also resize to fit their content such as Text(“Supercalifragilisticexpialidocious”) or Image(\"myCoolImage\").": {"zh": "视图也可以调整大小以适应其内容，如 Text(“Supercalifragilisticexpialidocious”) 或 Image(\"myCoolImage\")。", "tips": ""}, "Views are somewhat magical, in that certain view types control how they resize when placed in a container. They can expand to fill the available space, such as Rectangle or other Shape.": {"zh": "视图有点神奇，某些视图类型可以控制它们被放置在容器中时如何调整大小。它们可以扩展以填充可用空间，例如 Rectangle 或其他 Shape。", "tips": ""}, "Adding a frame to an image can sometimes cause it to look stretched even by adding an ideal width and height. For images, it’s often better to use scaledToFill() or scaledToFit() instead of a frame.": {"zh": "即使添加了理想的宽度和高度，在图像上添加 frame 有时会导致图像看起来拉伸。对于图像，使用 scaledToFill() 或 scaledToFit() 通常比使用 frame 更好。", "tips": ""}}
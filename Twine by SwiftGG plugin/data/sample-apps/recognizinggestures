{"Recognizing Gestures": {"zh": "识别手势", "tips": ""}, "Update shapes or other content in response to taps, rotations, or other Multi-Touch gestures.": {"zh": "当识别到点击、旋转或其他多点触控手势时，更新形状或其他内容。", "tips": ""}, "Welcome to Recognizing Gestures. In this sample you’ll learn how to add different gestures to your views, like taps, drags, and touch and hold.": {"zh": "欢迎来到识别手势。在本示例中，您将学习如何将不同的手势添加到视图中，例如点击、拖动和触摸并保持。", "tips": ""}, "Start by trying out each gesture in the app preview. When you’re ready, dive into the code walkthrough and learn how to add a gesture to your next project.": {"zh": "你可以通过在预览窗口尝试各种手势来开始。当你准备好之后，就可以深入代码并在下一个项目中学习如何添加手势了", "tips": ""}, "Tap": {"zh": "点击", "tips": ""}, "Explore how to apply different colors to a rectangle when tapped.": {"zh": "探索如何在点击的时候给正方形赋予不同的颜色", "tips": ""}, "Step 1": {"zh": "", "tips": ""}, "In SwiftUI, you can add a gesture directly to a view using a .gesture modifier. Here, you’ll explore how to add a tap gesture to a rectangle view so that it changes color when pressed.": {"zh": "在 SwiftUI 中，你可以使用 .gesture 修饰符直接将手势添加到视图中。在这里，你将探索如何将点击手势添加到矩形视图中，以便在按下时更改颜色。", "tips": ""}, "Step 2": {"zh": "", "tips": ""}, "To set up this tap gesture, you need a @State value, color. When you mark the property with @State, SwiftUI updates all views that use this value any time it changes.": {"zh": "为了设置这个点击手势，你需要一个用 @State 修饰的值，也就是这里的 color 属性。当你使用 @State 标记属性后，SwiftUI 会在该值变化后更新所有使用了这个值的视图", "tips": ""}, "Step 3": {"zh": "", "tips": ""}, "The color value is set as the foreground color of the rectangle. Whenever this value changes, the color of the rectangle updates.": {"zh": "color 变量用于设置矩形的前景色。矩形的颜色会在这个变量变化时更新", "tips": ""}, "Step 4": {"zh": "", "tips": ""}, "This code defines a custom gesture, tapGesture. After you’ve defined a custom gesture, you can attach it to a view using the .gesture modifier.": {"zh": "这段代码定义了一个自定义的手势，点击手势。在你定义了自定义手势后，你就可以使用 .gesture 修饰符将其添加到一个视图上", "tips": ""}, "Step 5": {"zh": "", "tips": ""}, "Your custom gesture uses a TapGesture and defines the event handler for when the tap ends. When the tap ends, you assign a random value to color, and the rectangle automatically updates to reflect the new value.": {"zh": "你的自定义手势使用了 TapGesture 类，并定义了一个点击结束时的事件处理器。当点击结束时，你会给 color 属性设置一个随机的值，并且矩形会自动更新以反映出 color 属性的新值。", "tips": ""}, "Step 6": {"zh": "", "tips": ""}, "By passing tapGesture into the .gesture modifier, the rectangle responds to taps using your custom gesture definition.": {"zh": "通过将 tapGesture 传递给 .gesture 修饰符，矩形会使用你自定义的手势定义来响应点击。", "tips": ""}, "Long Press": {"zh": "长按", "tips": ""}, "Touch and hold to change the shape of a capsule.": {"zh": "触摸并保持以更改胶囊的形状。", "tips": ""}, "In the LongPressView, you’ll change the height and width of a capsule shape every time you touch and hold on the shape.": {"zh": "在 LongPressView 中，你将在每次触摸并保持的时候更改胶囊形状的高度和宽度。", "tips": ""}, "To change the capsule’s size, you’ll iterate through an array of size values. Changes to the @State property sizeIndex updates the capsule to a new size in the array.": {"zh": "为了改变胶囊的大小，你将遍历一个 size 值的数组。对 @State 属性 sizeIndex 的更改会将胶囊更新为数组中的新大小。", "tips": ""}, "Experiment": {"zh": "实验", "tips": ""}, "Try adding a few sizes of your own. Can you make a really big or really tiny capsule?": {"zh": "尝试添加一些自己的尺寸。你能做一个非常大或非常小的胶囊吗？", "tips": ""}, "The capsule shape uses the sizes value in the frame modifier to set its width and height based on the sizeIndex. If the index changes, this view automatically updates to reflect the new size it references in the array.": {"zh": "胶囊形状使用 frame 修饰符中的 sizes 值来根据 sizeIndex 设置其宽度和高度。如果索引发生变化，这个视图会自动更新以反映出它在数组中引用的新大小。", "tips": ""}, "What happens if you set the width’s index to 1 with sizes[1].width? What happens each time you touch and hold on the capsule? Try it before moving on.": {"zh": "如果你使用 sizes[1].width 将宽度的索引设置为 1，会发生什么？每次你触摸并保持胶囊时会发生什么？在继续之前试一试。", "tips": ""}, "Here you define your custom gesture using a LongPressGesture.": {"zh": "这里你使用 LongPressGesture 定义了你的自定义手势。", "tips": ""}, "When the long press gesture ends, iterate to the next index in the array. The value increments by 1 until it reaches the last index (sizes.count) before resetting back to 0.": {"zh": "当长按手势结束时，sizeIndex 会迭代到数组中的下一个索引。该值增加 1，直到它达到最后一个索引（sizes.count），然后重置为 0。", "tips": ""}, "The last step is to apply the long press gesture to the capsule shape using the .gesture modifier. The app calls event handlers from longPressGesture when you touch and hold the capsule.": {"zh": "最后一步是使用 .gesture 修饰符将长按手势应用到胶囊形状上。当你触摸并保持胶囊时，应用程序会通过 longPressGesture 调用事件处理器。", "tips": ""}, "Drag": {"zh": "拖动", "tips": ""}, "Learn how to use a drag gesture to move a circle around the screen.": {"zh": "学习如何使用拖动手势在屏幕上移动一个圆。", "tips": ""}, "In DragView you’ll use a drag gesture to move a circle shape around the view.": {"zh": "在 DragView 中，你将使用拖动手势在视图中移动一个圆形。", "tips": ""}, "To keep track of the circle’s position, the @State variable offset stores a CGSize value. This doesn’t refer to the circle’s size, but is instead used as a distance vector to represent its offset from its starting position in the view.": {"zh": "为了跟踪圆的位置，@State 变量 offset 存储了一个 CGSize 值。这并不是指圆的大小，而是用作距离向量来表示它在视图中的起始位置的偏移量。", "tips": ""}, "Here you pass in offset as the value for the circle view’s .offset modifier. Any change to this value causes SwiftUI to update the position of the circle relative to its original location in the view. As your gesture updates offset, the circle moves around the view.": {"zh": "这里你将 offset 作为圆视图的 .offset 修饰符的值传入。对该值的任何更改都会导致 SwiftUI 更新圆相对于视图中原始位置的位置。当你的手势更新 offset 时，圆会在视图中移动。", "tips": ""}, "Here you define a custom gesture using a DragGesture.": {"zh": "这里你使用 DragGesture 定义了一个自定义手势。", "tips": ""}, "The system calls the .onChanged event handler any time the position of your drag changes. Each time the handler is called, it assigns a new value to offset using the translation property of the drag value.": {"zh": "系统会在拖动位置发生变化时调用 .onChanged 事件处理器。每次调用处理器时，它都会使用拖动值的 translation 属性为 offset 赋一个新值。", "tips": ""}, "Try modifying this formula to see what happens to your circle when you drag it. What happens when you remove the -50 (the radius of the circle) from the width and height? What happens if you remove the start location of the width and height?": {"zh": "尝试修改这个公式，看看当你拖动它时你的圆会发生什么。当你从宽度和高度中删除 -50（圆的半径）时会发生什么？如果你删除宽度和高度的起始位置会发生什么？", "tips": ""}, "To apply the drag gesture to the circle, pass in the dragGesture to the .gesture modifier of the circle.": {"zh": "将拖动手势应用到圆上，将 dragGesture 传入到圆的 .gesture 修饰符中。", "tips": ""}, "Rotate": {"zh": "旋转", "tips": ""}, "Experiment rotating a square using two fingers.": {"zh": "尝试使用两根手指旋转一个正方形。", "tips": ""}, "In RotateView you’ll use a two-finger rotation gesture to rotate a square shape.": {"zh": "在 RotateView 中，你将使用双指旋转手势来旋转一个正方形。", "tips": ""}, "To set up the rotation gesture, you need a starting angle, rotation. This state property enables you to track the change of rotation, and redraws the view every time it changes.": {"zh": "为了设置旋转手势，你需要一个起始角度 rotation。这个状态属性使你能够跟踪旋转的变化，并在每次变化时重新绘制视图。", "tips": ""}, "You pass in rotation as the value for the .rotationEffect modifier, enabling the view to update the rotation angle as the value changes.": {"zh": "你将 rotation 作为 .rotationEffect 修饰符的值传入，使视图能够在值变化时更新旋转角度。", "tips": ""}, "Here you define a custom gesture using a RotationGesture.": {"zh": "这里你使用 RotationGesture 定义了一个自定义手势。", "tips": ""}, "While you rotate the square, the rotation property constantly updates the value of the @State property, rotation. SwiftUI then detects those changes and tells the square to redraw itself.": {"zh": "当你旋转正方形时，rotation 属性不断更新 @State 属性 rotation 的值。SwiftUI 会检测到这些变化，并告诉正方形重新绘制自己。", "tips": ""}, "To capture the gesture’s final value, use the onEnded event handler. This updates rotation with the last value from the gesture and draws the square view to perfectly match the angle of your last movement.": {"zh": "为了捕获手势的最终值，使用 onEnded 事件处理器。这会使用手势的最后一个值更新 rotation，并绘制正方形视图以完美匹配你最后一次移动的角度。", "tips": ""}, "Note": {"zh": "注意", "tips": ""}, "You could remove this whole section of code, and you might not notice any difference when you rotate the square. However, if you record the exact angles, you might notice a small difference between the final angle of your finger movements and the final angle of the square after it stops rotating.": {"zh": "你可以删除这整个代码部分，当你旋转正方形时你可能不会注意到任何不同。然而，如果你记录下确切的角度，你可能会注意到你的手指移动的最终角度和正方形停止旋转后的最终角度之间的微小差异。", "tips": ""}, "Step 7": {"zh": "", "tips": ""}, "The last step required to make this square rotate is to add the .gesture modifier to the square, passing in rotationGesture so it responds to your touch.": {"zh": "最后一步是让这个正方形旋转，将 .gesture 修饰符添加到正方形中，传入 rotationGesture 使它响应你的触摸。", "tips": ""}, "The rotation gesture is only available on Multi-Touch devices (Magic Mouse, Magic Trackpad, MacBook, or iOS devices), and may not be available in some macOS configurations. For more details, see Using Multi-Touch gestures on your Mac.": {"zh": "旋转手势仅适用于多点触摸设备（Magic Mouse、Magic Trackpad、MacBook 或 iOS 设备），并且可能在某些 macOS 配置中不可用。有关更多详细信息，请参阅在 Mac 上使用多点触摸手势。", "tips": ""}, "Line Drawing": {"zh": "线段绘制", "tips": ""}, "Explore how to draw lines onscreen using a drag gesture.": {"zh": "探索如何使用拖动手势在屏幕上绘制线条。", "tips": ""}, "In SingleLine, you’ll use a drag gesture to draw a line in the view. To do this, you’ll create a Path and redraw it every time you initiate a drag event.": {"zh": "在 SingleLine 中，你将使用拖动手势在视图中绘制一条线。为此，你将创建一个 Path，并在每次启动拖动事件时重新绘制它。", "tips": ""}, "This drag gesture needs two state properties: one to track the start of the line, and one to track the end of the line.": {"zh": "这个拖动手势需要两个状态属性：一个用来跟踪线的起点，一个用来跟踪线的终点。", "tips": ""}, "To draw a line, you’ll use a Path, which creates an outline of a shape. First, you’ll move the path to the lineStart value and then you’ll add a line to the lineEnd value. Because each of these values are @State properties, any changes to their data causes SwiftUI to redraw the path and update the view. As a result, you can see the line updating as you drag around the view.": {"zh": "为了绘制一条线，你将使用 Path，它创建了一个形状的轮廓。首先，你将把路径移动到 lineStart 的值，然后你将在 lineEnd 的值上添加一条线。因为这些值都是 @State 属性，所以对它们的数据的任何更改都会导致 SwiftUI 重新绘制路径并更新视图。因此，你可以看到当你在视图周围拖动时，线条在更新。", "tips": ""}, "This drag gesture example uses a DragGesture, just like the other drag gesture example. However, here you need two event handlers: one that’s called as the drag value changes in .onChanged, and the other that’s called when the drag gesture ends in .onEnded.": {"zh": "这个拖动手势示例使用 DragGesture，就像其他拖动手势示例一样。然而，在这里你需要两个事件处理器：一个在 .onChanged 中调用，当拖动值改变时，另一个在 .onEnded 中调用，当拖动手势结束时。", "tips": ""}, "When your device detects a drag gesture, lineStart uses the initial location of the drag, and this value remains constant. However, lineEnd updates with a new location for each .onChanged event sent. This allows the line to redraw, making it look like you’re dragging the end of the line wherever you want it to go.": {"zh": "当你的设备检测到拖动手势时，lineStart 使用拖动的初始位置，这个值保持不变。然而，lineEnd 会使用每个 .onChanged 事件发送的新位置进行更新。这将会让线条重新绘制，使它看起来像你在拖动线条的末端。", "tips": ""}, "The second event handler, .onEnded, captures the last location of your drag and updates the lineEnd property, ensuring your line ends where your touch left the view. After the .onEnded handler recognizes that you’ve stopped drawing, the line stays in place until you start a new drag gesture.": {"zh": "第二个事件处理器 .onEnded 会捕获你拖动的最后位置，并更新 lineEnd 属性，确保你的线条在你的触摸离开视图的地方结束。在 .onEnded 处理程序识别到你已经停止绘制之后，线条会保持在原地，直到你开始一个新的拖动手势。", "tips": ""}, "To assign the gesture, pass in lineDrawingGesture to the .gesture modifier of your Path.": {"zh": "为了让手势生效，将 lineDrawingGesture 传递给 Path 的 .gesture 修饰符。", "tips": ""}, "Animating Shapes": {"zh": "动画形状", "tips": ""}, "Learn how to use shapes and simple animations in SwiftUI.": {"zh": "学习如何在 SwiftUI 中使用形状和简单的动画。", "tips": ""}}
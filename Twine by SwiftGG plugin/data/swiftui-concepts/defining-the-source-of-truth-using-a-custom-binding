{"Defining the source of truth using a custom binding": {"zh": "通过自定义绑定定义数据源", "tips": ""}, "Provide an alternative to a state variable by using a custom binding.": {"zh": "通过使用自定义绑定提供状态变量的替代方案。", "tips": ""}, "The most common way to define a source of truth that binds to other views in your app is to declare a state variable using the State property wrapper. However, there may be those rare occasions when the source of truth is dynamic and can’t be defined using the @State attribute. For instance, this sample app needs to retrieve a recipe as the source of truth using the recipe’s id. The app accomplishes this by creating a computed property that returns a custom binding.": {"zh": "定义与应用中其他视图绑定的数据源的最常见方式是使用 State 属性包装器声明一个状态变量。然而，在一些罕见的情况下，数据源是动态的，不能用 @State 包装器来定义。例如，这个示例应用需要使用配方的 id 来检索一个配方作为数据源。该应用通过创建一个返回自定义绑定的计算属性来实现这一目的。", "tips": ""}, "To experiment with the code, download the project files and open the sample in Xcode.": {"zh": "如果要亲自尝试代码，请下载项目文件，并在Xcode中打开案例。", "tips": ""}, "Specifying the source of truth": {"zh": "指定数据源", "tips": ""}, "This sample app displays the details of a recipe in the custom view DetailView. The view only knows the recipe id, but not the recipe, so it uses the id to retrieve the recipe from the recipe box (a data store that contains all the recipes). Because the view needs to retrieve the recipe, it uses a custom binding as the source of truth of the recipe instead of declaring a state variable for the recipe.": {"zh": "这个示例应用将在自定义视图 DetailView 显示食谱详情。由于视图只知道菜谱的 ID，但不知道菜谱本身的内容，所以它需要使用 ID 从菜谱盒（一个包含所有菜谱的数据存储）中检索菜谱。因为视图需要检索菜谱，所以它使用自定义绑定作为配方的数据源，而不是直接给菜谱声明状态变量。", "tips": ""}, "Note": {"zh": "注释", "tips": ""}, "Using a custom binding is a useful feature of SwiftUI, but isn’t always the best option. Limit its use to use cases where using a state variable or object isn’t possible. In most cases, define the source of truth as either a State variable (for state local to the view) or StateObject (for shared data models) to let SwiftUI manage the value or object for you.": {"zh": "SwiftUI 中的自定义绑定是一个非常有用的功能，但是它并不永远是最好的选择。请仅在无法使用状态变量和状态对象的时候使用它。在大多数情况下，使用 State 变量（当这个状态仅用于当前视图）或 StateObject（用于被多个视图共享的数据模型）让 SwiftUI 管理你的值和状态。", "tips": ""}, "Step 1": {"zh": "第一步", "tips": ""}, "To get the recipe value in the DetailView, this sample implements the computed property recipe instead of declaring a state variable.": {"zh": "为了在 DetailView 中获得菜谱的具体内容， 这个案例将 recipe 设置为计算属性而不是状态变量。", "tips": ""}, "The computed recipe property doesn’t return a Recipe. Instead, it returns a custom Binding of type Recipe. This allows the view to share the recipe as a source of truth with other views.": {"zh": "计算属性的 recipe 并不会返回一个 Recipe。相反，它会返回一个绑定类型为 Recipe 的自定义 Binding。这将允许视图将菜谱视为数据源并与其他视图共享。", "tips": ""}, "Step 2": {"zh": "第二步", "tips": ""}, "A Binding provides read and write access to a value. To provide this access to the recipe value, the computed recipe property uses the init(get:set:) initializer method to create a binding.": {"zh": "Binding 能使一个值变得可读和课写。为了使菜谱值可读可写，计算属性 recipe 使用了 init(get:set:) 初始化器来创建一个绑定。", "tips": ""}, "Step 3": {"zh": "第三步", "tips": ""}, "The binding’s get closure uses recipeId to retrieve a recipe from the data store recipeBox.": {"zh": "绑定的 get 闭包使用 recipeId 来从数据库 recipeBox 中获取一个配方。", "tips": ""}, "If the recipe no longer exists or can’t be found, the closure returns an empty recipe.": {"zh": "如果配方不再存在或无法找到，闭包会返回一个空的配方。", "tips": ""}, "Step 4": {"zh": "第四步", "tips": ""}, "In the set closure, the binding updates the recipe box with the new recipe value, updatedRecipe.": {"zh": "在 set 闭包中，绑定用新的配方值 updateRecipe 来更新菜谱盒。", "tips": ""}, "This update happens any time data changes in the binding’s recipe value; for instance, after a person changes the rating of the recipe.": {"zh": "当绑定的菜谱值发生任何变化的时候，这个更新就会发生。举个例子，当用户改变了菜谱评分，那么就会更新菜谱。", "tips": ""}, "Step 5": {"zh": "第五步", "tips": ""}, "DetailView passes recipe to the RecipeDetailView view as a binding value, which allows the detail view to read and write to the recipe value.": {"zh": "DetailView 将配方作为一个绑定值传递给 RecipeDetailView 视图，这使得这个详情视图可以读取和写入配方值。", "tips": ""}, "Important": {"zh": "重要提示", "tips": ""}, "Because the computed property recipe returns a Binding, it isn’t necessary to include the dollar sign ($) prefix that’s required when passing a state variable as a binding. For state variables — variables defined with a State property wrapper — the dollar sign ($) prefix tells SwiftUI to pass the projectedValue, which is a Binding.": {"zh": "因为计算的属性 recipe 会返回一个绑定，所以没有必要使用在传递状态变量作为绑定时必须的美元符号（$）前缀。对于状态变量--用状态属性包装器定义的变量--美元符号（$）前缀告诉 SwiftUI 传递 projectedValue，其本质是一个 Binding。", "tips": ""}, "Step 6": {"zh": "第六步", "tips": ""}, "The navigationTitle(_:) modifier accepts a string value not a binding to a string value, so the view passes the recipe binding’s wrappedValue.": {"zh": "navigationTitle(_:) 修改器接受的是一个字符串值，而不是对一个字符串值的绑定，所以视图会传递 recipe 绑定的 wrappedValue 值。", "tips": ""}, "A wrappedValue is the underlying value referenced by the binding. Since the computed recipe property returns a binding, its wrapped value is the actual recipe value. So recipe.wrappedValue.title gets the wrappedValue of the recipe binding, then it passes the title property of the recipe value to navigationTitle(_:).": {"zh": "wrappedValue 是绑定所引用的值。由于计算的配方属性返回一个绑定，它的包装值（也就是所引用的值）就是实际的配方值。所以 recipe.wrappedValue.title 得到了 recipe 绑定的 wrappedValue，然后它将配方的标题传递给 navigationTitle(_:)。", "tips": ""}}
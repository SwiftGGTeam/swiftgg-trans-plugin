{"Layering content": {"zh": "内容分层", "tips": ""}, "Define views in an overlay or background to adapt their layout to the primary content.": {"zh": "可以在 overlay 或 background 中定义视图，以使它们的布局适应主要内容。", "tips": ""}, "Designs that layer content often specify that some content stays within the bounds of other content, or maintains a specific margin around that content. You can define these relationships between views with overlay and background modifiers. For example, if your design includes a graphic that provides contrast behind some text, you can define a layout so that the graphic adapts its size and position as the text updates. You can wrap text to fit within the width of another view by defining the text in a background or overlay of that other view.": {"zh": "设计中内容分层的情况通常需要指定某些内容保持在其他内容的边界内，或者在其周围保持一个特定的边距。你可以使用 overlay 和 background 修饰符定义视图之间的这些关系。 例如，如果你的设计中包含一个用来在某些文本后面提供对比度的图形，那么可以定义一个布局，使得该图形随着文本的更新而自适应其大小和位置。 你可以通过将文本定义在另一个视图的 background 或 overlay 中，使其适应该视图的宽度进行换行。", "tips": ""}, "To experiment with the code, download the project files and open the sample in Xcode.": {"zh": "要实践这段代码的话，请下载项目文件并在 Xcode 中打开示例。", "tips": ""}, "Define an overlay": {"zh": "定义一个 overlay", "tips": ""}, "When you arrange content on the z-axis, you can use a ZStack or an overlay or background modifier, like overlay(alignment:content:) or background(_:in:fillStyle:), respectively. A ZStack sizes each view based on the available space, without consideration for the other views in the stack. To specify that the size of some content depends on the size of other content, define this secondary content inside one of the overlay or background modifiers.": {"zh": "当你在z轴上排列内容时，可以使用 ZStack、overlay 修饰符（例如 overlay(alignment:content:)）或 background 修饰符 （例如 background(_:in:fillStyle:)）。 对于堆栈中的每个视图，ZStack 是根据可用空间调整其大小，而不会考虑它与其他视图的关系。 如果要指定某些内容的大小是要取决于其他内容大小的话，可以将这些次要内容定义在 overlay 或 background 修饰符中。", "tips": ""}, "This example presents a photo with a block of text over the lower portion of the photo. To improve readability of the text without completely obscuring that portion of the photo, there’s a mostly transparent background behind the text. The text wraps to fit within the width of the photo. The text’s background sizes to fit around the text. The CaptionedPhoto view arranges the image and provides the text to a Caption view in the image’s overlay(alignment:content:).": {"zh": "这个例子展示了一张照片，照片的下半部分有一块文本。为了在提高文本可读性的同时，又不完全遮挡住照片的这部分内容，文本背后会有一个几乎透明的背景。 文本会自动换行以适应照片的宽度。文本的背景会根据其大小进行调整。CaptionedPhoto 视图会显示照片，并将文本传给一个 Caption 视图，其是在图片的 overlay(alignment:content:) 修饰符中定义的。", "tips": ""}, "Step 1": {"zh": "第一步", "tips": ""}, "CaptionedPhoto is a custom View that defines the layout of a photo and another custom Caption view, which defines the layout of the caption text that appears on top of the image.": {"zh": "CaptionedPhoto 是一个自定义视图，它定义了照片以及另一个自定义 Caption 视图的布局，后者则定义了显示在图片上的标题文本的布局。", "tips": ""}, "Step 2": {"zh": "第二步", "tips": ""}, "This view defines an assetName property to hold the name of the image asset.": {"zh": "这个视图定义了一个 assetName 属性，用于保存图片资源的名称。", "tips": ""}, "Step 3": {"zh": "第三步", "tips": ""}, "This view also defines a captionText property to contain the caption text that it eventually passes along to the Caption view.": {"zh": "这个视图还定义了一个 captionText 属性，用于保存最终传递给 Caption 视图的标题文本。", "tips": ""}, "Step 4": {"zh": "第四步", "tips": ""}, "This Image view initializer retrieves a photo or graphic by name from your app and displays it.": {"zh": "这个 Image 视图的初始化程序，从你 app 中通过传入的名字检索照片或图形，并显示它。", "tips": ""}, "Step 5": {"zh": "第五步", "tips": ""}, "By default, an Image displays an image at its original size. The resizable(capInsets:resizingMode:) and scaledToFit() modifiers adjust this Image to fit within the available space.": {"zh": "默认情况下，Image 视图会以其原始尺寸显示图片。通过使用 resizable(capInsets:resizingMode:) 和 scaledToFit() 修饰符，可以调整 Image 以适应可用空间。", "tips": ""}, "Step 6": {"zh": "第六步", "tips": ""}, "The Caption custom view defines the text and its background.": {"zh": "Caption 自定义视图定义了文本及其背景。", "tips": ""}, "Step 7": {"zh": "第七步", "tips": ""}, "Defining the caption inside overlay(alignment:content:) declares that the caption belongs in front of the image. The size of the primary view limits the size of the overlay(alignment:content:) that modifies the primary view.": {"zh": "在 overlay(alignment:content:) 中定义的 Caption 视图位于图片的上方。父视图的大小限制了作用于父视图的 overlay(alignment:content:) 的大小。", "tips": ""}, "Specifying an alignment of bottom pushes the overlay(alignment:content:) modifier’s contents to the bottom center of the primary view.": {"zh": "通过指定 alignment 参数为 bottom，可以将 overlay(alignment:content:) 修饰符的内容放到父视图的底部中心位置。", "tips": ""}, "Note": {"zh": "注释", "tips": ""}, "An overlay can be smaller than the view it modifies.": {"zh": "一个 overlay 可以比它所修改的视图小。", "tips": ""}, "Step 8": {"zh": "第八步", "tips": ""}, "Clipping the view to a RoundedRectangle rounds the corners of the image without changing its size or position.": {"zh": "将视图剪切为一个 RoundedRectangle，可以在不改变其大小或位置的情况下，将图片的四个角变为圆角。", "tips": ""}, "Experiment": {"zh": "实践", "tips": ""}, "Change the cornerRadius value to a larger number to see its effect on the photo’s corners.": {"zh": "将 cornerRadius 的值更改为较大的数字，以查看其对照片四个角的影响。", "tips": ""}, "Step 9": {"zh": "第九步", "tips": ""}, "This padding(_:_:) puts some space between all four edges of the photo and its containing view.": {"zh": "padding(::) 修饰符在照片的四个边缘和其父视图之间添加了一些间距。", "tips": ""}, "Delete the padding(_:_:) modifier to see how that changes the layout. The padding modifier also appears twice in the Caption view. Remove each of those as well to see how their absence affects the layout.": {"zh": "删除 padding(::) 修饰符来看看布局是如何变化的。padding 修饰符也同样在 Caption 视图中出现了两次。同样地，删除每个修饰符以查看其是如何影响布局的。", "tips": ""}, "Define a background": {"zh": "定义一个 background", "tips": ""}, "The overlay(alignment:content:) on the CaptionedPhoto contains a Caption view to display the caption text.": {"zh": "在 CaptionedPhoto 的 overlay(alignment:content:) 修饰符中包含了一个用于显示标题文本的 Caption 视图。", "tips": ""}, "The Caption view uses the background(_:in:fillStyle:) modifier to place a shape behind the text that partially obscures any content behind it — in this example, the photo — to provide higher contrast for the text.": {"zh": "Caption 视图使用 background(_:in:fillStyle:) 修饰符在文本后面放置了一个形状来遮挡其后面的任何内容（在本例中是照片），以提高文本的对比度。", "tips": ""}, "This padding(_:_:) modifier adds some space between the words and the edges of the contrasting background underneath. The structure of the code matches the visual appearance of the view — the padding is between the text and the background.": {"zh": "padding(::) 修饰符在文本和背景的四条边之间添加一些间距。代码的结构与视图的外观相匹配 - 间距位于文本和背景之间。", "tips": ""}, "Important": {"zh": "重要提示", "tips": ""}, "Choose carefully how to combine padding with an overlay or background modifier. If you pad the primary view before modifying it with the overlay or background, the system uses the size of the padded primary view to calculate the placement of the secondary view. Apply the padding after the overlay or background to put a little space around the view that includes both layers.": {"zh": "在使用 padding 修饰符 与overlay 或 background 修饰符结合时，需要谨慎选择使用的顺序。 如果在使用 overlay 或 background 修饰符之前对主要视图应用 padding 修饰符，系统将使用带有边距的主要视图的大小来计算次要视图的位置。 在 overlay 或 background 修饰符之后应用 padding 的话，会在包含两个图层的视图中留出一些空间。", "tips": ""}, "A background modifier like background(_:in:fillStyle:) is similar to an overlay modifier, in that its content bases its size on the size of the view it modifies. However, a background modifier puts its contents behind the view it modifies, rather than in front.": {"zh": "和 overlay 修饰符类似，background 修饰符（如 background(_:in:fillStyle:)）的内容大小也基于所修改的视图大小。但是 background 修饰符是将其内容放在所修改的视图的背后，而不是在前面。", "tips": ""}, "To provide high contrast whether or not people use Dark Mode, this background(_:in:fillstyle:) modifier uses a custom color with partial opacity.": {"zh": "为了无论用户是否使用黑暗模式都提供高对比度，background(_:in:fillStyle:) 修饰符使用了一个具有一定不透明度的自定义颜色。", "tips": ""}, "The TextContrast color set in this project’s asset catalog defines separate color values for light and dark appearances.": {"zh": "在项目的资源目录中，TextContrast 颜色集分别为不同的外观（明亮和暗黑）定义了颜色值。", "tips": ""}, "RoundedRectangle, as a Shape, accepts whatever size its containing view proposes.": {"zh": "作为一个形状，RoundedRectangle 接受其父视图提供的任何尺寸。", "tips": ""}, "In this case, the background(_:in:fillstyle:) modifier creates that containing view, and any background modifier determines its size from the view it modifies. This results in a RoundedRectangle that is the same size as the padding around the Text view.": {"zh": "在这种例子中，background(_:in:fillStyle:) 修饰符创建了包含 RoundedRectangle 的视图，而任何 background 修饰符都会根据它所修饰的视图确定其大小。 这就导致 RoundedRectangle 的大小与 Text 视图周围的padding相同。", "tips": ""}, "This additional padding(_:_:) around the background adds space between the outside of the Caption view and the container it appears inside; in this case, CaptionedPhoto is the containing view.": {"zh": "在 background 周围添加额外的 padding(::)，会在 Caption 视图的外围和其所在的容器之间增加空间。在这个例子中，CaptionedPhoto 就是容器视图。", "tips": ""}, "Section 1": {"zh": "第一节", "tips": ""}, "The scaled image is the only view at the top level of this body, so the image determines the size of the CaptionedPhoto view. For more information about resizing images, see Fitting images into available space.": {"zh": "对 body 属性返回的视图来说，缩放后的 Image 视图使其顶层中唯一的视图，因此它也决定了 CaptionedPhoto 视图的大小。有关调整图片大小的更多信息，请参阅《Fitting images into available space》。", "tips": ""}, "Section 2": {"zh": "第二节", "tips": ""}}
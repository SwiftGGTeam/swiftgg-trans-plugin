{"To prepare for adding a custom UIPageControl, you need a way to track the current page from within PageView.": {"zh": "要准备添加自定义 UIPageControl，你需要一种从 PageView 中跟踪当前页面的方法。", "tips": ""}, "Next, you’ll create a custom view to present your UIViewControllerRepresentable view.": {"zh": "接下来，你将创建一个自定义视图来呈现你的 UIViewControllerRepresentable 视图。", "tips": ""}, "Because SwiftUI calls this method whenever a page switching animation completes, you can find the index of the current view controller and update the binding.": {"zh": "因为 SwiftUI 会在页面切换动画完成时调用此方法，所以你可以找到当前视图控制器的索引并更新绑定值。", "tips": ""}, "Update the preview provider to pass the required array of views, and the preview starts working.": {"zh": "更新预览提供类并传递所需的视图数组，然后预览将会开始工作。", "tips": ""}, "Step 6": {"zh": "步骤 6", "tips": ""}, "Observe that when you swipe from page to page, the value doesn’t change.": {"zh": "请注意，当你从一页滑动到另一页时，它的值不会改变。", "tips": ""}, "Add an updateUIViewController(_:context:) method that calls setViewControllers(_:direction:animated:) to provide a view controller for display.": {"zh": "添加一个调用了 setViewControllers(_:direction:animated:) 的 updateUIViewController(_:context:) 方法来提供用于显示的视图控制器。", "tips": ""}, "UIViewRepresentable and UIViewControllerRepresentable types have the same life cycle, with methods that correspond to their underlying UIKit types.": {"zh": "UIViewRepresentable 和 UIViewControllerRepresentable 类型具有相同的生命周期，它们具有与其底层 UIKit 类型相对应的方法。", "tips": ""}, "Step 8": {"zh": "步骤 8", "tips": ""}, "With the binding connected in both directions, the text view updates to show the correct page number after each swipe.": {"zh": "通过双向连接的绑定，在每次滑动后文本视图会更新显示正确的页码。", "tips": ""}, "The preview fails because Xcode can’t infer a type for Page.": {"zh": "预览失败，因为 Xcode 无法推断 Page 的类型。", "tips": ""}, "Add a makeUIViewController(context:) method that creates a UIPageViewController with the desired configuration.": {"zh": "添加一个 makeUIViewController(context:) 方法来创建带有我们需要配置的 UIPageViewController。", "tips": ""}, "Interfacing with UIKit": {"zh": "", "tips": ""}, "Section 1": {"zh": "第 1 节", "tips": ""}, "A landmark’s feature image, if it exists, has different dimensions than the regular image.": {"zh": "地标的特征图像（如果存在）与常规图像具有不同的尺寸。", "tips": ""}, "Create a View to Represent a UIPageViewController": {"zh": "创建一个视图来表示 UIPageViewController", "tips": ""}, "Create the View Controller’s Data Source": {"zh": "创建视图控制器的数据源", "tips": ""}, "Replace the text box with the page control, switching from a VStack to a ZStack for layout.": {"zh": "将文本框替换为 PageControl，将布局从 VStack 切换到 ZStack。", "tips": ""}, "Create a nested Coordinator type in PageControl, and add a makeCoordinator() method to create and return a new coordinator.": {"zh": "在 PageControl 中创建一个嵌套的 Coordinator 类型，并添加一个 makeCoordinator() 方法来创建并返回一个新的协调器。", "tips": ""}, "You can use this coordinator to implement common Cocoa patterns, such as delegates, data sources, and responding to user events via target-action.": {"zh": "你可以使用这个协调器来实现常见的 Cocoa 模式，比如委托，数据源以及通过目标 - 动作响应用户事件。", "tips": ""}, "Check Your Understanding": {"zh": "", "tips": ""}, "This tutorial gives you a chance to apply much of what you’ve already learned about SwiftUI, and — with little effort — migrate the Landmarks app to watchOS.": {"zh": "本教程让你有机会应用你已了解的有关 SwiftUI 的大部分知识，并且只需很少的努力即可将 Landmarks 应用程序迁移到 watchOS。", "tips": ""}, "This tutorial shows you how to convert the featured landmark from the home screen to wrap instances of UIPageViewController and UIPageControl. You’ll use UIPageViewController to display a carousel of SwiftUI views, and use state variables and bindings to coordinate data updates throughout the user interface.": {"zh": "本教程向你展示如何将主屏幕上的特色地标转换成为包装 UIPageViewController 和 UIPageControl 的实例。 你将使用 UIPageViewController 来显示 SwiftUI 视图的轮播，并使用状态变量和绑定来协调整个用户界面的数据更新。", "tips": ""}, "Finally, in CategoryHome, replace the placeholder feature image with the new page view.": {"zh": "最后，在 CategoryHome 中，将占位图片替换为新的 PageView。", "tips": ""}, "Overlay text information about the landmark on the image.": {"zh": "在图像上叠加有关地标的文本信息。", "tips": ""}, "Test that the value flows through the binding to the PageViewController by changing its initial value.": {"zh": "通过更改其初始值来测试该值是否通过绑定流向 PageViewController。", "tips": ""}, "Before you continue, prepare a feature card for use as a page.": {"zh": "在继续之前，请准备一张功能卡片视图以用作页面。", "tips": ""}, "Step 3": {"zh": "步骤 3", "tips": ""}, "Add the coordinator as the target for the valueChanged event, specifying the updateCurrentPage(sender:) method as the action to perform.": {"zh": "添加协调器作为 valueChanged 事件的目标，指定 updateCurrentPage(sender:) 方法作为要执行的操作。", "tips": ""}, "Section 2": {"zh": "第 2 节", "tips": ""}, "Add a button to PageView that makes the page view controller jump to the second view.": {"zh": "向 PageView 添加一个按钮，使页面视图控制器跳转到第二个视图。", "tips": ""}, "Initialize an array of controllers in the coordinator using the pages array of views.": {"zh": "使用 pages 视图数组初始化协调器中的控制器数组。", "tips": ""}, "To do this, you’ll declare a @State property in PageView, and pass a binding to this property down to the PageViewController view. The PageViewController updates the binding to match the visible page.": {"zh": "为了做到这种效果，你需要在 PageView 中声明一个 @State 属性，并将对该属性的绑定向下传递到 PageViewController 视图。 PageViewController 更新绑定的值来匹配可见页面。", "tips": ""}, "SwiftUI manages your UIViewControllerRepresentable type’s coordinator, and provides it as part of the context when calling the methods you created above.": {"zh": "SwiftUI 管理你的 UIViewControllerRepresentable 类型的协调器，并在调用你在上面创建的方法时将其作为上下文的一部分提供。", "tips": ""}, "Section 4": {"zh": "第 4 节", "tips": ""}, "Create a PageView group in your project’s Views folder, and add a new Swift file named PageViewController.swift; Declare the PageViewController type as conforming to UIViewControllerRepresentable.": {"zh": "在项目的 Views 文件夹中创建一个 PageView 文件夹，并添加一个名为 PageViewController.swift 的新 Swift 文件； 将 PageViewController 类型声明为符合 UIViewControllerRepresentable 协议。", "tips": ""}, "Now try out all the different interactions — PageView shows how UIKit and SwiftUI views and controllers can work together.": {"zh": "现在尝试一下所有不同的交互效果——PageView 展示了 UIKit 和 SwiftUI 视图和控制器如何协同工作。", "tips": ""}, "Step 7": {"zh": "步骤 7", "tips": ""}, "Step 5": {"zh": "步骤 5", "tips": ""}, "SwiftUI works seamlessly with the existing UI frameworks on all Apple platforms. For example, you can place UIKit views and view controllers inside SwiftUI views, and vice versa.": {"zh": "SwiftUI 可以与所有 Apple 平台上的现有 UI 框架无缝协作。 例如，你可以将 UIKit 视图和视图控制器放置在 SwiftUI 视图中，反之亦然。", "tips": ""}, "These two methods establish the relationships between view controllers, so that you can swipe back and forth between them.": {"zh": "这两种方法建立视图控制器之间的关系，让你可以在它们之间来回滑动。", "tips": ""}, "The page view controller stores an array of Page instances, which must be a type of View. These are the pages you use to scroll between landmarks.": {"zh": "页面视图控制器存储一个 Page 实例数组，它必须是 View 类型。 这些是你用来在滚动切换地标的页面。", "tips": ""}, "Tip": {"zh": "提示", "tips": ""}, "Add a Custom Page Control": {"zh": "添加自定义页面控件", "tips": ""}, "Add another method to PageViewController to make the coordinator.": {"zh": "向 PageViewController 添加另一个方法来创建协调器。", "tips": ""}, "Because UIControl subclasses like UIPageControl use the target-action pattern instead of delegation, this Coordinator implements an @objc method to update the current page binding.": {"zh": "因为像 UIPageControl 这样的 UIControl 子类使用目标-动作模式而不是代理模式，所以这个 Coordinator 实现了一个@objc 方法来更新当前页面绑定。", "tips": ""}, "Create a new SwiftUI view file, named PageControl.swift. Update the PageControl type to conform to the UIViewRepresentable protocol.": {"zh": "创建一个新的 SwiftUI 视图文件，命名为 PageControl.swift。 更新 PageControl 类使它遵循 UIViewRepresentable 协议。", "tips": ""}, "You’re ready to add a custom UIPageControl to your view, wrapped in SwiftUI UIViewRepresentable view.": {"zh": "你已准备好将自定义 UIPageControl 添加到你的视图，包装在 SwiftUI UIViewRepresentable 视图中。", "tips": ""}, "Add a text view with the currentPage property, so that you can keep an eye on the @State property’s value.": {"zh": "添加具有 currentPage 属性的文本视图，以便你可以观察 @State 属性的值。", "tips": ""}, "In addition to declaring the @Binding property, you also update the call to setViewControllers(_:direction:animated:), passing the value of the currentPage binding.": {"zh": "除了声明 @Binding 属性之外，你还将更新对 setViewControllers(_:direction:animated:) 的调用，传递了 currentPage 的值进行绑定。", "tips": ""}, "Follow the steps to build this project, or download the finished project to explore on your own.": {"zh": "按照步骤构建此项目，或下载已完成的项目来自行探索。", "tips": ""}, "SwiftUI calls this method a single time when it’s ready to display the view, and then manages the view controller’s life cycle.": {"zh": "SwiftUI 在准备好显示视图时会调用此方法一次，然后管理视图控制器的生命周期。", "tips": ""}, "Return to PageView, turn on live previews, and test out the swipe interactions.": {"zh": "返回 PageView，打开实时预览，并测试滑动交互。", "tips": ""}, "Remember to use the $ syntax to create a binding to a value that is stored as state.": {"zh": "请记住使用 $ 语法设置带 @State 属性的值。", "tips": ""}, "For now, you create the UIHostingController that hosts the page SwiftUI view on every update. Later, you’ll make this more efficient by initializing the controller only once for the life of the page view controller.": {"zh": "现在，你在每次更新时都创建托管 SwiftUI 视图的 UIHostingController。稍后，将通过仅在页面视图控制器的生命周期内初始化一次控制器来提高效率。", "tips": ""}, "Step 2": {"zh": "步骤 2", "tips": ""}, "In a few short steps, you’ve done a lot — the PageViewController uses a UIPageViewController to show content from a SwiftUI view. Now it’s time to enable swiping interactions to move from page to page.": {"zh": "在几个简短的步骤中，你已经完成了很多工作 —— PageViewController 使用 UIPageViewController 来显示来自 SwiftUI 视图的内容。 现在是时候启用滑动交互以从一个页面移动到另一个页面了。", "tips": ""}, "Creating a watchOS App": {"zh": "", "tips": ""}, "Assign the coordinator as the delegate for the UIPageViewController, in addition to the data source.": {"zh": "除了数据源之外，还将协调器指定为 UIPageViewController 的委托。", "tips": ""}, "To represent UIKit views and view controllers in SwiftUI, you create types that conform to the UIViewRepresentable and UIViewControllerRepresentable protocols. Your custom types create and configure the UIKit types that they represent, while SwiftUI manages their life cycle and updates them when needed.": {"zh": "要在 SwiftUI 中展示 UIKit 视图和视图控制器，你可以创建符合 UIViewRepresentable 和 UIViewControllerRepresentable 协议的类。 然后用你自定义的类创建和配置它们所表示的 UIKit 类型，而 SwiftUI 管理它们的生命周期并在需要时更新它们。", "tips": ""}, "Next, add the two requirements for the UIViewControllerRepresentable protocol.": {"zh": "接下来，添加 UIViewControllerRepresentable 协议的两个要求。", "tips": ""}, "Because you’re passing the page count and the binding to the current page, the page control is already showing the correct values.": {"zh": "因为你已经将页数和当前定位传递到当前页面，所以页面控件已经显示了正确的值。", "tips": ""}, "Track the Page in a SwiftUI View’s State": {"zh": "在 SwiftUI 视图的状态中跟踪页面变化", "tips": ""}, "A SwiftUI view that represents a UIKit view controller can define a Coordinator type that SwiftUI manages and provides as part of the representable view’s context.": {"zh": "表示 UIKit 视图控制器的 SwiftUI 视图可以定义一个 Coordinator 类型，这个视图由 SwiftUI 管理并作为可呈现视图上下文的一部分", "tips": ""}, "Experiment": {"zh": "实验", "tips": ""}, "In PageViewController.swift, conform the coordinator to UIPageViewControllerDelegate, and add the pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted completed: Bool) method.": {"zh": "在 PageViewController.swift 中，使协调器符合 UIPageViewControllerDelegate 协议，并添加 pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted completed: Bool) 方法。", "tips": ""}, "Add the coordinator as the data source of the UIPageViewController.": {"zh": "添加协调器作为 UIPageViewController 的数据源。", "tips": ""}, "Declare the @State variable in PageView, and pass a binding to the property when creating the child PageViewController.": {"zh": "在 PageView 中声明 @State 变量，并在创建子 PageViewController 时将该属性传进去。", "tips": ""}, "Start by adding a currentPage binding as a property of PageViewController.": {"zh": "首先为 PageViewController 添加一个 currentPage 绑定属性。", "tips": ""}, "SwiftUI calls this makeCoordinator() method before makeUIViewController(context:), so that you have access to the coordinator object when configuring your view controller.": {"zh": "SwiftUI 在 makeUIViewController(context:) 之前调用此 makeCoordinator() 方法，这样在配置视图控制器时就可以访问协调器对象。", "tips": ""}, "Create a new SwiftUI view file, named PageView.swift, and update the PageView type to declare PageViewController as a child view.": {"zh": "创建一个新的 SwiftUI 视图文件，命名为 PageView.swift，并更新 PageView 类，将 PageViewController 声明为子视图。", "tips": ""}, "Step 4": {"zh": "步骤 4", "tips": ""}, "Declare a nested Coordinator class inside PageViewController.": {"zh": "在 PageViewController 中声明一个嵌套的 Coordinator 类。", "tips": ""}, "Add UIPageViewControllerDataSource conformance to the Coordinator type, and implement the two required methods.": {"zh": "将 UIPageViewControllerDataSource 协议添加到 Coordinator 类，并实现两个必需的方法。", "tips": ""}, "Next, make the page control interactive so users can tap one side or the other to move between pages.": {"zh": "接下来，使页面控件能够进行交互，以便用户可以点击一侧或另一侧以在页面之间移动。", "tips": ""}, "Step 9": {"zh": "步骤 9", "tips": ""}, "Section 3": {"zh": "第 3 节", "tips": ""}, "Step 1": {"zh": "步骤 1", "tips": ""}, "Add a computed property to the Landmark structure that returns the feature image, if it exists.": {"zh": "将计算属性添加到 Landmark 结构体（如果存在），这个属性返回地标的特征图像 。", "tips": ""}, "Important": {"zh": "重要的", "tips": ""}, "The coordinator is a good place to store these controllers, because the system initializes them only once, and before you need them to update the view controller.": {"zh": "协调器是存储这些控制器的好地方，因为系统只初始化它们一次，并且是在你需要它们更新视图控制器之前。", "tips": ""}, "Drag the images in the downloaded project files’ Resources directory into your app’s Asset catalog.": {"zh": "将下载的项目文件的 Resources 目录中的图像拖到应用程序的 Asset 目录中。", "tips": ""}, "Add a new SwiftUI view file, named FeatureCard.swift that displays the landmark’s feature image.": {"zh": "添加一个名为 FeatureCard.swift 的新 SwiftUI 视图文件，用于显示地标的特征图像。", "tips": ""}}
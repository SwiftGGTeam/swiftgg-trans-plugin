{"Adding 3D content to your app": {"zh": "为 App 增添 3D 内容", "tips": ""}, "Add depth and dimension to your visionOS app and discover how to incorporate your app’s content into a person’s surroundings.": {"zh": "在你的 visionOS App 中添加“深度”——这个第三个维度（ z 轴），以及了解如何将你的应用程序融入到用户的周围环境中。", "tips": "译者注： depth ，这里翻译成“深度”，即为空间深度，也叫纵深。是物体在空间距离下，产生的视觉焦点，并导致所有物体围绕这个焦点聚拢的聚焦方式。通俗讲就是人在一副画面中感觉到的强烈的远近对比。所以，用户通过纵深来营造画面的立体感。"}, "Overview": {"zh": "概述", "tips": ""}, "A device with a stereoscopic display lets people experience 3D content in a way that feels more real. Content appears to have real depth, and people can view it from different angles, making it seem like it’s there in front of them.": {"zh": "立体显示可以让人感受到更真实的 3D 内容。 3D 内容增添让人感觉更加真实的视觉深度，用户可以从不同角度观看，仿佛这些内容真的就在他们的面前。", "tips": ""}, "When building an app for visionOS, think about ways you might add depth to your app’s interface. The system provides several ways to display 3D content, including in your existing windows, in a volume, and in an immersive space. Choose the options that work best for your app and the content you offer.": {"zh": "在构建 visionOS 应用程序，就要考虑在你的应用程序中添加深度（ z 轴）这个纬度。系统提供了多种方式展示 3D 内容，包括在已有的 2D 窗口( window )，立体窗口( volume )，或者虚拟空间( ImmersiveSpace )。 根据你 App 中内容选择最适合展示方式。", "tips": ""}, "Add depth to traditional 2D windows": {"zh": "在二维平面窗口添加深度（ z 轴）维度", "tips": ""}, "Windows are an important part of your app’s interface. With visionOS, apps automatically get materials with the visionOS look and feel, fully resizable windows with spacing tuned for eyes and hands input, and access to highlighting adjustments for your custom controls.": {"zh": "二维平面窗口( window )是应用程序界面的重要组成部分。 visionOS 系统下的应用软件界面可自动获得 visionOS 系统风格元素，并且可紧紧跟随用户手和眼的移动，灵活地调整窗口的大小，同时突出显示你的自定义控件。", "tips": ""}, "Incorporate depth effects into your custom views as needed, and use 3D layout options to arrange views in your windows.": {"zh": "根据需求在你的自定义视图中添加 深度效应，并使用下面这些 3D 布局选项在你的二维平面窗口( window )中摆设视图( view )。", "tips": ""}, "Apply a shadow(color:radius:x:y:) or visualEffect(_:) modifier to the view.": {"zh": "使用 shadow(color:radius:x:y:) 或者 visualEffect(_:) 修改视图( view )显示外观，使其更具有深度效果。", "tips": ""}, "Lift or highlight the view when someone looks at it using a hoverEffect(_:isEnabled:) modifier.": {"zh": "使用 hoverEffect(_:isEnabled:) 方法，使视图( view )能够以突出移动或高亮的方式响应用户视线关注。", "tips": ""}, "Lay out views using a ZStack.": {"zh": "使用 ZStack 在 Z 轴(深度维度)布局视图( view )。", "tips": ""}, "Animate view-related changes with transform3DEffect(_:).": {"zh": "使用 transform3DEffect(_:) ，为视图( view )变化添加 3D 动画效果。", "tips": ""}, "Rotate the view using a rotation3DEffect(_:axis:anchor:anchorZ:perspective:) modifier.": {"zh": "使用 rotation3DEffect(_:axis:anchor:anchorZ:perspective:) 来旋转视图。", "tips": ""}, "In addition to giving 2D views more depth, you can also add static 3D models to your 2D windows. The Model3D view loads a USDZ file or other asset type and displays it at its intrinsic size in your window. Use this in places where you already have the model data in your app, or can download it from the network. For example, a shopping app might use this type of view to display a 3D version of a product.": {"zh": "另外，你也可以在二维平面窗口( window )添加静态 3D 模型，来为 2D 视图( view )增加视觉深度。 Model3D 视图类型可以加载 USDZ 文件，或者以 Asset 方式加载，并在窗口( window )以文件的固有尺寸展示。通过这种方式展示 3D 内容，前提是你已经有了可展示的模型数据，模型数据可以是放在 App 本地，或者通过网络加载。例如，电商类的 App 可以使用 Model3D 类型视图来展示商品的 3D 效果。", "tips": ""}, "Display dynamic 3D scenes using RealityKit": {"zh": "使用 RealityKit 展示动态的 3D 场景", "tips": ""}, "RealityKit is Apple’s technology for building 3D models and scenes that you update dynamically onscreen. In visionOS, use RealityKit and SwiftUI together to seamlessly couple your app’s 2D and 3D content. Load existing USDZ assets or create scenes in Reality Composer Pro that incorporate animation, physics, lighting, sounds, and custom behaviors for your content. To use a Reality Composer Pro project in your app, add the Swift package to your Xcode project and import its module in your Swift file. For for information, see Managing files and folders in your Xcode project.": {"zh": "RealityKit 是苹果为构建 3D 模型，以及在屏幕中动态更新场景，而开发的框架。在 visionOS 系统中，可以同时使用 RealityKit 和`SwiftUI 将 App 中 2D 和 3D 内容丝滑的融合起来。加载现有的 USDZ Assets，或者使用 Reality Composer Pro，为你的 App 内容，创建一个富有动画，符合物理特性，有光影效果，音效，和自定义行为的场景。以 Swift Package 方式将 Reality Composer Pro project 添加关联到你的 Xcode 项目中，然后在你的 Xcode 项目 Swift 代码中，使用 import ModuleName 方式引用。(和使用和苹果其他 Framework 一样，用 ModuleName 来引用)。更多关于怎样管理项目文件，请参照 Managing files and folders in your Xcode project 。", "tips": "译者推荐：更多关于 Creating 3D Content with Reality Composer 文档 和  Meet Reality Composer Pro 视频。"}, "When you’re ready to display 3D content in your interface, use a RealityView. This SwiftUI view serves as a container for your RealityKit content, and lets you update that content using familiar SwiftUI techniques.": {"zh": "使用 RealityView 在用户界面中展示 3D 内容。这个 SwiftUI 就像是一个盛放 RealityKit 内容(就是 3D 内容)的容器，接下来你可以使用熟悉的 SwiftUI 技术更新 3D 内容。", "tips": ""}, "The following example shows a view that uses a RealityView to display a 3D sphere. The code in the view’s closure creates a RealityKit entity for the sphere, applies a texture to the surface of the sphere, and adds the sphere to the view’s content.": {"zh": "下面的示例代码展示了在视图( view )中使用 RealityView 展示一个 3D 球体。在视图( view )的闭包中创建一个表面光滑的 RealityKit 球体，然后把球体添加到视图( view )中。", "tips": ""}, "When SwiftUI displays your RealityView, it executes your code once to create the entities and other content. Because creating entities is relatively expensive, the view runs your creation code only once. When you want to update the state of your entities, change the state of your view and use an update closure to apply those changes to your content. The following example uses an update closure to change the size of the sphere when the value in the scale property changes:": {"zh": "当 SwiftUI 要显示 RealityView 时，它只会执行一次闭包的代码来创建实体和其他内容。因为 3D 实体创建相当的消耗性能，所以视图( view )只会执行一次创建代码。当需要更新 3D 实体显示状态时，那么就改变相应视图( view )的显示状态，并通过更新闭包来实现显示内容的变化。下面的示例代码，在更新闭包中，通过改变模型的 transform.scale 属性来改变球体的大小：", "tips": ""}, "For information about how to create content using RealityKit, see RealityKit.": {"zh": "更多关于如何使用 RealityKit 创建 3D 内容的，请参照 RealityKit 。", "tips": ""}, "Respond to interactions with RealityKit content": {"zh": "如何响应与 RealityKit 内容的交互", "tips": ""}, "To handle interactions with the entities of your RealityKit scenes:": {"zh": "处理与 RealityKit 场景里实体的交互：", "tips": ""}, "Attach a gesture recognizer to your RealityView and add the targetedToAnyEntity() modifier to it.": {"zh": "创建手势识别器 TapGesture ，然后通过 targetedToAnyEntity() 修改手势识别器参数，并将手势识别器添加到 RealityView 上。", "tips": ""}, "Attach an InputTargetComponent to the entity or one of its parent entities.": {"zh": "在实体或者父实体中添加 InputTargetComponent 实例。", "tips": ""}, "Add collision shapes to the RealityKit entities that support interactions.": {"zh": "给 RealityKit 实体添加触摸形状，让它支持交互。", "tips": ""}, "The targetedToAnyEntity() modifier provides a bridge between the gesture recognizer and your RealityKit content. For example, to recognize when someone drags an entity, specify a DragGesture and add the modifier to it. When the specified gesture occurs on an entity, SwiftUI executes the provided closure.": {"zh": "targetedToAnyEntity() 修改器是链接手势识别器和 RealityKit 内容的桥梁。例如，创建 DragGesture 手势，通过手势修饰符设置参数和响应闭包，然后把手势添加到实体上，这样实体就可以响应用户的拖拽。当实体有了手势识别器， SwiftUI 执行提供的响应闭包中的代码。", "tips": ""}, "The following example adds a tap gesture recognizer to the sphere view from the previous example. The code also adds InputTargetComponent and CollisionComponent components to the shape to allow the interactions to occur. If you omit these components, the view doesn’t detect the interactions with your entity.": {"zh": "下面的示例代码是在前面的例子的基础上给 SphereView 添加手势识别器。同时也在模型中添加 InputTargetComponent 和相应触摸形状的 CollisionComponent ，这样实体便能够进行交互。如果不添加这些组件，视图( view )不会把交互事件分发到相应的实体上。", "tips": ""}, "Display 3D content in a volume": {"zh": "在三维立体窗口( volume )中展示 3D 内容", "tips": ""}, "A volume is a type of window that grows in three dimensions to match the size of the content it contains. Windows and volumes both accommodate 2D and 3D content, and are alike in many ways. However, windows clip 3D content that extends too far from the window’s surface, so volumes are the better choice for content that is primarily 3D.": {"zh": "三维立体窗口( volume )是一种有三个维度窗口(即 volumetric window)，它符合显示 3D 内容需求。二维平面窗口( window )和三维立体窗口( volume )均可容纳 2D 和 3D 内容，而且它们有许多相似之处。然而，二维平面窗口( window )会把超出显示区域太多的 3D 内容剪切掉，所以，对于以显示 3D 为主的内容，三维立体窗口( volume )是更好的选择。", "tips": ""}, "To create a volume, add a WindowGroup scene to your app and set its style to volumetric. This style tells SwiftUI to create a window for 3D content. Include any 2D or 3D views you want in your volume. You can also add a RealityView to build your content using RealityKit. The following example creates a volume with a static 3D model of some balloons stored in the app’s bundle:": {"zh": "在App中添加 WindowGroup Scene，并将 windowStyle 设置为 volumetric ，这样就创建了一个三维立体窗口( volume )。这种 windowStyle 指定 SwiftUI 创建一个显示 3D 内容的 window 。三维立体窗口( volume )既可以包含 2D 视图，也可以包含 3D 视图。所以，你可以使用 RealityKit 创建 RealityView 实例，来构造 App 内容。下面的例子代码，使用应用包( App Bundle )中的 balloons 静态 3D 模型为内容创建一个三维立体窗口( volume )：", "tips": ""}, "Windows and volumes are a convenient way to display bounded 2D and 3D content, but your app doesn’t control the placement of that content in the person’s surroundings. The system sets the initial position of each window and volume at display time. The system also adds a window bar to allow someone to reposition the window or resize it.": {"zh": "使用二维平面窗口( window )和三维立体窗口( volume )展示有限的 2D 和 3D 内容是一种很便捷的方式，但是同时，你就不能在控制你要显示的内容在用户周围环境中的位置。系统会在要显示二维平面窗口( window )和三维立体窗口( volume )的时候设置其初始位置。系统也会为其添加一个工具栏( window bar )，以便用户移动或者缩放窗口。", "tips": ""}, "For more information about when to use volumes, see Human Interface Guidelines > Windows.": {"zh": "了解更多关于“什么情况下使用三维立体窗口( volume )”，参照 Human Interface Guidelines > Windows", "tips": ""}, "Display 3D content in a person’s surroundings": {"zh": "在用户周围环境中的展示 3D 内容", "tips": ""}, "When you need more control over the placement of your app’s content, add that content to an ImmersiveSpace. An immersive space offers an unbounded area for your content, and you control the size and placement of content within the space. After receiving permission from the user, you can also use ARKit with an immersive space to integrate content into their surroundings. For example, you can use ARKit scene reconstruction to obtain a mesh of furniture and nearby objects and have your content interact with that mesh.": {"zh": "当你需要定义 App 内容所要展示的位置，那么就使用 ImmersiveSpace 展示相应内容。沉浸式空间( immersive space )提供无限区域来展示你的 3D 内容，并且在这个空间里你可以控制 3D 内容的大小和位置。在获得用户许可后，你还可以将 ARKit 与沉浸式空间( immersive space )结合使用，将内容整合到用户周围的环境中。例如，你可以使用 ARKit 场景重建来获取家具和附近物体的三维网格结构，并让你的内容与该三维网格结构进行相互融合。", "tips": ""}, "An ImmersiveSpace is a scene type that you create alongside your app’s other scenes. The following example shows an app that contains an immersive space and a window:": {"zh": "ImmersiveSpace 是一种特定类型的 Scene ，可以和 App 中其他的 Scene 一起创建。下面的例子展示了包含了沉浸式空间( immersive space )和普通窗口( window )的 App 的代码：", "tips": ""}, "If you don’t add a style modifier to your ImmersiveSpace declaration, the system creates that space using the mixed style. This style displays your content together with the passthrough content that shows the person’s surroundings. Other styles let you hide passthrough to varying degrees. Use the immersionStyle(selection:in:) modifier to specify which styles your space supports. If you specify more than one style, you can toggle between the styles using the selection parameter of the modifier.": {"zh": "如果在创建 ImmersiveSpace 时没有制定类型，系统会默认创建一个 mixed 类型的空间。这个类型会将你的内容和贯穿用户周围环境的内容融合在一起展示。其他沉浸类型会不同程度的隐藏周围环境内容。调用 immersionStyle(selection:in:) 指定你的空间支持什么沉浸类型。如果指定了多个样式，则可以使用修改器的 selection 参数在样式之间切换。", "tips": ""}, "Warning": {"zh": "警告", "tips": ""}, "Be mindful of how much content you include in immersive scenes that use the mixed style. Content that fills a significant portion of the screen, even if that content is partially transparent, can prevent the person from seeing potential hazards in their surroundings. If you want to immerse the person in your content, configure your space with the full style. For more information, see, Creating fully immersive experiences in your app.": {"zh": "请注意一下在沉浸式场景( immersive scenes )中有多少内容使用 mixed 类型。因为如果 3D 内容占满屏幕很大一部分的，即使可以看见部分周围环境，也可能使用户完全无法看到周围环境中的潜在危险。如果想让用户完全沉浸在你的内容中，请使 full 配置你的空间。如需了解更多信息，请参阅 Creating fully immersive experiences in your app 。", "tips": ""}, "Remember to set the position of items you place in an ImmersiveSpace. Position SwiftUI views using modifiers, and position a RealityKit entity using its transform component. SwiftUI places the origin of a space at a person’s feet initially, but can change this origin in response to other events. For example, the system might shift the origin to accommodate a SharePlay activity that displays your content with Spatial Personas. If you need to position SwiftUI views and RealityKit entities relative to one another, perform any needed coordinate conversions using the methods in the content parameter of RealityView.": {"zh": "记得在 ImmersiveSpace 中设置实体的位置。 SwiftUI 中，通过相应的修改器 position(x:y:) 、 position(_:CGPoint) 设置视图的位置，对于 RealityKit 实体，则是通过设置 transform 相关的属性，来设置实体的位置。SwiftUI 会以用户所站的位置作为空间原点初始位置，但是原点位置可以随其他事件而改变。例如，当需要同时展示有用户虚拟角色的 SharePlay Activity 和 你的 3D 内容时，系统会平移你的空间原点的位置。如果需要对 SwiftUI 视图和 RealityKit 实体进行相对定位，请使用 RealityView 和 RealityViewContent 的参数和方法来实现所需的坐标转换。", "tips": "译者注：这里将 Spatial Personas 翻译为“用户虚拟角色”，是用户的拟真形象，是苹果的一项新技术。更多关于 SharePlay activity 和 Spatial Personas，可以通过 Design spatial SharePlay experiences 视频了解。"}, "To display your ImmersiveSpace scene, open it using the openImmersiveSpace action, which you obtain from the SwiftUI environment. This action runs asynchronously and uses the provided information to find and initialize your scene. The following example shows a button that opens the space with the solarSystem identifier:": {"zh": "在 SwiftUI 环境中，通过 openImmersiveSpace 方法，显示你的 ImmersiveSpace Scene。系统会异步执行这个方法，并通过已有的信息初始化你的 Scene 。下列实例代码展示了点击按钮，通过 solarSystem 的唯一标识符打开这个虚拟空间。", "tips": ""}, "When an app presents an ImmersiveSpace, the system hides the content of other apps to prevent visual conflicts. The other apps remain hidden while your space is visible but return when you dismiss it. If your app defines multiple spaces, you must dismiss the currently visible space before displaying a different space. If you don’t dismiss the visible space, the system issues a runtime warning when you try to open the other space.": {"zh": "当应用程序展示一个虚拟空间—— ImmersiveSpace 时，系统为了防止视觉冲突会隐藏其他 App 的内容。当你的虚拟空间展示着的时候，其他应用程序会一直被隐藏着，直到用户退出了你的虚拟空间，其他应用程序才会恢复显示。当你没有退出当前显示的虚拟空间，而去打开另一个虚拟空间，系统就会抛出一个运行时的错误。", "tips": ""}}
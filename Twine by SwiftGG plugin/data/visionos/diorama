{"Diorama": {"zh": "西洋镜", "tips": ""}, "Design scenes for your visionOS app using Reality Composer Pro.": {"zh": "使用 Reality Composer Pro 设计 visionOS 应用中的场景。", "tips": ""}, "Overview": {"zh": "概览", "tips": ""}, "Use Reality Composer Pro to compose, edit, and preview RealityKit content for your visionOS app. In your Reality Composer Pro project, you can create one or more scenes, each of which contains a hierarchy of virtual objects called entities that your app can efficiently load and display.": {"zh": "VisionOS 应用程序使用 RealityKit 展示的虚拟现实内容，可以通过 Reality Composer Pro 来构建，编辑，预览。在 Reality Composer Pro 项目中，可以创建多个场景，每个场景通过层次结构组织虚拟对象（也就是实体），这样你的应用程序可以高效率地加载显示虚拟现实内容。", "tips": ""}, "In addition to helping you compose entity hierarchies, Reality Composer Pro also gives you the ability to add and configure components — even custom components that you’ve written — to the entities in your scenes.": {"zh": "另外，在 Reality Composer Pro 中也可以为场景中的实体（ Entity ）增加和配置组件（ Component ）—— 也包括自定义的组件，这样可以帮助你构建实体的层次结构。", "tips": ""}, "You can also design the visual appearance of entities using Shader Graph, a node-based visual tool for creating RealityKit materials. Shader Graph gives you a tremendous amount of control over the surface details and shape of entities. You can even create animated materials and dynamic materials that change based on the state of your app or user input.": {"zh": "你也可以使用 Shader Graph 设计实体的虚拟外观，Shader Graph 也是一个基于节点的视觉工具，用来创造 RealityKit 可以使用的素材（Materials）。Shader Graph 提供了丰富的表面细节和形状可以操作的实体。你也可以创建有动画效果的材质( animated materials )和动态的材质（ dynamic materials ），这些素材可以根据应用程序的状态或用户的输入而改变。", "tips": ""}, "Diorama demonstrates many of RealityKit and Reality Composer Pro’s features. It displays an interactive, virtual topographical trail map, much like the real-world dioramas you find at trailheads and ranger stations in national parks. This virtual map has points of interest you can tap to bring up more detailed information. You can also smoothly transition between two trail maps: Yosemite and Catalina Island.": {"zh": "Diorama 项目展示了 RealityKit 和 Reality Composer Pro 许多特性。这个项目展示了一个可交互的虚拟徒步地形图，模拟了现实世界中国家公园的登山路径和护林员站点的地形图。虚拟地图上有标志性景点，可以点击获取详细信息。也可以在 Yosemite 和 Catalina Island 这两个虚拟徒步地图之间丝滑的切换。", "tips": ""}, "Import assets for building the scene": {"zh": "导入 Asset 来构建场景", "tips": ""}, "Your Reality Composer Pro project must contain assets, which you use to compose scenes for your app. Diorama’s project has several assets, including 3D models like the diorama table, trail map, some birds and clouds that fly over the map, and a number of sounds and images. Reality Composer Pro provides a library of 3D models you can use. Access the library by clicking the Add (+) button on the right side of the toolbar. Selecting objects from the library imports them into your project.": {"zh": "Reality Composer Pro 项目包含了应用程序用来构建场景的各种数字资源（ Asset ）。Diorama 项目中有多个 Asset ，包括许多 3D 模型，比如仿真桌子，模拟的徒步地形图，几只鸟儿和云朵，以及环境音和一些图像。Reality Composer Pro 提供了一系列内置 3D 模型。可以点击窗口右上角的“ Add (+) ”按钮，在右边弹出的工具栏中可以看到这些 3D 模型。选择相应的对象就将它们导入到项目中。", "tips": ""}, "Diorama uses custom assets instead of the available library assets. To use custom assets in your own Reality Composer Pro scenes, import them into your project in one of three ways: by dragging them to Reality Composer Pro’s project browser, using File > Import from the File menu, or copying the assets into the .rkassets bundle inside your project’s Swift package.": {"zh": "Diorama 使用的是自定义的 Asset。为了在 Reality Composer Pro 的场景中使用自定义的 Asset ，有三种方式将 Asset 导入到项目中：直接将它们拖拽到 Reality Composer Pro 项目的 Project Browser 窗口中；点击菜单栏中“ File > Import ”选择相应的资源文件( Asset )导入；将资源文件( Asset ) 拷贝到项目关联的 Swift package 的 .rkassets Bundle中。", "tips": ""}, "Note": {"zh": "注意", "tips": ""}, "Although you can still load USDZ files and other assets directly in visionOS, RealityKit compiles assets in your Reality Composer Pro project into a binary format that loads considerably faster than loading from individual files.": {"zh": "即使可以在 VisionOS 系统中直接加载 USDZ 文件，以及其他的资源文件( Asset )，但是 RealityKit 会将 Reality Composer Pro 项目中的资源文件( Asset )编译为二进制格式，这比加载单独的文件要快得很多。", "tips": ""}, "Create scenes containing the app’s entities": {"zh": "创建包含应用程序实体的场景", "tips": ""}, "A single Reality Composer Pro project can have multiple scenes. A scene is an entity hierarchy stored in the project as a .usda file that you can load and display in a RealityView. You can use Reality Composer’s scenes to build an entire RealityKit scene, or to store reusable entity hierarchies that you can use as building block for composing scenes at runtime — the approach Diorama uses. You can add as many different scenes to your project as you need by selecting File > New > Scene, or pressing ⌘N.": {"zh": "单独的 Reality Composer Pro 项目中可以有很多个场景。场景是实体的层次结构，在项目中以 .usda 类型的文件存储场景，可以通过 RealityView 加载显示。你可以使用 Reality Composer 的“ Scenes ”可以构建完整的 RealityKit 场景，也可以用于存储可重用的实体层次结构——在运行时作为构建块创建其他场景——类似于 Diorama 项目中那样使用。可以根据需要，在菜单栏中选择“ File > New > Scene ”，或者点击“ ⌘N ”，在项目中添加不同场景。", "tips": ""}, "At the top of the Reality Composer Pro window, there’s a separate tab for every scene that’s currently open. To open a scene, double-click the scene’s .usda file in the project browser. To edit a scene, select its tab, and make changes using the hierarchy viewer, the 3D view, and the inspector.": {"zh": "在 Reality Composer Pro 窗口的顶端显示当前所有打开场景的标签 Tab 。 Project Browser 窗口中双击 .usda 文件来打开场景。选中场景的标签 tab ，这样就可以编辑场景——在 Hierarchy Viewer 窗口（在左侧），3D 内容展示（中间），Inspector 属性窗口（在右侧）可以对场景做修改。", "tips": ""}, "Add assets to your scenes": {"zh": "在场景中添加资源 Asset", "tips": ""}, "RealityKit can only include entities in a scene, but it can’t use every type of asset that Reality Composer Pro supports as an entity. Reality Composer Pro automatically turns some assets, like 3D models, into an entity when you place them in a scene. It uses other assets indirectly. It uses image files, for example, primarily to define the surface details of model entities.": {"zh": "RealityKit 只支持场景中包含实体，但它无法将 Reality Composer Pro 支持的所有类型的资源 Asset 转化为实体使用。当你将某些 Asset——例如3D模型，置于场景中时，Reality Composer Pro 会自动将 Asset 转化为一个实体。Reality Composer Pro 则会间接使用其他类型的资源 Asset。例如，它主要使用图像文件描绘模型实体的表面细节。", "tips": ""}, "Diorama uses multiple scenes to group assets together and then, at runtime, combines those scenes into a single immersive experience. For example, the diorama table has its own scene that includes the table, the map surface, and the trail lines. There are separate scenes for the birds that flock over the table, and for the clouds that float above it.": {"zh": "Diorama 使用多个场景将资源 Asset 整合在一起，这样运行时可以将这些场景整合为一个完整的沉浸式体验环境。例如，DioramaAssembled 场景中包含了桌子，徒步地形图作为桌面，以及地形图上的路线。在地形图上飞翔的鸟群和漂浮的云朵也分作独立的场景。", "tips": ""}, "To add entities to a scene, drag assets from the project browser to the scene’s hierarchy view or 3D view. If the asset you drag is a type that can be represented as an entity, Reality Composer Pro adds it to your scene. You can select any asset in the scene hierarchy or the 3D view and change its location, rotation, and scale using the inspector on the right side of the window or the manipulator in the 3D view.": {"zh": "将 Asset 从 Project Browser 窗口拖拽到场景层次结构中或 3D 内容展示区域中，这样就在场景中添加了实体。如果你拖拽的 Asset 可以作为实体的类型，Reality Composer Pro 就会将它添加到场景中。在场景层次结构 或者 3D 内容展示区域中选中任何一个 Asset ，可以在右侧的 Inspector 属性窗口中，或者3D 内容展示区域使用操纵器 Manipulator ，调整 Asset 的位置，旋转角度，或者缩放操作。", "tips": ""}, "Add components to entities": {"zh": "给实体添加组件", "tips": ""}, "RealityKit follows a design pattern called Entity Component System (ECS). In an ECS app, you store additional data on an entity using components and can implement entity behavior by writing systems that use the data from those components. You can add and configure components to entities in Reality Composer Pro, including both shipped components like PhysicsBodyComponent, and custom components that you write and place in the Sources folder of your Reality Composer Pro Swift package. You can even create new components in Reality Composer Pro and then edit them in Xcode. For more information about ECS, see Understanding RealityKit’s modular architecture.": {"zh": "RealityKit 遵循“实体-组件-系统”（ ECS ）的设计原则。在 ECS 架构的应用程序中，你就可以使用组件存储实体额外的数据，使用组件中的数据编写系统逻辑实现实体的行为。Reality Composer Pro 中可以为实体添加和设置组件，组件类型包括像 PhysicsBodyComponent 这样自带的组件，也可以自定义的组件——位于 Reality Composer Pro 项目的 Swift Package 包中的 Sources 文夹件下。你也可以在 Reality Composer Pro 中创建新的组件，并且可以在 Xcode 中修改它们。更多关于 ECS 的信息，请查阅 Understanding RealityKit’s modular architecture 。", "tips": ""}, "Diorama uses custom components to identify which transforms are points of interest, to mark the birds so the app can make sure they flock together, and to control the opacity of entities that are specific to just one of the two maps.": {"zh": "Diorama 使用自定义组件辨认那些标志性景点的变换操作 transform ，标记鸟儿让它们成群结队的飞翔，或者指定两张地图中的一个的组件以控制实体的透明度。", "tips": ""}, "To add a component to an entity, select that entity in the hierarchy view or 3D view. At the bottom right of the inspector window, click on the Add Component button. A list of available components appears and the first item in that list is New Component. This item creates a new component class, and optionally a new system class, and adds the component to the selected entity.": {"zh": "在层次结构或 3D 内容展示区域中选择其中的实体，这时展示在右侧 Inspector 属性窗口种，点击最下面的 Add Component 按钮来为选中的实体添加组件。这时，屏幕中间会出现一个可用的组件列表，列表的第一行是“ New Component ”。这个选项是创建一个新的组件类别，也可以选择创建一个新的系统类别，同时把这个新创建的组件添加到了选中的实体中。", "tips": ""}, "If you look at the list of components, you see the PointOfInterestComponent that Diorama uses to indicate which transforms are points of interest. If the selected entity doesn’t already contain a PointOfInterestComponent, selecting that adds it to the selected entity. Each entity can only have one component of a specific type. You can edit the values of the existing component in the inspector, which changes what shows up when you tap that point of interest in the app.": {"zh": "在组件列表中，可以看到 Diorama 项目中用来辨认标志性景点的变换操作 Transform 的 PointOfInterestComponent 组件。如果选中实体没有包含 PointOfInterestComponent 组件，选择把这个组件添加到选中的实体中。每个实体有且仅有一个某种类型组件的实例。你可以在 Inspector 属性窗口编辑现存组件的数值，这些会改变标志性景点被点击时的显示。", "tips": ""}, "Use transforms to mark locations": {"zh": "使用 Transform 去做标注点", "tips": ""}, "In Reality Composer Pro, a transform is an empty entity that marks a point in space. A transform contains a location, rotation, and scale, and its child entities inherit those. But, transforms have no visual representation and do nothing by themselves. Use transforms to mark locations in your scene or organize your entity hierarchy. For example, you might make several entities that need to move together into child entities of the same transform, so you can move them together by moving the parent transform.": {"zh": "在 Reality Composer Pro 中，Transform 是标记空间的点的虚实体。Transform 包含位置信息 Position，旋转信息 Rotation，缩放信息 Scale，同时他的子类实体会继承这些信息。但是，Transform 没有视觉表述，它们本身没有独立的功能。Transform 是用来标记场景中位置，或者用来组织实体层次结构。比如，你会将需要一起移动的实体设置为有相同 Transform 的子实体，这样就可以通过移动父实体的 Transform 的同时将子实体们一起移动。", "tips": ""}, "Diorama uses transforms with a PointOfInterestComponent to indicate points of interest on the map. When the app runs, those transforms mark the location of the floating placards with the name of the location. Tapping on a placard expands it to show more detailed information. To turn transforms into an interactive view, the app looks for a specific component on transforms called a PointOfInterestComponent. Because a transform contains no data other than location, orientation, and scale, it uses this component to hold the data the app needs to display on the placards. If you open the DioramaAssembled scene in Reality Composer Pro and click on the transform called Cathedral_Rocks, you see the PointOfInterestComponent in the inspector.": {"zh": "Diorama 使用 PointOfInterestComponent 组件和 Transform 一起标示地图上的标志性景点。在应用程序运行时，Transform 会标记展示地理位置名称的悬浮标牌的位置。点击标牌使其展开显示详细信息。将 PointOfInterestComponent 组件添加到 Transform 虚实体中，应用程序查找有 PointOfInterestComponent 类型组件的 Transform 虚实体，将其转化为可交互的视图。因为 Transform 除了包含位置数据 Position，方向数据 Rotation，缩放数据 Scale 之外没有其他的数据，所以 Transform 使用 PointOfInterestComponent 组件来存储标牌显示所需要的数据。在 Reality Composer Pro 打开名为 DioramaAssembled 场景，点击名为 Cathedral_Rocks 的 Transform，这时在 Inspector 属性窗口就能看到 PointOfInterestComponent 组件。", "tips": ""}, "Load a scene at runtime": {"zh": "程序运行时加载场景", "tips": ""}, "To load a Reality Composer Pro scene, use load(named:in:), passing the name of the scene you want to load and the project’s bundle. Reality Composer Pro Swift packages define a constant that provides ready access to its bundle. The constant is the name of the Reality Composer Pro project with “Bundle” appended to the end. In this case, the project is called RealityKitContent, so the constant is called RealityKitContentBundle. Here’s how Diorama loads the map table in the RealityView initializer:": {"zh": "为了更方便快捷地加载 Reality Composer Pro 场景，Reality Composer Pro Swift package 定义了一个常量，这个常量就是 Reality Composer Pro 项目名称后面追加 “Bundle” 字符。在调用 load(named:in:)，将场景的名称字符串作为 named 参数，“ {{ProjectName}}Bundle ”常量作为 in 参数，就可以加载 Reality Composer Pro 项目 Bundle 中的场景。下面的例子中，项目名是 RealityKitContent ，所以常量就是 RealityKitContentBundle 。下面代码就是在 Diorama 项目中通过 RealityView 初始化方法加载地图桌面场景：", "tips": ""}, "The load(named:in:) function is asynchronous when called from an asynchronous context. Because the content closure of the RealityView initializer is asynchronous, it automatically uses the async version to load the scene. Note that when using it asynchronously, you must call it using the await keyword.": {"zh": "当从一个异步上下文中调用时 load(named:in:) 方法时，这个方法就会被异步执行的。因为 RealityView 初始化方法中的 content 闭包时异步执行，那么在闭包中加载场景也是异步的。注意异步调用 load(named:in:) 须要使用 await 关键字。", "tips": ""}, "Create the floating view": {"zh": "创建悬浮视图", "tips": ""}, "Diorama adds a PointOfInterestComponent to a transform to display details about interesting places. Every point of interest’s name appears in a view that floats above its location on the map. When you tap the floating view, it expands to show detailed information, which the app pulls from the PointOfInterestComponent. The app shows these details by creating a SwiftUI view for each point of interest and querying for all entities that have a PointOfInterestComponent using this query declared in ImmersiveView.swift:": {"zh": "Diorama 将 PointOfInterestComponent 组件添加到 Transform 用以显示景点的详细信息。地图上每个景点的位置上面都悬浮着显示景点名字的视图。点击悬浮视图时，便会展开显示详细信息，这些信息就是来自 PointOfInterestComponent 组件存储的数据。创建 SwiftUI 视图展示景点的详细信息，通过 PointOfInterestComponent 组件查询相应的实体，使用 ImmersiveView.swift 中声明的查询：", "tips": ""}, "In the RealityView initializer, Diorama queries to retrieve the points of interest entities and passes them to a function called createLearnMoreView(for:), which creates the view and saves it for display when it’s tapped.": {"zh": "Diorama 项目中，在 RealityView 初始化方法中查询获取那些标志性景点实体，并将它们传递给 createLearnMoreView(for:) 函数，这个函数创建详情视图，并将它存储下来，在点击的时候在展示它。", "tips": ""}, "Create attachments for points of interest": {"zh": "为标志性景点创建附属视图", "tips": ""}, "Diorama displays the information added to a PointOfInterestComponent in a LearnMoreView, which it stores as an attachment. Attachments are SwiftUI views that are also RealityKit entities and that you can place into a RealityKit scene at a specific location. Diorama uses attachments to position the view that floats above each point of interest.": {"zh": "Diorama 用 LearnMoreView 视图展示 PointOfInterestComponent 组件中储存的详细信息，首先将 LearnMoreView 存储为附属视图。附属视图是 SwiftUI 视图，也是 RealityKit 实体，而在 RealityKit 场景中使用的是附属视图作为实体并设定位置。例如，Diorama 设置的是附属视图（ Attachment ）的位置，让它们悬浮在每个标志景点的上方。", "tips": "译者注：将 Attachment 译作“附属视图”，attachment 就像是链接 SwiftUI 环境 和 RealityKit 环境 的一个中间件。"}, "The app first checks to see if the entity has a component called PointOfInterestRuntimeComponent. If it doesn’t, it creates a new one and adds it to the entity. This new component contains a value you only use at runtime that you don’t need to edit in Reality Composer Pro.": {"zh": "应用程序首先会检查实体是否有 PointOfInterestRuntimeComponent 组件。如果没有，会创建新的 PointOfInterestRuntimeComponent 组件并将这个组件添加到实体中。这个组件存储的是只有在运行时使用的数值，无需用 Reality Composer Pro 编辑。", "tips": ""}, "By putting this value into a separate component and adding it to entities at runtime, Reality Composer Pro never displays it in the inspector. The PointOfInterestRuntimeComponent stores an identifier called an attachment tag, which uniquely identifies an attachment so the app can retrieve and display it at the appropriate time.": {"zh": "在运行时将数值放在单独的组件中，并把组件添加到实体中，Reality Composer Pro 不会在 Inspector 属性窗口中显示出这个运行时组件。PointOfInterestRuntimeComponent 用 attachmentTag 属性存储附属视图的唯一标识符，这样应用程序会在合适的时候通过 attachmentTag 获取相应视图并显示出来。", "tips": ""}, "Next, Diorama creates a SwiftUI view called a LearnMoreView with the information from the PointOfInterestComponent, tags that view, and stores the tag in the PointOfInterestRuntimeComponent. Finally, it stores the view in an AttachmentProvider, which is a custom class that maintains references to the attachment views so they don’t get deallocated when they’re not in a scene.": {"zh": "接下来， Diorama 创建 LearnMoreView 类型的 SwiftUI 视图，显示 PointOfInterestComponent 中的信息，接下来设置详细视图的 tag 值，同时使用相同的 tag 值设置 PointOfInterestRuntimeComponent 的 attachmentTag 属性。最后，讲这些详细视图存储在 AttachmentProvider 中，AttachmentProvider 是用来维护持有附属视图引用的自定义类，以防这些视图没有在场景中而被释放。", "tips": ""}, "Display point of interest attachments": {"zh": "展示标志景点的附属视图", "tips": ""}, "Assigning a view to an attachment provider doesn’t actually display that view in the scene. The initializer for RealityView has an optional view builder called attachments that’s used to specify the attachments.": {"zh": "将视图添加到 AttachmentProvider 中时，并不会立即显示在场景中。可以选择 RealityView 有名为 attachments 的视图构建器（ ViewBuilder）参数的初始化方法，这个视图构建器创建的附属视图指定给了 attachments 参数。", "tips": ""}, "In the update closure of the initializer, which RealityKit calls when the contents of the view change, the app queries for entities with a PointOfInterestRuntimeComponent, uses the tag from that component to retrieve the correct attachment for it, and then adds that attachment and places it above its location on the map.": {"zh": "当 RealityKit 视图内容发生变化的时候，会调用初始化时指定 update 闭包，在这个闭包中会通过 PointOfInterestRuntimeComponent 类型查询相应的实体，通过组件的 attachmentTag 属性获取对应的附属视图，然后将附属视图添加到地图上并设置它的位置。（译者注：详细请参阅 RealityView 的初始化方法）。", "tips": ""}, "Create custom materials with Shader Graph": {"zh": "使用 Shader Graph 创建自定义的素材", "tips": ""}, "To switch between the two different topographical maps, Diorama shows a slider that morphs the map between the two locations. To accomplish this, and to draw elevation lines on the map, the FlatTerrain entity in the DioramaAssembled scene uses a Shader Graph material. Shader Graph is a node-based material editor that’s built into Reality Composer Pro. Shader Graph gives you the ability to create dynamic materials that you can change at runtime. Prior to Reality Composer Pro, the only way to implement a dynamic material like this was to create a CustomMaterial and write Metal shaders to implement the necessary logic.": {"zh": "Diorama 通过滑动条控制两张地图之间渐变地切换。为了达到这种效果，先在地图上绘制等高翔，DioramaAssembled 场景中的 FlatTerrain 实体使用的 Shader Graph 素材。 Shader Graph 是基于节点（ node-base ）的素材编辑器，它已经集成到 Reality Composer Pro 。使用 Shader Graph 可以创建运行时改变的动态素材。在 Reality Composer Pro 推出之前，实现动态素材唯一办法就是创建自定义素材 CustomMaterial 并通过编写 Metal Shader 实现必要逻辑。", "tips": ""}, "Diorama’s DynamicTerrainMaterialEnhanced does two things. It draws contour lines on the map based on height data stored in displacement map images, and it also offsets the vertices of the flat disk based on the same data. By interpolating between two different height maps, the app achieves a smooth transition between the two different sets of height data.": {"zh": "Diorama 项目中的 DynamicTerrainMaterialEnhanced 做了两件事情：根据地图模型的位移贴图中存储高度数据来描绘等高线和平面圆形上地形外表的顶点；通过在两个不同的高度地图之间进行插值。应用程序实现了在两组有不同的高度数据的地图之间平滑切换。", "tips": ""}, "When you build Shader Graph materials, you can give them input parameters called promoted inputs that you set from Swift code. This allows you to implement logic that previously required writing a Metal shader. The materials you build in the editor can affect both the look of an entity using the custom surface output node, which equates to writing Metal code in a fragment shader, or the position of vertices using the geometry modifier output, which equates to Metal code running in a vertex shader.": {"zh": "在创建 Shader Graph 素材时，你可以在Swift代码中通过 Promote Input 参数给 Shader Graph 素材传递数据。这样可以实现编写 Metal Shader 所需要的逻辑。使用编辑器创建的素材后，可以使用素材中自定义外表的输出节点（ custom surface output ）作用与实体的外观，这等价于编写 Fragment Shader 的 Metal 代码；也可以使用素材中集合修改器的输出（ geometry modifier output ）摆放顶点的位置，这等价于编写 Vertex Shader 的 Metal 代码。", "tips": ""}, "Node graphs can contain subgraphs, which are similar to functions. They contain reusable sets of nodes with inputs and outputs. Subgraphs contain the logic to draw the contour lines and the logic to offset the vertices. Double-click a subgraph to edit it. For more information about building materials using Shader Graph, see Explore Materials in Reality Composer Pro.": {"zh": "节点图（ Node graph ）可以包含子图（ Subgraph ），这类似函数。它们包含一系列可重用的输入和输出节点。子图（ Subgraph ）包含绘制等高线和调整顶点的逻辑。双击子图（ Subgraph ）进行编辑操作。更多关于使用 Shader Graph 创建素材，请参照 Explore Materials in Reality Composer Pro 。", "tips": ""}, "Update the Shader Graph material at runtime": {"zh": "运行时更新 Shader Graph 素材", "tips": ""}, "To change the map, DynamicTerrainMaterialEnhanced has a promoted input called Progress. If that parameter is set to 1.0, it displays Catalina Island. If it’s set to 0, it displays Yosemite. Any other number shows a state in transition between the two. When someone manipulates the slider, the app updates that input parameter based on the slider’s value.": {"zh": "DynamicTerrainMaterialEnhanced 有名为 Progress 的 Promoted Input 参数。如果将参数设置为 1.0 ，则会显示 Catalina Island。如果见参数设为 0 ，则会显示 Yosemite。如果将参数设置为 0 到 1 之间的数值，则显示两个地图切换时的中间状态。当用户操作滑动条时，应用程序会用滑动条当前的数值更新输入参数。", "tips": ""}, "Important": {"zh": "要点", "tips": ""}, "Shader Graph material parameters are case-sensitive. If the capitalization is wrong, your code won’t actually update the material.": {"zh": "Shader Graph 素材参数的名称是区分大小写的。如果大写和小写的拼写不正确，你的代码就无法更新材料。", "tips": ""}, "The app sets the value of the input parameter in a function called handleMaterial() that the slider’s .onChanged closure calls. That function retrieves the ShaderGraphMaterial from the terrain entity and calls setParameter(name:value:) on it.": {"zh": "应用程序会在 Slider 的 .onChanged 回调闭包中调用 handleMaterial() 函数，在函数中获取 terrain 实体中的 ShaderGraphMaterial 素材，然后调用素材的 setParameter(name:value:) 的方法去更新素材的输入参数。", "tips": ""}}
{"Drawing sharp layer-based content in visionOS": {"zh": "在 visionOS 中绘制基于图层的清晰内容", "tips": ""}, "Deliver text and vector images at multiple resolutions from custom Core Animation layers in visionOS.": {"zh": "在 visionOS 中，从自定义的 Core Animation 图层中以多种分辨率提供文本和矢量图形", "tips": ""}, "Overview": {"zh": "概述", "tips": ""}, "If your app uses Core Animation layers directly, update your layer code to draw a high-resolution version of your content when appropriate. SwiftUI and UIKit views use Core Animation layers to manage interface content efficiently. When a view draws its content, the underlying layer captures that content and caches it to improve subsequent render operations.": {"zh": "如果你的应用直接使用了 Core Animation 图层（layer），请更新这部分代码，以便在适当的时候绘制高分辨率版本的内容。SwiftUI 和 UIKit 视图使用 Core Animation 层来高效管理界面内容。当一个 View 绘制其内容时，底层的 layer 会捕获该内容并对其进行缓存，为后续的渲染操作作出优化。", "tips": ""}, "Core Animation on most Apple platforms rasterizes your layer at the same resolution as the screen, but Core Animation on visionOS can rasterize at different resolutions to maximize both content clarity and performance. The system follows the person’s eyes and renders content immediately in front of them at the highest possible resolution. Outside of this focal area, the system renders content at progressively lower resolutions to reduce GPU workloads. Because the content is in the person’s peripheral vision, these lower resolutions don’t impact the content’s clarity. As the person’s eyes move around, the system redraws content at different resolutions to match the change in focus.": {"zh": "大多数 Apple 平台上的 Core Animation 使用与屏幕相同的分辨率对图层进行栅格化，但是 visionOS 有所不同，在 visionOS 上的 Core Animation 可以以不同的分辨率栅格化，以最大化提升绘制内容的清晰度和性能。系统会跟踪人眼，根据人眼所在焦点以尽可能高的分辨率立即呈现内容。在此焦点的区域之外，系统以逐渐降低的分辨率渲染内容，以减少 GPU 工作负载。由于焦点外的内容位于人的周边视觉中，因此这些较低的分辨率不会影响内容的清晰度。当人的眼睛四处移动时，系统会以不同的分辨率重新绘制内容，来匹配焦点的变化。", "tips": ""}, "If you deliver content using custom CALayer objects, you can configure your custom layers to support drawing at different resolutions. If you don’t perform this extra configuration step, each layer rasterizes its content at a @2x scale factor, which is good enough for most content and matches what the layer provides on a Retina display. However, if you opt in to drawing at different resolutions, the layer rasterizes its content at up to @8x scale factor in visionOS, which adds significant detail to text and vector-based content.": {"zh": "如果使用自定义 CALayer 对象提供内容，则可以配置你的自定义图层以支持以不同分辨率来进行绘制。如果不执行这一额外的配置步骤，则每个图层都会以 @2x 的比例栅格化其内容，这对于大多数内容来说已经足够了，并且与图层在 Retina 显示屏上提供的内容相匹配。但是，如果您选择以不同的分辨率进行绘制，则图层会在 visionOS 中以高达  @8x 的比例栅格化其内容，从而为文本和基于矢量的内容添加大量细节。", "tips": ""}, "Request dynamic scaling for custom layers": {"zh": "请求自定义图层的动态缩放", "tips": ""}, "Dynamic content scaling is off by default for all Core Animation layers, and frameworks or apps must turn on this support explicitly. If your interface uses only SwiftUI or UIKit views, you don’t need to do anything to support this feature. SwiftUI and UIKit enable it automatically for views that benefit from the added detail, such as text views and image views with SF Symbols or other vector-based artwork. However, the frameworks don’t enable the feature for all views, including UIView and View.": {"zh": "默认情况下，所有 Core Animation 图层的动态内容缩放都处于关闭状态，框架或应用必须显式地启用此支持。如果您的界面仅使用 SwiftUI 或 UIKit 视图，则无需执行任何操作即可支持此功能。SwiftUI 和 UIKit 会自动为那些受益于被添加了细节的视图启用它，例如带有 SF 符号的文本和图像视图，或其他基于矢量的美术资源。但是，框架不会为所有视图（包括 UIView 和 View ）启用该功能。", "tips": ""}, "If your visionOS interface includes custom Core Animation layers, you can enable the wantsDynamicContentScaling property of any CALayer objects that contain vector-based content. Setting this property to true tells the system that you support rendering your layer’s content at different resolutions. However, the setting is not a guarantee that the system applies dynamic content scaling to your content. The system can disable the feature if your layer draws using incompatible functions or techniques.": {"zh": "如果您的 visionOS 界面包含自定义的 Core Animation 图层，对于包含基于矢量的内容的任意 CALayer 对象，您都可以启用它们的 wantsDynamicContentScaling 属性。将此属性设置为 true 会告知系统您支持以不同的分辨率渲染图层的内容。但是，此设置并不能保证系统将动态内容缩放应用于您的内容。如果图层使用不兼容的函数或技术进行绘制，系统可能会禁用该属性。", "tips": ""}, "The following example shows how to enable this feature for a CATextLayer object. After configuring the layer, set the wantsDynamicContentScaling property to true and add the layer to your layer hierarchy.": {"zh": "以下示例演示如何为 CATextLayer 对象启用此功能。配置图层后，将 wantsDynamicContentScaling 属性设置为 true ，然后将此图层添加到图层层次结构中。", "tips": ""}, "Dynamic content scaling works best when the layer contains text or vector-based content. Don’t enable the feature if you do any of the following in your layer:": {"zh": "当图层包含文本或基于矢量的内容时，动态内容缩放效果最佳。如果在图层中执行以下任一操作，请勿启用该功能：", "tips": ""}, "You set the layer’s content using the contents property.": {"zh": "您使用 contents 属性设置了图层的内容。", "tips": ""}, "You draw primarily bitmap-based content.": {"zh": "您主要绘制的是基于位图的内容。", "tips": ""}, "You redraw your layer’s contents repeatedly over a short time period.": {"zh": "您可能会在短时间内多次重绘您的内容。", "tips": ""}, "The CAShapeLayer class ignores the value of the wantsDynamicContentScaling property and always enables dynamic content scaling. For other Core Animation layers, you must enable the feature explicitly to take advantage of it.": {"zh": "CAShapeLayer 类忽略 wantsDynamicContentScaling 属性的值，并始终启用动态内容缩放。对于其他 Core Animation 图层，必须显式启用该功能才能利用它。", "tips": ""}, "Draw the layer’s content dynamically": {"zh": "动态绘制图层的内容", "tips": ""}, "Dynamic content scaling requires you to draw your layer’s contents using one of the prescribed methods. If you define a custom subclass of CALayer, draw your layer’s content in the draw(in:) method. If you use a CALayerDelegate object to draw the layer’s content, use the delgate’s drawLayer:inContext: method instead.": {"zh": "动态内容缩放要求您使用某个指定的方法绘制图层的内容。如果定义了一个自定义的 CALayer 子类，请在 draw(in:) 方法中绘制图层的内容。如果使用 CALayerDelegate 对象绘制图层的内容，请改用 delgate 中的 drawLayer:inContext: 方法。", "tips": ""}, "When you enable dynamic content scaling for a layer, the system captures your app’s drawing commands for playback later. As the person’s eyes move, the system draws the layer at higher resolutions when someone looks directly at it, or at lower resolutions otherwise. Because the redraw operations implicitly communicate what the person is looking at, the system performs them outside of your app’s process. Letting the system handle these operations maintains the person’s privacy while still giving your app the benefits of high-resolution drawing.": {"zh": "当您为图层启用动态内容缩放时，系统会捕获应用程序的绘图命令以供以后重绘。当人的眼睛移动时，如果视线直视图层，系统会以更高的分辨率绘制图层，否则系统会以较低的分辨率绘制图层。由于重绘操作隐式透露了用户正在查看的内容，因此系统会在应用进程之外执行这些操作。让系统处理这些操作不仅可以保护用户隐私，同时可使您的应用程序能够受益于高分辨率绘制。", "tips": ""}, "Some Core Graphics routines are incompatible with dynamic content scaling. Even if you enable dynamic content scaling for your layer, the system automatically disables the feature if your layer uses any of the following:": {"zh": "一些 Core Graphics 的 API 与动态内容缩放不兼容。即使您为图层启用了动态内容缩放，如果您的图层使用以下任一选项，系统也会自动禁用该功能：", "tips": ""}, "Core Graphics shaders.": {"zh": "使用 Core Graphics 的 着色器（shader）", "tips": ""}, "APIs that set intent, quality, or other bitmap-related properties. For example, don’t call CGContextSetInterpolationQuality.": {"zh": "设置意图、质量或其他位图相关属性的 API。例如，不要调用 CGContextSetInterpolationQuality 。", "tips": ""}, "A CGBitmapContext to draw content.": {"zh": "用于绘制内容的 CGBitmapContext", "tips": ""}, "If your app creates timer-based animations, don’t animate layer changes using your drawing method. Calling setNeedsDisplay() on your layer repeatedly in a short time causes the system to draw the layer multiple times in quick succession. Because visionOS needs a little extra time to draw a layer at high resolution, each redraw request forces it to throw away work. A better option is to animate layer-based properties to achieve the same effect, or use a CAShapeLayer to animate paths when needed.": {"zh": "如果您的应用创建基于计时器的动画，请不要使用绘制方法对图层更改进行动画处理。在短时间内重复调用图层的 setNeedsDisplay() 方法会导致系统快速连续多次绘制图层。由于 visionOS 需要一些额外的时间来以高分辨率绘制图层，因此每次重绘请求都会强制它放弃当前工作。更好的选择是对基于图层的属性进行动画处理以实现相同的效果，或者在需要时使用 CAShapeLayer 对路径进行动画处理。", "tips": ""}, "Modify layer hierarchies to improve performance": {"zh": "修改图层层次结构以改善性能", "tips": ""}, "The backing store for a layer consumes more memory at higher resolutions than at lower resolutions. Measure your app’s memory usage before and after you enable dynamic content scaling to make sure the increased memory cost is worth the benefit. If your app’s memory usage increases too much, limit which layers adopt dynamic content scaling. You can also reduce the amount of memory each layer uses in the following ways:": {"zh": "图层的后端存储在较高分辨率下比在较低分辨率下消耗更多的内存。在启用动态内容缩放之前和之后测量应用的内存使用情况，以确保增加的内存成本物有所值。如果应用的内存使用量增加过多，请对某些图层是否采用动态内容缩放加以限制。您还可以通过以下方式减少每个图层使用的内存量：", "tips": ""}, "Make your layer the smallest size possible. Larger layers require significantly more memory, especially at higher resolutions. Make the size of the layer match the size of your content by eliminating padding or extra space.": {"zh": "尽可能最小化您的图层尺寸。越大的图层需要的内存也越多，尤其是在更高的分辨率下。通过消除缩进或周围额外的空间，来使图层的大小与内容的大小相匹配。", "tips": ""}, "Separate complex content into different layers. Instead of drawing everything in a single layer, build your content from multiple layers and arrange them hierarchically to achieve the same result. Enable dynamic content scaling only in the layers that actually need it.": {"zh": "将复杂内容置于不同图层。相比在单个图层中绘制所有内容，不如从多个图层构建内容并分层排列它们，以达到相同的效果。仅在实际需要的图层中启用动态内容缩放。", "tips": ""}, "Apply special effects using layer properties whenever possible. Applying effects during drawing might require you to increase the layer’s size. For example, apply scale and rotation effects to the layer’s transform property, instead of during drawing.": {"zh": "尽可能使用图层属性来应用特殊效果。在绘制过程中应用某些效果可能需要增加图层的占用大小。例如，请将缩放和旋转效果应用于图层的 transform 属性，而不是在绘制过程中这么做。", "tips": ""}, "Don’t draw your layer’s content at different resolutions in advance and cache the images. Maintaining multiple images requires more memory. If you do cache images, draw them only at @2x scale factor.": {"zh": "不要提前用不同的分辨率绘制图层的内容并缓存图像。维护多个图像需要更多内存。如果您确需缓存图像，请仅以 @2x 的比例绘制它们。", "tips": ""}, "Don’t use your drawing code to draw a single image. If your layer’s content consists of an image, assign that image to the layer’s contents property directly.": {"zh": "不要使用绘制代码绘制单个图像。如果图层的内容由图像组成，请直接将该图像分配给图层的 contents 属性。", "tips": ""}, "Complex drawing code can also lead to performance issues. A layer with many strokes can render quickly at lower scale factors, but might be computationally too complex to render at larger scales. If a complex layer doesn’t render correctly at higher resolutions, turn off dynamic content scaling and measure the render times again.": {"zh": "复杂的绘图代码也可能导致性能问题。一个具有许多描边的图层可以在较低分辨率下快速渲染，但在计算上可能过于复杂，继而无法在较大比例下渲染。如果复杂图层无法在更高分辨率下正确渲染，请关闭动态内容缩放并再次测量渲染时间。", "tips": ""}}
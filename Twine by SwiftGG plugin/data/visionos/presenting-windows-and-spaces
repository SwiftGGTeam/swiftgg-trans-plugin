{"Presenting windows and spaces": {"zh": "展示窗口和空间", "tips": ""}, "Open and close the scenes that make up your app’s interface.": {"zh": "打开和关闭组成应用界面的场景。", "tips": ""}, "Overview": {"zh": "概述", "tips": ""}, "An app’s scenes, which contain views that people interact with, can take different forms. For example, a scene can fill a window, a tab in a window, or an entire screen. Some scenes can even place views throughout a person’s surroundings. How a scene appears depends on its type, the platform, and the context.": {"zh": "一个应用程序的场景，包括了用户与之进行交互的视图，它可以有多样的形式。例如，场景可以被一个窗口、一个窗口中的选项卡或一整个其他场景所填满。有些场景甚至可以将视图置于用户的周围环境中。场景的出现方式取决于其类型、系统平台和上下文。", "tips": ""}, "When someone launches your app, SwiftUI looks for the first WindowGroup, Window, or DocumentGroup in your app declaration and opens a scene of that type, typically filling a new window or the entire screen, depending on the platform. For example, the following app running in macOS presents a window that contains a MailViewer view:": {"zh": "当用户启动你的 app 时，SwiftUI 会在你的 app 声明中查找首个 WindowGroup 、 Window 或 DocumentGroup ，然后打开该类型的场景，通常会用一个新窗口或整个屏幕填充它，具体取决于系统平台。例如，在 macOS 中运行的以下应用会显示一个包含 MailViewer 视图的窗口：", "tips": ""}, "In visionOS, you can alternatively configure your app to open the first ImmersiveSpace that the app declares. In any case, specific platforms and configurations enable you to open more than one scene at a time. Under those conditions, you can use actions that appear in the environment to programmatically open and close the scenes in your app.": {"zh": "在 visionOS 中，您也可以将 app 配置为打开 app 声明的首个 ImmersiveSpace 。在任何情况下，特定的平台和配置都允许您一次打开多个场景。在这些条件下，您可以使用环境中出现的操作人为地打开和关闭应用中的场景。", "tips": ""}, "Check for multiple-scene support": {"zh": "检查多场景支持", "tips": ""}, "If you share code among different platforms and need to find out at runtime whether the current system supports displaying multiple scenes, read the supportsMultipleWindows environment value. The following code creates a button that’s hidden unless the app supports multiple windows:": {"zh": "如果您在不同系统平台上共享一套代码，并且需要在运行时了解当前系统是否支持显示多个场景，请读取 supportsMultipleWindows 环境变量。以下代码创建了一个按钮，只有在 app 支持多个窗口时按钮才会显示：", "tips": ""}, "The value that you read depends on both the platform and how you configure your app:": {"zh": "你读取到的值由平台和你的 app 配置共同决定：", "tips": ""}, "In macOS, this property returns true for any app that uses the SwiftUI app lifecycle.": {"zh": "在 macOS 中，对于使用 SwiftUI app 生命周期的任何 app，该值返回 true 。", "tips": ""}, "In iPadOS and visionOS, this property returns true for any app that uses the SwiftUI app lifecycle and has the Information Property List key UIApplicationSupportsMultipleScenes set to true, and false otherwise.": {"zh": "在 iPadOS 和 visionOS 中，对于使用 SwiftUI app 生命周期且 info plist 中键 UIApplicationSupportsMultipleScenes 设为 true 的任何 app，此属性返回 true ，否则返回 false 。", "tips": ""}, "For all other platforms and configurations, the value returns false.": {"zh": "对于所有其他系统平台和配置，该值返回 false 。", "tips": ""}, "If your app only ever runs in one of these situations, you can assume the associated behavior and don’t need to check the value.": {"zh": "如果您的 app 仅在其中一种情况下运行，则可以默认其采取对应的行为，而无需检查该值。", "tips": ""}, "Enable multiple simultaneous scenes": {"zh": "同时启用多个共存场景", "tips": ""}, "You can always present multiple scenes in macOS. To enable an iPadOS or visionOS app to simultaneously display multiple scenes — including ImmersiveSpace scenes in visionOS — add the UIApplicationSupportsMultipleScenes key with a value of true in the UIApplicationSceneManifest dictionary of your app’s Information Property List. Use the Info tab in Xcode for your app’s target to add this key:": {"zh": "您始终可以在 macOS 中呈现多个场景。若要使 iPadOS 或 visionOS 上的 app 能够同时显示多个场景（包括 visionOS 中的 ImmersiveSpace 场景），请在 app 中 info.plist 里的 UIApplicationSceneManifest 字典中添加值为 true 的 UIApplicationSupportsMultipleScenes 键。在 Xcode 中，选择你 app 对应的一个 target 的 info 标签页以添加此键：", "tips": ""}, "Apps on other platforms can display only one scene during their lifetime.": {"zh": "其他平台上的 app 在其生命周期内只能显示一个场景。", "tips": ""}, "Open windows programmatically": {"zh": "以编程方式打开窗口", "tips": ""}, "Some platforms provide built-in controls that enable people to open instances of the window-style scenes that your app defines. For example, in macOS people can choose File > New Window from the menu bar to open a new window. SwiftUI also provides ways for you to open new windows programmatically.": {"zh": "某些系统平台提供内置控件，使用户能够打开 app 自定义的窗口样式的场景的实例。例如，在 macOS 中，用户可以从菜单栏中选取 File > New Window 以打开新窗口。SwiftUI 还为您提供了以编程方式打开新窗口的方法。", "tips": ""}, "To do this, get the openWindow action from the environment and call it with an identifier, a value, or both to indicate what kind of window to open and optionally what data to open it with. The following view opens a new instance of the previously defined mail viewer window when someone clicks or taps the button:": {"zh": "为此，请从环境中获取 openWindow 操作，并使用标识符、值或同时使用两者调用它，以指示要打开的窗口类型以及要打开的窗口（可选）数据。当有人单击或轻按该按钮时，以下视图将打开之前定义的邮件查看器窗口的新实例：", "tips": ""}, "When the action runs on a system that supports multiple scenes, SwiftUI looks for a window in the app declaration that has a matching identifier and creates a new scene of that type.": {"zh": "当该操作在支持多个场景的系统上运行时，SwiftUI 会在 app 声明中查找具有匹配标识符的窗口，并创建该类型的新场景。", "tips": ""}, "Important": {"zh": "重要", "tips": ""}, "If supportsMultipleWindows is false and you try to open a new window, SwiftUI ignores the action and logs a runtime error.": {"zh": "如果在 supportsMultipleWindows 为 false 的情况下，您尝试打开一个新窗口，SwiftUI 会忽略该操作并记录一个运行时错误。", "tips": ""}, "In addition to opening more instances of an app’s main window, as in the above example, you can also open other window types that your app’s body declares. For example, you can open an instance of the Window that displays connectivity information:": {"zh": "除了打开 app 主窗口的更多实例（如上例所示）之外，还可以打开 app 的 body 内声明的其他窗口类型。例如，您可以打开显示连接信息的 Window 实例：", "tips": ""}, "Open a space programmatically": {"zh": "以编程方式打开空间", "tips": ""}, "In visionOS, you open an immersive space — a scene that you can use to present unbounded content in a person’s surroundings — in much the same way that you open a window, except that you use the openImmersiveSpace action. The action runs asynchronously, so you use the await keyword when you call it, and typically do so from inside a Task:": {"zh": "在 visionOS 中，您可以打开一个沉浸式空间（可用于在用户周围环境中呈现无限内容的场景），其方式与打开窗口的方式大致相同，只需使用 openImmersiveSpace 操作。该操作以异步方式运行，因此在调用它时需使用 await 关键字，并且通常在一个 Task 闭包内部执行此操作：", "tips": ""}, "Because your app operates in a Full Space when you open an ImmersiveSpace scene, you can only open one scene of this type at a time. If you try to open a space when one is already open, the system logs a runtime error.": {"zh": "由于当您打开 ImmersiveSpace 场景时，您的应用在 ImmersiveSpace 中运行，因此您一次只能打开一个此类场景。如果尝试在空间已存在时再次打开空间，系统将记录一个运行时错误。", "tips": ""}, "Your app can display any number of windows together with an immersive space. However, when you open a space from your app, the system hides all windows that belong to other apps. After you dismiss your space, the other apps’ windows reappear. Similarly, the system hides your app’s windows if another app opens an immersive space.": {"zh": "你的 app 可以在一个沉浸式空间中显示任意数量的窗口。。但是，当您从 app 中打开空间时，系统会隐藏属于其他应用程序的所有窗口。关闭您的 app 的空间后，其他应用的窗口会重新显示。同样地，如果另一个 app 打开沉浸式空间，系统会隐藏您的 app 的窗口。", "tips": ""}, "Designate a space as your app’s main interface": {"zh": "将空间指定为 app 的主界面", "tips": ""}, "When visionOS launches an app, it opens the first window group, window, or document scene that the app’s body declares, just like on other platforms. This is true even if you first declare a space. However, if you want to open your app into an immersive space directly, specify a space as the default scene for your app by adding the UIApplicationPreferredDefaultSceneSessionRole key to your app’s information property list and setting its value to UISceneSessionRoleImmersiveSpaceApplication. In that case, visionOS opens the first space that it finds in your app declaration.": {"zh": "当 visionOS 启动一个 app 时，它会打开 app 的 body 中声明的第一个窗口组、窗口或文档场景，就像在其他系统平台上一样。即使您先声明的是一个空间，也是如此。但是，如果要直接在沉浸式空间中打开 app，请将 UIApplicationPreferredDefaultSceneSessionRole 键添加到 app 的 info.plist 中并将其值设置为 UISceneSessionRoleImmersiveSpaceApplication ，从而将空间指定为 app 的默认场景。在这种情况下，visionOS 会打开它在 app 声明中找到的第一个空间。", "tips": ""}, "Be careful not to overwhelm people when starting your app with an immersive space. For design guidance, see Immersive experiences.": {"zh": "在以沉浸式空间启动 app 时，避免用户产生不知所措的感觉。有关设计指南，请参阅《沉浸式体验》。", "tips": ""}, "Close windows programmatically": {"zh": "以编程方式关闭窗口", "tips": ""}, "People can close windows using system controls, like the close button built into the frame around a macOS window. You can also close windows programmatically. Get the dismissWindow action from the environment, and call it using the identifier of the window that you want to dismiss:": {"zh": "用户可以使用系统自带的控件关闭窗口，例如 macOS 窗口上面系统默认的关闭按钮。您当然也可以以编程方式关闭窗口。从环境中获取 dismissWindow 操作，并使用要关闭的窗口的标识符来调用它：", "tips": ""}, "In iPadOS and visionOS, the system ignores the dismiss action if you use it to close a window that’s your app’s only open scene.": {"zh": "在 iPadOS 和 visionOS 中，如果要关闭是当前 app 唯一打开的场景，系统会忽略该操作。", "tips": ""}, "Close spaces programmatically": {"zh": "以编程方式关闭空间", "tips": ""}, "To close a space, call the dismissImmersiveSpace action. Like the corresponding open space action, the close action operates asynchronously and requires the await keyword:": {"zh": "若要关闭空间，请调用 dismissImmersiveSpace 操作。与相应的打开空间的操作类似，关闭操作是异步执行的，并且需要 await 关键字：", "tips": ""}, "You don’t need to specify an identifier for this action, because there can only ever be one space open at a time. Like with windows, you can’t dismiss a space that’s your app’s only open scene.": {"zh": "您无需为此操作指定标识符，因为一次只能打开一个空间。与窗口一样，你不能关闭 app 唯一打开的场景的空间。", "tips": ""}, "Transition between a window and a space": {"zh": "在窗口和空间之间过渡", "tips": ""}, "Because you can’t programmatically close the last open window or immersive space in a visionOS app, be sure to open a new scene before closing the old one. Pay particular attention to the sequencing when moving between a window and an immersive space, because the space’s open and dismiss actions run asynchronously.": {"zh": "由于无法以编程方式关闭 visionOS app 中上次打开的窗口或沉浸式空间，因此请务必在关闭旧场景之前打开新场景。在窗口和沉浸式空间之间移动时，请特别注意事件发生的顺序，因为空间的打开和关闭操作是异步运行的。", "tips": ""}, "For example, consider a chess game that begins by displaying a start button in a window. When someone taps the button, the app dismisses the window and opens an immersive space that presents a chess board. The following button demonstrates proper sequencing by opening the space and then closing the window:": {"zh": "例如，考虑一个国际象棋游戏，它首先在窗口中显示一个开始按钮。当有人点击按钮时，应用程序会关闭窗口并打开一个显示棋盘的沉浸式空间。以下按钮演示了一个正确的事件顺序--先打开空间然后关闭窗口：", "tips": ""}, "In the above code, it’s important to include the dismissWindow action inside the task, so that it waits until the openImmersiveSpace action completes. If you put the action outside the task — either before or after — it might execute before the asynchronous open action completes, when the window is still the only open scene. In that case, the system opens the space but doesn’t close the window.": {"zh": "在上面的代码中，务必将 dismissWindow 操作放在一个 Task 中，以便它会等待 openImmersiveSpace 操作完成后执行。如果将操作放在 Task 之外（无论是在 Task 之前还是之后），它可能会在异步打开操作完成之前执行，此时窗口仍是唯一打开的场景。在这种情况下，系统会打开空间，但不会关闭窗口。", "tips": ""}}
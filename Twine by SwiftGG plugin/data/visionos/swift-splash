{"Swift Splash": {"zh": "Swift Splash", "tips": ""}, "Use RealityKit to create an interactive ride in visionOS.": {"zh": "使用 RealityKit 在 visionOS 中搭建一个交互式的水上游乐设施。", "tips": ""}, "Overview": {"zh": "概览", "tips": ""}, "Apple Vision Pro’s ability to combine virtual content seamlessly with the real world allows for many kinds of interactive virtual experiences. Swift Splash leverages RealityKit and Reality Composer Pro to create a virtual water slide by combining modular slide pieces. When the builder finishes their ride, they can release an adventurous goldfish to try it out.": {"zh": "Apple Vision Pro 能够将虚拟内容和现实世界无缝结合，从而为诸多类型的虚拟交互体验提供可能。Swift Splash 使用 RealityKit 和 Reality Composer Pro 来构建一个由模块化的滑道部件组成的虚拟水上滑梯。而当建造者完成了他们的游乐设施，就能够释放一只勇于冒险的小金鱼去体验他们的作品。", "tips": ""}, "Swift Splash uses multiple Reality Composer Scenes to create prepackaged entity hierarchies that represent each of the slide pieces the player connects to construct their ride. It demonstrates how to hide and reveal sections of the entity hierarchy based on the current state of the app. For example, each slide piece contains an animated fish entity that’s hidden until the ride runs and the fish arrives at that particular piece. While Swift Splash is a fun, game-like experience, the core idea of assembling virtual objects out of predefined parts can also be used as the basis for a productivity or creation app.": {"zh": "Swift Splash 使用多个 Reality Composer 场景形成预设的实体层次结构，这些结构代表了玩家在构筑游乐设施过程中所需要衔接的每一块滑道部件。它示范了如何依照应用的当前状态去隐藏和展示实体层次结构的部分。举个例子来说，每一片滑道部件包含了一条会游动但隐藏着的鱼，直至启动整个游乐设施装置且小鱼到达指定物件时才会被看到。尽管 Swift Splash 看上去提供了一种有趣的、类似游戏的体验，不过其本质利用预设部分来构造虚拟物件的核心思想也可以被用于生产力或是创造性应用的基础。", "tips": ""}, "Swift Splash scenes include Shader Graph materials built in Reality Composer Pro to change the appearance of the ride at runtime. Each piece can be configured to display in one of three materials: metal, wood, or plastic. Other Shader Graph materials create special effects, such as the movement of the water and the flashing lights on the start and end pieces. Even particle effects are included in some of these prepackaged entities, such as the fireworks that play when the goldfish crosses the finish line.": {"zh": "Swift Splash 的场景囊括了在 Reality Composer Pro 中内建的 Shader Graph 材质，它们用于在运行时改变游乐设施的外观。每一块滑道部件都可以被设定用来展示三种不同材质中的某一种：金属、木质或塑料。其他风格的 Shader Graph 材质会创建特效，例如水的流动以及起点和终点物件上的闪光灯灯效。甚至其中的一些预设实体内还包含了粒子效果，比如当小金鱼抵达终点线时绽放的礼花。", "tips": ""}, "Build slide pieces in Reality Composer Pro": {"zh": "在 Reality Composer Pro 中构建水上滑道部件", "tips": ""}, "Slide pieces are the building blocks of Swift Splash. The Reality Composer project contains a separate scene for each one. In addition to the 3D models that make up the slide piece, each scene contains a number of other entities the app uses to animate and place the slide piece.": {"zh": "滑道部件是构建 Swift Splash 项目的基础模块。Reality Composer 为每一个物件元素提供了独立的编辑场景。除了组成滑梯的 3D 模型以外，每一个场景还包含了若干个在程序中用于对滑道部件进行动画和定位的其他实体。", "tips": ""}, "In the hierarchy viewer on the left side of the screenshot above, there are two transform entities called connect_in and connect_out. These transforms mark the points where the slide piece connects to the next or previous piece. Swift Splash uses these transforms to place new pieces at the end of the existing slide, as well as to snap pieces to other slide pieces when you manually move them near each other.": {"zh": "在上方屏幕截图左侧的层级检视面板中，有两个被称作 connect_in 和 connect_out 的变换节点。这两个变换节点会对滑道部件的前后连接做出标记。Swift Splash 就是利用了这些节点从而将新的滑道部件对接到现有内容的末端，也可通过手动移动滑道部件并靠近其他物件的方式将它们吸附在一起。", "tips": ""}, "Slide pieces demonstrate the two primary mechanisms Swift Splash uses to find entities at runtime. For some entities, such as connect_in, Swift Splash uses a naming convention and retrieves the entities by name or suffix when it needs to use them. In other cases, such as when names aren’t unique or the retrieving code needs configuration values, Swift Splash uses a custom component to mark and retrieve entities.": {"zh": "这个滑道部件窗口展示了在 Swift Splash 中通过运行时去查找实体的两种主要机制。对于一些实体来说，例如 connect_in，Swift Splash 会借助命名规则并在需要使用这些实体时通过匹配名称或后缀来获取它们。在其他场景下，例如名称不唯一或者必须通过配置值取得实体时，Swift Splash 会使用自定义组件来对实体进行标记和检索。", "tips": ""}, "For example, animated entities that appear when the ride runs contain a component called RideAnimationComponent. The app uses this component to determine if the entity is an animation that plays while the ride is running. The component also stores additional state the app needs to implement the ride animation, such as a property called duration that specifies when to start the animations on the next connected slide piece.": {"zh": "举例来说，当游乐设施运行起来后出现的动画实体会包含一个名为 RideAnimationComponent 的组件。程序借助这个组件来判断这个实体是否为设施在运行状态下播放的动画。该组件还负责存储这个程序实现游乐设施动画所需要的额外状态信息，比如名为 duration 的属性，它用于明确何时去启动下一个已经连接的滑梯组件上的动画。", "tips": ""}, "RideAnimationComponent also includes a property called isPersistent. Persistent ride animations stay visible at all times but only animate when the ride is running, such as the animated door on the start piece. Nonpersistent ride animations, such as the fish swimming through a slide piece, display only while the ride is running and the fish swims through that particular piece.": {"zh": "RideAnimationComponent 组件还有一个名为 isPersistent 的属性。持续的水上游乐设施动画内容是始终可见的，不过只有当设施在运行时才会去执行动画，像是在起点区块上通过动画打开的门。非持续的设施动画，例如小鱼在滑道内游过，只会在设施运行并且小鱼正在通过对应的滑道物件时才会显示出来。", "tips": ""}, "Avoid duplicate materials with material references": {"zh": "通过材质引用避免重复的材质实例", "tips": ""}, "Many of Swift Splash’s slide pieces use the same materials. For example, the shader graph material that changes pieces from metal to wood to plastic is shared by all but one of the slide pieces. To avoid having duplicate copies of each material, Swift Splash leverages USD material references to share materials between multiple entities in multiple scenes.": {"zh": "在 Swift Splash 中，许多滑道部件会使用相同的材质元素。举个例子，所有部件都共享着同一个能够将部件从金属转变成木质或是塑料的着色器图形材质。为了避免每一种材质都产生重复的副本，Swift Splash 借助 USD 材质引用特性，做到了在多个场景的多个实体之间共享材质。", "tips": "有关 USD（Universal Scene Description）的概述和定义：https://www.nvidia.cn/omniverse/usd/#:~:text=USD%20%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80,%E7%9A%84%E4%BB%BB%E4%BD%95%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E3%80%82"}, "The Reality Composer Pro project contains a separate scene for each shared material, containing only that one material. Other track pieces create references to that material. If you change the original material, it affects all of the entities that reference it. For example, a scene called M_RainbowLights.usda contains the material M_RainbowLights, and both StartPiece.usda and EndPiece.usda reference that material.": {"zh": "Reality Composer Pro 工程中对每一个共享的材质都做了独立的场景设定，这个场景只包含了那一种材质。其他的轨道部件只会建立对这材质的引用。如果你尝试改变原始材质，就会影响所有引用了它的实体。例如，一个名为 M_RainbowLights.usda 的场景包含了 M_RainbowLights 的材质，而 StartPiece.usda 和 EndPiece.usda 两者都引用了这种材质。", "tips": ""}, "Parallelize the asset load": {"zh": "并行化的资产加载", "tips": ""}, "To maximize load speed and make the most efficient use of available compute resources, Swift Splash parallelizes loading scenes from the Reality Composer project using a TaskGroup. The app creates a separate Task for each of the scenes it needs to load.": {"zh": "为了尽可能提升加载速度以及最高效地运用可用的计算资源，Swift Splash 通过 TaskGroup 并行化地加载 Reality Composer 工程中的所有场景。程序会为需要加载资产的每一个场景创建一个独立的 Task。", "tips": ""}, "The app then uses an async iterator to wait for and receive the results.": {"zh": "程序随后会使用异步迭代器来等待并接收加载结果。", "tips": ""}, "For more information on task groups, see Concurrency in The Swift Programming Language.": {"zh": "有关任务组（task groups）的更多信息，详见 The Swift Programming Language 中的 Concurrency 相关内容。", "tips": ""}, "Each of these loaded pieces acts as a template. When the player adds a new piece of that type, the app clones the piece loaded from Reality Composer Pro and adds the clone to the scene.": {"zh": "每一个已经加载的部件都会被看作是一个模板。当玩家在项目中添加了同类部件时，程序会从 Reality Composer Pro 中复制加载过的部件，然后将该部件添加到场景中。", "tips": ""}, "Specify sort ordering for transparent entities": {"zh": "指定透明实体的排序顺序", "tips": ""}, "When multiple entities have more than one overlapping, nonopaque material, RealityKit’s default depth-sorting can cause it to draw those entities in the wrong order. As a result, some entities may not be visible from certain angles or in certain positions relative to other transparent entities. The default depth sorting is based on the center of the entity’s bounding box, which may result in the incorrect drawing order when there are multiple overlapping materials with any amount of transparency. You can see an example of this by looking at the start piece in Reality Composer Pro, or by watching the video below.": {"zh": "当遇到多个实体产生超过一个重叠，并且存在非不透明的材质时，RealityKit 的默认深度排序可能会按照错误的顺序绘制这些实体内容。这就导致，从特定角度或是相对于其他透明实体的特定位置上看，有一部分实体可能无法被看到。默认深度排序的计算基于实体边界盒的中心点，当存在多个任何透明度的重叠材质时，可能会引发不正确的绘制顺序。你可以在 Reality Composer Pro 中查看起始部件，或观看下方的视频来了解示例的表现形式。", "tips": ""}, "The following video demonstrates the problem. If the three boxes are the bounding boxes for three different transparent entities, and the small spheres are the box centers, the sphere that’s closest to the camera changes as the camera moves around the boxes, which changes the order that RealityKit’s default depth sorting algorithm draws them.": {"zh": "下方的视频演示了这个问题。假设这三个矩形框分别是三个不同的透明实体的边界盒，其中的圆形则代表着盒子的中心，当摄像机在矩形框周围移动时，距离摄像机最近的圆形就会改变，这就会影响 RealityKit 的默认深度排序算法绘制它们的顺序。", "tips": ""}, "Swift Splash assigns a ModelSortGroupComponent to each of the transparent entities to manually specify the relative depth sorting. To fix the transparency issues in the start piece in the video above, Swift Splash instructs RealityKit to draw the opaque parts of the fish first, its transparent goggles second, the water third, the glass globe fourth, and the selection glow shell last. Swift Splash does this by assigning a ModelSortGroupComponent to each of the overlapping entities using the same ModelSortGroup, but with a different order specified.": {"zh": "Swift Splash 会为每一个透明实体关联一个 ModalSortGroupComponent 组件，用于手动去指定相对的深度排序。为了修正上方视频中起始部件的透明度问题，Swift Splash 会命令 RealityKit 首先去绘制鱼的不透明部分，再者是透明的护目镜，第三是水，第四是玻璃球，把选中发光的外壳作为最后的绘制物件。Swift Splash 通过使用相同的但制定了不同顺序的 ModelSortGroup，并为每一个重叠实体关联 ModelSortGroupComponent 组件来实现这一点。", "tips": ""}, "Traverse connected track pieces": {"zh": "逐个操作连接的轨道部件", "tips": ""}, "The root entity for all of the individual slide pieces has a ConnectableComponent. This custom component marks the entity as one that can be connected or snapped to other connectable entities. At runtime, the app adds a ConnectableStateComponent to each slide piece it adds. The component stores state information for the track piece that doesn’t need to be edited in Reality Composer Pro. Among the state information that this component stores is a reference to the next and previous piece.": {"zh": "所有独立的滑道部件的根实体都有一个 ConnectableComponent 组件。这个可自定义的组件会将实体标记为允许连接或者吸附到其他可连接的实体。在程序运行时，应用会为每一个添加的部件都新增一个 ConnectableStateComponent 组件。这个组件储存的轨道部件状态信息不需在 Reality Composer Pro 进行编辑修改。在这个组件存储的状态信息中也涵盖了前后部件的连接关系。", "tips": ""}, "To iterate through the entire ride, ignoring any disconnected pieces, the app gets a reference to the start piece and then iterates until nextPiece is nil. This iteration, similar to iterating a linked list, repeats many times throughout the app. One example is the function that calculates the duration of the built ride by iterating through the individual pieces and adding up the duration of their animations.": {"zh": "要把整条游乐设施串联起来，略去未对接上的滑道部件，应用程序可以从起始部件获取一个引用，然后遍历直至没有后续部件。这种迭代，类似于遍历一条链表，会在应用中被重复运用很多次。一个例子就是计算已搭建的设施运行时长的函数，它通过遍历整轨上每条单独的部件并将它们执行动画的时长依次累加来完成计算。", "tips": ""}, "Interact with the ride": {"zh": "体验游乐设施", "tips": ""}, "To build and edit the ride, players interact with Swift Splash in two different ways. They interact with SwiftUI windows to perform certain tasks, such as adding a new piece or deleting an existing piece of the ride. They also manipulate slide pieces using standard visionOS gestures, including taps, double taps, drags, and rotates. The player taps on a piece to select or deselect it. When a player double taps a piece, they select that piece without deselecting any other selected pieces. When someone drags a piece, it moves around the immsersive space, snapping together with other pieces if placed near one. A two-finger rotate gesture spins the selected track piece or pieces on the Z-axis.": {"zh": "有两种不同的方式可供玩家在 Swift Splash 中进行交互来构建和编辑游乐设施。他们可以通过 SwiftUI 窗口完成特定的操作，例如新增一段新滑道，或是移除一段已经添加到设施中的滑道部件。玩家还可利用 visionOS 支持的标准手势来操作部件，包括点按、双击、拖动和旋转。玩家点击部件以选择或取消选择它。当玩家双击部件时，他们会选择该部件，而不会取消选中的其他部件。当有人去拖移部件时，它会在沉浸式空间中移动，如果和另一个部件靠得足够近，它们就会自动吸附在一起。使用两指旋转手势会让选中的轨道部件或所有部件沿着 Z 轴进行旋转。", "tips": ""}, "Swift Splash handles all of these interactions using standard SwiftUI gestures targeted to an entity. To support any of these gestures at any time, the app declares them using SimultaneousGesture. The code for all of the gestures are contained in TrackBuildingView, which controls the app’s immersive space. Here’s how the app defines the rotation gesture:": {"zh": "Swift Splash 在目标实体上采用标准的 SwiftUI 手势去处理其所有的交互操作。为了能随时给任意手势提供支持，应用内使用 SimultaneousGesture 来进行声明。所有的手势代码都包含在 TrackBuildingView 中，这个视图管理着应用内的沉浸式空间。以下是在应用中定义旋转手势的代码：", "tips": ""}, "Because multiple tap gestures on the same RealityView execute with a different number of taps, multiple gestures may be called at once. If a player double taps an entity, for example, both the single tap and the double tap gesture code get called, and the app has to determine which one to execute. Swift Splash makes this determination by using a Boolean state variable. If a player single taps, it sets that variable — called shouldSingleTap — to true. Then it waits for a period of time before executing the rest of its code. If shouldSingleTap gets set to false while it’s waiting, the code doesn’t execute. When SwiftSplash detects a double tap gesture, it sets shouldSingleTap to false, preventing the single-tap code from firing when it executes the double-tap code.": {"zh": "因为在相同的 RealityView 上执行的多次点按手势可能带有不同的点击次数，多种手势可能会同时被响应。举个例子来说，如果玩家对一个实体进行双击操作，实际上单击和双击的手势代码都会被调用，最终执行的手势由程序决定。Swift Splash 通过一个布尔状态变量来做这个决定。如果玩家单击了，程序会将此变量（叫做 shouldSingleTap）设置为 true。然后程序会等待一段时间再去执行后续的代码。如果在等待阶段 shouldSingleTap 被设定为 false，那么代码就不会被执行。当 Swift Splash 检测到一个双击手势，它会将 shouldSingleTap 设置为 false，以避免在执行双击代码时触发单击代码。", "tips": ""}}